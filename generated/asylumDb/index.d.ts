
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model court_appeal_types
 * 
 */
export type court_appeal_types = $Result.DefaultSelection<Prisma.$court_appeal_typesPayload>
/**
 * Model court_appeals
 * 
 */
export type court_appeals = $Result.DefaultSelection<Prisma.$court_appealsPayload>
/**
 * Model court_claim_initiators
 * 
 */
export type court_claim_initiators = $Result.DefaultSelection<Prisma.$court_claim_initiatorsPayload>
/**
 * Model court_claim_members
 * 
 */
export type court_claim_members = $Result.DefaultSelection<Prisma.$court_claim_membersPayload>
/**
 * Model court_claims
 * 
 */
export type court_claims = $Result.DefaultSelection<Prisma.$court_claimsPayload>
/**
 * Model court_cliam_status
 * 
 */
export type court_cliam_status = $Result.DefaultSelection<Prisma.$court_cliam_statusPayload>
/**
 * Model court_decision_types
 * 
 */
export type court_decision_types = $Result.DefaultSelection<Prisma.$court_decision_typesPayload>
/**
 * Model court_decisions
 * 
 */
export type court_decisions = $Result.DefaultSelection<Prisma.$court_decisionsPayload>
/**
 * Model court_levels
 * 
 */
export type court_levels = $Result.DefaultSelection<Prisma.$court_levelsPayload>
/**
 * Model cover_sign_status
 * 
 */
export type cover_sign_status = $Result.DefaultSelection<Prisma.$cover_sign_statusPayload>
/**
 * Model files
 * 
 */
export type files = $Result.DefaultSelection<Prisma.$filesPayload>
/**
 * Model ips
 * 
 */
export type ips = $Result.DefaultSelection<Prisma.$ipsPayload>
/**
 * Model old_case_decisions
 * 
 */
export type old_case_decisions = $Result.DefaultSelection<Prisma.$old_case_decisionsPayload>
/**
 * Model old_case_person
 * 
 */
export type old_case_person = $Result.DefaultSelection<Prisma.$old_case_personPayload>
/**
 * Model old_cases
 * 
 */
export type old_cases = $Result.DefaultSelection<Prisma.$old_casesPayload>
/**
 * Model tb_arm_com
 * 
 */
export type tb_arm_com = $Result.DefaultSelection<Prisma.$tb_arm_comPayload>
/**
 * Model tb_arm_com__
 * 
 */
export type tb_arm_com__ = $Result.DefaultSelection<Prisma.$tb_arm_com__Payload>
/**
 * Model tb_calendar
 * 
 */
export type tb_calendar = $Result.DefaultSelection<Prisma.$tb_calendarPayload>
/**
 * Model tb_cancel
 * 
 */
export type tb_cancel = $Result.DefaultSelection<Prisma.$tb_cancelPayload>
/**
 * Model tb_cards
 * 
 */
export type tb_cards = $Result.DefaultSelection<Prisma.$tb_cardsPayload>
/**
 * Model tb_case
 * 
 */
export type tb_case = $Result.DefaultSelection<Prisma.$tb_casePayload>
/**
 * Model tb_case_status
 * 
 */
export type tb_case_status = $Result.DefaultSelection<Prisma.$tb_case_statusPayload>
/**
 * Model tb_checkin
 * 
 */
export type tb_checkin = $Result.DefaultSelection<Prisma.$tb_checkinPayload>
/**
 * Model tb_coi
 * 
 */
export type tb_coi = $Result.DefaultSelection<Prisma.$tb_coiPayload>
/**
 * Model tb_country
 * 
 */
export type tb_country = $Result.DefaultSelection<Prisma.$tb_countryPayload>
/**
 * Model tb_cover_files
 * 
 */
export type tb_cover_files = $Result.DefaultSelection<Prisma.$tb_cover_filesPayload>
/**
 * Model tb_deadline
 * 
 */
export type tb_deadline = $Result.DefaultSelection<Prisma.$tb_deadlinePayload>
/**
 * Model tb_deadline_types
 * 
 */
export type tb_deadline_types = $Result.DefaultSelection<Prisma.$tb_deadline_typesPayload>
/**
 * Model tb_decision_status
 * 
 */
export type tb_decision_status = $Result.DefaultSelection<Prisma.$tb_decision_statusPayload>
/**
 * Model tb_decision_types
 * 
 */
export type tb_decision_types = $Result.DefaultSelection<Prisma.$tb_decision_typesPayload>
/**
 * Model tb_decisions
 * 
 */
export type tb_decisions = $Result.DefaultSelection<Prisma.$tb_decisionsPayload>
/**
 * Model tb_doss
 * 
 */
export type tb_doss = $Result.DefaultSelection<Prisma.$tb_dossPayload>
/**
 * Model tb_draft
 * 
 */
export type tb_draft = $Result.DefaultSelection<Prisma.$tb_draftPayload>
/**
 * Model tb_drooms
 * 
 */
export type tb_drooms = $Result.DefaultSelection<Prisma.$tb_droomsPayload>
/**
 * Model tb_edu_lvl
 * 
 */
export type tb_edu_lvl = $Result.DefaultSelection<Prisma.$tb_edu_lvlPayload>
/**
 * Model tb_education
 * 
 */
export type tb_education = $Result.DefaultSelection<Prisma.$tb_educationPayload>
/**
 * Model tb_employment
 * 
 */
export type tb_employment = $Result.DefaultSelection<Prisma.$tb_employmentPayload>
/**
 * Model tb_etnics
 * 
 */
export type tb_etnics = $Result.DefaultSelection<Prisma.$tb_etnicsPayload>
/**
 * Model tb_file_type
 * 
 */
export type tb_file_type = $Result.DefaultSelection<Prisma.$tb_file_typePayload>
/**
 * Model tb_handed
 * 
 */
export type tb_handed = $Result.DefaultSelection<Prisma.$tb_handedPayload>
/**
 * Model tb_inter
 * 
 */
export type tb_inter = $Result.DefaultSelection<Prisma.$tb_interPayload>
/**
 * Model tb_inter_notified
 * 
 */
export type tb_inter_notified = $Result.DefaultSelection<Prisma.$tb_inter_notifiedPayload>
/**
 * Model tb_inter_recivers
 * 
 */
export type tb_inter_recivers = $Result.DefaultSelection<Prisma.$tb_inter_reciversPayload>
/**
 * Model tb_inter_send_type
 * 
 */
export type tb_inter_send_type = $Result.DefaultSelection<Prisma.$tb_inter_send_typePayload>
/**
 * Model tb_inter_status_types
 * 
 */
export type tb_inter_status_types = $Result.DefaultSelection<Prisma.$tb_inter_status_typesPayload>
/**
 * Model tb_inter_type
 * 
 */
export type tb_inter_type = $Result.DefaultSelection<Prisma.$tb_inter_typePayload>
/**
 * Model tb_lawyer
 * 
 */
export type tb_lawyer = $Result.DefaultSelection<Prisma.$tb_lawyerPayload>
/**
 * Model tb_marz
 * 
 */
export type tb_marz = $Result.DefaultSelection<Prisma.$tb_marzPayload>
/**
 * Model tb_members
 * 
 */
export type tb_members = $Result.DefaultSelection<Prisma.$tb_membersPayload>
/**
 * Model tb_notifications
 * 
 */
export type tb_notifications = $Result.DefaultSelection<Prisma.$tb_notificationsPayload>
/**
 * Model tb_orders
 * 
 */
export type tb_orders = $Result.DefaultSelection<Prisma.$tb_ordersPayload>
/**
 * Model tb_person
 * 
 */
export type tb_person = $Result.DefaultSelection<Prisma.$tb_personPayload>
/**
 * Model tb_person_status
 * 
 */
export type tb_person_status = $Result.DefaultSelection<Prisma.$tb_person_statusPayload>
/**
 * Model tb_process
 * 
 */
export type tb_process = $Result.DefaultSelection<Prisma.$tb_processPayload>
/**
 * Model tb_process_type
 * 
 */
export type tb_process_type = $Result.DefaultSelection<Prisma.$tb_process_typePayload>
/**
 * Model tb_religions
 * 
 */
export type tb_religions = $Result.DefaultSelection<Prisma.$tb_religionsPayload>
/**
 * Model tb_request_bodies
 * 
 */
export type tb_request_bodies = $Result.DefaultSelection<Prisma.$tb_request_bodiesPayload>
/**
 * Model tb_request_out
 * 
 */
export type tb_request_out = $Result.DefaultSelection<Prisma.$tb_request_outPayload>
/**
 * Model tb_role
 * 
 */
export type tb_role = $Result.DefaultSelection<Prisma.$tb_rolePayload>
/**
 * Model tb_settlement
 * 
 */
export type tb_settlement = $Result.DefaultSelection<Prisma.$tb_settlementPayload>
/**
 * Model tb_settlement_
 * 
 */
export type tb_settlement_ = $Result.DefaultSelection<Prisma.$tb_settlement_Payload>
/**
 * Model tb_sign_status
 * 
 */
export type tb_sign_status = $Result.DefaultSelection<Prisma.$tb_sign_statusPayload>
/**
 * Model tb_translate
 * 
 */
export type tb_translate = $Result.DefaultSelection<Prisma.$tb_translatePayload>
/**
 * Model tb_translate_sign_statuses
 * 
 */
export type tb_translate_sign_statuses = $Result.DefaultSelection<Prisma.$tb_translate_sign_statusesPayload>
/**
 * Model tb_translation_type
 * 
 */
export type tb_translation_type = $Result.DefaultSelection<Prisma.$tb_translation_typePayload>
/**
 * Model tb_translators
 * 
 */
export type tb_translators = $Result.DefaultSelection<Prisma.$tb_translatorsPayload>
/**
 * Model users
 * 
 */
export type users = $Result.DefaultSelection<Prisma.$usersPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const tb_inter_notified_notification_status: {
  notified: 'notified',
  not_notified: 'not_notified',
  EMPTY_ENUM_VALUE: 'EMPTY_ENUM_VALUE'
};

export type tb_inter_notified_notification_status = (typeof tb_inter_notified_notification_status)[keyof typeof tb_inter_notified_notification_status]

}

export type tb_inter_notified_notification_status = $Enums.tb_inter_notified_notification_status

export const tb_inter_notified_notification_status: typeof $Enums.tb_inter_notified_notification_status

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Court_appeal_types
 * const court_appeal_types = await prisma.court_appeal_types.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Court_appeal_types
   * const court_appeal_types = await prisma.court_appeal_types.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.court_appeal_types`: Exposes CRUD operations for the **court_appeal_types** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Court_appeal_types
    * const court_appeal_types = await prisma.court_appeal_types.findMany()
    * ```
    */
  get court_appeal_types(): Prisma.court_appeal_typesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.court_appeals`: Exposes CRUD operations for the **court_appeals** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Court_appeals
    * const court_appeals = await prisma.court_appeals.findMany()
    * ```
    */
  get court_appeals(): Prisma.court_appealsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.court_claim_initiators`: Exposes CRUD operations for the **court_claim_initiators** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Court_claim_initiators
    * const court_claim_initiators = await prisma.court_claim_initiators.findMany()
    * ```
    */
  get court_claim_initiators(): Prisma.court_claim_initiatorsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.court_claim_members`: Exposes CRUD operations for the **court_claim_members** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Court_claim_members
    * const court_claim_members = await prisma.court_claim_members.findMany()
    * ```
    */
  get court_claim_members(): Prisma.court_claim_membersDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.court_claims`: Exposes CRUD operations for the **court_claims** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Court_claims
    * const court_claims = await prisma.court_claims.findMany()
    * ```
    */
  get court_claims(): Prisma.court_claimsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.court_cliam_status`: Exposes CRUD operations for the **court_cliam_status** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Court_cliam_statuses
    * const court_cliam_statuses = await prisma.court_cliam_status.findMany()
    * ```
    */
  get court_cliam_status(): Prisma.court_cliam_statusDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.court_decision_types`: Exposes CRUD operations for the **court_decision_types** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Court_decision_types
    * const court_decision_types = await prisma.court_decision_types.findMany()
    * ```
    */
  get court_decision_types(): Prisma.court_decision_typesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.court_decisions`: Exposes CRUD operations for the **court_decisions** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Court_decisions
    * const court_decisions = await prisma.court_decisions.findMany()
    * ```
    */
  get court_decisions(): Prisma.court_decisionsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.court_levels`: Exposes CRUD operations for the **court_levels** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Court_levels
    * const court_levels = await prisma.court_levels.findMany()
    * ```
    */
  get court_levels(): Prisma.court_levelsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.cover_sign_status`: Exposes CRUD operations for the **cover_sign_status** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Cover_sign_statuses
    * const cover_sign_statuses = await prisma.cover_sign_status.findMany()
    * ```
    */
  get cover_sign_status(): Prisma.cover_sign_statusDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.files`: Exposes CRUD operations for the **files** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Files
    * const files = await prisma.files.findMany()
    * ```
    */
  get files(): Prisma.filesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.ips`: Exposes CRUD operations for the **ips** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Ips
    * const ips = await prisma.ips.findMany()
    * ```
    */
  get ips(): Prisma.ipsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.old_case_decisions`: Exposes CRUD operations for the **old_case_decisions** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Old_case_decisions
    * const old_case_decisions = await prisma.old_case_decisions.findMany()
    * ```
    */
  get old_case_decisions(): Prisma.old_case_decisionsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.old_case_person`: Exposes CRUD operations for the **old_case_person** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Old_case_people
    * const old_case_people = await prisma.old_case_person.findMany()
    * ```
    */
  get old_case_person(): Prisma.old_case_personDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.old_cases`: Exposes CRUD operations for the **old_cases** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Old_cases
    * const old_cases = await prisma.old_cases.findMany()
    * ```
    */
  get old_cases(): Prisma.old_casesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tb_arm_com`: Exposes CRUD operations for the **tb_arm_com** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tb_arm_coms
    * const tb_arm_coms = await prisma.tb_arm_com.findMany()
    * ```
    */
  get tb_arm_com(): Prisma.tb_arm_comDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tb_arm_com__`: Exposes CRUD operations for the **tb_arm_com__** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tb_arm_com__s
    * const tb_arm_com__s = await prisma.tb_arm_com__.findMany()
    * ```
    */
  get tb_arm_com__(): Prisma.tb_arm_com__Delegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tb_calendar`: Exposes CRUD operations for the **tb_calendar** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tb_calendars
    * const tb_calendars = await prisma.tb_calendar.findMany()
    * ```
    */
  get tb_calendar(): Prisma.tb_calendarDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tb_cancel`: Exposes CRUD operations for the **tb_cancel** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tb_cancels
    * const tb_cancels = await prisma.tb_cancel.findMany()
    * ```
    */
  get tb_cancel(): Prisma.tb_cancelDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tb_cards`: Exposes CRUD operations for the **tb_cards** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tb_cards
    * const tb_cards = await prisma.tb_cards.findMany()
    * ```
    */
  get tb_cards(): Prisma.tb_cardsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tb_case`: Exposes CRUD operations for the **tb_case** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tb_cases
    * const tb_cases = await prisma.tb_case.findMany()
    * ```
    */
  get tb_case(): Prisma.tb_caseDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tb_case_status`: Exposes CRUD operations for the **tb_case_status** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tb_case_statuses
    * const tb_case_statuses = await prisma.tb_case_status.findMany()
    * ```
    */
  get tb_case_status(): Prisma.tb_case_statusDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tb_checkin`: Exposes CRUD operations for the **tb_checkin** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tb_checkins
    * const tb_checkins = await prisma.tb_checkin.findMany()
    * ```
    */
  get tb_checkin(): Prisma.tb_checkinDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tb_coi`: Exposes CRUD operations for the **tb_coi** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tb_cois
    * const tb_cois = await prisma.tb_coi.findMany()
    * ```
    */
  get tb_coi(): Prisma.tb_coiDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tb_country`: Exposes CRUD operations for the **tb_country** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tb_countries
    * const tb_countries = await prisma.tb_country.findMany()
    * ```
    */
  get tb_country(): Prisma.tb_countryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tb_cover_files`: Exposes CRUD operations for the **tb_cover_files** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tb_cover_files
    * const tb_cover_files = await prisma.tb_cover_files.findMany()
    * ```
    */
  get tb_cover_files(): Prisma.tb_cover_filesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tb_deadline`: Exposes CRUD operations for the **tb_deadline** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tb_deadlines
    * const tb_deadlines = await prisma.tb_deadline.findMany()
    * ```
    */
  get tb_deadline(): Prisma.tb_deadlineDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tb_deadline_types`: Exposes CRUD operations for the **tb_deadline_types** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tb_deadline_types
    * const tb_deadline_types = await prisma.tb_deadline_types.findMany()
    * ```
    */
  get tb_deadline_types(): Prisma.tb_deadline_typesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tb_decision_status`: Exposes CRUD operations for the **tb_decision_status** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tb_decision_statuses
    * const tb_decision_statuses = await prisma.tb_decision_status.findMany()
    * ```
    */
  get tb_decision_status(): Prisma.tb_decision_statusDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tb_decision_types`: Exposes CRUD operations for the **tb_decision_types** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tb_decision_types
    * const tb_decision_types = await prisma.tb_decision_types.findMany()
    * ```
    */
  get tb_decision_types(): Prisma.tb_decision_typesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tb_decisions`: Exposes CRUD operations for the **tb_decisions** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tb_decisions
    * const tb_decisions = await prisma.tb_decisions.findMany()
    * ```
    */
  get tb_decisions(): Prisma.tb_decisionsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tb_doss`: Exposes CRUD operations for the **tb_doss** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tb_dosses
    * const tb_dosses = await prisma.tb_doss.findMany()
    * ```
    */
  get tb_doss(): Prisma.tb_dossDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tb_draft`: Exposes CRUD operations for the **tb_draft** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tb_drafts
    * const tb_drafts = await prisma.tb_draft.findMany()
    * ```
    */
  get tb_draft(): Prisma.tb_draftDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tb_drooms`: Exposes CRUD operations for the **tb_drooms** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tb_drooms
    * const tb_drooms = await prisma.tb_drooms.findMany()
    * ```
    */
  get tb_drooms(): Prisma.tb_droomsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tb_edu_lvl`: Exposes CRUD operations for the **tb_edu_lvl** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tb_edu_lvls
    * const tb_edu_lvls = await prisma.tb_edu_lvl.findMany()
    * ```
    */
  get tb_edu_lvl(): Prisma.tb_edu_lvlDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tb_education`: Exposes CRUD operations for the **tb_education** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tb_educations
    * const tb_educations = await prisma.tb_education.findMany()
    * ```
    */
  get tb_education(): Prisma.tb_educationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tb_employment`: Exposes CRUD operations for the **tb_employment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tb_employments
    * const tb_employments = await prisma.tb_employment.findMany()
    * ```
    */
  get tb_employment(): Prisma.tb_employmentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tb_etnics`: Exposes CRUD operations for the **tb_etnics** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tb_etnics
    * const tb_etnics = await prisma.tb_etnics.findMany()
    * ```
    */
  get tb_etnics(): Prisma.tb_etnicsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tb_file_type`: Exposes CRUD operations for the **tb_file_type** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tb_file_types
    * const tb_file_types = await prisma.tb_file_type.findMany()
    * ```
    */
  get tb_file_type(): Prisma.tb_file_typeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tb_handed`: Exposes CRUD operations for the **tb_handed** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tb_handeds
    * const tb_handeds = await prisma.tb_handed.findMany()
    * ```
    */
  get tb_handed(): Prisma.tb_handedDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tb_inter`: Exposes CRUD operations for the **tb_inter** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tb_inters
    * const tb_inters = await prisma.tb_inter.findMany()
    * ```
    */
  get tb_inter(): Prisma.tb_interDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tb_inter_notified`: Exposes CRUD operations for the **tb_inter_notified** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tb_inter_notifieds
    * const tb_inter_notifieds = await prisma.tb_inter_notified.findMany()
    * ```
    */
  get tb_inter_notified(): Prisma.tb_inter_notifiedDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tb_inter_recivers`: Exposes CRUD operations for the **tb_inter_recivers** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tb_inter_recivers
    * const tb_inter_recivers = await prisma.tb_inter_recivers.findMany()
    * ```
    */
  get tb_inter_recivers(): Prisma.tb_inter_reciversDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tb_inter_send_type`: Exposes CRUD operations for the **tb_inter_send_type** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tb_inter_send_types
    * const tb_inter_send_types = await prisma.tb_inter_send_type.findMany()
    * ```
    */
  get tb_inter_send_type(): Prisma.tb_inter_send_typeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tb_inter_status_types`: Exposes CRUD operations for the **tb_inter_status_types** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tb_inter_status_types
    * const tb_inter_status_types = await prisma.tb_inter_status_types.findMany()
    * ```
    */
  get tb_inter_status_types(): Prisma.tb_inter_status_typesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tb_inter_type`: Exposes CRUD operations for the **tb_inter_type** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tb_inter_types
    * const tb_inter_types = await prisma.tb_inter_type.findMany()
    * ```
    */
  get tb_inter_type(): Prisma.tb_inter_typeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tb_lawyer`: Exposes CRUD operations for the **tb_lawyer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tb_lawyers
    * const tb_lawyers = await prisma.tb_lawyer.findMany()
    * ```
    */
  get tb_lawyer(): Prisma.tb_lawyerDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tb_marz`: Exposes CRUD operations for the **tb_marz** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tb_marzs
    * const tb_marzs = await prisma.tb_marz.findMany()
    * ```
    */
  get tb_marz(): Prisma.tb_marzDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tb_members`: Exposes CRUD operations for the **tb_members** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tb_members
    * const tb_members = await prisma.tb_members.findMany()
    * ```
    */
  get tb_members(): Prisma.tb_membersDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tb_notifications`: Exposes CRUD operations for the **tb_notifications** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tb_notifications
    * const tb_notifications = await prisma.tb_notifications.findMany()
    * ```
    */
  get tb_notifications(): Prisma.tb_notificationsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tb_orders`: Exposes CRUD operations for the **tb_orders** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tb_orders
    * const tb_orders = await prisma.tb_orders.findMany()
    * ```
    */
  get tb_orders(): Prisma.tb_ordersDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tb_person`: Exposes CRUD operations for the **tb_person** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tb_people
    * const tb_people = await prisma.tb_person.findMany()
    * ```
    */
  get tb_person(): Prisma.tb_personDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tb_person_status`: Exposes CRUD operations for the **tb_person_status** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tb_person_statuses
    * const tb_person_statuses = await prisma.tb_person_status.findMany()
    * ```
    */
  get tb_person_status(): Prisma.tb_person_statusDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tb_process`: Exposes CRUD operations for the **tb_process** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tb_processes
    * const tb_processes = await prisma.tb_process.findMany()
    * ```
    */
  get tb_process(): Prisma.tb_processDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tb_process_type`: Exposes CRUD operations for the **tb_process_type** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tb_process_types
    * const tb_process_types = await prisma.tb_process_type.findMany()
    * ```
    */
  get tb_process_type(): Prisma.tb_process_typeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tb_religions`: Exposes CRUD operations for the **tb_religions** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tb_religions
    * const tb_religions = await prisma.tb_religions.findMany()
    * ```
    */
  get tb_religions(): Prisma.tb_religionsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tb_request_bodies`: Exposes CRUD operations for the **tb_request_bodies** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tb_request_bodies
    * const tb_request_bodies = await prisma.tb_request_bodies.findMany()
    * ```
    */
  get tb_request_bodies(): Prisma.tb_request_bodiesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tb_request_out`: Exposes CRUD operations for the **tb_request_out** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tb_request_outs
    * const tb_request_outs = await prisma.tb_request_out.findMany()
    * ```
    */
  get tb_request_out(): Prisma.tb_request_outDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tb_role`: Exposes CRUD operations for the **tb_role** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tb_roles
    * const tb_roles = await prisma.tb_role.findMany()
    * ```
    */
  get tb_role(): Prisma.tb_roleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tb_settlement`: Exposes CRUD operations for the **tb_settlement** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tb_settlements
    * const tb_settlements = await prisma.tb_settlement.findMany()
    * ```
    */
  get tb_settlement(): Prisma.tb_settlementDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tb_settlement_`: Exposes CRUD operations for the **tb_settlement_** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tb_settlement_s
    * const tb_settlement_s = await prisma.tb_settlement_.findMany()
    * ```
    */
  get tb_settlement_(): Prisma.tb_settlement_Delegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tb_sign_status`: Exposes CRUD operations for the **tb_sign_status** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tb_sign_statuses
    * const tb_sign_statuses = await prisma.tb_sign_status.findMany()
    * ```
    */
  get tb_sign_status(): Prisma.tb_sign_statusDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tb_translate`: Exposes CRUD operations for the **tb_translate** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tb_translates
    * const tb_translates = await prisma.tb_translate.findMany()
    * ```
    */
  get tb_translate(): Prisma.tb_translateDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tb_translate_sign_statuses`: Exposes CRUD operations for the **tb_translate_sign_statuses** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tb_translate_sign_statuses
    * const tb_translate_sign_statuses = await prisma.tb_translate_sign_statuses.findMany()
    * ```
    */
  get tb_translate_sign_statuses(): Prisma.tb_translate_sign_statusesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tb_translation_type`: Exposes CRUD operations for the **tb_translation_type** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tb_translation_types
    * const tb_translation_types = await prisma.tb_translation_type.findMany()
    * ```
    */
  get tb_translation_type(): Prisma.tb_translation_typeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tb_translators`: Exposes CRUD operations for the **tb_translators** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tb_translators
    * const tb_translators = await prisma.tb_translators.findMany()
    * ```
    */
  get tb_translators(): Prisma.tb_translatorsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.users`: Exposes CRUD operations for the **users** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.users.findMany()
    * ```
    */
  get users(): Prisma.usersDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.13.0
   * Query Engine version: 361e86d0ea4987e9f53a565309b3eed797a6bcbd
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    court_appeal_types: 'court_appeal_types',
    court_appeals: 'court_appeals',
    court_claim_initiators: 'court_claim_initiators',
    court_claim_members: 'court_claim_members',
    court_claims: 'court_claims',
    court_cliam_status: 'court_cliam_status',
    court_decision_types: 'court_decision_types',
    court_decisions: 'court_decisions',
    court_levels: 'court_levels',
    cover_sign_status: 'cover_sign_status',
    files: 'files',
    ips: 'ips',
    old_case_decisions: 'old_case_decisions',
    old_case_person: 'old_case_person',
    old_cases: 'old_cases',
    tb_arm_com: 'tb_arm_com',
    tb_arm_com__: 'tb_arm_com__',
    tb_calendar: 'tb_calendar',
    tb_cancel: 'tb_cancel',
    tb_cards: 'tb_cards',
    tb_case: 'tb_case',
    tb_case_status: 'tb_case_status',
    tb_checkin: 'tb_checkin',
    tb_coi: 'tb_coi',
    tb_country: 'tb_country',
    tb_cover_files: 'tb_cover_files',
    tb_deadline: 'tb_deadline',
    tb_deadline_types: 'tb_deadline_types',
    tb_decision_status: 'tb_decision_status',
    tb_decision_types: 'tb_decision_types',
    tb_decisions: 'tb_decisions',
    tb_doss: 'tb_doss',
    tb_draft: 'tb_draft',
    tb_drooms: 'tb_drooms',
    tb_edu_lvl: 'tb_edu_lvl',
    tb_education: 'tb_education',
    tb_employment: 'tb_employment',
    tb_etnics: 'tb_etnics',
    tb_file_type: 'tb_file_type',
    tb_handed: 'tb_handed',
    tb_inter: 'tb_inter',
    tb_inter_notified: 'tb_inter_notified',
    tb_inter_recivers: 'tb_inter_recivers',
    tb_inter_send_type: 'tb_inter_send_type',
    tb_inter_status_types: 'tb_inter_status_types',
    tb_inter_type: 'tb_inter_type',
    tb_lawyer: 'tb_lawyer',
    tb_marz: 'tb_marz',
    tb_members: 'tb_members',
    tb_notifications: 'tb_notifications',
    tb_orders: 'tb_orders',
    tb_person: 'tb_person',
    tb_person_status: 'tb_person_status',
    tb_process: 'tb_process',
    tb_process_type: 'tb_process_type',
    tb_religions: 'tb_religions',
    tb_request_bodies: 'tb_request_bodies',
    tb_request_out: 'tb_request_out',
    tb_role: 'tb_role',
    tb_settlement: 'tb_settlement',
    tb_settlement_: 'tb_settlement_',
    tb_sign_status: 'tb_sign_status',
    tb_translate: 'tb_translate',
    tb_translate_sign_statuses: 'tb_translate_sign_statuses',
    tb_translation_type: 'tb_translation_type',
    tb_translators: 'tb_translators',
    users: 'users'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "court_appeal_types" | "court_appeals" | "court_claim_initiators" | "court_claim_members" | "court_claims" | "court_cliam_status" | "court_decision_types" | "court_decisions" | "court_levels" | "cover_sign_status" | "files" | "ips" | "old_case_decisions" | "old_case_person" | "old_cases" | "tb_arm_com" | "tb_arm_com__" | "tb_calendar" | "tb_cancel" | "tb_cards" | "tb_case" | "tb_case_status" | "tb_checkin" | "tb_coi" | "tb_country" | "tb_cover_files" | "tb_deadline" | "tb_deadline_types" | "tb_decision_status" | "tb_decision_types" | "tb_decisions" | "tb_doss" | "tb_draft" | "tb_drooms" | "tb_edu_lvl" | "tb_education" | "tb_employment" | "tb_etnics" | "tb_file_type" | "tb_handed" | "tb_inter" | "tb_inter_notified" | "tb_inter_recivers" | "tb_inter_send_type" | "tb_inter_status_types" | "tb_inter_type" | "tb_lawyer" | "tb_marz" | "tb_members" | "tb_notifications" | "tb_orders" | "tb_person" | "tb_person_status" | "tb_process" | "tb_process_type" | "tb_religions" | "tb_request_bodies" | "tb_request_out" | "tb_role" | "tb_settlement" | "tb_settlement_" | "tb_sign_status" | "tb_translate" | "tb_translate_sign_statuses" | "tb_translation_type" | "tb_translators" | "users"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      court_appeal_types: {
        payload: Prisma.$court_appeal_typesPayload<ExtArgs>
        fields: Prisma.court_appeal_typesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.court_appeal_typesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$court_appeal_typesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.court_appeal_typesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$court_appeal_typesPayload>
          }
          findFirst: {
            args: Prisma.court_appeal_typesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$court_appeal_typesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.court_appeal_typesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$court_appeal_typesPayload>
          }
          findMany: {
            args: Prisma.court_appeal_typesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$court_appeal_typesPayload>[]
          }
          create: {
            args: Prisma.court_appeal_typesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$court_appeal_typesPayload>
          }
          createMany: {
            args: Prisma.court_appeal_typesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.court_appeal_typesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$court_appeal_typesPayload>
          }
          update: {
            args: Prisma.court_appeal_typesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$court_appeal_typesPayload>
          }
          deleteMany: {
            args: Prisma.court_appeal_typesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.court_appeal_typesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.court_appeal_typesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$court_appeal_typesPayload>
          }
          aggregate: {
            args: Prisma.Court_appeal_typesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCourt_appeal_types>
          }
          groupBy: {
            args: Prisma.court_appeal_typesGroupByArgs<ExtArgs>
            result: $Utils.Optional<Court_appeal_typesGroupByOutputType>[]
          }
          count: {
            args: Prisma.court_appeal_typesCountArgs<ExtArgs>
            result: $Utils.Optional<Court_appeal_typesCountAggregateOutputType> | number
          }
        }
      }
      court_appeals: {
        payload: Prisma.$court_appealsPayload<ExtArgs>
        fields: Prisma.court_appealsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.court_appealsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$court_appealsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.court_appealsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$court_appealsPayload>
          }
          findFirst: {
            args: Prisma.court_appealsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$court_appealsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.court_appealsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$court_appealsPayload>
          }
          findMany: {
            args: Prisma.court_appealsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$court_appealsPayload>[]
          }
          create: {
            args: Prisma.court_appealsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$court_appealsPayload>
          }
          createMany: {
            args: Prisma.court_appealsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.court_appealsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$court_appealsPayload>
          }
          update: {
            args: Prisma.court_appealsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$court_appealsPayload>
          }
          deleteMany: {
            args: Prisma.court_appealsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.court_appealsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.court_appealsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$court_appealsPayload>
          }
          aggregate: {
            args: Prisma.Court_appealsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCourt_appeals>
          }
          groupBy: {
            args: Prisma.court_appealsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Court_appealsGroupByOutputType>[]
          }
          count: {
            args: Prisma.court_appealsCountArgs<ExtArgs>
            result: $Utils.Optional<Court_appealsCountAggregateOutputType> | number
          }
        }
      }
      court_claim_initiators: {
        payload: Prisma.$court_claim_initiatorsPayload<ExtArgs>
        fields: Prisma.court_claim_initiatorsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.court_claim_initiatorsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$court_claim_initiatorsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.court_claim_initiatorsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$court_claim_initiatorsPayload>
          }
          findFirst: {
            args: Prisma.court_claim_initiatorsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$court_claim_initiatorsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.court_claim_initiatorsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$court_claim_initiatorsPayload>
          }
          findMany: {
            args: Prisma.court_claim_initiatorsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$court_claim_initiatorsPayload>[]
          }
          create: {
            args: Prisma.court_claim_initiatorsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$court_claim_initiatorsPayload>
          }
          createMany: {
            args: Prisma.court_claim_initiatorsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.court_claim_initiatorsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$court_claim_initiatorsPayload>
          }
          update: {
            args: Prisma.court_claim_initiatorsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$court_claim_initiatorsPayload>
          }
          deleteMany: {
            args: Prisma.court_claim_initiatorsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.court_claim_initiatorsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.court_claim_initiatorsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$court_claim_initiatorsPayload>
          }
          aggregate: {
            args: Prisma.Court_claim_initiatorsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCourt_claim_initiators>
          }
          groupBy: {
            args: Prisma.court_claim_initiatorsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Court_claim_initiatorsGroupByOutputType>[]
          }
          count: {
            args: Prisma.court_claim_initiatorsCountArgs<ExtArgs>
            result: $Utils.Optional<Court_claim_initiatorsCountAggregateOutputType> | number
          }
        }
      }
      court_claim_members: {
        payload: Prisma.$court_claim_membersPayload<ExtArgs>
        fields: Prisma.court_claim_membersFieldRefs
        operations: {
          findUnique: {
            args: Prisma.court_claim_membersFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$court_claim_membersPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.court_claim_membersFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$court_claim_membersPayload>
          }
          findFirst: {
            args: Prisma.court_claim_membersFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$court_claim_membersPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.court_claim_membersFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$court_claim_membersPayload>
          }
          findMany: {
            args: Prisma.court_claim_membersFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$court_claim_membersPayload>[]
          }
          create: {
            args: Prisma.court_claim_membersCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$court_claim_membersPayload>
          }
          createMany: {
            args: Prisma.court_claim_membersCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.court_claim_membersDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$court_claim_membersPayload>
          }
          update: {
            args: Prisma.court_claim_membersUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$court_claim_membersPayload>
          }
          deleteMany: {
            args: Prisma.court_claim_membersDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.court_claim_membersUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.court_claim_membersUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$court_claim_membersPayload>
          }
          aggregate: {
            args: Prisma.Court_claim_membersAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCourt_claim_members>
          }
          groupBy: {
            args: Prisma.court_claim_membersGroupByArgs<ExtArgs>
            result: $Utils.Optional<Court_claim_membersGroupByOutputType>[]
          }
          count: {
            args: Prisma.court_claim_membersCountArgs<ExtArgs>
            result: $Utils.Optional<Court_claim_membersCountAggregateOutputType> | number
          }
        }
      }
      court_claims: {
        payload: Prisma.$court_claimsPayload<ExtArgs>
        fields: Prisma.court_claimsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.court_claimsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$court_claimsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.court_claimsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$court_claimsPayload>
          }
          findFirst: {
            args: Prisma.court_claimsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$court_claimsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.court_claimsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$court_claimsPayload>
          }
          findMany: {
            args: Prisma.court_claimsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$court_claimsPayload>[]
          }
          create: {
            args: Prisma.court_claimsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$court_claimsPayload>
          }
          createMany: {
            args: Prisma.court_claimsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.court_claimsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$court_claimsPayload>
          }
          update: {
            args: Prisma.court_claimsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$court_claimsPayload>
          }
          deleteMany: {
            args: Prisma.court_claimsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.court_claimsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.court_claimsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$court_claimsPayload>
          }
          aggregate: {
            args: Prisma.Court_claimsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCourt_claims>
          }
          groupBy: {
            args: Prisma.court_claimsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Court_claimsGroupByOutputType>[]
          }
          count: {
            args: Prisma.court_claimsCountArgs<ExtArgs>
            result: $Utils.Optional<Court_claimsCountAggregateOutputType> | number
          }
        }
      }
      court_cliam_status: {
        payload: Prisma.$court_cliam_statusPayload<ExtArgs>
        fields: Prisma.court_cliam_statusFieldRefs
        operations: {
          findUnique: {
            args: Prisma.court_cliam_statusFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$court_cliam_statusPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.court_cliam_statusFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$court_cliam_statusPayload>
          }
          findFirst: {
            args: Prisma.court_cliam_statusFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$court_cliam_statusPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.court_cliam_statusFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$court_cliam_statusPayload>
          }
          findMany: {
            args: Prisma.court_cliam_statusFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$court_cliam_statusPayload>[]
          }
          create: {
            args: Prisma.court_cliam_statusCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$court_cliam_statusPayload>
          }
          createMany: {
            args: Prisma.court_cliam_statusCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.court_cliam_statusDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$court_cliam_statusPayload>
          }
          update: {
            args: Prisma.court_cliam_statusUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$court_cliam_statusPayload>
          }
          deleteMany: {
            args: Prisma.court_cliam_statusDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.court_cliam_statusUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.court_cliam_statusUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$court_cliam_statusPayload>
          }
          aggregate: {
            args: Prisma.Court_cliam_statusAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCourt_cliam_status>
          }
          groupBy: {
            args: Prisma.court_cliam_statusGroupByArgs<ExtArgs>
            result: $Utils.Optional<Court_cliam_statusGroupByOutputType>[]
          }
          count: {
            args: Prisma.court_cliam_statusCountArgs<ExtArgs>
            result: $Utils.Optional<Court_cliam_statusCountAggregateOutputType> | number
          }
        }
      }
      court_decision_types: {
        payload: Prisma.$court_decision_typesPayload<ExtArgs>
        fields: Prisma.court_decision_typesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.court_decision_typesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$court_decision_typesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.court_decision_typesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$court_decision_typesPayload>
          }
          findFirst: {
            args: Prisma.court_decision_typesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$court_decision_typesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.court_decision_typesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$court_decision_typesPayload>
          }
          findMany: {
            args: Prisma.court_decision_typesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$court_decision_typesPayload>[]
          }
          create: {
            args: Prisma.court_decision_typesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$court_decision_typesPayload>
          }
          createMany: {
            args: Prisma.court_decision_typesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.court_decision_typesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$court_decision_typesPayload>
          }
          update: {
            args: Prisma.court_decision_typesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$court_decision_typesPayload>
          }
          deleteMany: {
            args: Prisma.court_decision_typesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.court_decision_typesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.court_decision_typesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$court_decision_typesPayload>
          }
          aggregate: {
            args: Prisma.Court_decision_typesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCourt_decision_types>
          }
          groupBy: {
            args: Prisma.court_decision_typesGroupByArgs<ExtArgs>
            result: $Utils.Optional<Court_decision_typesGroupByOutputType>[]
          }
          count: {
            args: Prisma.court_decision_typesCountArgs<ExtArgs>
            result: $Utils.Optional<Court_decision_typesCountAggregateOutputType> | number
          }
        }
      }
      court_decisions: {
        payload: Prisma.$court_decisionsPayload<ExtArgs>
        fields: Prisma.court_decisionsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.court_decisionsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$court_decisionsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.court_decisionsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$court_decisionsPayload>
          }
          findFirst: {
            args: Prisma.court_decisionsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$court_decisionsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.court_decisionsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$court_decisionsPayload>
          }
          findMany: {
            args: Prisma.court_decisionsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$court_decisionsPayload>[]
          }
          create: {
            args: Prisma.court_decisionsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$court_decisionsPayload>
          }
          createMany: {
            args: Prisma.court_decisionsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.court_decisionsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$court_decisionsPayload>
          }
          update: {
            args: Prisma.court_decisionsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$court_decisionsPayload>
          }
          deleteMany: {
            args: Prisma.court_decisionsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.court_decisionsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.court_decisionsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$court_decisionsPayload>
          }
          aggregate: {
            args: Prisma.Court_decisionsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCourt_decisions>
          }
          groupBy: {
            args: Prisma.court_decisionsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Court_decisionsGroupByOutputType>[]
          }
          count: {
            args: Prisma.court_decisionsCountArgs<ExtArgs>
            result: $Utils.Optional<Court_decisionsCountAggregateOutputType> | number
          }
        }
      }
      court_levels: {
        payload: Prisma.$court_levelsPayload<ExtArgs>
        fields: Prisma.court_levelsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.court_levelsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$court_levelsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.court_levelsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$court_levelsPayload>
          }
          findFirst: {
            args: Prisma.court_levelsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$court_levelsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.court_levelsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$court_levelsPayload>
          }
          findMany: {
            args: Prisma.court_levelsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$court_levelsPayload>[]
          }
          create: {
            args: Prisma.court_levelsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$court_levelsPayload>
          }
          createMany: {
            args: Prisma.court_levelsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.court_levelsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$court_levelsPayload>
          }
          update: {
            args: Prisma.court_levelsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$court_levelsPayload>
          }
          deleteMany: {
            args: Prisma.court_levelsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.court_levelsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.court_levelsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$court_levelsPayload>
          }
          aggregate: {
            args: Prisma.Court_levelsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCourt_levels>
          }
          groupBy: {
            args: Prisma.court_levelsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Court_levelsGroupByOutputType>[]
          }
          count: {
            args: Prisma.court_levelsCountArgs<ExtArgs>
            result: $Utils.Optional<Court_levelsCountAggregateOutputType> | number
          }
        }
      }
      cover_sign_status: {
        payload: Prisma.$cover_sign_statusPayload<ExtArgs>
        fields: Prisma.cover_sign_statusFieldRefs
        operations: {
          findUnique: {
            args: Prisma.cover_sign_statusFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cover_sign_statusPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.cover_sign_statusFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cover_sign_statusPayload>
          }
          findFirst: {
            args: Prisma.cover_sign_statusFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cover_sign_statusPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.cover_sign_statusFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cover_sign_statusPayload>
          }
          findMany: {
            args: Prisma.cover_sign_statusFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cover_sign_statusPayload>[]
          }
          create: {
            args: Prisma.cover_sign_statusCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cover_sign_statusPayload>
          }
          createMany: {
            args: Prisma.cover_sign_statusCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.cover_sign_statusDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cover_sign_statusPayload>
          }
          update: {
            args: Prisma.cover_sign_statusUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cover_sign_statusPayload>
          }
          deleteMany: {
            args: Prisma.cover_sign_statusDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.cover_sign_statusUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.cover_sign_statusUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cover_sign_statusPayload>
          }
          aggregate: {
            args: Prisma.Cover_sign_statusAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCover_sign_status>
          }
          groupBy: {
            args: Prisma.cover_sign_statusGroupByArgs<ExtArgs>
            result: $Utils.Optional<Cover_sign_statusGroupByOutputType>[]
          }
          count: {
            args: Prisma.cover_sign_statusCountArgs<ExtArgs>
            result: $Utils.Optional<Cover_sign_statusCountAggregateOutputType> | number
          }
        }
      }
      files: {
        payload: Prisma.$filesPayload<ExtArgs>
        fields: Prisma.filesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.filesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$filesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.filesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$filesPayload>
          }
          findFirst: {
            args: Prisma.filesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$filesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.filesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$filesPayload>
          }
          findMany: {
            args: Prisma.filesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$filesPayload>[]
          }
          create: {
            args: Prisma.filesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$filesPayload>
          }
          createMany: {
            args: Prisma.filesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.filesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$filesPayload>
          }
          update: {
            args: Prisma.filesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$filesPayload>
          }
          deleteMany: {
            args: Prisma.filesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.filesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.filesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$filesPayload>
          }
          aggregate: {
            args: Prisma.FilesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFiles>
          }
          groupBy: {
            args: Prisma.filesGroupByArgs<ExtArgs>
            result: $Utils.Optional<FilesGroupByOutputType>[]
          }
          count: {
            args: Prisma.filesCountArgs<ExtArgs>
            result: $Utils.Optional<FilesCountAggregateOutputType> | number
          }
        }
      }
      ips: {
        payload: Prisma.$ipsPayload<ExtArgs>
        fields: Prisma.ipsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ipsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ipsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ipsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ipsPayload>
          }
          findFirst: {
            args: Prisma.ipsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ipsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ipsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ipsPayload>
          }
          findMany: {
            args: Prisma.ipsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ipsPayload>[]
          }
          create: {
            args: Prisma.ipsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ipsPayload>
          }
          createMany: {
            args: Prisma.ipsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ipsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ipsPayload>
          }
          update: {
            args: Prisma.ipsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ipsPayload>
          }
          deleteMany: {
            args: Prisma.ipsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ipsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ipsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ipsPayload>
          }
          aggregate: {
            args: Prisma.IpsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateIps>
          }
          groupBy: {
            args: Prisma.ipsGroupByArgs<ExtArgs>
            result: $Utils.Optional<IpsGroupByOutputType>[]
          }
          count: {
            args: Prisma.ipsCountArgs<ExtArgs>
            result: $Utils.Optional<IpsCountAggregateOutputType> | number
          }
        }
      }
      old_case_decisions: {
        payload: Prisma.$old_case_decisionsPayload<ExtArgs>
        fields: Prisma.old_case_decisionsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.old_case_decisionsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$old_case_decisionsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.old_case_decisionsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$old_case_decisionsPayload>
          }
          findFirst: {
            args: Prisma.old_case_decisionsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$old_case_decisionsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.old_case_decisionsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$old_case_decisionsPayload>
          }
          findMany: {
            args: Prisma.old_case_decisionsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$old_case_decisionsPayload>[]
          }
          create: {
            args: Prisma.old_case_decisionsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$old_case_decisionsPayload>
          }
          createMany: {
            args: Prisma.old_case_decisionsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.old_case_decisionsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$old_case_decisionsPayload>
          }
          update: {
            args: Prisma.old_case_decisionsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$old_case_decisionsPayload>
          }
          deleteMany: {
            args: Prisma.old_case_decisionsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.old_case_decisionsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.old_case_decisionsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$old_case_decisionsPayload>
          }
          aggregate: {
            args: Prisma.Old_case_decisionsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOld_case_decisions>
          }
          groupBy: {
            args: Prisma.old_case_decisionsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Old_case_decisionsGroupByOutputType>[]
          }
          count: {
            args: Prisma.old_case_decisionsCountArgs<ExtArgs>
            result: $Utils.Optional<Old_case_decisionsCountAggregateOutputType> | number
          }
        }
      }
      old_case_person: {
        payload: Prisma.$old_case_personPayload<ExtArgs>
        fields: Prisma.old_case_personFieldRefs
        operations: {
          findUnique: {
            args: Prisma.old_case_personFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$old_case_personPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.old_case_personFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$old_case_personPayload>
          }
          findFirst: {
            args: Prisma.old_case_personFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$old_case_personPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.old_case_personFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$old_case_personPayload>
          }
          findMany: {
            args: Prisma.old_case_personFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$old_case_personPayload>[]
          }
          create: {
            args: Prisma.old_case_personCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$old_case_personPayload>
          }
          createMany: {
            args: Prisma.old_case_personCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.old_case_personDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$old_case_personPayload>
          }
          update: {
            args: Prisma.old_case_personUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$old_case_personPayload>
          }
          deleteMany: {
            args: Prisma.old_case_personDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.old_case_personUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.old_case_personUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$old_case_personPayload>
          }
          aggregate: {
            args: Prisma.Old_case_personAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOld_case_person>
          }
          groupBy: {
            args: Prisma.old_case_personGroupByArgs<ExtArgs>
            result: $Utils.Optional<Old_case_personGroupByOutputType>[]
          }
          count: {
            args: Prisma.old_case_personCountArgs<ExtArgs>
            result: $Utils.Optional<Old_case_personCountAggregateOutputType> | number
          }
        }
      }
      old_cases: {
        payload: Prisma.$old_casesPayload<ExtArgs>
        fields: Prisma.old_casesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.old_casesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$old_casesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.old_casesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$old_casesPayload>
          }
          findFirst: {
            args: Prisma.old_casesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$old_casesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.old_casesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$old_casesPayload>
          }
          findMany: {
            args: Prisma.old_casesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$old_casesPayload>[]
          }
          create: {
            args: Prisma.old_casesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$old_casesPayload>
          }
          createMany: {
            args: Prisma.old_casesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.old_casesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$old_casesPayload>
          }
          update: {
            args: Prisma.old_casesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$old_casesPayload>
          }
          deleteMany: {
            args: Prisma.old_casesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.old_casesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.old_casesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$old_casesPayload>
          }
          aggregate: {
            args: Prisma.Old_casesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOld_cases>
          }
          groupBy: {
            args: Prisma.old_casesGroupByArgs<ExtArgs>
            result: $Utils.Optional<Old_casesGroupByOutputType>[]
          }
          count: {
            args: Prisma.old_casesCountArgs<ExtArgs>
            result: $Utils.Optional<Old_casesCountAggregateOutputType> | number
          }
        }
      }
      tb_arm_com: {
        payload: Prisma.$tb_arm_comPayload<ExtArgs>
        fields: Prisma.tb_arm_comFieldRefs
        operations: {
          findUnique: {
            args: Prisma.tb_arm_comFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_arm_comPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.tb_arm_comFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_arm_comPayload>
          }
          findFirst: {
            args: Prisma.tb_arm_comFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_arm_comPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.tb_arm_comFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_arm_comPayload>
          }
          findMany: {
            args: Prisma.tb_arm_comFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_arm_comPayload>[]
          }
          create: {
            args: Prisma.tb_arm_comCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_arm_comPayload>
          }
          createMany: {
            args: Prisma.tb_arm_comCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.tb_arm_comDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_arm_comPayload>
          }
          update: {
            args: Prisma.tb_arm_comUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_arm_comPayload>
          }
          deleteMany: {
            args: Prisma.tb_arm_comDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.tb_arm_comUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.tb_arm_comUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_arm_comPayload>
          }
          aggregate: {
            args: Prisma.Tb_arm_comAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTb_arm_com>
          }
          groupBy: {
            args: Prisma.tb_arm_comGroupByArgs<ExtArgs>
            result: $Utils.Optional<Tb_arm_comGroupByOutputType>[]
          }
          count: {
            args: Prisma.tb_arm_comCountArgs<ExtArgs>
            result: $Utils.Optional<Tb_arm_comCountAggregateOutputType> | number
          }
        }
      }
      tb_arm_com__: {
        payload: Prisma.$tb_arm_com__Payload<ExtArgs>
        fields: Prisma.tb_arm_com__FieldRefs
        operations: {
          findUnique: {
            args: Prisma.tb_arm_com__FindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_arm_com__Payload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.tb_arm_com__FindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_arm_com__Payload>
          }
          findFirst: {
            args: Prisma.tb_arm_com__FindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_arm_com__Payload> | null
          }
          findFirstOrThrow: {
            args: Prisma.tb_arm_com__FindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_arm_com__Payload>
          }
          findMany: {
            args: Prisma.tb_arm_com__FindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_arm_com__Payload>[]
          }
          create: {
            args: Prisma.tb_arm_com__CreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_arm_com__Payload>
          }
          createMany: {
            args: Prisma.tb_arm_com__CreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.tb_arm_com__DeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_arm_com__Payload>
          }
          update: {
            args: Prisma.tb_arm_com__UpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_arm_com__Payload>
          }
          deleteMany: {
            args: Prisma.tb_arm_com__DeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.tb_arm_com__UpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.tb_arm_com__UpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_arm_com__Payload>
          }
          aggregate: {
            args: Prisma.Tb_arm_com__AggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTb_arm_com__>
          }
          groupBy: {
            args: Prisma.tb_arm_com__GroupByArgs<ExtArgs>
            result: $Utils.Optional<Tb_arm_com__GroupByOutputType>[]
          }
          count: {
            args: Prisma.tb_arm_com__CountArgs<ExtArgs>
            result: $Utils.Optional<Tb_arm_com__CountAggregateOutputType> | number
          }
        }
      }
      tb_calendar: {
        payload: Prisma.$tb_calendarPayload<ExtArgs>
        fields: Prisma.tb_calendarFieldRefs
        operations: {
          findUnique: {
            args: Prisma.tb_calendarFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_calendarPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.tb_calendarFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_calendarPayload>
          }
          findFirst: {
            args: Prisma.tb_calendarFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_calendarPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.tb_calendarFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_calendarPayload>
          }
          findMany: {
            args: Prisma.tb_calendarFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_calendarPayload>[]
          }
          create: {
            args: Prisma.tb_calendarCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_calendarPayload>
          }
          createMany: {
            args: Prisma.tb_calendarCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.tb_calendarDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_calendarPayload>
          }
          update: {
            args: Prisma.tb_calendarUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_calendarPayload>
          }
          deleteMany: {
            args: Prisma.tb_calendarDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.tb_calendarUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.tb_calendarUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_calendarPayload>
          }
          aggregate: {
            args: Prisma.Tb_calendarAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTb_calendar>
          }
          groupBy: {
            args: Prisma.tb_calendarGroupByArgs<ExtArgs>
            result: $Utils.Optional<Tb_calendarGroupByOutputType>[]
          }
          count: {
            args: Prisma.tb_calendarCountArgs<ExtArgs>
            result: $Utils.Optional<Tb_calendarCountAggregateOutputType> | number
          }
        }
      }
      tb_cancel: {
        payload: Prisma.$tb_cancelPayload<ExtArgs>
        fields: Prisma.tb_cancelFieldRefs
        operations: {
          findUnique: {
            args: Prisma.tb_cancelFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_cancelPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.tb_cancelFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_cancelPayload>
          }
          findFirst: {
            args: Prisma.tb_cancelFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_cancelPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.tb_cancelFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_cancelPayload>
          }
          findMany: {
            args: Prisma.tb_cancelFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_cancelPayload>[]
          }
          create: {
            args: Prisma.tb_cancelCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_cancelPayload>
          }
          createMany: {
            args: Prisma.tb_cancelCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.tb_cancelDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_cancelPayload>
          }
          update: {
            args: Prisma.tb_cancelUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_cancelPayload>
          }
          deleteMany: {
            args: Prisma.tb_cancelDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.tb_cancelUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.tb_cancelUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_cancelPayload>
          }
          aggregate: {
            args: Prisma.Tb_cancelAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTb_cancel>
          }
          groupBy: {
            args: Prisma.tb_cancelGroupByArgs<ExtArgs>
            result: $Utils.Optional<Tb_cancelGroupByOutputType>[]
          }
          count: {
            args: Prisma.tb_cancelCountArgs<ExtArgs>
            result: $Utils.Optional<Tb_cancelCountAggregateOutputType> | number
          }
        }
      }
      tb_cards: {
        payload: Prisma.$tb_cardsPayload<ExtArgs>
        fields: Prisma.tb_cardsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.tb_cardsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_cardsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.tb_cardsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_cardsPayload>
          }
          findFirst: {
            args: Prisma.tb_cardsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_cardsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.tb_cardsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_cardsPayload>
          }
          findMany: {
            args: Prisma.tb_cardsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_cardsPayload>[]
          }
          create: {
            args: Prisma.tb_cardsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_cardsPayload>
          }
          createMany: {
            args: Prisma.tb_cardsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.tb_cardsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_cardsPayload>
          }
          update: {
            args: Prisma.tb_cardsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_cardsPayload>
          }
          deleteMany: {
            args: Prisma.tb_cardsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.tb_cardsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.tb_cardsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_cardsPayload>
          }
          aggregate: {
            args: Prisma.Tb_cardsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTb_cards>
          }
          groupBy: {
            args: Prisma.tb_cardsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Tb_cardsGroupByOutputType>[]
          }
          count: {
            args: Prisma.tb_cardsCountArgs<ExtArgs>
            result: $Utils.Optional<Tb_cardsCountAggregateOutputType> | number
          }
        }
      }
      tb_case: {
        payload: Prisma.$tb_casePayload<ExtArgs>
        fields: Prisma.tb_caseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.tb_caseFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_casePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.tb_caseFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_casePayload>
          }
          findFirst: {
            args: Prisma.tb_caseFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_casePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.tb_caseFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_casePayload>
          }
          findMany: {
            args: Prisma.tb_caseFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_casePayload>[]
          }
          create: {
            args: Prisma.tb_caseCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_casePayload>
          }
          createMany: {
            args: Prisma.tb_caseCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.tb_caseDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_casePayload>
          }
          update: {
            args: Prisma.tb_caseUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_casePayload>
          }
          deleteMany: {
            args: Prisma.tb_caseDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.tb_caseUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.tb_caseUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_casePayload>
          }
          aggregate: {
            args: Prisma.Tb_caseAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTb_case>
          }
          groupBy: {
            args: Prisma.tb_caseGroupByArgs<ExtArgs>
            result: $Utils.Optional<Tb_caseGroupByOutputType>[]
          }
          count: {
            args: Prisma.tb_caseCountArgs<ExtArgs>
            result: $Utils.Optional<Tb_caseCountAggregateOutputType> | number
          }
        }
      }
      tb_case_status: {
        payload: Prisma.$tb_case_statusPayload<ExtArgs>
        fields: Prisma.tb_case_statusFieldRefs
        operations: {
          findUnique: {
            args: Prisma.tb_case_statusFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_case_statusPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.tb_case_statusFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_case_statusPayload>
          }
          findFirst: {
            args: Prisma.tb_case_statusFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_case_statusPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.tb_case_statusFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_case_statusPayload>
          }
          findMany: {
            args: Prisma.tb_case_statusFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_case_statusPayload>[]
          }
          create: {
            args: Prisma.tb_case_statusCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_case_statusPayload>
          }
          createMany: {
            args: Prisma.tb_case_statusCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.tb_case_statusDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_case_statusPayload>
          }
          update: {
            args: Prisma.tb_case_statusUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_case_statusPayload>
          }
          deleteMany: {
            args: Prisma.tb_case_statusDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.tb_case_statusUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.tb_case_statusUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_case_statusPayload>
          }
          aggregate: {
            args: Prisma.Tb_case_statusAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTb_case_status>
          }
          groupBy: {
            args: Prisma.tb_case_statusGroupByArgs<ExtArgs>
            result: $Utils.Optional<Tb_case_statusGroupByOutputType>[]
          }
          count: {
            args: Prisma.tb_case_statusCountArgs<ExtArgs>
            result: $Utils.Optional<Tb_case_statusCountAggregateOutputType> | number
          }
        }
      }
      tb_checkin: {
        payload: Prisma.$tb_checkinPayload<ExtArgs>
        fields: Prisma.tb_checkinFieldRefs
        operations: {
          findUnique: {
            args: Prisma.tb_checkinFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_checkinPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.tb_checkinFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_checkinPayload>
          }
          findFirst: {
            args: Prisma.tb_checkinFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_checkinPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.tb_checkinFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_checkinPayload>
          }
          findMany: {
            args: Prisma.tb_checkinFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_checkinPayload>[]
          }
          create: {
            args: Prisma.tb_checkinCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_checkinPayload>
          }
          createMany: {
            args: Prisma.tb_checkinCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.tb_checkinDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_checkinPayload>
          }
          update: {
            args: Prisma.tb_checkinUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_checkinPayload>
          }
          deleteMany: {
            args: Prisma.tb_checkinDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.tb_checkinUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.tb_checkinUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_checkinPayload>
          }
          aggregate: {
            args: Prisma.Tb_checkinAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTb_checkin>
          }
          groupBy: {
            args: Prisma.tb_checkinGroupByArgs<ExtArgs>
            result: $Utils.Optional<Tb_checkinGroupByOutputType>[]
          }
          count: {
            args: Prisma.tb_checkinCountArgs<ExtArgs>
            result: $Utils.Optional<Tb_checkinCountAggregateOutputType> | number
          }
        }
      }
      tb_coi: {
        payload: Prisma.$tb_coiPayload<ExtArgs>
        fields: Prisma.tb_coiFieldRefs
        operations: {
          findUnique: {
            args: Prisma.tb_coiFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_coiPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.tb_coiFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_coiPayload>
          }
          findFirst: {
            args: Prisma.tb_coiFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_coiPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.tb_coiFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_coiPayload>
          }
          findMany: {
            args: Prisma.tb_coiFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_coiPayload>[]
          }
          create: {
            args: Prisma.tb_coiCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_coiPayload>
          }
          createMany: {
            args: Prisma.tb_coiCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.tb_coiDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_coiPayload>
          }
          update: {
            args: Prisma.tb_coiUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_coiPayload>
          }
          deleteMany: {
            args: Prisma.tb_coiDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.tb_coiUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.tb_coiUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_coiPayload>
          }
          aggregate: {
            args: Prisma.Tb_coiAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTb_coi>
          }
          groupBy: {
            args: Prisma.tb_coiGroupByArgs<ExtArgs>
            result: $Utils.Optional<Tb_coiGroupByOutputType>[]
          }
          count: {
            args: Prisma.tb_coiCountArgs<ExtArgs>
            result: $Utils.Optional<Tb_coiCountAggregateOutputType> | number
          }
        }
      }
      tb_country: {
        payload: Prisma.$tb_countryPayload<ExtArgs>
        fields: Prisma.tb_countryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.tb_countryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_countryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.tb_countryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_countryPayload>
          }
          findFirst: {
            args: Prisma.tb_countryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_countryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.tb_countryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_countryPayload>
          }
          findMany: {
            args: Prisma.tb_countryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_countryPayload>[]
          }
          create: {
            args: Prisma.tb_countryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_countryPayload>
          }
          createMany: {
            args: Prisma.tb_countryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.tb_countryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_countryPayload>
          }
          update: {
            args: Prisma.tb_countryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_countryPayload>
          }
          deleteMany: {
            args: Prisma.tb_countryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.tb_countryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.tb_countryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_countryPayload>
          }
          aggregate: {
            args: Prisma.Tb_countryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTb_country>
          }
          groupBy: {
            args: Prisma.tb_countryGroupByArgs<ExtArgs>
            result: $Utils.Optional<Tb_countryGroupByOutputType>[]
          }
          count: {
            args: Prisma.tb_countryCountArgs<ExtArgs>
            result: $Utils.Optional<Tb_countryCountAggregateOutputType> | number
          }
        }
      }
      tb_cover_files: {
        payload: Prisma.$tb_cover_filesPayload<ExtArgs>
        fields: Prisma.tb_cover_filesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.tb_cover_filesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_cover_filesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.tb_cover_filesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_cover_filesPayload>
          }
          findFirst: {
            args: Prisma.tb_cover_filesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_cover_filesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.tb_cover_filesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_cover_filesPayload>
          }
          findMany: {
            args: Prisma.tb_cover_filesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_cover_filesPayload>[]
          }
          create: {
            args: Prisma.tb_cover_filesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_cover_filesPayload>
          }
          createMany: {
            args: Prisma.tb_cover_filesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.tb_cover_filesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_cover_filesPayload>
          }
          update: {
            args: Prisma.tb_cover_filesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_cover_filesPayload>
          }
          deleteMany: {
            args: Prisma.tb_cover_filesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.tb_cover_filesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.tb_cover_filesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_cover_filesPayload>
          }
          aggregate: {
            args: Prisma.Tb_cover_filesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTb_cover_files>
          }
          groupBy: {
            args: Prisma.tb_cover_filesGroupByArgs<ExtArgs>
            result: $Utils.Optional<Tb_cover_filesGroupByOutputType>[]
          }
          count: {
            args: Prisma.tb_cover_filesCountArgs<ExtArgs>
            result: $Utils.Optional<Tb_cover_filesCountAggregateOutputType> | number
          }
        }
      }
      tb_deadline: {
        payload: Prisma.$tb_deadlinePayload<ExtArgs>
        fields: Prisma.tb_deadlineFieldRefs
        operations: {
          findUnique: {
            args: Prisma.tb_deadlineFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_deadlinePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.tb_deadlineFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_deadlinePayload>
          }
          findFirst: {
            args: Prisma.tb_deadlineFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_deadlinePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.tb_deadlineFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_deadlinePayload>
          }
          findMany: {
            args: Prisma.tb_deadlineFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_deadlinePayload>[]
          }
          create: {
            args: Prisma.tb_deadlineCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_deadlinePayload>
          }
          createMany: {
            args: Prisma.tb_deadlineCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.tb_deadlineDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_deadlinePayload>
          }
          update: {
            args: Prisma.tb_deadlineUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_deadlinePayload>
          }
          deleteMany: {
            args: Prisma.tb_deadlineDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.tb_deadlineUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.tb_deadlineUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_deadlinePayload>
          }
          aggregate: {
            args: Prisma.Tb_deadlineAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTb_deadline>
          }
          groupBy: {
            args: Prisma.tb_deadlineGroupByArgs<ExtArgs>
            result: $Utils.Optional<Tb_deadlineGroupByOutputType>[]
          }
          count: {
            args: Prisma.tb_deadlineCountArgs<ExtArgs>
            result: $Utils.Optional<Tb_deadlineCountAggregateOutputType> | number
          }
        }
      }
      tb_deadline_types: {
        payload: Prisma.$tb_deadline_typesPayload<ExtArgs>
        fields: Prisma.tb_deadline_typesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.tb_deadline_typesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_deadline_typesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.tb_deadline_typesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_deadline_typesPayload>
          }
          findFirst: {
            args: Prisma.tb_deadline_typesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_deadline_typesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.tb_deadline_typesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_deadline_typesPayload>
          }
          findMany: {
            args: Prisma.tb_deadline_typesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_deadline_typesPayload>[]
          }
          create: {
            args: Prisma.tb_deadline_typesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_deadline_typesPayload>
          }
          createMany: {
            args: Prisma.tb_deadline_typesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.tb_deadline_typesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_deadline_typesPayload>
          }
          update: {
            args: Prisma.tb_deadline_typesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_deadline_typesPayload>
          }
          deleteMany: {
            args: Prisma.tb_deadline_typesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.tb_deadline_typesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.tb_deadline_typesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_deadline_typesPayload>
          }
          aggregate: {
            args: Prisma.Tb_deadline_typesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTb_deadline_types>
          }
          groupBy: {
            args: Prisma.tb_deadline_typesGroupByArgs<ExtArgs>
            result: $Utils.Optional<Tb_deadline_typesGroupByOutputType>[]
          }
          count: {
            args: Prisma.tb_deadline_typesCountArgs<ExtArgs>
            result: $Utils.Optional<Tb_deadline_typesCountAggregateOutputType> | number
          }
        }
      }
      tb_decision_status: {
        payload: Prisma.$tb_decision_statusPayload<ExtArgs>
        fields: Prisma.tb_decision_statusFieldRefs
        operations: {
          findUnique: {
            args: Prisma.tb_decision_statusFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_decision_statusPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.tb_decision_statusFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_decision_statusPayload>
          }
          findFirst: {
            args: Prisma.tb_decision_statusFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_decision_statusPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.tb_decision_statusFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_decision_statusPayload>
          }
          findMany: {
            args: Prisma.tb_decision_statusFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_decision_statusPayload>[]
          }
          create: {
            args: Prisma.tb_decision_statusCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_decision_statusPayload>
          }
          createMany: {
            args: Prisma.tb_decision_statusCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.tb_decision_statusDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_decision_statusPayload>
          }
          update: {
            args: Prisma.tb_decision_statusUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_decision_statusPayload>
          }
          deleteMany: {
            args: Prisma.tb_decision_statusDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.tb_decision_statusUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.tb_decision_statusUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_decision_statusPayload>
          }
          aggregate: {
            args: Prisma.Tb_decision_statusAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTb_decision_status>
          }
          groupBy: {
            args: Prisma.tb_decision_statusGroupByArgs<ExtArgs>
            result: $Utils.Optional<Tb_decision_statusGroupByOutputType>[]
          }
          count: {
            args: Prisma.tb_decision_statusCountArgs<ExtArgs>
            result: $Utils.Optional<Tb_decision_statusCountAggregateOutputType> | number
          }
        }
      }
      tb_decision_types: {
        payload: Prisma.$tb_decision_typesPayload<ExtArgs>
        fields: Prisma.tb_decision_typesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.tb_decision_typesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_decision_typesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.tb_decision_typesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_decision_typesPayload>
          }
          findFirst: {
            args: Prisma.tb_decision_typesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_decision_typesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.tb_decision_typesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_decision_typesPayload>
          }
          findMany: {
            args: Prisma.tb_decision_typesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_decision_typesPayload>[]
          }
          create: {
            args: Prisma.tb_decision_typesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_decision_typesPayload>
          }
          createMany: {
            args: Prisma.tb_decision_typesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.tb_decision_typesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_decision_typesPayload>
          }
          update: {
            args: Prisma.tb_decision_typesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_decision_typesPayload>
          }
          deleteMany: {
            args: Prisma.tb_decision_typesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.tb_decision_typesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.tb_decision_typesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_decision_typesPayload>
          }
          aggregate: {
            args: Prisma.Tb_decision_typesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTb_decision_types>
          }
          groupBy: {
            args: Prisma.tb_decision_typesGroupByArgs<ExtArgs>
            result: $Utils.Optional<Tb_decision_typesGroupByOutputType>[]
          }
          count: {
            args: Prisma.tb_decision_typesCountArgs<ExtArgs>
            result: $Utils.Optional<Tb_decision_typesCountAggregateOutputType> | number
          }
        }
      }
      tb_decisions: {
        payload: Prisma.$tb_decisionsPayload<ExtArgs>
        fields: Prisma.tb_decisionsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.tb_decisionsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_decisionsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.tb_decisionsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_decisionsPayload>
          }
          findFirst: {
            args: Prisma.tb_decisionsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_decisionsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.tb_decisionsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_decisionsPayload>
          }
          findMany: {
            args: Prisma.tb_decisionsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_decisionsPayload>[]
          }
          create: {
            args: Prisma.tb_decisionsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_decisionsPayload>
          }
          createMany: {
            args: Prisma.tb_decisionsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.tb_decisionsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_decisionsPayload>
          }
          update: {
            args: Prisma.tb_decisionsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_decisionsPayload>
          }
          deleteMany: {
            args: Prisma.tb_decisionsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.tb_decisionsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.tb_decisionsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_decisionsPayload>
          }
          aggregate: {
            args: Prisma.Tb_decisionsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTb_decisions>
          }
          groupBy: {
            args: Prisma.tb_decisionsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Tb_decisionsGroupByOutputType>[]
          }
          count: {
            args: Prisma.tb_decisionsCountArgs<ExtArgs>
            result: $Utils.Optional<Tb_decisionsCountAggregateOutputType> | number
          }
        }
      }
      tb_doss: {
        payload: Prisma.$tb_dossPayload<ExtArgs>
        fields: Prisma.tb_dossFieldRefs
        operations: {
          findUnique: {
            args: Prisma.tb_dossFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_dossPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.tb_dossFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_dossPayload>
          }
          findFirst: {
            args: Prisma.tb_dossFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_dossPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.tb_dossFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_dossPayload>
          }
          findMany: {
            args: Prisma.tb_dossFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_dossPayload>[]
          }
          create: {
            args: Prisma.tb_dossCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_dossPayload>
          }
          createMany: {
            args: Prisma.tb_dossCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.tb_dossDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_dossPayload>
          }
          update: {
            args: Prisma.tb_dossUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_dossPayload>
          }
          deleteMany: {
            args: Prisma.tb_dossDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.tb_dossUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.tb_dossUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_dossPayload>
          }
          aggregate: {
            args: Prisma.Tb_dossAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTb_doss>
          }
          groupBy: {
            args: Prisma.tb_dossGroupByArgs<ExtArgs>
            result: $Utils.Optional<Tb_dossGroupByOutputType>[]
          }
          count: {
            args: Prisma.tb_dossCountArgs<ExtArgs>
            result: $Utils.Optional<Tb_dossCountAggregateOutputType> | number
          }
        }
      }
      tb_draft: {
        payload: Prisma.$tb_draftPayload<ExtArgs>
        fields: Prisma.tb_draftFieldRefs
        operations: {
          findUnique: {
            args: Prisma.tb_draftFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_draftPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.tb_draftFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_draftPayload>
          }
          findFirst: {
            args: Prisma.tb_draftFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_draftPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.tb_draftFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_draftPayload>
          }
          findMany: {
            args: Prisma.tb_draftFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_draftPayload>[]
          }
          create: {
            args: Prisma.tb_draftCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_draftPayload>
          }
          createMany: {
            args: Prisma.tb_draftCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.tb_draftDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_draftPayload>
          }
          update: {
            args: Prisma.tb_draftUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_draftPayload>
          }
          deleteMany: {
            args: Prisma.tb_draftDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.tb_draftUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.tb_draftUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_draftPayload>
          }
          aggregate: {
            args: Prisma.Tb_draftAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTb_draft>
          }
          groupBy: {
            args: Prisma.tb_draftGroupByArgs<ExtArgs>
            result: $Utils.Optional<Tb_draftGroupByOutputType>[]
          }
          count: {
            args: Prisma.tb_draftCountArgs<ExtArgs>
            result: $Utils.Optional<Tb_draftCountAggregateOutputType> | number
          }
        }
      }
      tb_drooms: {
        payload: Prisma.$tb_droomsPayload<ExtArgs>
        fields: Prisma.tb_droomsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.tb_droomsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_droomsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.tb_droomsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_droomsPayload>
          }
          findFirst: {
            args: Prisma.tb_droomsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_droomsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.tb_droomsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_droomsPayload>
          }
          findMany: {
            args: Prisma.tb_droomsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_droomsPayload>[]
          }
          create: {
            args: Prisma.tb_droomsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_droomsPayload>
          }
          createMany: {
            args: Prisma.tb_droomsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.tb_droomsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_droomsPayload>
          }
          update: {
            args: Prisma.tb_droomsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_droomsPayload>
          }
          deleteMany: {
            args: Prisma.tb_droomsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.tb_droomsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.tb_droomsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_droomsPayload>
          }
          aggregate: {
            args: Prisma.Tb_droomsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTb_drooms>
          }
          groupBy: {
            args: Prisma.tb_droomsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Tb_droomsGroupByOutputType>[]
          }
          count: {
            args: Prisma.tb_droomsCountArgs<ExtArgs>
            result: $Utils.Optional<Tb_droomsCountAggregateOutputType> | number
          }
        }
      }
      tb_edu_lvl: {
        payload: Prisma.$tb_edu_lvlPayload<ExtArgs>
        fields: Prisma.tb_edu_lvlFieldRefs
        operations: {
          findUnique: {
            args: Prisma.tb_edu_lvlFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_edu_lvlPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.tb_edu_lvlFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_edu_lvlPayload>
          }
          findFirst: {
            args: Prisma.tb_edu_lvlFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_edu_lvlPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.tb_edu_lvlFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_edu_lvlPayload>
          }
          findMany: {
            args: Prisma.tb_edu_lvlFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_edu_lvlPayload>[]
          }
          create: {
            args: Prisma.tb_edu_lvlCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_edu_lvlPayload>
          }
          createMany: {
            args: Prisma.tb_edu_lvlCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.tb_edu_lvlDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_edu_lvlPayload>
          }
          update: {
            args: Prisma.tb_edu_lvlUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_edu_lvlPayload>
          }
          deleteMany: {
            args: Prisma.tb_edu_lvlDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.tb_edu_lvlUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.tb_edu_lvlUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_edu_lvlPayload>
          }
          aggregate: {
            args: Prisma.Tb_edu_lvlAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTb_edu_lvl>
          }
          groupBy: {
            args: Prisma.tb_edu_lvlGroupByArgs<ExtArgs>
            result: $Utils.Optional<Tb_edu_lvlGroupByOutputType>[]
          }
          count: {
            args: Prisma.tb_edu_lvlCountArgs<ExtArgs>
            result: $Utils.Optional<Tb_edu_lvlCountAggregateOutputType> | number
          }
        }
      }
      tb_education: {
        payload: Prisma.$tb_educationPayload<ExtArgs>
        fields: Prisma.tb_educationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.tb_educationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_educationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.tb_educationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_educationPayload>
          }
          findFirst: {
            args: Prisma.tb_educationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_educationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.tb_educationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_educationPayload>
          }
          findMany: {
            args: Prisma.tb_educationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_educationPayload>[]
          }
          create: {
            args: Prisma.tb_educationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_educationPayload>
          }
          createMany: {
            args: Prisma.tb_educationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.tb_educationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_educationPayload>
          }
          update: {
            args: Prisma.tb_educationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_educationPayload>
          }
          deleteMany: {
            args: Prisma.tb_educationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.tb_educationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.tb_educationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_educationPayload>
          }
          aggregate: {
            args: Prisma.Tb_educationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTb_education>
          }
          groupBy: {
            args: Prisma.tb_educationGroupByArgs<ExtArgs>
            result: $Utils.Optional<Tb_educationGroupByOutputType>[]
          }
          count: {
            args: Prisma.tb_educationCountArgs<ExtArgs>
            result: $Utils.Optional<Tb_educationCountAggregateOutputType> | number
          }
        }
      }
      tb_employment: {
        payload: Prisma.$tb_employmentPayload<ExtArgs>
        fields: Prisma.tb_employmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.tb_employmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_employmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.tb_employmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_employmentPayload>
          }
          findFirst: {
            args: Prisma.tb_employmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_employmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.tb_employmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_employmentPayload>
          }
          findMany: {
            args: Prisma.tb_employmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_employmentPayload>[]
          }
          create: {
            args: Prisma.tb_employmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_employmentPayload>
          }
          createMany: {
            args: Prisma.tb_employmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.tb_employmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_employmentPayload>
          }
          update: {
            args: Prisma.tb_employmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_employmentPayload>
          }
          deleteMany: {
            args: Prisma.tb_employmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.tb_employmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.tb_employmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_employmentPayload>
          }
          aggregate: {
            args: Prisma.Tb_employmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTb_employment>
          }
          groupBy: {
            args: Prisma.tb_employmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<Tb_employmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.tb_employmentCountArgs<ExtArgs>
            result: $Utils.Optional<Tb_employmentCountAggregateOutputType> | number
          }
        }
      }
      tb_etnics: {
        payload: Prisma.$tb_etnicsPayload<ExtArgs>
        fields: Prisma.tb_etnicsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.tb_etnicsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_etnicsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.tb_etnicsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_etnicsPayload>
          }
          findFirst: {
            args: Prisma.tb_etnicsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_etnicsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.tb_etnicsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_etnicsPayload>
          }
          findMany: {
            args: Prisma.tb_etnicsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_etnicsPayload>[]
          }
          create: {
            args: Prisma.tb_etnicsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_etnicsPayload>
          }
          createMany: {
            args: Prisma.tb_etnicsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.tb_etnicsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_etnicsPayload>
          }
          update: {
            args: Prisma.tb_etnicsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_etnicsPayload>
          }
          deleteMany: {
            args: Prisma.tb_etnicsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.tb_etnicsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.tb_etnicsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_etnicsPayload>
          }
          aggregate: {
            args: Prisma.Tb_etnicsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTb_etnics>
          }
          groupBy: {
            args: Prisma.tb_etnicsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Tb_etnicsGroupByOutputType>[]
          }
          count: {
            args: Prisma.tb_etnicsCountArgs<ExtArgs>
            result: $Utils.Optional<Tb_etnicsCountAggregateOutputType> | number
          }
        }
      }
      tb_file_type: {
        payload: Prisma.$tb_file_typePayload<ExtArgs>
        fields: Prisma.tb_file_typeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.tb_file_typeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_file_typePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.tb_file_typeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_file_typePayload>
          }
          findFirst: {
            args: Prisma.tb_file_typeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_file_typePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.tb_file_typeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_file_typePayload>
          }
          findMany: {
            args: Prisma.tb_file_typeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_file_typePayload>[]
          }
          create: {
            args: Prisma.tb_file_typeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_file_typePayload>
          }
          createMany: {
            args: Prisma.tb_file_typeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.tb_file_typeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_file_typePayload>
          }
          update: {
            args: Prisma.tb_file_typeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_file_typePayload>
          }
          deleteMany: {
            args: Prisma.tb_file_typeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.tb_file_typeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.tb_file_typeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_file_typePayload>
          }
          aggregate: {
            args: Prisma.Tb_file_typeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTb_file_type>
          }
          groupBy: {
            args: Prisma.tb_file_typeGroupByArgs<ExtArgs>
            result: $Utils.Optional<Tb_file_typeGroupByOutputType>[]
          }
          count: {
            args: Prisma.tb_file_typeCountArgs<ExtArgs>
            result: $Utils.Optional<Tb_file_typeCountAggregateOutputType> | number
          }
        }
      }
      tb_handed: {
        payload: Prisma.$tb_handedPayload<ExtArgs>
        fields: Prisma.tb_handedFieldRefs
        operations: {
          findUnique: {
            args: Prisma.tb_handedFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_handedPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.tb_handedFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_handedPayload>
          }
          findFirst: {
            args: Prisma.tb_handedFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_handedPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.tb_handedFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_handedPayload>
          }
          findMany: {
            args: Prisma.tb_handedFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_handedPayload>[]
          }
          create: {
            args: Prisma.tb_handedCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_handedPayload>
          }
          createMany: {
            args: Prisma.tb_handedCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.tb_handedDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_handedPayload>
          }
          update: {
            args: Prisma.tb_handedUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_handedPayload>
          }
          deleteMany: {
            args: Prisma.tb_handedDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.tb_handedUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.tb_handedUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_handedPayload>
          }
          aggregate: {
            args: Prisma.Tb_handedAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTb_handed>
          }
          groupBy: {
            args: Prisma.tb_handedGroupByArgs<ExtArgs>
            result: $Utils.Optional<Tb_handedGroupByOutputType>[]
          }
          count: {
            args: Prisma.tb_handedCountArgs<ExtArgs>
            result: $Utils.Optional<Tb_handedCountAggregateOutputType> | number
          }
        }
      }
      tb_inter: {
        payload: Prisma.$tb_interPayload<ExtArgs>
        fields: Prisma.tb_interFieldRefs
        operations: {
          findUnique: {
            args: Prisma.tb_interFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_interPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.tb_interFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_interPayload>
          }
          findFirst: {
            args: Prisma.tb_interFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_interPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.tb_interFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_interPayload>
          }
          findMany: {
            args: Prisma.tb_interFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_interPayload>[]
          }
          create: {
            args: Prisma.tb_interCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_interPayload>
          }
          createMany: {
            args: Prisma.tb_interCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.tb_interDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_interPayload>
          }
          update: {
            args: Prisma.tb_interUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_interPayload>
          }
          deleteMany: {
            args: Prisma.tb_interDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.tb_interUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.tb_interUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_interPayload>
          }
          aggregate: {
            args: Prisma.Tb_interAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTb_inter>
          }
          groupBy: {
            args: Prisma.tb_interGroupByArgs<ExtArgs>
            result: $Utils.Optional<Tb_interGroupByOutputType>[]
          }
          count: {
            args: Prisma.tb_interCountArgs<ExtArgs>
            result: $Utils.Optional<Tb_interCountAggregateOutputType> | number
          }
        }
      }
      tb_inter_notified: {
        payload: Prisma.$tb_inter_notifiedPayload<ExtArgs>
        fields: Prisma.tb_inter_notifiedFieldRefs
        operations: {
          findUnique: {
            args: Prisma.tb_inter_notifiedFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_inter_notifiedPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.tb_inter_notifiedFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_inter_notifiedPayload>
          }
          findFirst: {
            args: Prisma.tb_inter_notifiedFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_inter_notifiedPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.tb_inter_notifiedFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_inter_notifiedPayload>
          }
          findMany: {
            args: Prisma.tb_inter_notifiedFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_inter_notifiedPayload>[]
          }
          create: {
            args: Prisma.tb_inter_notifiedCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_inter_notifiedPayload>
          }
          createMany: {
            args: Prisma.tb_inter_notifiedCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.tb_inter_notifiedDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_inter_notifiedPayload>
          }
          update: {
            args: Prisma.tb_inter_notifiedUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_inter_notifiedPayload>
          }
          deleteMany: {
            args: Prisma.tb_inter_notifiedDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.tb_inter_notifiedUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.tb_inter_notifiedUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_inter_notifiedPayload>
          }
          aggregate: {
            args: Prisma.Tb_inter_notifiedAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTb_inter_notified>
          }
          groupBy: {
            args: Prisma.tb_inter_notifiedGroupByArgs<ExtArgs>
            result: $Utils.Optional<Tb_inter_notifiedGroupByOutputType>[]
          }
          count: {
            args: Prisma.tb_inter_notifiedCountArgs<ExtArgs>
            result: $Utils.Optional<Tb_inter_notifiedCountAggregateOutputType> | number
          }
        }
      }
      tb_inter_recivers: {
        payload: Prisma.$tb_inter_reciversPayload<ExtArgs>
        fields: Prisma.tb_inter_reciversFieldRefs
        operations: {
          findUnique: {
            args: Prisma.tb_inter_reciversFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_inter_reciversPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.tb_inter_reciversFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_inter_reciversPayload>
          }
          findFirst: {
            args: Prisma.tb_inter_reciversFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_inter_reciversPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.tb_inter_reciversFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_inter_reciversPayload>
          }
          findMany: {
            args: Prisma.tb_inter_reciversFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_inter_reciversPayload>[]
          }
          create: {
            args: Prisma.tb_inter_reciversCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_inter_reciversPayload>
          }
          createMany: {
            args: Prisma.tb_inter_reciversCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.tb_inter_reciversDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_inter_reciversPayload>
          }
          update: {
            args: Prisma.tb_inter_reciversUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_inter_reciversPayload>
          }
          deleteMany: {
            args: Prisma.tb_inter_reciversDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.tb_inter_reciversUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.tb_inter_reciversUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_inter_reciversPayload>
          }
          aggregate: {
            args: Prisma.Tb_inter_reciversAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTb_inter_recivers>
          }
          groupBy: {
            args: Prisma.tb_inter_reciversGroupByArgs<ExtArgs>
            result: $Utils.Optional<Tb_inter_reciversGroupByOutputType>[]
          }
          count: {
            args: Prisma.tb_inter_reciversCountArgs<ExtArgs>
            result: $Utils.Optional<Tb_inter_reciversCountAggregateOutputType> | number
          }
        }
      }
      tb_inter_send_type: {
        payload: Prisma.$tb_inter_send_typePayload<ExtArgs>
        fields: Prisma.tb_inter_send_typeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.tb_inter_send_typeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_inter_send_typePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.tb_inter_send_typeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_inter_send_typePayload>
          }
          findFirst: {
            args: Prisma.tb_inter_send_typeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_inter_send_typePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.tb_inter_send_typeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_inter_send_typePayload>
          }
          findMany: {
            args: Prisma.tb_inter_send_typeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_inter_send_typePayload>[]
          }
          create: {
            args: Prisma.tb_inter_send_typeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_inter_send_typePayload>
          }
          createMany: {
            args: Prisma.tb_inter_send_typeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.tb_inter_send_typeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_inter_send_typePayload>
          }
          update: {
            args: Prisma.tb_inter_send_typeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_inter_send_typePayload>
          }
          deleteMany: {
            args: Prisma.tb_inter_send_typeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.tb_inter_send_typeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.tb_inter_send_typeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_inter_send_typePayload>
          }
          aggregate: {
            args: Prisma.Tb_inter_send_typeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTb_inter_send_type>
          }
          groupBy: {
            args: Prisma.tb_inter_send_typeGroupByArgs<ExtArgs>
            result: $Utils.Optional<Tb_inter_send_typeGroupByOutputType>[]
          }
          count: {
            args: Prisma.tb_inter_send_typeCountArgs<ExtArgs>
            result: $Utils.Optional<Tb_inter_send_typeCountAggregateOutputType> | number
          }
        }
      }
      tb_inter_status_types: {
        payload: Prisma.$tb_inter_status_typesPayload<ExtArgs>
        fields: Prisma.tb_inter_status_typesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.tb_inter_status_typesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_inter_status_typesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.tb_inter_status_typesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_inter_status_typesPayload>
          }
          findFirst: {
            args: Prisma.tb_inter_status_typesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_inter_status_typesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.tb_inter_status_typesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_inter_status_typesPayload>
          }
          findMany: {
            args: Prisma.tb_inter_status_typesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_inter_status_typesPayload>[]
          }
          create: {
            args: Prisma.tb_inter_status_typesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_inter_status_typesPayload>
          }
          createMany: {
            args: Prisma.tb_inter_status_typesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.tb_inter_status_typesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_inter_status_typesPayload>
          }
          update: {
            args: Prisma.tb_inter_status_typesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_inter_status_typesPayload>
          }
          deleteMany: {
            args: Prisma.tb_inter_status_typesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.tb_inter_status_typesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.tb_inter_status_typesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_inter_status_typesPayload>
          }
          aggregate: {
            args: Prisma.Tb_inter_status_typesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTb_inter_status_types>
          }
          groupBy: {
            args: Prisma.tb_inter_status_typesGroupByArgs<ExtArgs>
            result: $Utils.Optional<Tb_inter_status_typesGroupByOutputType>[]
          }
          count: {
            args: Prisma.tb_inter_status_typesCountArgs<ExtArgs>
            result: $Utils.Optional<Tb_inter_status_typesCountAggregateOutputType> | number
          }
        }
      }
      tb_inter_type: {
        payload: Prisma.$tb_inter_typePayload<ExtArgs>
        fields: Prisma.tb_inter_typeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.tb_inter_typeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_inter_typePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.tb_inter_typeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_inter_typePayload>
          }
          findFirst: {
            args: Prisma.tb_inter_typeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_inter_typePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.tb_inter_typeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_inter_typePayload>
          }
          findMany: {
            args: Prisma.tb_inter_typeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_inter_typePayload>[]
          }
          create: {
            args: Prisma.tb_inter_typeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_inter_typePayload>
          }
          createMany: {
            args: Prisma.tb_inter_typeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.tb_inter_typeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_inter_typePayload>
          }
          update: {
            args: Prisma.tb_inter_typeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_inter_typePayload>
          }
          deleteMany: {
            args: Prisma.tb_inter_typeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.tb_inter_typeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.tb_inter_typeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_inter_typePayload>
          }
          aggregate: {
            args: Prisma.Tb_inter_typeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTb_inter_type>
          }
          groupBy: {
            args: Prisma.tb_inter_typeGroupByArgs<ExtArgs>
            result: $Utils.Optional<Tb_inter_typeGroupByOutputType>[]
          }
          count: {
            args: Prisma.tb_inter_typeCountArgs<ExtArgs>
            result: $Utils.Optional<Tb_inter_typeCountAggregateOutputType> | number
          }
        }
      }
      tb_lawyer: {
        payload: Prisma.$tb_lawyerPayload<ExtArgs>
        fields: Prisma.tb_lawyerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.tb_lawyerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_lawyerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.tb_lawyerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_lawyerPayload>
          }
          findFirst: {
            args: Prisma.tb_lawyerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_lawyerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.tb_lawyerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_lawyerPayload>
          }
          findMany: {
            args: Prisma.tb_lawyerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_lawyerPayload>[]
          }
          create: {
            args: Prisma.tb_lawyerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_lawyerPayload>
          }
          createMany: {
            args: Prisma.tb_lawyerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.tb_lawyerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_lawyerPayload>
          }
          update: {
            args: Prisma.tb_lawyerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_lawyerPayload>
          }
          deleteMany: {
            args: Prisma.tb_lawyerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.tb_lawyerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.tb_lawyerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_lawyerPayload>
          }
          aggregate: {
            args: Prisma.Tb_lawyerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTb_lawyer>
          }
          groupBy: {
            args: Prisma.tb_lawyerGroupByArgs<ExtArgs>
            result: $Utils.Optional<Tb_lawyerGroupByOutputType>[]
          }
          count: {
            args: Prisma.tb_lawyerCountArgs<ExtArgs>
            result: $Utils.Optional<Tb_lawyerCountAggregateOutputType> | number
          }
        }
      }
      tb_marz: {
        payload: Prisma.$tb_marzPayload<ExtArgs>
        fields: Prisma.tb_marzFieldRefs
        operations: {
          findUnique: {
            args: Prisma.tb_marzFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_marzPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.tb_marzFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_marzPayload>
          }
          findFirst: {
            args: Prisma.tb_marzFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_marzPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.tb_marzFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_marzPayload>
          }
          findMany: {
            args: Prisma.tb_marzFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_marzPayload>[]
          }
          create: {
            args: Prisma.tb_marzCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_marzPayload>
          }
          createMany: {
            args: Prisma.tb_marzCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.tb_marzDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_marzPayload>
          }
          update: {
            args: Prisma.tb_marzUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_marzPayload>
          }
          deleteMany: {
            args: Prisma.tb_marzDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.tb_marzUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.tb_marzUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_marzPayload>
          }
          aggregate: {
            args: Prisma.Tb_marzAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTb_marz>
          }
          groupBy: {
            args: Prisma.tb_marzGroupByArgs<ExtArgs>
            result: $Utils.Optional<Tb_marzGroupByOutputType>[]
          }
          count: {
            args: Prisma.tb_marzCountArgs<ExtArgs>
            result: $Utils.Optional<Tb_marzCountAggregateOutputType> | number
          }
        }
      }
      tb_members: {
        payload: Prisma.$tb_membersPayload<ExtArgs>
        fields: Prisma.tb_membersFieldRefs
        operations: {
          findUnique: {
            args: Prisma.tb_membersFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_membersPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.tb_membersFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_membersPayload>
          }
          findFirst: {
            args: Prisma.tb_membersFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_membersPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.tb_membersFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_membersPayload>
          }
          findMany: {
            args: Prisma.tb_membersFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_membersPayload>[]
          }
          create: {
            args: Prisma.tb_membersCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_membersPayload>
          }
          createMany: {
            args: Prisma.tb_membersCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.tb_membersDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_membersPayload>
          }
          update: {
            args: Prisma.tb_membersUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_membersPayload>
          }
          deleteMany: {
            args: Prisma.tb_membersDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.tb_membersUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.tb_membersUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_membersPayload>
          }
          aggregate: {
            args: Prisma.Tb_membersAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTb_members>
          }
          groupBy: {
            args: Prisma.tb_membersGroupByArgs<ExtArgs>
            result: $Utils.Optional<Tb_membersGroupByOutputType>[]
          }
          count: {
            args: Prisma.tb_membersCountArgs<ExtArgs>
            result: $Utils.Optional<Tb_membersCountAggregateOutputType> | number
          }
        }
      }
      tb_notifications: {
        payload: Prisma.$tb_notificationsPayload<ExtArgs>
        fields: Prisma.tb_notificationsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.tb_notificationsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_notificationsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.tb_notificationsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_notificationsPayload>
          }
          findFirst: {
            args: Prisma.tb_notificationsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_notificationsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.tb_notificationsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_notificationsPayload>
          }
          findMany: {
            args: Prisma.tb_notificationsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_notificationsPayload>[]
          }
          create: {
            args: Prisma.tb_notificationsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_notificationsPayload>
          }
          createMany: {
            args: Prisma.tb_notificationsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.tb_notificationsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_notificationsPayload>
          }
          update: {
            args: Prisma.tb_notificationsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_notificationsPayload>
          }
          deleteMany: {
            args: Prisma.tb_notificationsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.tb_notificationsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.tb_notificationsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_notificationsPayload>
          }
          aggregate: {
            args: Prisma.Tb_notificationsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTb_notifications>
          }
          groupBy: {
            args: Prisma.tb_notificationsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Tb_notificationsGroupByOutputType>[]
          }
          count: {
            args: Prisma.tb_notificationsCountArgs<ExtArgs>
            result: $Utils.Optional<Tb_notificationsCountAggregateOutputType> | number
          }
        }
      }
      tb_orders: {
        payload: Prisma.$tb_ordersPayload<ExtArgs>
        fields: Prisma.tb_ordersFieldRefs
        operations: {
          findUnique: {
            args: Prisma.tb_ordersFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_ordersPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.tb_ordersFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_ordersPayload>
          }
          findFirst: {
            args: Prisma.tb_ordersFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_ordersPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.tb_ordersFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_ordersPayload>
          }
          findMany: {
            args: Prisma.tb_ordersFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_ordersPayload>[]
          }
          create: {
            args: Prisma.tb_ordersCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_ordersPayload>
          }
          createMany: {
            args: Prisma.tb_ordersCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.tb_ordersDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_ordersPayload>
          }
          update: {
            args: Prisma.tb_ordersUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_ordersPayload>
          }
          deleteMany: {
            args: Prisma.tb_ordersDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.tb_ordersUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.tb_ordersUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_ordersPayload>
          }
          aggregate: {
            args: Prisma.Tb_ordersAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTb_orders>
          }
          groupBy: {
            args: Prisma.tb_ordersGroupByArgs<ExtArgs>
            result: $Utils.Optional<Tb_ordersGroupByOutputType>[]
          }
          count: {
            args: Prisma.tb_ordersCountArgs<ExtArgs>
            result: $Utils.Optional<Tb_ordersCountAggregateOutputType> | number
          }
        }
      }
      tb_person: {
        payload: Prisma.$tb_personPayload<ExtArgs>
        fields: Prisma.tb_personFieldRefs
        operations: {
          findUnique: {
            args: Prisma.tb_personFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_personPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.tb_personFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_personPayload>
          }
          findFirst: {
            args: Prisma.tb_personFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_personPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.tb_personFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_personPayload>
          }
          findMany: {
            args: Prisma.tb_personFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_personPayload>[]
          }
          create: {
            args: Prisma.tb_personCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_personPayload>
          }
          createMany: {
            args: Prisma.tb_personCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.tb_personDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_personPayload>
          }
          update: {
            args: Prisma.tb_personUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_personPayload>
          }
          deleteMany: {
            args: Prisma.tb_personDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.tb_personUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.tb_personUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_personPayload>
          }
          aggregate: {
            args: Prisma.Tb_personAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTb_person>
          }
          groupBy: {
            args: Prisma.tb_personGroupByArgs<ExtArgs>
            result: $Utils.Optional<Tb_personGroupByOutputType>[]
          }
          count: {
            args: Prisma.tb_personCountArgs<ExtArgs>
            result: $Utils.Optional<Tb_personCountAggregateOutputType> | number
          }
        }
      }
      tb_person_status: {
        payload: Prisma.$tb_person_statusPayload<ExtArgs>
        fields: Prisma.tb_person_statusFieldRefs
        operations: {
          findUnique: {
            args: Prisma.tb_person_statusFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_person_statusPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.tb_person_statusFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_person_statusPayload>
          }
          findFirst: {
            args: Prisma.tb_person_statusFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_person_statusPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.tb_person_statusFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_person_statusPayload>
          }
          findMany: {
            args: Prisma.tb_person_statusFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_person_statusPayload>[]
          }
          create: {
            args: Prisma.tb_person_statusCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_person_statusPayload>
          }
          createMany: {
            args: Prisma.tb_person_statusCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.tb_person_statusDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_person_statusPayload>
          }
          update: {
            args: Prisma.tb_person_statusUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_person_statusPayload>
          }
          deleteMany: {
            args: Prisma.tb_person_statusDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.tb_person_statusUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.tb_person_statusUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_person_statusPayload>
          }
          aggregate: {
            args: Prisma.Tb_person_statusAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTb_person_status>
          }
          groupBy: {
            args: Prisma.tb_person_statusGroupByArgs<ExtArgs>
            result: $Utils.Optional<Tb_person_statusGroupByOutputType>[]
          }
          count: {
            args: Prisma.tb_person_statusCountArgs<ExtArgs>
            result: $Utils.Optional<Tb_person_statusCountAggregateOutputType> | number
          }
        }
      }
      tb_process: {
        payload: Prisma.$tb_processPayload<ExtArgs>
        fields: Prisma.tb_processFieldRefs
        operations: {
          findUnique: {
            args: Prisma.tb_processFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_processPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.tb_processFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_processPayload>
          }
          findFirst: {
            args: Prisma.tb_processFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_processPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.tb_processFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_processPayload>
          }
          findMany: {
            args: Prisma.tb_processFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_processPayload>[]
          }
          create: {
            args: Prisma.tb_processCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_processPayload>
          }
          createMany: {
            args: Prisma.tb_processCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.tb_processDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_processPayload>
          }
          update: {
            args: Prisma.tb_processUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_processPayload>
          }
          deleteMany: {
            args: Prisma.tb_processDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.tb_processUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.tb_processUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_processPayload>
          }
          aggregate: {
            args: Prisma.Tb_processAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTb_process>
          }
          groupBy: {
            args: Prisma.tb_processGroupByArgs<ExtArgs>
            result: $Utils.Optional<Tb_processGroupByOutputType>[]
          }
          count: {
            args: Prisma.tb_processCountArgs<ExtArgs>
            result: $Utils.Optional<Tb_processCountAggregateOutputType> | number
          }
        }
      }
      tb_process_type: {
        payload: Prisma.$tb_process_typePayload<ExtArgs>
        fields: Prisma.tb_process_typeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.tb_process_typeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_process_typePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.tb_process_typeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_process_typePayload>
          }
          findFirst: {
            args: Prisma.tb_process_typeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_process_typePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.tb_process_typeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_process_typePayload>
          }
          findMany: {
            args: Prisma.tb_process_typeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_process_typePayload>[]
          }
          create: {
            args: Prisma.tb_process_typeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_process_typePayload>
          }
          createMany: {
            args: Prisma.tb_process_typeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.tb_process_typeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_process_typePayload>
          }
          update: {
            args: Prisma.tb_process_typeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_process_typePayload>
          }
          deleteMany: {
            args: Prisma.tb_process_typeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.tb_process_typeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.tb_process_typeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_process_typePayload>
          }
          aggregate: {
            args: Prisma.Tb_process_typeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTb_process_type>
          }
          groupBy: {
            args: Prisma.tb_process_typeGroupByArgs<ExtArgs>
            result: $Utils.Optional<Tb_process_typeGroupByOutputType>[]
          }
          count: {
            args: Prisma.tb_process_typeCountArgs<ExtArgs>
            result: $Utils.Optional<Tb_process_typeCountAggregateOutputType> | number
          }
        }
      }
      tb_religions: {
        payload: Prisma.$tb_religionsPayload<ExtArgs>
        fields: Prisma.tb_religionsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.tb_religionsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_religionsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.tb_religionsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_religionsPayload>
          }
          findFirst: {
            args: Prisma.tb_religionsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_religionsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.tb_religionsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_religionsPayload>
          }
          findMany: {
            args: Prisma.tb_religionsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_religionsPayload>[]
          }
          create: {
            args: Prisma.tb_religionsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_religionsPayload>
          }
          createMany: {
            args: Prisma.tb_religionsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.tb_religionsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_religionsPayload>
          }
          update: {
            args: Prisma.tb_religionsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_religionsPayload>
          }
          deleteMany: {
            args: Prisma.tb_religionsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.tb_religionsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.tb_religionsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_religionsPayload>
          }
          aggregate: {
            args: Prisma.Tb_religionsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTb_religions>
          }
          groupBy: {
            args: Prisma.tb_religionsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Tb_religionsGroupByOutputType>[]
          }
          count: {
            args: Prisma.tb_religionsCountArgs<ExtArgs>
            result: $Utils.Optional<Tb_religionsCountAggregateOutputType> | number
          }
        }
      }
      tb_request_bodies: {
        payload: Prisma.$tb_request_bodiesPayload<ExtArgs>
        fields: Prisma.tb_request_bodiesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.tb_request_bodiesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_request_bodiesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.tb_request_bodiesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_request_bodiesPayload>
          }
          findFirst: {
            args: Prisma.tb_request_bodiesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_request_bodiesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.tb_request_bodiesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_request_bodiesPayload>
          }
          findMany: {
            args: Prisma.tb_request_bodiesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_request_bodiesPayload>[]
          }
          create: {
            args: Prisma.tb_request_bodiesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_request_bodiesPayload>
          }
          createMany: {
            args: Prisma.tb_request_bodiesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.tb_request_bodiesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_request_bodiesPayload>
          }
          update: {
            args: Prisma.tb_request_bodiesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_request_bodiesPayload>
          }
          deleteMany: {
            args: Prisma.tb_request_bodiesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.tb_request_bodiesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.tb_request_bodiesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_request_bodiesPayload>
          }
          aggregate: {
            args: Prisma.Tb_request_bodiesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTb_request_bodies>
          }
          groupBy: {
            args: Prisma.tb_request_bodiesGroupByArgs<ExtArgs>
            result: $Utils.Optional<Tb_request_bodiesGroupByOutputType>[]
          }
          count: {
            args: Prisma.tb_request_bodiesCountArgs<ExtArgs>
            result: $Utils.Optional<Tb_request_bodiesCountAggregateOutputType> | number
          }
        }
      }
      tb_request_out: {
        payload: Prisma.$tb_request_outPayload<ExtArgs>
        fields: Prisma.tb_request_outFieldRefs
        operations: {
          findUnique: {
            args: Prisma.tb_request_outFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_request_outPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.tb_request_outFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_request_outPayload>
          }
          findFirst: {
            args: Prisma.tb_request_outFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_request_outPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.tb_request_outFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_request_outPayload>
          }
          findMany: {
            args: Prisma.tb_request_outFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_request_outPayload>[]
          }
          create: {
            args: Prisma.tb_request_outCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_request_outPayload>
          }
          createMany: {
            args: Prisma.tb_request_outCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.tb_request_outDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_request_outPayload>
          }
          update: {
            args: Prisma.tb_request_outUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_request_outPayload>
          }
          deleteMany: {
            args: Prisma.tb_request_outDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.tb_request_outUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.tb_request_outUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_request_outPayload>
          }
          aggregate: {
            args: Prisma.Tb_request_outAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTb_request_out>
          }
          groupBy: {
            args: Prisma.tb_request_outGroupByArgs<ExtArgs>
            result: $Utils.Optional<Tb_request_outGroupByOutputType>[]
          }
          count: {
            args: Prisma.tb_request_outCountArgs<ExtArgs>
            result: $Utils.Optional<Tb_request_outCountAggregateOutputType> | number
          }
        }
      }
      tb_role: {
        payload: Prisma.$tb_rolePayload<ExtArgs>
        fields: Prisma.tb_roleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.tb_roleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_rolePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.tb_roleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_rolePayload>
          }
          findFirst: {
            args: Prisma.tb_roleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_rolePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.tb_roleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_rolePayload>
          }
          findMany: {
            args: Prisma.tb_roleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_rolePayload>[]
          }
          create: {
            args: Prisma.tb_roleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_rolePayload>
          }
          createMany: {
            args: Prisma.tb_roleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.tb_roleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_rolePayload>
          }
          update: {
            args: Prisma.tb_roleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_rolePayload>
          }
          deleteMany: {
            args: Prisma.tb_roleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.tb_roleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.tb_roleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_rolePayload>
          }
          aggregate: {
            args: Prisma.Tb_roleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTb_role>
          }
          groupBy: {
            args: Prisma.tb_roleGroupByArgs<ExtArgs>
            result: $Utils.Optional<Tb_roleGroupByOutputType>[]
          }
          count: {
            args: Prisma.tb_roleCountArgs<ExtArgs>
            result: $Utils.Optional<Tb_roleCountAggregateOutputType> | number
          }
        }
      }
      tb_settlement: {
        payload: Prisma.$tb_settlementPayload<ExtArgs>
        fields: Prisma.tb_settlementFieldRefs
        operations: {
          findUnique: {
            args: Prisma.tb_settlementFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_settlementPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.tb_settlementFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_settlementPayload>
          }
          findFirst: {
            args: Prisma.tb_settlementFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_settlementPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.tb_settlementFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_settlementPayload>
          }
          findMany: {
            args: Prisma.tb_settlementFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_settlementPayload>[]
          }
          create: {
            args: Prisma.tb_settlementCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_settlementPayload>
          }
          createMany: {
            args: Prisma.tb_settlementCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.tb_settlementDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_settlementPayload>
          }
          update: {
            args: Prisma.tb_settlementUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_settlementPayload>
          }
          deleteMany: {
            args: Prisma.tb_settlementDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.tb_settlementUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.tb_settlementUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_settlementPayload>
          }
          aggregate: {
            args: Prisma.Tb_settlementAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTb_settlement>
          }
          groupBy: {
            args: Prisma.tb_settlementGroupByArgs<ExtArgs>
            result: $Utils.Optional<Tb_settlementGroupByOutputType>[]
          }
          count: {
            args: Prisma.tb_settlementCountArgs<ExtArgs>
            result: $Utils.Optional<Tb_settlementCountAggregateOutputType> | number
          }
        }
      }
      tb_settlement_: {
        payload: Prisma.$tb_settlement_Payload<ExtArgs>
        fields: Prisma.tb_settlement_FieldRefs
        operations: {
          findUnique: {
            args: Prisma.tb_settlement_FindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_settlement_Payload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.tb_settlement_FindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_settlement_Payload>
          }
          findFirst: {
            args: Prisma.tb_settlement_FindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_settlement_Payload> | null
          }
          findFirstOrThrow: {
            args: Prisma.tb_settlement_FindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_settlement_Payload>
          }
          findMany: {
            args: Prisma.tb_settlement_FindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_settlement_Payload>[]
          }
          create: {
            args: Prisma.tb_settlement_CreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_settlement_Payload>
          }
          createMany: {
            args: Prisma.tb_settlement_CreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.tb_settlement_DeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_settlement_Payload>
          }
          update: {
            args: Prisma.tb_settlement_UpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_settlement_Payload>
          }
          deleteMany: {
            args: Prisma.tb_settlement_DeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.tb_settlement_UpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.tb_settlement_UpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_settlement_Payload>
          }
          aggregate: {
            args: Prisma.Tb_settlement_AggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTb_settlement_>
          }
          groupBy: {
            args: Prisma.tb_settlement_GroupByArgs<ExtArgs>
            result: $Utils.Optional<Tb_settlement_GroupByOutputType>[]
          }
          count: {
            args: Prisma.tb_settlement_CountArgs<ExtArgs>
            result: $Utils.Optional<Tb_settlement_CountAggregateOutputType> | number
          }
        }
      }
      tb_sign_status: {
        payload: Prisma.$tb_sign_statusPayload<ExtArgs>
        fields: Prisma.tb_sign_statusFieldRefs
        operations: {
          findUnique: {
            args: Prisma.tb_sign_statusFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_sign_statusPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.tb_sign_statusFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_sign_statusPayload>
          }
          findFirst: {
            args: Prisma.tb_sign_statusFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_sign_statusPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.tb_sign_statusFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_sign_statusPayload>
          }
          findMany: {
            args: Prisma.tb_sign_statusFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_sign_statusPayload>[]
          }
          create: {
            args: Prisma.tb_sign_statusCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_sign_statusPayload>
          }
          createMany: {
            args: Prisma.tb_sign_statusCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.tb_sign_statusDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_sign_statusPayload>
          }
          update: {
            args: Prisma.tb_sign_statusUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_sign_statusPayload>
          }
          deleteMany: {
            args: Prisma.tb_sign_statusDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.tb_sign_statusUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.tb_sign_statusUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_sign_statusPayload>
          }
          aggregate: {
            args: Prisma.Tb_sign_statusAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTb_sign_status>
          }
          groupBy: {
            args: Prisma.tb_sign_statusGroupByArgs<ExtArgs>
            result: $Utils.Optional<Tb_sign_statusGroupByOutputType>[]
          }
          count: {
            args: Prisma.tb_sign_statusCountArgs<ExtArgs>
            result: $Utils.Optional<Tb_sign_statusCountAggregateOutputType> | number
          }
        }
      }
      tb_translate: {
        payload: Prisma.$tb_translatePayload<ExtArgs>
        fields: Prisma.tb_translateFieldRefs
        operations: {
          findUnique: {
            args: Prisma.tb_translateFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_translatePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.tb_translateFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_translatePayload>
          }
          findFirst: {
            args: Prisma.tb_translateFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_translatePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.tb_translateFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_translatePayload>
          }
          findMany: {
            args: Prisma.tb_translateFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_translatePayload>[]
          }
          create: {
            args: Prisma.tb_translateCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_translatePayload>
          }
          createMany: {
            args: Prisma.tb_translateCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.tb_translateDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_translatePayload>
          }
          update: {
            args: Prisma.tb_translateUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_translatePayload>
          }
          deleteMany: {
            args: Prisma.tb_translateDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.tb_translateUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.tb_translateUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_translatePayload>
          }
          aggregate: {
            args: Prisma.Tb_translateAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTb_translate>
          }
          groupBy: {
            args: Prisma.tb_translateGroupByArgs<ExtArgs>
            result: $Utils.Optional<Tb_translateGroupByOutputType>[]
          }
          count: {
            args: Prisma.tb_translateCountArgs<ExtArgs>
            result: $Utils.Optional<Tb_translateCountAggregateOutputType> | number
          }
        }
      }
      tb_translate_sign_statuses: {
        payload: Prisma.$tb_translate_sign_statusesPayload<ExtArgs>
        fields: Prisma.tb_translate_sign_statusesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.tb_translate_sign_statusesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_translate_sign_statusesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.tb_translate_sign_statusesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_translate_sign_statusesPayload>
          }
          findFirst: {
            args: Prisma.tb_translate_sign_statusesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_translate_sign_statusesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.tb_translate_sign_statusesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_translate_sign_statusesPayload>
          }
          findMany: {
            args: Prisma.tb_translate_sign_statusesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_translate_sign_statusesPayload>[]
          }
          create: {
            args: Prisma.tb_translate_sign_statusesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_translate_sign_statusesPayload>
          }
          createMany: {
            args: Prisma.tb_translate_sign_statusesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.tb_translate_sign_statusesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_translate_sign_statusesPayload>
          }
          update: {
            args: Prisma.tb_translate_sign_statusesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_translate_sign_statusesPayload>
          }
          deleteMany: {
            args: Prisma.tb_translate_sign_statusesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.tb_translate_sign_statusesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.tb_translate_sign_statusesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_translate_sign_statusesPayload>
          }
          aggregate: {
            args: Prisma.Tb_translate_sign_statusesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTb_translate_sign_statuses>
          }
          groupBy: {
            args: Prisma.tb_translate_sign_statusesGroupByArgs<ExtArgs>
            result: $Utils.Optional<Tb_translate_sign_statusesGroupByOutputType>[]
          }
          count: {
            args: Prisma.tb_translate_sign_statusesCountArgs<ExtArgs>
            result: $Utils.Optional<Tb_translate_sign_statusesCountAggregateOutputType> | number
          }
        }
      }
      tb_translation_type: {
        payload: Prisma.$tb_translation_typePayload<ExtArgs>
        fields: Prisma.tb_translation_typeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.tb_translation_typeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_translation_typePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.tb_translation_typeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_translation_typePayload>
          }
          findFirst: {
            args: Prisma.tb_translation_typeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_translation_typePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.tb_translation_typeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_translation_typePayload>
          }
          findMany: {
            args: Prisma.tb_translation_typeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_translation_typePayload>[]
          }
          create: {
            args: Prisma.tb_translation_typeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_translation_typePayload>
          }
          createMany: {
            args: Prisma.tb_translation_typeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.tb_translation_typeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_translation_typePayload>
          }
          update: {
            args: Prisma.tb_translation_typeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_translation_typePayload>
          }
          deleteMany: {
            args: Prisma.tb_translation_typeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.tb_translation_typeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.tb_translation_typeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_translation_typePayload>
          }
          aggregate: {
            args: Prisma.Tb_translation_typeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTb_translation_type>
          }
          groupBy: {
            args: Prisma.tb_translation_typeGroupByArgs<ExtArgs>
            result: $Utils.Optional<Tb_translation_typeGroupByOutputType>[]
          }
          count: {
            args: Prisma.tb_translation_typeCountArgs<ExtArgs>
            result: $Utils.Optional<Tb_translation_typeCountAggregateOutputType> | number
          }
        }
      }
      tb_translators: {
        payload: Prisma.$tb_translatorsPayload<ExtArgs>
        fields: Prisma.tb_translatorsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.tb_translatorsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_translatorsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.tb_translatorsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_translatorsPayload>
          }
          findFirst: {
            args: Prisma.tb_translatorsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_translatorsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.tb_translatorsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_translatorsPayload>
          }
          findMany: {
            args: Prisma.tb_translatorsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_translatorsPayload>[]
          }
          create: {
            args: Prisma.tb_translatorsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_translatorsPayload>
          }
          createMany: {
            args: Prisma.tb_translatorsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.tb_translatorsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_translatorsPayload>
          }
          update: {
            args: Prisma.tb_translatorsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_translatorsPayload>
          }
          deleteMany: {
            args: Prisma.tb_translatorsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.tb_translatorsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.tb_translatorsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tb_translatorsPayload>
          }
          aggregate: {
            args: Prisma.Tb_translatorsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTb_translators>
          }
          groupBy: {
            args: Prisma.tb_translatorsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Tb_translatorsGroupByOutputType>[]
          }
          count: {
            args: Prisma.tb_translatorsCountArgs<ExtArgs>
            result: $Utils.Optional<Tb_translatorsCountAggregateOutputType> | number
          }
        }
      }
      users: {
        payload: Prisma.$usersPayload<ExtArgs>
        fields: Prisma.usersFieldRefs
        operations: {
          findUnique: {
            args: Prisma.usersFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.usersFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          findFirst: {
            args: Prisma.usersFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.usersFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          findMany: {
            args: Prisma.usersFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>[]
          }
          create: {
            args: Prisma.usersCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          createMany: {
            args: Prisma.usersCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.usersDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          update: {
            args: Prisma.usersUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          deleteMany: {
            args: Prisma.usersDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.usersUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.usersUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          aggregate: {
            args: Prisma.UsersAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUsers>
          }
          groupBy: {
            args: Prisma.usersGroupByArgs<ExtArgs>
            result: $Utils.Optional<UsersGroupByOutputType>[]
          }
          count: {
            args: Prisma.usersCountArgs<ExtArgs>
            result: $Utils.Optional<UsersCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    court_appeal_types?: court_appeal_typesOmit
    court_appeals?: court_appealsOmit
    court_claim_initiators?: court_claim_initiatorsOmit
    court_claim_members?: court_claim_membersOmit
    court_claims?: court_claimsOmit
    court_cliam_status?: court_cliam_statusOmit
    court_decision_types?: court_decision_typesOmit
    court_decisions?: court_decisionsOmit
    court_levels?: court_levelsOmit
    cover_sign_status?: cover_sign_statusOmit
    files?: filesOmit
    ips?: ipsOmit
    old_case_decisions?: old_case_decisionsOmit
    old_case_person?: old_case_personOmit
    old_cases?: old_casesOmit
    tb_arm_com?: tb_arm_comOmit
    tb_arm_com__?: tb_arm_com__Omit
    tb_calendar?: tb_calendarOmit
    tb_cancel?: tb_cancelOmit
    tb_cards?: tb_cardsOmit
    tb_case?: tb_caseOmit
    tb_case_status?: tb_case_statusOmit
    tb_checkin?: tb_checkinOmit
    tb_coi?: tb_coiOmit
    tb_country?: tb_countryOmit
    tb_cover_files?: tb_cover_filesOmit
    tb_deadline?: tb_deadlineOmit
    tb_deadline_types?: tb_deadline_typesOmit
    tb_decision_status?: tb_decision_statusOmit
    tb_decision_types?: tb_decision_typesOmit
    tb_decisions?: tb_decisionsOmit
    tb_doss?: tb_dossOmit
    tb_draft?: tb_draftOmit
    tb_drooms?: tb_droomsOmit
    tb_edu_lvl?: tb_edu_lvlOmit
    tb_education?: tb_educationOmit
    tb_employment?: tb_employmentOmit
    tb_etnics?: tb_etnicsOmit
    tb_file_type?: tb_file_typeOmit
    tb_handed?: tb_handedOmit
    tb_inter?: tb_interOmit
    tb_inter_notified?: tb_inter_notifiedOmit
    tb_inter_recivers?: tb_inter_reciversOmit
    tb_inter_send_type?: tb_inter_send_typeOmit
    tb_inter_status_types?: tb_inter_status_typesOmit
    tb_inter_type?: tb_inter_typeOmit
    tb_lawyer?: tb_lawyerOmit
    tb_marz?: tb_marzOmit
    tb_members?: tb_membersOmit
    tb_notifications?: tb_notificationsOmit
    tb_orders?: tb_ordersOmit
    tb_person?: tb_personOmit
    tb_person_status?: tb_person_statusOmit
    tb_process?: tb_processOmit
    tb_process_type?: tb_process_typeOmit
    tb_religions?: tb_religionsOmit
    tb_request_bodies?: tb_request_bodiesOmit
    tb_request_out?: tb_request_outOmit
    tb_role?: tb_roleOmit
    tb_settlement?: tb_settlementOmit
    tb_settlement_?: tb_settlement_Omit
    tb_sign_status?: tb_sign_statusOmit
    tb_translate?: tb_translateOmit
    tb_translate_sign_statuses?: tb_translate_sign_statusesOmit
    tb_translation_type?: tb_translation_typeOmit
    tb_translators?: tb_translatorsOmit
    users?: usersOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */



  /**
   * Models
   */

  /**
   * Model court_appeal_types
   */

  export type AggregateCourt_appeal_types = {
    _count: Court_appeal_typesCountAggregateOutputType | null
    _avg: Court_appeal_typesAvgAggregateOutputType | null
    _sum: Court_appeal_typesSumAggregateOutputType | null
    _min: Court_appeal_typesMinAggregateOutputType | null
    _max: Court_appeal_typesMaxAggregateOutputType | null
  }

  export type Court_appeal_typesAvgAggregateOutputType = {
    appeal_type_id: number | null
  }

  export type Court_appeal_typesSumAggregateOutputType = {
    appeal_type_id: number | null
  }

  export type Court_appeal_typesMinAggregateOutputType = {
    appeal_type_id: number | null
    appeal_type: string | null
  }

  export type Court_appeal_typesMaxAggregateOutputType = {
    appeal_type_id: number | null
    appeal_type: string | null
  }

  export type Court_appeal_typesCountAggregateOutputType = {
    appeal_type_id: number
    appeal_type: number
    _all: number
  }


  export type Court_appeal_typesAvgAggregateInputType = {
    appeal_type_id?: true
  }

  export type Court_appeal_typesSumAggregateInputType = {
    appeal_type_id?: true
  }

  export type Court_appeal_typesMinAggregateInputType = {
    appeal_type_id?: true
    appeal_type?: true
  }

  export type Court_appeal_typesMaxAggregateInputType = {
    appeal_type_id?: true
    appeal_type?: true
  }

  export type Court_appeal_typesCountAggregateInputType = {
    appeal_type_id?: true
    appeal_type?: true
    _all?: true
  }

  export type Court_appeal_typesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which court_appeal_types to aggregate.
     */
    where?: court_appeal_typesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of court_appeal_types to fetch.
     */
    orderBy?: court_appeal_typesOrderByWithRelationInput | court_appeal_typesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: court_appeal_typesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` court_appeal_types from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` court_appeal_types.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned court_appeal_types
    **/
    _count?: true | Court_appeal_typesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Court_appeal_typesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Court_appeal_typesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Court_appeal_typesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Court_appeal_typesMaxAggregateInputType
  }

  export type GetCourt_appeal_typesAggregateType<T extends Court_appeal_typesAggregateArgs> = {
        [P in keyof T & keyof AggregateCourt_appeal_types]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCourt_appeal_types[P]>
      : GetScalarType<T[P], AggregateCourt_appeal_types[P]>
  }




  export type court_appeal_typesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: court_appeal_typesWhereInput
    orderBy?: court_appeal_typesOrderByWithAggregationInput | court_appeal_typesOrderByWithAggregationInput[]
    by: Court_appeal_typesScalarFieldEnum[] | Court_appeal_typesScalarFieldEnum
    having?: court_appeal_typesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Court_appeal_typesCountAggregateInputType | true
    _avg?: Court_appeal_typesAvgAggregateInputType
    _sum?: Court_appeal_typesSumAggregateInputType
    _min?: Court_appeal_typesMinAggregateInputType
    _max?: Court_appeal_typesMaxAggregateInputType
  }

  export type Court_appeal_typesGroupByOutputType = {
    appeal_type_id: number
    appeal_type: string
    _count: Court_appeal_typesCountAggregateOutputType | null
    _avg: Court_appeal_typesAvgAggregateOutputType | null
    _sum: Court_appeal_typesSumAggregateOutputType | null
    _min: Court_appeal_typesMinAggregateOutputType | null
    _max: Court_appeal_typesMaxAggregateOutputType | null
  }

  type GetCourt_appeal_typesGroupByPayload<T extends court_appeal_typesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Court_appeal_typesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Court_appeal_typesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Court_appeal_typesGroupByOutputType[P]>
            : GetScalarType<T[P], Court_appeal_typesGroupByOutputType[P]>
        }
      >
    >


  export type court_appeal_typesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    appeal_type_id?: boolean
    appeal_type?: boolean
  }, ExtArgs["result"]["court_appeal_types"]>



  export type court_appeal_typesSelectScalar = {
    appeal_type_id?: boolean
    appeal_type?: boolean
  }

  export type court_appeal_typesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"appeal_type_id" | "appeal_type", ExtArgs["result"]["court_appeal_types"]>

  export type $court_appeal_typesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "court_appeal_types"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      appeal_type_id: number
      appeal_type: string
    }, ExtArgs["result"]["court_appeal_types"]>
    composites: {}
  }

  type court_appeal_typesGetPayload<S extends boolean | null | undefined | court_appeal_typesDefaultArgs> = $Result.GetResult<Prisma.$court_appeal_typesPayload, S>

  type court_appeal_typesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<court_appeal_typesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Court_appeal_typesCountAggregateInputType | true
    }

  export interface court_appeal_typesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['court_appeal_types'], meta: { name: 'court_appeal_types' } }
    /**
     * Find zero or one Court_appeal_types that matches the filter.
     * @param {court_appeal_typesFindUniqueArgs} args - Arguments to find a Court_appeal_types
     * @example
     * // Get one Court_appeal_types
     * const court_appeal_types = await prisma.court_appeal_types.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends court_appeal_typesFindUniqueArgs>(args: SelectSubset<T, court_appeal_typesFindUniqueArgs<ExtArgs>>): Prisma__court_appeal_typesClient<$Result.GetResult<Prisma.$court_appeal_typesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Court_appeal_types that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {court_appeal_typesFindUniqueOrThrowArgs} args - Arguments to find a Court_appeal_types
     * @example
     * // Get one Court_appeal_types
     * const court_appeal_types = await prisma.court_appeal_types.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends court_appeal_typesFindUniqueOrThrowArgs>(args: SelectSubset<T, court_appeal_typesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__court_appeal_typesClient<$Result.GetResult<Prisma.$court_appeal_typesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Court_appeal_types that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {court_appeal_typesFindFirstArgs} args - Arguments to find a Court_appeal_types
     * @example
     * // Get one Court_appeal_types
     * const court_appeal_types = await prisma.court_appeal_types.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends court_appeal_typesFindFirstArgs>(args?: SelectSubset<T, court_appeal_typesFindFirstArgs<ExtArgs>>): Prisma__court_appeal_typesClient<$Result.GetResult<Prisma.$court_appeal_typesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Court_appeal_types that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {court_appeal_typesFindFirstOrThrowArgs} args - Arguments to find a Court_appeal_types
     * @example
     * // Get one Court_appeal_types
     * const court_appeal_types = await prisma.court_appeal_types.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends court_appeal_typesFindFirstOrThrowArgs>(args?: SelectSubset<T, court_appeal_typesFindFirstOrThrowArgs<ExtArgs>>): Prisma__court_appeal_typesClient<$Result.GetResult<Prisma.$court_appeal_typesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Court_appeal_types that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {court_appeal_typesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Court_appeal_types
     * const court_appeal_types = await prisma.court_appeal_types.findMany()
     * 
     * // Get first 10 Court_appeal_types
     * const court_appeal_types = await prisma.court_appeal_types.findMany({ take: 10 })
     * 
     * // Only select the `appeal_type_id`
     * const court_appeal_typesWithAppeal_type_idOnly = await prisma.court_appeal_types.findMany({ select: { appeal_type_id: true } })
     * 
     */
    findMany<T extends court_appeal_typesFindManyArgs>(args?: SelectSubset<T, court_appeal_typesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$court_appeal_typesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Court_appeal_types.
     * @param {court_appeal_typesCreateArgs} args - Arguments to create a Court_appeal_types.
     * @example
     * // Create one Court_appeal_types
     * const Court_appeal_types = await prisma.court_appeal_types.create({
     *   data: {
     *     // ... data to create a Court_appeal_types
     *   }
     * })
     * 
     */
    create<T extends court_appeal_typesCreateArgs>(args: SelectSubset<T, court_appeal_typesCreateArgs<ExtArgs>>): Prisma__court_appeal_typesClient<$Result.GetResult<Prisma.$court_appeal_typesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Court_appeal_types.
     * @param {court_appeal_typesCreateManyArgs} args - Arguments to create many Court_appeal_types.
     * @example
     * // Create many Court_appeal_types
     * const court_appeal_types = await prisma.court_appeal_types.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends court_appeal_typesCreateManyArgs>(args?: SelectSubset<T, court_appeal_typesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Court_appeal_types.
     * @param {court_appeal_typesDeleteArgs} args - Arguments to delete one Court_appeal_types.
     * @example
     * // Delete one Court_appeal_types
     * const Court_appeal_types = await prisma.court_appeal_types.delete({
     *   where: {
     *     // ... filter to delete one Court_appeal_types
     *   }
     * })
     * 
     */
    delete<T extends court_appeal_typesDeleteArgs>(args: SelectSubset<T, court_appeal_typesDeleteArgs<ExtArgs>>): Prisma__court_appeal_typesClient<$Result.GetResult<Prisma.$court_appeal_typesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Court_appeal_types.
     * @param {court_appeal_typesUpdateArgs} args - Arguments to update one Court_appeal_types.
     * @example
     * // Update one Court_appeal_types
     * const court_appeal_types = await prisma.court_appeal_types.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends court_appeal_typesUpdateArgs>(args: SelectSubset<T, court_appeal_typesUpdateArgs<ExtArgs>>): Prisma__court_appeal_typesClient<$Result.GetResult<Prisma.$court_appeal_typesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Court_appeal_types.
     * @param {court_appeal_typesDeleteManyArgs} args - Arguments to filter Court_appeal_types to delete.
     * @example
     * // Delete a few Court_appeal_types
     * const { count } = await prisma.court_appeal_types.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends court_appeal_typesDeleteManyArgs>(args?: SelectSubset<T, court_appeal_typesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Court_appeal_types.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {court_appeal_typesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Court_appeal_types
     * const court_appeal_types = await prisma.court_appeal_types.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends court_appeal_typesUpdateManyArgs>(args: SelectSubset<T, court_appeal_typesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Court_appeal_types.
     * @param {court_appeal_typesUpsertArgs} args - Arguments to update or create a Court_appeal_types.
     * @example
     * // Update or create a Court_appeal_types
     * const court_appeal_types = await prisma.court_appeal_types.upsert({
     *   create: {
     *     // ... data to create a Court_appeal_types
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Court_appeal_types we want to update
     *   }
     * })
     */
    upsert<T extends court_appeal_typesUpsertArgs>(args: SelectSubset<T, court_appeal_typesUpsertArgs<ExtArgs>>): Prisma__court_appeal_typesClient<$Result.GetResult<Prisma.$court_appeal_typesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Court_appeal_types.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {court_appeal_typesCountArgs} args - Arguments to filter Court_appeal_types to count.
     * @example
     * // Count the number of Court_appeal_types
     * const count = await prisma.court_appeal_types.count({
     *   where: {
     *     // ... the filter for the Court_appeal_types we want to count
     *   }
     * })
    **/
    count<T extends court_appeal_typesCountArgs>(
      args?: Subset<T, court_appeal_typesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Court_appeal_typesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Court_appeal_types.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Court_appeal_typesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Court_appeal_typesAggregateArgs>(args: Subset<T, Court_appeal_typesAggregateArgs>): Prisma.PrismaPromise<GetCourt_appeal_typesAggregateType<T>>

    /**
     * Group by Court_appeal_types.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {court_appeal_typesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends court_appeal_typesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: court_appeal_typesGroupByArgs['orderBy'] }
        : { orderBy?: court_appeal_typesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, court_appeal_typesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCourt_appeal_typesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the court_appeal_types model
   */
  readonly fields: court_appeal_typesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for court_appeal_types.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__court_appeal_typesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the court_appeal_types model
   */
  interface court_appeal_typesFieldRefs {
    readonly appeal_type_id: FieldRef<"court_appeal_types", 'Int'>
    readonly appeal_type: FieldRef<"court_appeal_types", 'String'>
  }
    

  // Custom InputTypes
  /**
   * court_appeal_types findUnique
   */
  export type court_appeal_typesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the court_appeal_types
     */
    select?: court_appeal_typesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the court_appeal_types
     */
    omit?: court_appeal_typesOmit<ExtArgs> | null
    /**
     * Filter, which court_appeal_types to fetch.
     */
    where: court_appeal_typesWhereUniqueInput
  }

  /**
   * court_appeal_types findUniqueOrThrow
   */
  export type court_appeal_typesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the court_appeal_types
     */
    select?: court_appeal_typesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the court_appeal_types
     */
    omit?: court_appeal_typesOmit<ExtArgs> | null
    /**
     * Filter, which court_appeal_types to fetch.
     */
    where: court_appeal_typesWhereUniqueInput
  }

  /**
   * court_appeal_types findFirst
   */
  export type court_appeal_typesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the court_appeal_types
     */
    select?: court_appeal_typesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the court_appeal_types
     */
    omit?: court_appeal_typesOmit<ExtArgs> | null
    /**
     * Filter, which court_appeal_types to fetch.
     */
    where?: court_appeal_typesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of court_appeal_types to fetch.
     */
    orderBy?: court_appeal_typesOrderByWithRelationInput | court_appeal_typesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for court_appeal_types.
     */
    cursor?: court_appeal_typesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` court_appeal_types from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` court_appeal_types.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of court_appeal_types.
     */
    distinct?: Court_appeal_typesScalarFieldEnum | Court_appeal_typesScalarFieldEnum[]
  }

  /**
   * court_appeal_types findFirstOrThrow
   */
  export type court_appeal_typesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the court_appeal_types
     */
    select?: court_appeal_typesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the court_appeal_types
     */
    omit?: court_appeal_typesOmit<ExtArgs> | null
    /**
     * Filter, which court_appeal_types to fetch.
     */
    where?: court_appeal_typesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of court_appeal_types to fetch.
     */
    orderBy?: court_appeal_typesOrderByWithRelationInput | court_appeal_typesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for court_appeal_types.
     */
    cursor?: court_appeal_typesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` court_appeal_types from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` court_appeal_types.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of court_appeal_types.
     */
    distinct?: Court_appeal_typesScalarFieldEnum | Court_appeal_typesScalarFieldEnum[]
  }

  /**
   * court_appeal_types findMany
   */
  export type court_appeal_typesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the court_appeal_types
     */
    select?: court_appeal_typesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the court_appeal_types
     */
    omit?: court_appeal_typesOmit<ExtArgs> | null
    /**
     * Filter, which court_appeal_types to fetch.
     */
    where?: court_appeal_typesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of court_appeal_types to fetch.
     */
    orderBy?: court_appeal_typesOrderByWithRelationInput | court_appeal_typesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing court_appeal_types.
     */
    cursor?: court_appeal_typesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` court_appeal_types from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` court_appeal_types.
     */
    skip?: number
    distinct?: Court_appeal_typesScalarFieldEnum | Court_appeal_typesScalarFieldEnum[]
  }

  /**
   * court_appeal_types create
   */
  export type court_appeal_typesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the court_appeal_types
     */
    select?: court_appeal_typesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the court_appeal_types
     */
    omit?: court_appeal_typesOmit<ExtArgs> | null
    /**
     * The data needed to create a court_appeal_types.
     */
    data: XOR<court_appeal_typesCreateInput, court_appeal_typesUncheckedCreateInput>
  }

  /**
   * court_appeal_types createMany
   */
  export type court_appeal_typesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many court_appeal_types.
     */
    data: court_appeal_typesCreateManyInput | court_appeal_typesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * court_appeal_types update
   */
  export type court_appeal_typesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the court_appeal_types
     */
    select?: court_appeal_typesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the court_appeal_types
     */
    omit?: court_appeal_typesOmit<ExtArgs> | null
    /**
     * The data needed to update a court_appeal_types.
     */
    data: XOR<court_appeal_typesUpdateInput, court_appeal_typesUncheckedUpdateInput>
    /**
     * Choose, which court_appeal_types to update.
     */
    where: court_appeal_typesWhereUniqueInput
  }

  /**
   * court_appeal_types updateMany
   */
  export type court_appeal_typesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update court_appeal_types.
     */
    data: XOR<court_appeal_typesUpdateManyMutationInput, court_appeal_typesUncheckedUpdateManyInput>
    /**
     * Filter which court_appeal_types to update
     */
    where?: court_appeal_typesWhereInput
    /**
     * Limit how many court_appeal_types to update.
     */
    limit?: number
  }

  /**
   * court_appeal_types upsert
   */
  export type court_appeal_typesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the court_appeal_types
     */
    select?: court_appeal_typesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the court_appeal_types
     */
    omit?: court_appeal_typesOmit<ExtArgs> | null
    /**
     * The filter to search for the court_appeal_types to update in case it exists.
     */
    where: court_appeal_typesWhereUniqueInput
    /**
     * In case the court_appeal_types found by the `where` argument doesn't exist, create a new court_appeal_types with this data.
     */
    create: XOR<court_appeal_typesCreateInput, court_appeal_typesUncheckedCreateInput>
    /**
     * In case the court_appeal_types was found with the provided `where` argument, update it with this data.
     */
    update: XOR<court_appeal_typesUpdateInput, court_appeal_typesUncheckedUpdateInput>
  }

  /**
   * court_appeal_types delete
   */
  export type court_appeal_typesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the court_appeal_types
     */
    select?: court_appeal_typesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the court_appeal_types
     */
    omit?: court_appeal_typesOmit<ExtArgs> | null
    /**
     * Filter which court_appeal_types to delete.
     */
    where: court_appeal_typesWhereUniqueInput
  }

  /**
   * court_appeal_types deleteMany
   */
  export type court_appeal_typesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which court_appeal_types to delete
     */
    where?: court_appeal_typesWhereInput
    /**
     * Limit how many court_appeal_types to delete.
     */
    limit?: number
  }

  /**
   * court_appeal_types without action
   */
  export type court_appeal_typesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the court_appeal_types
     */
    select?: court_appeal_typesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the court_appeal_types
     */
    omit?: court_appeal_typesOmit<ExtArgs> | null
  }


  /**
   * Model court_appeals
   */

  export type AggregateCourt_appeals = {
    _count: Court_appealsCountAggregateOutputType | null
    _avg: Court_appealsAvgAggregateOutputType | null
    _sum: Court_appealsSumAggregateOutputType | null
    _min: Court_appealsMinAggregateOutputType | null
    _max: Court_appealsMaxAggregateOutputType | null
  }

  export type Court_appealsAvgAggregateOutputType = {
    appeal_id: number | null
    case_id: number | null
    claim_id: number | null
    actual: number | null
    filled_by: number | null
    court_level: number | null
  }

  export type Court_appealsSumAggregateOutputType = {
    appeal_id: number | null
    case_id: number | null
    claim_id: number | null
    actual: number | null
    filled_by: number | null
    court_level: number | null
  }

  export type Court_appealsMinAggregateOutputType = {
    appeal_id: number | null
    case_id: number | null
    claim_id: number | null
    court_accept_date: Date | null
    actual: number | null
    filled_in: Date | null
    filled_by: number | null
    court_level: number | null
    court_name: string | null
  }

  export type Court_appealsMaxAggregateOutputType = {
    appeal_id: number | null
    case_id: number | null
    claim_id: number | null
    court_accept_date: Date | null
    actual: number | null
    filled_in: Date | null
    filled_by: number | null
    court_level: number | null
    court_name: string | null
  }

  export type Court_appealsCountAggregateOutputType = {
    appeal_id: number
    case_id: number
    claim_id: number
    court_accept_date: number
    actual: number
    filled_in: number
    filled_by: number
    court_level: number
    court_name: number
    _all: number
  }


  export type Court_appealsAvgAggregateInputType = {
    appeal_id?: true
    case_id?: true
    claim_id?: true
    actual?: true
    filled_by?: true
    court_level?: true
  }

  export type Court_appealsSumAggregateInputType = {
    appeal_id?: true
    case_id?: true
    claim_id?: true
    actual?: true
    filled_by?: true
    court_level?: true
  }

  export type Court_appealsMinAggregateInputType = {
    appeal_id?: true
    case_id?: true
    claim_id?: true
    court_accept_date?: true
    actual?: true
    filled_in?: true
    filled_by?: true
    court_level?: true
    court_name?: true
  }

  export type Court_appealsMaxAggregateInputType = {
    appeal_id?: true
    case_id?: true
    claim_id?: true
    court_accept_date?: true
    actual?: true
    filled_in?: true
    filled_by?: true
    court_level?: true
    court_name?: true
  }

  export type Court_appealsCountAggregateInputType = {
    appeal_id?: true
    case_id?: true
    claim_id?: true
    court_accept_date?: true
    actual?: true
    filled_in?: true
    filled_by?: true
    court_level?: true
    court_name?: true
    _all?: true
  }

  export type Court_appealsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which court_appeals to aggregate.
     */
    where?: court_appealsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of court_appeals to fetch.
     */
    orderBy?: court_appealsOrderByWithRelationInput | court_appealsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: court_appealsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` court_appeals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` court_appeals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned court_appeals
    **/
    _count?: true | Court_appealsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Court_appealsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Court_appealsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Court_appealsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Court_appealsMaxAggregateInputType
  }

  export type GetCourt_appealsAggregateType<T extends Court_appealsAggregateArgs> = {
        [P in keyof T & keyof AggregateCourt_appeals]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCourt_appeals[P]>
      : GetScalarType<T[P], AggregateCourt_appeals[P]>
  }




  export type court_appealsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: court_appealsWhereInput
    orderBy?: court_appealsOrderByWithAggregationInput | court_appealsOrderByWithAggregationInput[]
    by: Court_appealsScalarFieldEnum[] | Court_appealsScalarFieldEnum
    having?: court_appealsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Court_appealsCountAggregateInputType | true
    _avg?: Court_appealsAvgAggregateInputType
    _sum?: Court_appealsSumAggregateInputType
    _min?: Court_appealsMinAggregateInputType
    _max?: Court_appealsMaxAggregateInputType
  }

  export type Court_appealsGroupByOutputType = {
    appeal_id: number
    case_id: number
    claim_id: number
    court_accept_date: Date
    actual: number
    filled_in: Date
    filled_by: number
    court_level: number
    court_name: string | null
    _count: Court_appealsCountAggregateOutputType | null
    _avg: Court_appealsAvgAggregateOutputType | null
    _sum: Court_appealsSumAggregateOutputType | null
    _min: Court_appealsMinAggregateOutputType | null
    _max: Court_appealsMaxAggregateOutputType | null
  }

  type GetCourt_appealsGroupByPayload<T extends court_appealsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Court_appealsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Court_appealsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Court_appealsGroupByOutputType[P]>
            : GetScalarType<T[P], Court_appealsGroupByOutputType[P]>
        }
      >
    >


  export type court_appealsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    appeal_id?: boolean
    case_id?: boolean
    claim_id?: boolean
    court_accept_date?: boolean
    actual?: boolean
    filled_in?: boolean
    filled_by?: boolean
    court_level?: boolean
    court_name?: boolean
  }, ExtArgs["result"]["court_appeals"]>



  export type court_appealsSelectScalar = {
    appeal_id?: boolean
    case_id?: boolean
    claim_id?: boolean
    court_accept_date?: boolean
    actual?: boolean
    filled_in?: boolean
    filled_by?: boolean
    court_level?: boolean
    court_name?: boolean
  }

  export type court_appealsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"appeal_id" | "case_id" | "claim_id" | "court_accept_date" | "actual" | "filled_in" | "filled_by" | "court_level" | "court_name", ExtArgs["result"]["court_appeals"]>

  export type $court_appealsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "court_appeals"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      appeal_id: number
      case_id: number
      claim_id: number
      court_accept_date: Date
      actual: number
      filled_in: Date
      filled_by: number
      court_level: number
      court_name: string | null
    }, ExtArgs["result"]["court_appeals"]>
    composites: {}
  }

  type court_appealsGetPayload<S extends boolean | null | undefined | court_appealsDefaultArgs> = $Result.GetResult<Prisma.$court_appealsPayload, S>

  type court_appealsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<court_appealsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Court_appealsCountAggregateInputType | true
    }

  export interface court_appealsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['court_appeals'], meta: { name: 'court_appeals' } }
    /**
     * Find zero or one Court_appeals that matches the filter.
     * @param {court_appealsFindUniqueArgs} args - Arguments to find a Court_appeals
     * @example
     * // Get one Court_appeals
     * const court_appeals = await prisma.court_appeals.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends court_appealsFindUniqueArgs>(args: SelectSubset<T, court_appealsFindUniqueArgs<ExtArgs>>): Prisma__court_appealsClient<$Result.GetResult<Prisma.$court_appealsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Court_appeals that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {court_appealsFindUniqueOrThrowArgs} args - Arguments to find a Court_appeals
     * @example
     * // Get one Court_appeals
     * const court_appeals = await prisma.court_appeals.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends court_appealsFindUniqueOrThrowArgs>(args: SelectSubset<T, court_appealsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__court_appealsClient<$Result.GetResult<Prisma.$court_appealsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Court_appeals that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {court_appealsFindFirstArgs} args - Arguments to find a Court_appeals
     * @example
     * // Get one Court_appeals
     * const court_appeals = await prisma.court_appeals.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends court_appealsFindFirstArgs>(args?: SelectSubset<T, court_appealsFindFirstArgs<ExtArgs>>): Prisma__court_appealsClient<$Result.GetResult<Prisma.$court_appealsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Court_appeals that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {court_appealsFindFirstOrThrowArgs} args - Arguments to find a Court_appeals
     * @example
     * // Get one Court_appeals
     * const court_appeals = await prisma.court_appeals.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends court_appealsFindFirstOrThrowArgs>(args?: SelectSubset<T, court_appealsFindFirstOrThrowArgs<ExtArgs>>): Prisma__court_appealsClient<$Result.GetResult<Prisma.$court_appealsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Court_appeals that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {court_appealsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Court_appeals
     * const court_appeals = await prisma.court_appeals.findMany()
     * 
     * // Get first 10 Court_appeals
     * const court_appeals = await prisma.court_appeals.findMany({ take: 10 })
     * 
     * // Only select the `appeal_id`
     * const court_appealsWithAppeal_idOnly = await prisma.court_appeals.findMany({ select: { appeal_id: true } })
     * 
     */
    findMany<T extends court_appealsFindManyArgs>(args?: SelectSubset<T, court_appealsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$court_appealsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Court_appeals.
     * @param {court_appealsCreateArgs} args - Arguments to create a Court_appeals.
     * @example
     * // Create one Court_appeals
     * const Court_appeals = await prisma.court_appeals.create({
     *   data: {
     *     // ... data to create a Court_appeals
     *   }
     * })
     * 
     */
    create<T extends court_appealsCreateArgs>(args: SelectSubset<T, court_appealsCreateArgs<ExtArgs>>): Prisma__court_appealsClient<$Result.GetResult<Prisma.$court_appealsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Court_appeals.
     * @param {court_appealsCreateManyArgs} args - Arguments to create many Court_appeals.
     * @example
     * // Create many Court_appeals
     * const court_appeals = await prisma.court_appeals.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends court_appealsCreateManyArgs>(args?: SelectSubset<T, court_appealsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Court_appeals.
     * @param {court_appealsDeleteArgs} args - Arguments to delete one Court_appeals.
     * @example
     * // Delete one Court_appeals
     * const Court_appeals = await prisma.court_appeals.delete({
     *   where: {
     *     // ... filter to delete one Court_appeals
     *   }
     * })
     * 
     */
    delete<T extends court_appealsDeleteArgs>(args: SelectSubset<T, court_appealsDeleteArgs<ExtArgs>>): Prisma__court_appealsClient<$Result.GetResult<Prisma.$court_appealsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Court_appeals.
     * @param {court_appealsUpdateArgs} args - Arguments to update one Court_appeals.
     * @example
     * // Update one Court_appeals
     * const court_appeals = await prisma.court_appeals.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends court_appealsUpdateArgs>(args: SelectSubset<T, court_appealsUpdateArgs<ExtArgs>>): Prisma__court_appealsClient<$Result.GetResult<Prisma.$court_appealsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Court_appeals.
     * @param {court_appealsDeleteManyArgs} args - Arguments to filter Court_appeals to delete.
     * @example
     * // Delete a few Court_appeals
     * const { count } = await prisma.court_appeals.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends court_appealsDeleteManyArgs>(args?: SelectSubset<T, court_appealsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Court_appeals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {court_appealsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Court_appeals
     * const court_appeals = await prisma.court_appeals.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends court_appealsUpdateManyArgs>(args: SelectSubset<T, court_appealsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Court_appeals.
     * @param {court_appealsUpsertArgs} args - Arguments to update or create a Court_appeals.
     * @example
     * // Update or create a Court_appeals
     * const court_appeals = await prisma.court_appeals.upsert({
     *   create: {
     *     // ... data to create a Court_appeals
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Court_appeals we want to update
     *   }
     * })
     */
    upsert<T extends court_appealsUpsertArgs>(args: SelectSubset<T, court_appealsUpsertArgs<ExtArgs>>): Prisma__court_appealsClient<$Result.GetResult<Prisma.$court_appealsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Court_appeals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {court_appealsCountArgs} args - Arguments to filter Court_appeals to count.
     * @example
     * // Count the number of Court_appeals
     * const count = await prisma.court_appeals.count({
     *   where: {
     *     // ... the filter for the Court_appeals we want to count
     *   }
     * })
    **/
    count<T extends court_appealsCountArgs>(
      args?: Subset<T, court_appealsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Court_appealsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Court_appeals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Court_appealsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Court_appealsAggregateArgs>(args: Subset<T, Court_appealsAggregateArgs>): Prisma.PrismaPromise<GetCourt_appealsAggregateType<T>>

    /**
     * Group by Court_appeals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {court_appealsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends court_appealsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: court_appealsGroupByArgs['orderBy'] }
        : { orderBy?: court_appealsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, court_appealsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCourt_appealsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the court_appeals model
   */
  readonly fields: court_appealsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for court_appeals.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__court_appealsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the court_appeals model
   */
  interface court_appealsFieldRefs {
    readonly appeal_id: FieldRef<"court_appeals", 'Int'>
    readonly case_id: FieldRef<"court_appeals", 'Int'>
    readonly claim_id: FieldRef<"court_appeals", 'Int'>
    readonly court_accept_date: FieldRef<"court_appeals", 'DateTime'>
    readonly actual: FieldRef<"court_appeals", 'Int'>
    readonly filled_in: FieldRef<"court_appeals", 'DateTime'>
    readonly filled_by: FieldRef<"court_appeals", 'Int'>
    readonly court_level: FieldRef<"court_appeals", 'Int'>
    readonly court_name: FieldRef<"court_appeals", 'String'>
  }
    

  // Custom InputTypes
  /**
   * court_appeals findUnique
   */
  export type court_appealsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the court_appeals
     */
    select?: court_appealsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the court_appeals
     */
    omit?: court_appealsOmit<ExtArgs> | null
    /**
     * Filter, which court_appeals to fetch.
     */
    where: court_appealsWhereUniqueInput
  }

  /**
   * court_appeals findUniqueOrThrow
   */
  export type court_appealsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the court_appeals
     */
    select?: court_appealsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the court_appeals
     */
    omit?: court_appealsOmit<ExtArgs> | null
    /**
     * Filter, which court_appeals to fetch.
     */
    where: court_appealsWhereUniqueInput
  }

  /**
   * court_appeals findFirst
   */
  export type court_appealsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the court_appeals
     */
    select?: court_appealsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the court_appeals
     */
    omit?: court_appealsOmit<ExtArgs> | null
    /**
     * Filter, which court_appeals to fetch.
     */
    where?: court_appealsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of court_appeals to fetch.
     */
    orderBy?: court_appealsOrderByWithRelationInput | court_appealsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for court_appeals.
     */
    cursor?: court_appealsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` court_appeals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` court_appeals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of court_appeals.
     */
    distinct?: Court_appealsScalarFieldEnum | Court_appealsScalarFieldEnum[]
  }

  /**
   * court_appeals findFirstOrThrow
   */
  export type court_appealsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the court_appeals
     */
    select?: court_appealsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the court_appeals
     */
    omit?: court_appealsOmit<ExtArgs> | null
    /**
     * Filter, which court_appeals to fetch.
     */
    where?: court_appealsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of court_appeals to fetch.
     */
    orderBy?: court_appealsOrderByWithRelationInput | court_appealsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for court_appeals.
     */
    cursor?: court_appealsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` court_appeals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` court_appeals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of court_appeals.
     */
    distinct?: Court_appealsScalarFieldEnum | Court_appealsScalarFieldEnum[]
  }

  /**
   * court_appeals findMany
   */
  export type court_appealsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the court_appeals
     */
    select?: court_appealsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the court_appeals
     */
    omit?: court_appealsOmit<ExtArgs> | null
    /**
     * Filter, which court_appeals to fetch.
     */
    where?: court_appealsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of court_appeals to fetch.
     */
    orderBy?: court_appealsOrderByWithRelationInput | court_appealsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing court_appeals.
     */
    cursor?: court_appealsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` court_appeals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` court_appeals.
     */
    skip?: number
    distinct?: Court_appealsScalarFieldEnum | Court_appealsScalarFieldEnum[]
  }

  /**
   * court_appeals create
   */
  export type court_appealsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the court_appeals
     */
    select?: court_appealsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the court_appeals
     */
    omit?: court_appealsOmit<ExtArgs> | null
    /**
     * The data needed to create a court_appeals.
     */
    data: XOR<court_appealsCreateInput, court_appealsUncheckedCreateInput>
  }

  /**
   * court_appeals createMany
   */
  export type court_appealsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many court_appeals.
     */
    data: court_appealsCreateManyInput | court_appealsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * court_appeals update
   */
  export type court_appealsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the court_appeals
     */
    select?: court_appealsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the court_appeals
     */
    omit?: court_appealsOmit<ExtArgs> | null
    /**
     * The data needed to update a court_appeals.
     */
    data: XOR<court_appealsUpdateInput, court_appealsUncheckedUpdateInput>
    /**
     * Choose, which court_appeals to update.
     */
    where: court_appealsWhereUniqueInput
  }

  /**
   * court_appeals updateMany
   */
  export type court_appealsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update court_appeals.
     */
    data: XOR<court_appealsUpdateManyMutationInput, court_appealsUncheckedUpdateManyInput>
    /**
     * Filter which court_appeals to update
     */
    where?: court_appealsWhereInput
    /**
     * Limit how many court_appeals to update.
     */
    limit?: number
  }

  /**
   * court_appeals upsert
   */
  export type court_appealsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the court_appeals
     */
    select?: court_appealsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the court_appeals
     */
    omit?: court_appealsOmit<ExtArgs> | null
    /**
     * The filter to search for the court_appeals to update in case it exists.
     */
    where: court_appealsWhereUniqueInput
    /**
     * In case the court_appeals found by the `where` argument doesn't exist, create a new court_appeals with this data.
     */
    create: XOR<court_appealsCreateInput, court_appealsUncheckedCreateInput>
    /**
     * In case the court_appeals was found with the provided `where` argument, update it with this data.
     */
    update: XOR<court_appealsUpdateInput, court_appealsUncheckedUpdateInput>
  }

  /**
   * court_appeals delete
   */
  export type court_appealsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the court_appeals
     */
    select?: court_appealsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the court_appeals
     */
    omit?: court_appealsOmit<ExtArgs> | null
    /**
     * Filter which court_appeals to delete.
     */
    where: court_appealsWhereUniqueInput
  }

  /**
   * court_appeals deleteMany
   */
  export type court_appealsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which court_appeals to delete
     */
    where?: court_appealsWhereInput
    /**
     * Limit how many court_appeals to delete.
     */
    limit?: number
  }

  /**
   * court_appeals without action
   */
  export type court_appealsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the court_appeals
     */
    select?: court_appealsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the court_appeals
     */
    omit?: court_appealsOmit<ExtArgs> | null
  }


  /**
   * Model court_claim_initiators
   */

  export type AggregateCourt_claim_initiators = {
    _count: Court_claim_initiatorsCountAggregateOutputType | null
    _avg: Court_claim_initiatorsAvgAggregateOutputType | null
    _sum: Court_claim_initiatorsSumAggregateOutputType | null
    _min: Court_claim_initiatorsMinAggregateOutputType | null
    _max: Court_claim_initiatorsMaxAggregateOutputType | null
  }

  export type Court_claim_initiatorsAvgAggregateOutputType = {
    id: number | null
  }

  export type Court_claim_initiatorsSumAggregateOutputType = {
    id: number | null
  }

  export type Court_claim_initiatorsMinAggregateOutputType = {
    id: number | null
    initiator_name: string | null
  }

  export type Court_claim_initiatorsMaxAggregateOutputType = {
    id: number | null
    initiator_name: string | null
  }

  export type Court_claim_initiatorsCountAggregateOutputType = {
    id: number
    initiator_name: number
    _all: number
  }


  export type Court_claim_initiatorsAvgAggregateInputType = {
    id?: true
  }

  export type Court_claim_initiatorsSumAggregateInputType = {
    id?: true
  }

  export type Court_claim_initiatorsMinAggregateInputType = {
    id?: true
    initiator_name?: true
  }

  export type Court_claim_initiatorsMaxAggregateInputType = {
    id?: true
    initiator_name?: true
  }

  export type Court_claim_initiatorsCountAggregateInputType = {
    id?: true
    initiator_name?: true
    _all?: true
  }

  export type Court_claim_initiatorsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which court_claim_initiators to aggregate.
     */
    where?: court_claim_initiatorsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of court_claim_initiators to fetch.
     */
    orderBy?: court_claim_initiatorsOrderByWithRelationInput | court_claim_initiatorsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: court_claim_initiatorsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` court_claim_initiators from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` court_claim_initiators.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned court_claim_initiators
    **/
    _count?: true | Court_claim_initiatorsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Court_claim_initiatorsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Court_claim_initiatorsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Court_claim_initiatorsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Court_claim_initiatorsMaxAggregateInputType
  }

  export type GetCourt_claim_initiatorsAggregateType<T extends Court_claim_initiatorsAggregateArgs> = {
        [P in keyof T & keyof AggregateCourt_claim_initiators]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCourt_claim_initiators[P]>
      : GetScalarType<T[P], AggregateCourt_claim_initiators[P]>
  }




  export type court_claim_initiatorsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: court_claim_initiatorsWhereInput
    orderBy?: court_claim_initiatorsOrderByWithAggregationInput | court_claim_initiatorsOrderByWithAggregationInput[]
    by: Court_claim_initiatorsScalarFieldEnum[] | Court_claim_initiatorsScalarFieldEnum
    having?: court_claim_initiatorsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Court_claim_initiatorsCountAggregateInputType | true
    _avg?: Court_claim_initiatorsAvgAggregateInputType
    _sum?: Court_claim_initiatorsSumAggregateInputType
    _min?: Court_claim_initiatorsMinAggregateInputType
    _max?: Court_claim_initiatorsMaxAggregateInputType
  }

  export type Court_claim_initiatorsGroupByOutputType = {
    id: number
    initiator_name: string
    _count: Court_claim_initiatorsCountAggregateOutputType | null
    _avg: Court_claim_initiatorsAvgAggregateOutputType | null
    _sum: Court_claim_initiatorsSumAggregateOutputType | null
    _min: Court_claim_initiatorsMinAggregateOutputType | null
    _max: Court_claim_initiatorsMaxAggregateOutputType | null
  }

  type GetCourt_claim_initiatorsGroupByPayload<T extends court_claim_initiatorsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Court_claim_initiatorsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Court_claim_initiatorsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Court_claim_initiatorsGroupByOutputType[P]>
            : GetScalarType<T[P], Court_claim_initiatorsGroupByOutputType[P]>
        }
      >
    >


  export type court_claim_initiatorsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    initiator_name?: boolean
  }, ExtArgs["result"]["court_claim_initiators"]>



  export type court_claim_initiatorsSelectScalar = {
    id?: boolean
    initiator_name?: boolean
  }

  export type court_claim_initiatorsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "initiator_name", ExtArgs["result"]["court_claim_initiators"]>

  export type $court_claim_initiatorsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "court_claim_initiators"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      initiator_name: string
    }, ExtArgs["result"]["court_claim_initiators"]>
    composites: {}
  }

  type court_claim_initiatorsGetPayload<S extends boolean | null | undefined | court_claim_initiatorsDefaultArgs> = $Result.GetResult<Prisma.$court_claim_initiatorsPayload, S>

  type court_claim_initiatorsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<court_claim_initiatorsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Court_claim_initiatorsCountAggregateInputType | true
    }

  export interface court_claim_initiatorsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['court_claim_initiators'], meta: { name: 'court_claim_initiators' } }
    /**
     * Find zero or one Court_claim_initiators that matches the filter.
     * @param {court_claim_initiatorsFindUniqueArgs} args - Arguments to find a Court_claim_initiators
     * @example
     * // Get one Court_claim_initiators
     * const court_claim_initiators = await prisma.court_claim_initiators.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends court_claim_initiatorsFindUniqueArgs>(args: SelectSubset<T, court_claim_initiatorsFindUniqueArgs<ExtArgs>>): Prisma__court_claim_initiatorsClient<$Result.GetResult<Prisma.$court_claim_initiatorsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Court_claim_initiators that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {court_claim_initiatorsFindUniqueOrThrowArgs} args - Arguments to find a Court_claim_initiators
     * @example
     * // Get one Court_claim_initiators
     * const court_claim_initiators = await prisma.court_claim_initiators.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends court_claim_initiatorsFindUniqueOrThrowArgs>(args: SelectSubset<T, court_claim_initiatorsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__court_claim_initiatorsClient<$Result.GetResult<Prisma.$court_claim_initiatorsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Court_claim_initiators that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {court_claim_initiatorsFindFirstArgs} args - Arguments to find a Court_claim_initiators
     * @example
     * // Get one Court_claim_initiators
     * const court_claim_initiators = await prisma.court_claim_initiators.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends court_claim_initiatorsFindFirstArgs>(args?: SelectSubset<T, court_claim_initiatorsFindFirstArgs<ExtArgs>>): Prisma__court_claim_initiatorsClient<$Result.GetResult<Prisma.$court_claim_initiatorsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Court_claim_initiators that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {court_claim_initiatorsFindFirstOrThrowArgs} args - Arguments to find a Court_claim_initiators
     * @example
     * // Get one Court_claim_initiators
     * const court_claim_initiators = await prisma.court_claim_initiators.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends court_claim_initiatorsFindFirstOrThrowArgs>(args?: SelectSubset<T, court_claim_initiatorsFindFirstOrThrowArgs<ExtArgs>>): Prisma__court_claim_initiatorsClient<$Result.GetResult<Prisma.$court_claim_initiatorsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Court_claim_initiators that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {court_claim_initiatorsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Court_claim_initiators
     * const court_claim_initiators = await prisma.court_claim_initiators.findMany()
     * 
     * // Get first 10 Court_claim_initiators
     * const court_claim_initiators = await prisma.court_claim_initiators.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const court_claim_initiatorsWithIdOnly = await prisma.court_claim_initiators.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends court_claim_initiatorsFindManyArgs>(args?: SelectSubset<T, court_claim_initiatorsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$court_claim_initiatorsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Court_claim_initiators.
     * @param {court_claim_initiatorsCreateArgs} args - Arguments to create a Court_claim_initiators.
     * @example
     * // Create one Court_claim_initiators
     * const Court_claim_initiators = await prisma.court_claim_initiators.create({
     *   data: {
     *     // ... data to create a Court_claim_initiators
     *   }
     * })
     * 
     */
    create<T extends court_claim_initiatorsCreateArgs>(args: SelectSubset<T, court_claim_initiatorsCreateArgs<ExtArgs>>): Prisma__court_claim_initiatorsClient<$Result.GetResult<Prisma.$court_claim_initiatorsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Court_claim_initiators.
     * @param {court_claim_initiatorsCreateManyArgs} args - Arguments to create many Court_claim_initiators.
     * @example
     * // Create many Court_claim_initiators
     * const court_claim_initiators = await prisma.court_claim_initiators.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends court_claim_initiatorsCreateManyArgs>(args?: SelectSubset<T, court_claim_initiatorsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Court_claim_initiators.
     * @param {court_claim_initiatorsDeleteArgs} args - Arguments to delete one Court_claim_initiators.
     * @example
     * // Delete one Court_claim_initiators
     * const Court_claim_initiators = await prisma.court_claim_initiators.delete({
     *   where: {
     *     // ... filter to delete one Court_claim_initiators
     *   }
     * })
     * 
     */
    delete<T extends court_claim_initiatorsDeleteArgs>(args: SelectSubset<T, court_claim_initiatorsDeleteArgs<ExtArgs>>): Prisma__court_claim_initiatorsClient<$Result.GetResult<Prisma.$court_claim_initiatorsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Court_claim_initiators.
     * @param {court_claim_initiatorsUpdateArgs} args - Arguments to update one Court_claim_initiators.
     * @example
     * // Update one Court_claim_initiators
     * const court_claim_initiators = await prisma.court_claim_initiators.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends court_claim_initiatorsUpdateArgs>(args: SelectSubset<T, court_claim_initiatorsUpdateArgs<ExtArgs>>): Prisma__court_claim_initiatorsClient<$Result.GetResult<Prisma.$court_claim_initiatorsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Court_claim_initiators.
     * @param {court_claim_initiatorsDeleteManyArgs} args - Arguments to filter Court_claim_initiators to delete.
     * @example
     * // Delete a few Court_claim_initiators
     * const { count } = await prisma.court_claim_initiators.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends court_claim_initiatorsDeleteManyArgs>(args?: SelectSubset<T, court_claim_initiatorsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Court_claim_initiators.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {court_claim_initiatorsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Court_claim_initiators
     * const court_claim_initiators = await prisma.court_claim_initiators.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends court_claim_initiatorsUpdateManyArgs>(args: SelectSubset<T, court_claim_initiatorsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Court_claim_initiators.
     * @param {court_claim_initiatorsUpsertArgs} args - Arguments to update or create a Court_claim_initiators.
     * @example
     * // Update or create a Court_claim_initiators
     * const court_claim_initiators = await prisma.court_claim_initiators.upsert({
     *   create: {
     *     // ... data to create a Court_claim_initiators
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Court_claim_initiators we want to update
     *   }
     * })
     */
    upsert<T extends court_claim_initiatorsUpsertArgs>(args: SelectSubset<T, court_claim_initiatorsUpsertArgs<ExtArgs>>): Prisma__court_claim_initiatorsClient<$Result.GetResult<Prisma.$court_claim_initiatorsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Court_claim_initiators.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {court_claim_initiatorsCountArgs} args - Arguments to filter Court_claim_initiators to count.
     * @example
     * // Count the number of Court_claim_initiators
     * const count = await prisma.court_claim_initiators.count({
     *   where: {
     *     // ... the filter for the Court_claim_initiators we want to count
     *   }
     * })
    **/
    count<T extends court_claim_initiatorsCountArgs>(
      args?: Subset<T, court_claim_initiatorsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Court_claim_initiatorsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Court_claim_initiators.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Court_claim_initiatorsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Court_claim_initiatorsAggregateArgs>(args: Subset<T, Court_claim_initiatorsAggregateArgs>): Prisma.PrismaPromise<GetCourt_claim_initiatorsAggregateType<T>>

    /**
     * Group by Court_claim_initiators.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {court_claim_initiatorsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends court_claim_initiatorsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: court_claim_initiatorsGroupByArgs['orderBy'] }
        : { orderBy?: court_claim_initiatorsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, court_claim_initiatorsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCourt_claim_initiatorsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the court_claim_initiators model
   */
  readonly fields: court_claim_initiatorsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for court_claim_initiators.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__court_claim_initiatorsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the court_claim_initiators model
   */
  interface court_claim_initiatorsFieldRefs {
    readonly id: FieldRef<"court_claim_initiators", 'Int'>
    readonly initiator_name: FieldRef<"court_claim_initiators", 'String'>
  }
    

  // Custom InputTypes
  /**
   * court_claim_initiators findUnique
   */
  export type court_claim_initiatorsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the court_claim_initiators
     */
    select?: court_claim_initiatorsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the court_claim_initiators
     */
    omit?: court_claim_initiatorsOmit<ExtArgs> | null
    /**
     * Filter, which court_claim_initiators to fetch.
     */
    where: court_claim_initiatorsWhereUniqueInput
  }

  /**
   * court_claim_initiators findUniqueOrThrow
   */
  export type court_claim_initiatorsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the court_claim_initiators
     */
    select?: court_claim_initiatorsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the court_claim_initiators
     */
    omit?: court_claim_initiatorsOmit<ExtArgs> | null
    /**
     * Filter, which court_claim_initiators to fetch.
     */
    where: court_claim_initiatorsWhereUniqueInput
  }

  /**
   * court_claim_initiators findFirst
   */
  export type court_claim_initiatorsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the court_claim_initiators
     */
    select?: court_claim_initiatorsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the court_claim_initiators
     */
    omit?: court_claim_initiatorsOmit<ExtArgs> | null
    /**
     * Filter, which court_claim_initiators to fetch.
     */
    where?: court_claim_initiatorsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of court_claim_initiators to fetch.
     */
    orderBy?: court_claim_initiatorsOrderByWithRelationInput | court_claim_initiatorsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for court_claim_initiators.
     */
    cursor?: court_claim_initiatorsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` court_claim_initiators from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` court_claim_initiators.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of court_claim_initiators.
     */
    distinct?: Court_claim_initiatorsScalarFieldEnum | Court_claim_initiatorsScalarFieldEnum[]
  }

  /**
   * court_claim_initiators findFirstOrThrow
   */
  export type court_claim_initiatorsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the court_claim_initiators
     */
    select?: court_claim_initiatorsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the court_claim_initiators
     */
    omit?: court_claim_initiatorsOmit<ExtArgs> | null
    /**
     * Filter, which court_claim_initiators to fetch.
     */
    where?: court_claim_initiatorsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of court_claim_initiators to fetch.
     */
    orderBy?: court_claim_initiatorsOrderByWithRelationInput | court_claim_initiatorsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for court_claim_initiators.
     */
    cursor?: court_claim_initiatorsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` court_claim_initiators from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` court_claim_initiators.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of court_claim_initiators.
     */
    distinct?: Court_claim_initiatorsScalarFieldEnum | Court_claim_initiatorsScalarFieldEnum[]
  }

  /**
   * court_claim_initiators findMany
   */
  export type court_claim_initiatorsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the court_claim_initiators
     */
    select?: court_claim_initiatorsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the court_claim_initiators
     */
    omit?: court_claim_initiatorsOmit<ExtArgs> | null
    /**
     * Filter, which court_claim_initiators to fetch.
     */
    where?: court_claim_initiatorsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of court_claim_initiators to fetch.
     */
    orderBy?: court_claim_initiatorsOrderByWithRelationInput | court_claim_initiatorsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing court_claim_initiators.
     */
    cursor?: court_claim_initiatorsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` court_claim_initiators from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` court_claim_initiators.
     */
    skip?: number
    distinct?: Court_claim_initiatorsScalarFieldEnum | Court_claim_initiatorsScalarFieldEnum[]
  }

  /**
   * court_claim_initiators create
   */
  export type court_claim_initiatorsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the court_claim_initiators
     */
    select?: court_claim_initiatorsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the court_claim_initiators
     */
    omit?: court_claim_initiatorsOmit<ExtArgs> | null
    /**
     * The data needed to create a court_claim_initiators.
     */
    data: XOR<court_claim_initiatorsCreateInput, court_claim_initiatorsUncheckedCreateInput>
  }

  /**
   * court_claim_initiators createMany
   */
  export type court_claim_initiatorsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many court_claim_initiators.
     */
    data: court_claim_initiatorsCreateManyInput | court_claim_initiatorsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * court_claim_initiators update
   */
  export type court_claim_initiatorsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the court_claim_initiators
     */
    select?: court_claim_initiatorsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the court_claim_initiators
     */
    omit?: court_claim_initiatorsOmit<ExtArgs> | null
    /**
     * The data needed to update a court_claim_initiators.
     */
    data: XOR<court_claim_initiatorsUpdateInput, court_claim_initiatorsUncheckedUpdateInput>
    /**
     * Choose, which court_claim_initiators to update.
     */
    where: court_claim_initiatorsWhereUniqueInput
  }

  /**
   * court_claim_initiators updateMany
   */
  export type court_claim_initiatorsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update court_claim_initiators.
     */
    data: XOR<court_claim_initiatorsUpdateManyMutationInput, court_claim_initiatorsUncheckedUpdateManyInput>
    /**
     * Filter which court_claim_initiators to update
     */
    where?: court_claim_initiatorsWhereInput
    /**
     * Limit how many court_claim_initiators to update.
     */
    limit?: number
  }

  /**
   * court_claim_initiators upsert
   */
  export type court_claim_initiatorsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the court_claim_initiators
     */
    select?: court_claim_initiatorsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the court_claim_initiators
     */
    omit?: court_claim_initiatorsOmit<ExtArgs> | null
    /**
     * The filter to search for the court_claim_initiators to update in case it exists.
     */
    where: court_claim_initiatorsWhereUniqueInput
    /**
     * In case the court_claim_initiators found by the `where` argument doesn't exist, create a new court_claim_initiators with this data.
     */
    create: XOR<court_claim_initiatorsCreateInput, court_claim_initiatorsUncheckedCreateInput>
    /**
     * In case the court_claim_initiators was found with the provided `where` argument, update it with this data.
     */
    update: XOR<court_claim_initiatorsUpdateInput, court_claim_initiatorsUncheckedUpdateInput>
  }

  /**
   * court_claim_initiators delete
   */
  export type court_claim_initiatorsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the court_claim_initiators
     */
    select?: court_claim_initiatorsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the court_claim_initiators
     */
    omit?: court_claim_initiatorsOmit<ExtArgs> | null
    /**
     * Filter which court_claim_initiators to delete.
     */
    where: court_claim_initiatorsWhereUniqueInput
  }

  /**
   * court_claim_initiators deleteMany
   */
  export type court_claim_initiatorsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which court_claim_initiators to delete
     */
    where?: court_claim_initiatorsWhereInput
    /**
     * Limit how many court_claim_initiators to delete.
     */
    limit?: number
  }

  /**
   * court_claim_initiators without action
   */
  export type court_claim_initiatorsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the court_claim_initiators
     */
    select?: court_claim_initiatorsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the court_claim_initiators
     */
    omit?: court_claim_initiatorsOmit<ExtArgs> | null
  }


  /**
   * Model court_claim_members
   */

  export type AggregateCourt_claim_members = {
    _count: Court_claim_membersCountAggregateOutputType | null
    _avg: Court_claim_membersAvgAggregateOutputType | null
    _sum: Court_claim_membersSumAggregateOutputType | null
    _min: Court_claim_membersMinAggregateOutputType | null
    _max: Court_claim_membersMaxAggregateOutputType | null
  }

  export type Court_claim_membersAvgAggregateOutputType = {
    id: number | null
    claim_id: number | null
    case_id: number | null
    person_id: number | null
    actual: number | null
  }

  export type Court_claim_membersSumAggregateOutputType = {
    id: number | null
    claim_id: number | null
    case_id: number | null
    person_id: number | null
    actual: number | null
  }

  export type Court_claim_membersMinAggregateOutputType = {
    id: number | null
    claim_id: number | null
    case_id: number | null
    person_id: number | null
    created_at: Date | null
    actual: number | null
  }

  export type Court_claim_membersMaxAggregateOutputType = {
    id: number | null
    claim_id: number | null
    case_id: number | null
    person_id: number | null
    created_at: Date | null
    actual: number | null
  }

  export type Court_claim_membersCountAggregateOutputType = {
    id: number
    claim_id: number
    case_id: number
    person_id: number
    created_at: number
    actual: number
    _all: number
  }


  export type Court_claim_membersAvgAggregateInputType = {
    id?: true
    claim_id?: true
    case_id?: true
    person_id?: true
    actual?: true
  }

  export type Court_claim_membersSumAggregateInputType = {
    id?: true
    claim_id?: true
    case_id?: true
    person_id?: true
    actual?: true
  }

  export type Court_claim_membersMinAggregateInputType = {
    id?: true
    claim_id?: true
    case_id?: true
    person_id?: true
    created_at?: true
    actual?: true
  }

  export type Court_claim_membersMaxAggregateInputType = {
    id?: true
    claim_id?: true
    case_id?: true
    person_id?: true
    created_at?: true
    actual?: true
  }

  export type Court_claim_membersCountAggregateInputType = {
    id?: true
    claim_id?: true
    case_id?: true
    person_id?: true
    created_at?: true
    actual?: true
    _all?: true
  }

  export type Court_claim_membersAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which court_claim_members to aggregate.
     */
    where?: court_claim_membersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of court_claim_members to fetch.
     */
    orderBy?: court_claim_membersOrderByWithRelationInput | court_claim_membersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: court_claim_membersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` court_claim_members from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` court_claim_members.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned court_claim_members
    **/
    _count?: true | Court_claim_membersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Court_claim_membersAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Court_claim_membersSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Court_claim_membersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Court_claim_membersMaxAggregateInputType
  }

  export type GetCourt_claim_membersAggregateType<T extends Court_claim_membersAggregateArgs> = {
        [P in keyof T & keyof AggregateCourt_claim_members]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCourt_claim_members[P]>
      : GetScalarType<T[P], AggregateCourt_claim_members[P]>
  }




  export type court_claim_membersGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: court_claim_membersWhereInput
    orderBy?: court_claim_membersOrderByWithAggregationInput | court_claim_membersOrderByWithAggregationInput[]
    by: Court_claim_membersScalarFieldEnum[] | Court_claim_membersScalarFieldEnum
    having?: court_claim_membersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Court_claim_membersCountAggregateInputType | true
    _avg?: Court_claim_membersAvgAggregateInputType
    _sum?: Court_claim_membersSumAggregateInputType
    _min?: Court_claim_membersMinAggregateInputType
    _max?: Court_claim_membersMaxAggregateInputType
  }

  export type Court_claim_membersGroupByOutputType = {
    id: number
    claim_id: number
    case_id: number
    person_id: number
    created_at: Date
    actual: number
    _count: Court_claim_membersCountAggregateOutputType | null
    _avg: Court_claim_membersAvgAggregateOutputType | null
    _sum: Court_claim_membersSumAggregateOutputType | null
    _min: Court_claim_membersMinAggregateOutputType | null
    _max: Court_claim_membersMaxAggregateOutputType | null
  }

  type GetCourt_claim_membersGroupByPayload<T extends court_claim_membersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Court_claim_membersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Court_claim_membersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Court_claim_membersGroupByOutputType[P]>
            : GetScalarType<T[P], Court_claim_membersGroupByOutputType[P]>
        }
      >
    >


  export type court_claim_membersSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    claim_id?: boolean
    case_id?: boolean
    person_id?: boolean
    created_at?: boolean
    actual?: boolean
  }, ExtArgs["result"]["court_claim_members"]>



  export type court_claim_membersSelectScalar = {
    id?: boolean
    claim_id?: boolean
    case_id?: boolean
    person_id?: boolean
    created_at?: boolean
    actual?: boolean
  }

  export type court_claim_membersOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "claim_id" | "case_id" | "person_id" | "created_at" | "actual", ExtArgs["result"]["court_claim_members"]>

  export type $court_claim_membersPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "court_claim_members"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      claim_id: number
      case_id: number
      person_id: number
      created_at: Date
      actual: number
    }, ExtArgs["result"]["court_claim_members"]>
    composites: {}
  }

  type court_claim_membersGetPayload<S extends boolean | null | undefined | court_claim_membersDefaultArgs> = $Result.GetResult<Prisma.$court_claim_membersPayload, S>

  type court_claim_membersCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<court_claim_membersFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Court_claim_membersCountAggregateInputType | true
    }

  export interface court_claim_membersDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['court_claim_members'], meta: { name: 'court_claim_members' } }
    /**
     * Find zero or one Court_claim_members that matches the filter.
     * @param {court_claim_membersFindUniqueArgs} args - Arguments to find a Court_claim_members
     * @example
     * // Get one Court_claim_members
     * const court_claim_members = await prisma.court_claim_members.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends court_claim_membersFindUniqueArgs>(args: SelectSubset<T, court_claim_membersFindUniqueArgs<ExtArgs>>): Prisma__court_claim_membersClient<$Result.GetResult<Prisma.$court_claim_membersPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Court_claim_members that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {court_claim_membersFindUniqueOrThrowArgs} args - Arguments to find a Court_claim_members
     * @example
     * // Get one Court_claim_members
     * const court_claim_members = await prisma.court_claim_members.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends court_claim_membersFindUniqueOrThrowArgs>(args: SelectSubset<T, court_claim_membersFindUniqueOrThrowArgs<ExtArgs>>): Prisma__court_claim_membersClient<$Result.GetResult<Prisma.$court_claim_membersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Court_claim_members that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {court_claim_membersFindFirstArgs} args - Arguments to find a Court_claim_members
     * @example
     * // Get one Court_claim_members
     * const court_claim_members = await prisma.court_claim_members.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends court_claim_membersFindFirstArgs>(args?: SelectSubset<T, court_claim_membersFindFirstArgs<ExtArgs>>): Prisma__court_claim_membersClient<$Result.GetResult<Prisma.$court_claim_membersPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Court_claim_members that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {court_claim_membersFindFirstOrThrowArgs} args - Arguments to find a Court_claim_members
     * @example
     * // Get one Court_claim_members
     * const court_claim_members = await prisma.court_claim_members.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends court_claim_membersFindFirstOrThrowArgs>(args?: SelectSubset<T, court_claim_membersFindFirstOrThrowArgs<ExtArgs>>): Prisma__court_claim_membersClient<$Result.GetResult<Prisma.$court_claim_membersPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Court_claim_members that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {court_claim_membersFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Court_claim_members
     * const court_claim_members = await prisma.court_claim_members.findMany()
     * 
     * // Get first 10 Court_claim_members
     * const court_claim_members = await prisma.court_claim_members.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const court_claim_membersWithIdOnly = await prisma.court_claim_members.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends court_claim_membersFindManyArgs>(args?: SelectSubset<T, court_claim_membersFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$court_claim_membersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Court_claim_members.
     * @param {court_claim_membersCreateArgs} args - Arguments to create a Court_claim_members.
     * @example
     * // Create one Court_claim_members
     * const Court_claim_members = await prisma.court_claim_members.create({
     *   data: {
     *     // ... data to create a Court_claim_members
     *   }
     * })
     * 
     */
    create<T extends court_claim_membersCreateArgs>(args: SelectSubset<T, court_claim_membersCreateArgs<ExtArgs>>): Prisma__court_claim_membersClient<$Result.GetResult<Prisma.$court_claim_membersPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Court_claim_members.
     * @param {court_claim_membersCreateManyArgs} args - Arguments to create many Court_claim_members.
     * @example
     * // Create many Court_claim_members
     * const court_claim_members = await prisma.court_claim_members.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends court_claim_membersCreateManyArgs>(args?: SelectSubset<T, court_claim_membersCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Court_claim_members.
     * @param {court_claim_membersDeleteArgs} args - Arguments to delete one Court_claim_members.
     * @example
     * // Delete one Court_claim_members
     * const Court_claim_members = await prisma.court_claim_members.delete({
     *   where: {
     *     // ... filter to delete one Court_claim_members
     *   }
     * })
     * 
     */
    delete<T extends court_claim_membersDeleteArgs>(args: SelectSubset<T, court_claim_membersDeleteArgs<ExtArgs>>): Prisma__court_claim_membersClient<$Result.GetResult<Prisma.$court_claim_membersPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Court_claim_members.
     * @param {court_claim_membersUpdateArgs} args - Arguments to update one Court_claim_members.
     * @example
     * // Update one Court_claim_members
     * const court_claim_members = await prisma.court_claim_members.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends court_claim_membersUpdateArgs>(args: SelectSubset<T, court_claim_membersUpdateArgs<ExtArgs>>): Prisma__court_claim_membersClient<$Result.GetResult<Prisma.$court_claim_membersPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Court_claim_members.
     * @param {court_claim_membersDeleteManyArgs} args - Arguments to filter Court_claim_members to delete.
     * @example
     * // Delete a few Court_claim_members
     * const { count } = await prisma.court_claim_members.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends court_claim_membersDeleteManyArgs>(args?: SelectSubset<T, court_claim_membersDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Court_claim_members.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {court_claim_membersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Court_claim_members
     * const court_claim_members = await prisma.court_claim_members.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends court_claim_membersUpdateManyArgs>(args: SelectSubset<T, court_claim_membersUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Court_claim_members.
     * @param {court_claim_membersUpsertArgs} args - Arguments to update or create a Court_claim_members.
     * @example
     * // Update or create a Court_claim_members
     * const court_claim_members = await prisma.court_claim_members.upsert({
     *   create: {
     *     // ... data to create a Court_claim_members
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Court_claim_members we want to update
     *   }
     * })
     */
    upsert<T extends court_claim_membersUpsertArgs>(args: SelectSubset<T, court_claim_membersUpsertArgs<ExtArgs>>): Prisma__court_claim_membersClient<$Result.GetResult<Prisma.$court_claim_membersPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Court_claim_members.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {court_claim_membersCountArgs} args - Arguments to filter Court_claim_members to count.
     * @example
     * // Count the number of Court_claim_members
     * const count = await prisma.court_claim_members.count({
     *   where: {
     *     // ... the filter for the Court_claim_members we want to count
     *   }
     * })
    **/
    count<T extends court_claim_membersCountArgs>(
      args?: Subset<T, court_claim_membersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Court_claim_membersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Court_claim_members.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Court_claim_membersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Court_claim_membersAggregateArgs>(args: Subset<T, Court_claim_membersAggregateArgs>): Prisma.PrismaPromise<GetCourt_claim_membersAggregateType<T>>

    /**
     * Group by Court_claim_members.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {court_claim_membersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends court_claim_membersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: court_claim_membersGroupByArgs['orderBy'] }
        : { orderBy?: court_claim_membersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, court_claim_membersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCourt_claim_membersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the court_claim_members model
   */
  readonly fields: court_claim_membersFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for court_claim_members.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__court_claim_membersClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the court_claim_members model
   */
  interface court_claim_membersFieldRefs {
    readonly id: FieldRef<"court_claim_members", 'Int'>
    readonly claim_id: FieldRef<"court_claim_members", 'Int'>
    readonly case_id: FieldRef<"court_claim_members", 'Int'>
    readonly person_id: FieldRef<"court_claim_members", 'Int'>
    readonly created_at: FieldRef<"court_claim_members", 'DateTime'>
    readonly actual: FieldRef<"court_claim_members", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * court_claim_members findUnique
   */
  export type court_claim_membersFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the court_claim_members
     */
    select?: court_claim_membersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the court_claim_members
     */
    omit?: court_claim_membersOmit<ExtArgs> | null
    /**
     * Filter, which court_claim_members to fetch.
     */
    where: court_claim_membersWhereUniqueInput
  }

  /**
   * court_claim_members findUniqueOrThrow
   */
  export type court_claim_membersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the court_claim_members
     */
    select?: court_claim_membersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the court_claim_members
     */
    omit?: court_claim_membersOmit<ExtArgs> | null
    /**
     * Filter, which court_claim_members to fetch.
     */
    where: court_claim_membersWhereUniqueInput
  }

  /**
   * court_claim_members findFirst
   */
  export type court_claim_membersFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the court_claim_members
     */
    select?: court_claim_membersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the court_claim_members
     */
    omit?: court_claim_membersOmit<ExtArgs> | null
    /**
     * Filter, which court_claim_members to fetch.
     */
    where?: court_claim_membersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of court_claim_members to fetch.
     */
    orderBy?: court_claim_membersOrderByWithRelationInput | court_claim_membersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for court_claim_members.
     */
    cursor?: court_claim_membersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` court_claim_members from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` court_claim_members.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of court_claim_members.
     */
    distinct?: Court_claim_membersScalarFieldEnum | Court_claim_membersScalarFieldEnum[]
  }

  /**
   * court_claim_members findFirstOrThrow
   */
  export type court_claim_membersFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the court_claim_members
     */
    select?: court_claim_membersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the court_claim_members
     */
    omit?: court_claim_membersOmit<ExtArgs> | null
    /**
     * Filter, which court_claim_members to fetch.
     */
    where?: court_claim_membersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of court_claim_members to fetch.
     */
    orderBy?: court_claim_membersOrderByWithRelationInput | court_claim_membersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for court_claim_members.
     */
    cursor?: court_claim_membersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` court_claim_members from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` court_claim_members.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of court_claim_members.
     */
    distinct?: Court_claim_membersScalarFieldEnum | Court_claim_membersScalarFieldEnum[]
  }

  /**
   * court_claim_members findMany
   */
  export type court_claim_membersFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the court_claim_members
     */
    select?: court_claim_membersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the court_claim_members
     */
    omit?: court_claim_membersOmit<ExtArgs> | null
    /**
     * Filter, which court_claim_members to fetch.
     */
    where?: court_claim_membersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of court_claim_members to fetch.
     */
    orderBy?: court_claim_membersOrderByWithRelationInput | court_claim_membersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing court_claim_members.
     */
    cursor?: court_claim_membersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` court_claim_members from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` court_claim_members.
     */
    skip?: number
    distinct?: Court_claim_membersScalarFieldEnum | Court_claim_membersScalarFieldEnum[]
  }

  /**
   * court_claim_members create
   */
  export type court_claim_membersCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the court_claim_members
     */
    select?: court_claim_membersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the court_claim_members
     */
    omit?: court_claim_membersOmit<ExtArgs> | null
    /**
     * The data needed to create a court_claim_members.
     */
    data: XOR<court_claim_membersCreateInput, court_claim_membersUncheckedCreateInput>
  }

  /**
   * court_claim_members createMany
   */
  export type court_claim_membersCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many court_claim_members.
     */
    data: court_claim_membersCreateManyInput | court_claim_membersCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * court_claim_members update
   */
  export type court_claim_membersUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the court_claim_members
     */
    select?: court_claim_membersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the court_claim_members
     */
    omit?: court_claim_membersOmit<ExtArgs> | null
    /**
     * The data needed to update a court_claim_members.
     */
    data: XOR<court_claim_membersUpdateInput, court_claim_membersUncheckedUpdateInput>
    /**
     * Choose, which court_claim_members to update.
     */
    where: court_claim_membersWhereUniqueInput
  }

  /**
   * court_claim_members updateMany
   */
  export type court_claim_membersUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update court_claim_members.
     */
    data: XOR<court_claim_membersUpdateManyMutationInput, court_claim_membersUncheckedUpdateManyInput>
    /**
     * Filter which court_claim_members to update
     */
    where?: court_claim_membersWhereInput
    /**
     * Limit how many court_claim_members to update.
     */
    limit?: number
  }

  /**
   * court_claim_members upsert
   */
  export type court_claim_membersUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the court_claim_members
     */
    select?: court_claim_membersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the court_claim_members
     */
    omit?: court_claim_membersOmit<ExtArgs> | null
    /**
     * The filter to search for the court_claim_members to update in case it exists.
     */
    where: court_claim_membersWhereUniqueInput
    /**
     * In case the court_claim_members found by the `where` argument doesn't exist, create a new court_claim_members with this data.
     */
    create: XOR<court_claim_membersCreateInput, court_claim_membersUncheckedCreateInput>
    /**
     * In case the court_claim_members was found with the provided `where` argument, update it with this data.
     */
    update: XOR<court_claim_membersUpdateInput, court_claim_membersUncheckedUpdateInput>
  }

  /**
   * court_claim_members delete
   */
  export type court_claim_membersDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the court_claim_members
     */
    select?: court_claim_membersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the court_claim_members
     */
    omit?: court_claim_membersOmit<ExtArgs> | null
    /**
     * Filter which court_claim_members to delete.
     */
    where: court_claim_membersWhereUniqueInput
  }

  /**
   * court_claim_members deleteMany
   */
  export type court_claim_membersDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which court_claim_members to delete
     */
    where?: court_claim_membersWhereInput
    /**
     * Limit how many court_claim_members to delete.
     */
    limit?: number
  }

  /**
   * court_claim_members without action
   */
  export type court_claim_membersDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the court_claim_members
     */
    select?: court_claim_membersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the court_claim_members
     */
    omit?: court_claim_membersOmit<ExtArgs> | null
  }


  /**
   * Model court_claims
   */

  export type AggregateCourt_claims = {
    _count: Court_claimsCountAggregateOutputType | null
    _avg: Court_claimsAvgAggregateOutputType | null
    _sum: Court_claimsSumAggregateOutputType | null
    _min: Court_claimsMinAggregateOutputType | null
    _max: Court_claimsMaxAggregateOutputType | null
  }

  export type Court_claimsAvgAggregateOutputType = {
    claim_id: number | null
    appealable_ms_decision: number | null
    appealable_court_decision: number | null
    appealable_claim: number | null
    filled_by: number | null
    ms_lawyer: number | null
    case_id: number | null
    court_level: number | null
    actual: number | null
    initiator: number | null
    claim_status: number | null
    appeal_type: number | null
  }

  export type Court_claimsSumAggregateOutputType = {
    claim_id: number | null
    appealable_ms_decision: number | null
    appealable_court_decision: number | null
    appealable_claim: number | null
    filled_by: number | null
    ms_lawyer: number | null
    case_id: number | null
    court_level: number | null
    actual: number | null
    initiator: number | null
    claim_status: number | null
    appeal_type: number | null
  }

  export type Court_claimsMinAggregateOutputType = {
    claim_id: number | null
    claim_serial_number: string | null
    claim_date: Date | null
    appealable_ms_decision: number | null
    appealable_court_decision: number | null
    appealable_claim: number | null
    filled_by: number | null
    filled_in_date: Date | null
    ms_notified_date: Date | null
    ms_lawyer: number | null
    case_id: number | null
    court_level: number | null
    actual: number | null
    initiator: number | null
    claim_status: number | null
    appeal_type: number | null
    status_change_date: Date | null
  }

  export type Court_claimsMaxAggregateOutputType = {
    claim_id: number | null
    claim_serial_number: string | null
    claim_date: Date | null
    appealable_ms_decision: number | null
    appealable_court_decision: number | null
    appealable_claim: number | null
    filled_by: number | null
    filled_in_date: Date | null
    ms_notified_date: Date | null
    ms_lawyer: number | null
    case_id: number | null
    court_level: number | null
    actual: number | null
    initiator: number | null
    claim_status: number | null
    appeal_type: number | null
    status_change_date: Date | null
  }

  export type Court_claimsCountAggregateOutputType = {
    claim_id: number
    claim_serial_number: number
    claim_date: number
    appealable_ms_decision: number
    appealable_court_decision: number
    appealable_claim: number
    filled_by: number
    filled_in_date: number
    ms_notified_date: number
    ms_lawyer: number
    case_id: number
    court_level: number
    actual: number
    initiator: number
    claim_status: number
    appeal_type: number
    status_change_date: number
    _all: number
  }


  export type Court_claimsAvgAggregateInputType = {
    claim_id?: true
    appealable_ms_decision?: true
    appealable_court_decision?: true
    appealable_claim?: true
    filled_by?: true
    ms_lawyer?: true
    case_id?: true
    court_level?: true
    actual?: true
    initiator?: true
    claim_status?: true
    appeal_type?: true
  }

  export type Court_claimsSumAggregateInputType = {
    claim_id?: true
    appealable_ms_decision?: true
    appealable_court_decision?: true
    appealable_claim?: true
    filled_by?: true
    ms_lawyer?: true
    case_id?: true
    court_level?: true
    actual?: true
    initiator?: true
    claim_status?: true
    appeal_type?: true
  }

  export type Court_claimsMinAggregateInputType = {
    claim_id?: true
    claim_serial_number?: true
    claim_date?: true
    appealable_ms_decision?: true
    appealable_court_decision?: true
    appealable_claim?: true
    filled_by?: true
    filled_in_date?: true
    ms_notified_date?: true
    ms_lawyer?: true
    case_id?: true
    court_level?: true
    actual?: true
    initiator?: true
    claim_status?: true
    appeal_type?: true
    status_change_date?: true
  }

  export type Court_claimsMaxAggregateInputType = {
    claim_id?: true
    claim_serial_number?: true
    claim_date?: true
    appealable_ms_decision?: true
    appealable_court_decision?: true
    appealable_claim?: true
    filled_by?: true
    filled_in_date?: true
    ms_notified_date?: true
    ms_lawyer?: true
    case_id?: true
    court_level?: true
    actual?: true
    initiator?: true
    claim_status?: true
    appeal_type?: true
    status_change_date?: true
  }

  export type Court_claimsCountAggregateInputType = {
    claim_id?: true
    claim_serial_number?: true
    claim_date?: true
    appealable_ms_decision?: true
    appealable_court_decision?: true
    appealable_claim?: true
    filled_by?: true
    filled_in_date?: true
    ms_notified_date?: true
    ms_lawyer?: true
    case_id?: true
    court_level?: true
    actual?: true
    initiator?: true
    claim_status?: true
    appeal_type?: true
    status_change_date?: true
    _all?: true
  }

  export type Court_claimsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which court_claims to aggregate.
     */
    where?: court_claimsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of court_claims to fetch.
     */
    orderBy?: court_claimsOrderByWithRelationInput | court_claimsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: court_claimsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` court_claims from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` court_claims.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned court_claims
    **/
    _count?: true | Court_claimsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Court_claimsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Court_claimsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Court_claimsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Court_claimsMaxAggregateInputType
  }

  export type GetCourt_claimsAggregateType<T extends Court_claimsAggregateArgs> = {
        [P in keyof T & keyof AggregateCourt_claims]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCourt_claims[P]>
      : GetScalarType<T[P], AggregateCourt_claims[P]>
  }




  export type court_claimsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: court_claimsWhereInput
    orderBy?: court_claimsOrderByWithAggregationInput | court_claimsOrderByWithAggregationInput[]
    by: Court_claimsScalarFieldEnum[] | Court_claimsScalarFieldEnum
    having?: court_claimsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Court_claimsCountAggregateInputType | true
    _avg?: Court_claimsAvgAggregateInputType
    _sum?: Court_claimsSumAggregateInputType
    _min?: Court_claimsMinAggregateInputType
    _max?: Court_claimsMaxAggregateInputType
  }

  export type Court_claimsGroupByOutputType = {
    claim_id: number
    claim_serial_number: string
    claim_date: Date
    appealable_ms_decision: number | null
    appealable_court_decision: number | null
    appealable_claim: number | null
    filled_by: number
    filled_in_date: Date
    ms_notified_date: Date
    ms_lawyer: number
    case_id: number
    court_level: number
    actual: number
    initiator: number
    claim_status: number
    appeal_type: number
    status_change_date: Date
    _count: Court_claimsCountAggregateOutputType | null
    _avg: Court_claimsAvgAggregateOutputType | null
    _sum: Court_claimsSumAggregateOutputType | null
    _min: Court_claimsMinAggregateOutputType | null
    _max: Court_claimsMaxAggregateOutputType | null
  }

  type GetCourt_claimsGroupByPayload<T extends court_claimsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Court_claimsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Court_claimsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Court_claimsGroupByOutputType[P]>
            : GetScalarType<T[P], Court_claimsGroupByOutputType[P]>
        }
      >
    >


  export type court_claimsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    claim_id?: boolean
    claim_serial_number?: boolean
    claim_date?: boolean
    appealable_ms_decision?: boolean
    appealable_court_decision?: boolean
    appealable_claim?: boolean
    filled_by?: boolean
    filled_in_date?: boolean
    ms_notified_date?: boolean
    ms_lawyer?: boolean
    case_id?: boolean
    court_level?: boolean
    actual?: boolean
    initiator?: boolean
    claim_status?: boolean
    appeal_type?: boolean
    status_change_date?: boolean
  }, ExtArgs["result"]["court_claims"]>



  export type court_claimsSelectScalar = {
    claim_id?: boolean
    claim_serial_number?: boolean
    claim_date?: boolean
    appealable_ms_decision?: boolean
    appealable_court_decision?: boolean
    appealable_claim?: boolean
    filled_by?: boolean
    filled_in_date?: boolean
    ms_notified_date?: boolean
    ms_lawyer?: boolean
    case_id?: boolean
    court_level?: boolean
    actual?: boolean
    initiator?: boolean
    claim_status?: boolean
    appeal_type?: boolean
    status_change_date?: boolean
  }

  export type court_claimsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"claim_id" | "claim_serial_number" | "claim_date" | "appealable_ms_decision" | "appealable_court_decision" | "appealable_claim" | "filled_by" | "filled_in_date" | "ms_notified_date" | "ms_lawyer" | "case_id" | "court_level" | "actual" | "initiator" | "claim_status" | "appeal_type" | "status_change_date", ExtArgs["result"]["court_claims"]>

  export type $court_claimsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "court_claims"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      claim_id: number
      claim_serial_number: string
      claim_date: Date
      appealable_ms_decision: number | null
      appealable_court_decision: number | null
      appealable_claim: number | null
      filled_by: number
      filled_in_date: Date
      ms_notified_date: Date
      ms_lawyer: number
      case_id: number
      court_level: number
      actual: number
      initiator: number
      claim_status: number
      appeal_type: number
      status_change_date: Date
    }, ExtArgs["result"]["court_claims"]>
    composites: {}
  }

  type court_claimsGetPayload<S extends boolean | null | undefined | court_claimsDefaultArgs> = $Result.GetResult<Prisma.$court_claimsPayload, S>

  type court_claimsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<court_claimsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Court_claimsCountAggregateInputType | true
    }

  export interface court_claimsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['court_claims'], meta: { name: 'court_claims' } }
    /**
     * Find zero or one Court_claims that matches the filter.
     * @param {court_claimsFindUniqueArgs} args - Arguments to find a Court_claims
     * @example
     * // Get one Court_claims
     * const court_claims = await prisma.court_claims.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends court_claimsFindUniqueArgs>(args: SelectSubset<T, court_claimsFindUniqueArgs<ExtArgs>>): Prisma__court_claimsClient<$Result.GetResult<Prisma.$court_claimsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Court_claims that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {court_claimsFindUniqueOrThrowArgs} args - Arguments to find a Court_claims
     * @example
     * // Get one Court_claims
     * const court_claims = await prisma.court_claims.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends court_claimsFindUniqueOrThrowArgs>(args: SelectSubset<T, court_claimsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__court_claimsClient<$Result.GetResult<Prisma.$court_claimsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Court_claims that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {court_claimsFindFirstArgs} args - Arguments to find a Court_claims
     * @example
     * // Get one Court_claims
     * const court_claims = await prisma.court_claims.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends court_claimsFindFirstArgs>(args?: SelectSubset<T, court_claimsFindFirstArgs<ExtArgs>>): Prisma__court_claimsClient<$Result.GetResult<Prisma.$court_claimsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Court_claims that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {court_claimsFindFirstOrThrowArgs} args - Arguments to find a Court_claims
     * @example
     * // Get one Court_claims
     * const court_claims = await prisma.court_claims.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends court_claimsFindFirstOrThrowArgs>(args?: SelectSubset<T, court_claimsFindFirstOrThrowArgs<ExtArgs>>): Prisma__court_claimsClient<$Result.GetResult<Prisma.$court_claimsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Court_claims that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {court_claimsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Court_claims
     * const court_claims = await prisma.court_claims.findMany()
     * 
     * // Get first 10 Court_claims
     * const court_claims = await prisma.court_claims.findMany({ take: 10 })
     * 
     * // Only select the `claim_id`
     * const court_claimsWithClaim_idOnly = await prisma.court_claims.findMany({ select: { claim_id: true } })
     * 
     */
    findMany<T extends court_claimsFindManyArgs>(args?: SelectSubset<T, court_claimsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$court_claimsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Court_claims.
     * @param {court_claimsCreateArgs} args - Arguments to create a Court_claims.
     * @example
     * // Create one Court_claims
     * const Court_claims = await prisma.court_claims.create({
     *   data: {
     *     // ... data to create a Court_claims
     *   }
     * })
     * 
     */
    create<T extends court_claimsCreateArgs>(args: SelectSubset<T, court_claimsCreateArgs<ExtArgs>>): Prisma__court_claimsClient<$Result.GetResult<Prisma.$court_claimsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Court_claims.
     * @param {court_claimsCreateManyArgs} args - Arguments to create many Court_claims.
     * @example
     * // Create many Court_claims
     * const court_claims = await prisma.court_claims.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends court_claimsCreateManyArgs>(args?: SelectSubset<T, court_claimsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Court_claims.
     * @param {court_claimsDeleteArgs} args - Arguments to delete one Court_claims.
     * @example
     * // Delete one Court_claims
     * const Court_claims = await prisma.court_claims.delete({
     *   where: {
     *     // ... filter to delete one Court_claims
     *   }
     * })
     * 
     */
    delete<T extends court_claimsDeleteArgs>(args: SelectSubset<T, court_claimsDeleteArgs<ExtArgs>>): Prisma__court_claimsClient<$Result.GetResult<Prisma.$court_claimsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Court_claims.
     * @param {court_claimsUpdateArgs} args - Arguments to update one Court_claims.
     * @example
     * // Update one Court_claims
     * const court_claims = await prisma.court_claims.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends court_claimsUpdateArgs>(args: SelectSubset<T, court_claimsUpdateArgs<ExtArgs>>): Prisma__court_claimsClient<$Result.GetResult<Prisma.$court_claimsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Court_claims.
     * @param {court_claimsDeleteManyArgs} args - Arguments to filter Court_claims to delete.
     * @example
     * // Delete a few Court_claims
     * const { count } = await prisma.court_claims.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends court_claimsDeleteManyArgs>(args?: SelectSubset<T, court_claimsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Court_claims.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {court_claimsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Court_claims
     * const court_claims = await prisma.court_claims.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends court_claimsUpdateManyArgs>(args: SelectSubset<T, court_claimsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Court_claims.
     * @param {court_claimsUpsertArgs} args - Arguments to update or create a Court_claims.
     * @example
     * // Update or create a Court_claims
     * const court_claims = await prisma.court_claims.upsert({
     *   create: {
     *     // ... data to create a Court_claims
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Court_claims we want to update
     *   }
     * })
     */
    upsert<T extends court_claimsUpsertArgs>(args: SelectSubset<T, court_claimsUpsertArgs<ExtArgs>>): Prisma__court_claimsClient<$Result.GetResult<Prisma.$court_claimsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Court_claims.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {court_claimsCountArgs} args - Arguments to filter Court_claims to count.
     * @example
     * // Count the number of Court_claims
     * const count = await prisma.court_claims.count({
     *   where: {
     *     // ... the filter for the Court_claims we want to count
     *   }
     * })
    **/
    count<T extends court_claimsCountArgs>(
      args?: Subset<T, court_claimsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Court_claimsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Court_claims.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Court_claimsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Court_claimsAggregateArgs>(args: Subset<T, Court_claimsAggregateArgs>): Prisma.PrismaPromise<GetCourt_claimsAggregateType<T>>

    /**
     * Group by Court_claims.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {court_claimsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends court_claimsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: court_claimsGroupByArgs['orderBy'] }
        : { orderBy?: court_claimsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, court_claimsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCourt_claimsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the court_claims model
   */
  readonly fields: court_claimsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for court_claims.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__court_claimsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the court_claims model
   */
  interface court_claimsFieldRefs {
    readonly claim_id: FieldRef<"court_claims", 'Int'>
    readonly claim_serial_number: FieldRef<"court_claims", 'String'>
    readonly claim_date: FieldRef<"court_claims", 'DateTime'>
    readonly appealable_ms_decision: FieldRef<"court_claims", 'Int'>
    readonly appealable_court_decision: FieldRef<"court_claims", 'Int'>
    readonly appealable_claim: FieldRef<"court_claims", 'Int'>
    readonly filled_by: FieldRef<"court_claims", 'Int'>
    readonly filled_in_date: FieldRef<"court_claims", 'DateTime'>
    readonly ms_notified_date: FieldRef<"court_claims", 'DateTime'>
    readonly ms_lawyer: FieldRef<"court_claims", 'Int'>
    readonly case_id: FieldRef<"court_claims", 'Int'>
    readonly court_level: FieldRef<"court_claims", 'Int'>
    readonly actual: FieldRef<"court_claims", 'Int'>
    readonly initiator: FieldRef<"court_claims", 'Int'>
    readonly claim_status: FieldRef<"court_claims", 'Int'>
    readonly appeal_type: FieldRef<"court_claims", 'Int'>
    readonly status_change_date: FieldRef<"court_claims", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * court_claims findUnique
   */
  export type court_claimsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the court_claims
     */
    select?: court_claimsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the court_claims
     */
    omit?: court_claimsOmit<ExtArgs> | null
    /**
     * Filter, which court_claims to fetch.
     */
    where: court_claimsWhereUniqueInput
  }

  /**
   * court_claims findUniqueOrThrow
   */
  export type court_claimsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the court_claims
     */
    select?: court_claimsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the court_claims
     */
    omit?: court_claimsOmit<ExtArgs> | null
    /**
     * Filter, which court_claims to fetch.
     */
    where: court_claimsWhereUniqueInput
  }

  /**
   * court_claims findFirst
   */
  export type court_claimsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the court_claims
     */
    select?: court_claimsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the court_claims
     */
    omit?: court_claimsOmit<ExtArgs> | null
    /**
     * Filter, which court_claims to fetch.
     */
    where?: court_claimsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of court_claims to fetch.
     */
    orderBy?: court_claimsOrderByWithRelationInput | court_claimsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for court_claims.
     */
    cursor?: court_claimsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` court_claims from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` court_claims.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of court_claims.
     */
    distinct?: Court_claimsScalarFieldEnum | Court_claimsScalarFieldEnum[]
  }

  /**
   * court_claims findFirstOrThrow
   */
  export type court_claimsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the court_claims
     */
    select?: court_claimsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the court_claims
     */
    omit?: court_claimsOmit<ExtArgs> | null
    /**
     * Filter, which court_claims to fetch.
     */
    where?: court_claimsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of court_claims to fetch.
     */
    orderBy?: court_claimsOrderByWithRelationInput | court_claimsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for court_claims.
     */
    cursor?: court_claimsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` court_claims from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` court_claims.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of court_claims.
     */
    distinct?: Court_claimsScalarFieldEnum | Court_claimsScalarFieldEnum[]
  }

  /**
   * court_claims findMany
   */
  export type court_claimsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the court_claims
     */
    select?: court_claimsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the court_claims
     */
    omit?: court_claimsOmit<ExtArgs> | null
    /**
     * Filter, which court_claims to fetch.
     */
    where?: court_claimsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of court_claims to fetch.
     */
    orderBy?: court_claimsOrderByWithRelationInput | court_claimsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing court_claims.
     */
    cursor?: court_claimsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` court_claims from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` court_claims.
     */
    skip?: number
    distinct?: Court_claimsScalarFieldEnum | Court_claimsScalarFieldEnum[]
  }

  /**
   * court_claims create
   */
  export type court_claimsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the court_claims
     */
    select?: court_claimsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the court_claims
     */
    omit?: court_claimsOmit<ExtArgs> | null
    /**
     * The data needed to create a court_claims.
     */
    data: XOR<court_claimsCreateInput, court_claimsUncheckedCreateInput>
  }

  /**
   * court_claims createMany
   */
  export type court_claimsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many court_claims.
     */
    data: court_claimsCreateManyInput | court_claimsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * court_claims update
   */
  export type court_claimsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the court_claims
     */
    select?: court_claimsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the court_claims
     */
    omit?: court_claimsOmit<ExtArgs> | null
    /**
     * The data needed to update a court_claims.
     */
    data: XOR<court_claimsUpdateInput, court_claimsUncheckedUpdateInput>
    /**
     * Choose, which court_claims to update.
     */
    where: court_claimsWhereUniqueInput
  }

  /**
   * court_claims updateMany
   */
  export type court_claimsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update court_claims.
     */
    data: XOR<court_claimsUpdateManyMutationInput, court_claimsUncheckedUpdateManyInput>
    /**
     * Filter which court_claims to update
     */
    where?: court_claimsWhereInput
    /**
     * Limit how many court_claims to update.
     */
    limit?: number
  }

  /**
   * court_claims upsert
   */
  export type court_claimsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the court_claims
     */
    select?: court_claimsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the court_claims
     */
    omit?: court_claimsOmit<ExtArgs> | null
    /**
     * The filter to search for the court_claims to update in case it exists.
     */
    where: court_claimsWhereUniqueInput
    /**
     * In case the court_claims found by the `where` argument doesn't exist, create a new court_claims with this data.
     */
    create: XOR<court_claimsCreateInput, court_claimsUncheckedCreateInput>
    /**
     * In case the court_claims was found with the provided `where` argument, update it with this data.
     */
    update: XOR<court_claimsUpdateInput, court_claimsUncheckedUpdateInput>
  }

  /**
   * court_claims delete
   */
  export type court_claimsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the court_claims
     */
    select?: court_claimsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the court_claims
     */
    omit?: court_claimsOmit<ExtArgs> | null
    /**
     * Filter which court_claims to delete.
     */
    where: court_claimsWhereUniqueInput
  }

  /**
   * court_claims deleteMany
   */
  export type court_claimsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which court_claims to delete
     */
    where?: court_claimsWhereInput
    /**
     * Limit how many court_claims to delete.
     */
    limit?: number
  }

  /**
   * court_claims without action
   */
  export type court_claimsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the court_claims
     */
    select?: court_claimsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the court_claims
     */
    omit?: court_claimsOmit<ExtArgs> | null
  }


  /**
   * Model court_cliam_status
   */

  export type AggregateCourt_cliam_status = {
    _count: Court_cliam_statusCountAggregateOutputType | null
    _avg: Court_cliam_statusAvgAggregateOutputType | null
    _sum: Court_cliam_statusSumAggregateOutputType | null
    _min: Court_cliam_statusMinAggregateOutputType | null
    _max: Court_cliam_statusMaxAggregateOutputType | null
  }

  export type Court_cliam_statusAvgAggregateOutputType = {
    id: number | null
    court_level: number | null
  }

  export type Court_cliam_statusSumAggregateOutputType = {
    id: number | null
    court_level: number | null
  }

  export type Court_cliam_statusMinAggregateOutputType = {
    id: number | null
    court_level: number | null
    name: string | null
    button_value: string | null
  }

  export type Court_cliam_statusMaxAggregateOutputType = {
    id: number | null
    court_level: number | null
    name: string | null
    button_value: string | null
  }

  export type Court_cliam_statusCountAggregateOutputType = {
    id: number
    court_level: number
    name: number
    button_value: number
    _all: number
  }


  export type Court_cliam_statusAvgAggregateInputType = {
    id?: true
    court_level?: true
  }

  export type Court_cliam_statusSumAggregateInputType = {
    id?: true
    court_level?: true
  }

  export type Court_cliam_statusMinAggregateInputType = {
    id?: true
    court_level?: true
    name?: true
    button_value?: true
  }

  export type Court_cliam_statusMaxAggregateInputType = {
    id?: true
    court_level?: true
    name?: true
    button_value?: true
  }

  export type Court_cliam_statusCountAggregateInputType = {
    id?: true
    court_level?: true
    name?: true
    button_value?: true
    _all?: true
  }

  export type Court_cliam_statusAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which court_cliam_status to aggregate.
     */
    where?: court_cliam_statusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of court_cliam_statuses to fetch.
     */
    orderBy?: court_cliam_statusOrderByWithRelationInput | court_cliam_statusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: court_cliam_statusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` court_cliam_statuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` court_cliam_statuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned court_cliam_statuses
    **/
    _count?: true | Court_cliam_statusCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Court_cliam_statusAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Court_cliam_statusSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Court_cliam_statusMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Court_cliam_statusMaxAggregateInputType
  }

  export type GetCourt_cliam_statusAggregateType<T extends Court_cliam_statusAggregateArgs> = {
        [P in keyof T & keyof AggregateCourt_cliam_status]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCourt_cliam_status[P]>
      : GetScalarType<T[P], AggregateCourt_cliam_status[P]>
  }




  export type court_cliam_statusGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: court_cliam_statusWhereInput
    orderBy?: court_cliam_statusOrderByWithAggregationInput | court_cliam_statusOrderByWithAggregationInput[]
    by: Court_cliam_statusScalarFieldEnum[] | Court_cliam_statusScalarFieldEnum
    having?: court_cliam_statusScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Court_cliam_statusCountAggregateInputType | true
    _avg?: Court_cliam_statusAvgAggregateInputType
    _sum?: Court_cliam_statusSumAggregateInputType
    _min?: Court_cliam_statusMinAggregateInputType
    _max?: Court_cliam_statusMaxAggregateInputType
  }

  export type Court_cliam_statusGroupByOutputType = {
    id: number
    court_level: number
    name: string
    button_value: string | null
    _count: Court_cliam_statusCountAggregateOutputType | null
    _avg: Court_cliam_statusAvgAggregateOutputType | null
    _sum: Court_cliam_statusSumAggregateOutputType | null
    _min: Court_cliam_statusMinAggregateOutputType | null
    _max: Court_cliam_statusMaxAggregateOutputType | null
  }

  type GetCourt_cliam_statusGroupByPayload<T extends court_cliam_statusGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Court_cliam_statusGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Court_cliam_statusGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Court_cliam_statusGroupByOutputType[P]>
            : GetScalarType<T[P], Court_cliam_statusGroupByOutputType[P]>
        }
      >
    >


  export type court_cliam_statusSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    court_level?: boolean
    name?: boolean
    button_value?: boolean
  }, ExtArgs["result"]["court_cliam_status"]>



  export type court_cliam_statusSelectScalar = {
    id?: boolean
    court_level?: boolean
    name?: boolean
    button_value?: boolean
  }

  export type court_cliam_statusOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "court_level" | "name" | "button_value", ExtArgs["result"]["court_cliam_status"]>

  export type $court_cliam_statusPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "court_cliam_status"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      court_level: number
      name: string
      button_value: string | null
    }, ExtArgs["result"]["court_cliam_status"]>
    composites: {}
  }

  type court_cliam_statusGetPayload<S extends boolean | null | undefined | court_cliam_statusDefaultArgs> = $Result.GetResult<Prisma.$court_cliam_statusPayload, S>

  type court_cliam_statusCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<court_cliam_statusFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Court_cliam_statusCountAggregateInputType | true
    }

  export interface court_cliam_statusDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['court_cliam_status'], meta: { name: 'court_cliam_status' } }
    /**
     * Find zero or one Court_cliam_status that matches the filter.
     * @param {court_cliam_statusFindUniqueArgs} args - Arguments to find a Court_cliam_status
     * @example
     * // Get one Court_cliam_status
     * const court_cliam_status = await prisma.court_cliam_status.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends court_cliam_statusFindUniqueArgs>(args: SelectSubset<T, court_cliam_statusFindUniqueArgs<ExtArgs>>): Prisma__court_cliam_statusClient<$Result.GetResult<Prisma.$court_cliam_statusPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Court_cliam_status that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {court_cliam_statusFindUniqueOrThrowArgs} args - Arguments to find a Court_cliam_status
     * @example
     * // Get one Court_cliam_status
     * const court_cliam_status = await prisma.court_cliam_status.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends court_cliam_statusFindUniqueOrThrowArgs>(args: SelectSubset<T, court_cliam_statusFindUniqueOrThrowArgs<ExtArgs>>): Prisma__court_cliam_statusClient<$Result.GetResult<Prisma.$court_cliam_statusPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Court_cliam_status that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {court_cliam_statusFindFirstArgs} args - Arguments to find a Court_cliam_status
     * @example
     * // Get one Court_cliam_status
     * const court_cliam_status = await prisma.court_cliam_status.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends court_cliam_statusFindFirstArgs>(args?: SelectSubset<T, court_cliam_statusFindFirstArgs<ExtArgs>>): Prisma__court_cliam_statusClient<$Result.GetResult<Prisma.$court_cliam_statusPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Court_cliam_status that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {court_cliam_statusFindFirstOrThrowArgs} args - Arguments to find a Court_cliam_status
     * @example
     * // Get one Court_cliam_status
     * const court_cliam_status = await prisma.court_cliam_status.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends court_cliam_statusFindFirstOrThrowArgs>(args?: SelectSubset<T, court_cliam_statusFindFirstOrThrowArgs<ExtArgs>>): Prisma__court_cliam_statusClient<$Result.GetResult<Prisma.$court_cliam_statusPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Court_cliam_statuses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {court_cliam_statusFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Court_cliam_statuses
     * const court_cliam_statuses = await prisma.court_cliam_status.findMany()
     * 
     * // Get first 10 Court_cliam_statuses
     * const court_cliam_statuses = await prisma.court_cliam_status.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const court_cliam_statusWithIdOnly = await prisma.court_cliam_status.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends court_cliam_statusFindManyArgs>(args?: SelectSubset<T, court_cliam_statusFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$court_cliam_statusPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Court_cliam_status.
     * @param {court_cliam_statusCreateArgs} args - Arguments to create a Court_cliam_status.
     * @example
     * // Create one Court_cliam_status
     * const Court_cliam_status = await prisma.court_cliam_status.create({
     *   data: {
     *     // ... data to create a Court_cliam_status
     *   }
     * })
     * 
     */
    create<T extends court_cliam_statusCreateArgs>(args: SelectSubset<T, court_cliam_statusCreateArgs<ExtArgs>>): Prisma__court_cliam_statusClient<$Result.GetResult<Prisma.$court_cliam_statusPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Court_cliam_statuses.
     * @param {court_cliam_statusCreateManyArgs} args - Arguments to create many Court_cliam_statuses.
     * @example
     * // Create many Court_cliam_statuses
     * const court_cliam_status = await prisma.court_cliam_status.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends court_cliam_statusCreateManyArgs>(args?: SelectSubset<T, court_cliam_statusCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Court_cliam_status.
     * @param {court_cliam_statusDeleteArgs} args - Arguments to delete one Court_cliam_status.
     * @example
     * // Delete one Court_cliam_status
     * const Court_cliam_status = await prisma.court_cliam_status.delete({
     *   where: {
     *     // ... filter to delete one Court_cliam_status
     *   }
     * })
     * 
     */
    delete<T extends court_cliam_statusDeleteArgs>(args: SelectSubset<T, court_cliam_statusDeleteArgs<ExtArgs>>): Prisma__court_cliam_statusClient<$Result.GetResult<Prisma.$court_cliam_statusPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Court_cliam_status.
     * @param {court_cliam_statusUpdateArgs} args - Arguments to update one Court_cliam_status.
     * @example
     * // Update one Court_cliam_status
     * const court_cliam_status = await prisma.court_cliam_status.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends court_cliam_statusUpdateArgs>(args: SelectSubset<T, court_cliam_statusUpdateArgs<ExtArgs>>): Prisma__court_cliam_statusClient<$Result.GetResult<Prisma.$court_cliam_statusPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Court_cliam_statuses.
     * @param {court_cliam_statusDeleteManyArgs} args - Arguments to filter Court_cliam_statuses to delete.
     * @example
     * // Delete a few Court_cliam_statuses
     * const { count } = await prisma.court_cliam_status.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends court_cliam_statusDeleteManyArgs>(args?: SelectSubset<T, court_cliam_statusDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Court_cliam_statuses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {court_cliam_statusUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Court_cliam_statuses
     * const court_cliam_status = await prisma.court_cliam_status.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends court_cliam_statusUpdateManyArgs>(args: SelectSubset<T, court_cliam_statusUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Court_cliam_status.
     * @param {court_cliam_statusUpsertArgs} args - Arguments to update or create a Court_cliam_status.
     * @example
     * // Update or create a Court_cliam_status
     * const court_cliam_status = await prisma.court_cliam_status.upsert({
     *   create: {
     *     // ... data to create a Court_cliam_status
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Court_cliam_status we want to update
     *   }
     * })
     */
    upsert<T extends court_cliam_statusUpsertArgs>(args: SelectSubset<T, court_cliam_statusUpsertArgs<ExtArgs>>): Prisma__court_cliam_statusClient<$Result.GetResult<Prisma.$court_cliam_statusPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Court_cliam_statuses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {court_cliam_statusCountArgs} args - Arguments to filter Court_cliam_statuses to count.
     * @example
     * // Count the number of Court_cliam_statuses
     * const count = await prisma.court_cliam_status.count({
     *   where: {
     *     // ... the filter for the Court_cliam_statuses we want to count
     *   }
     * })
    **/
    count<T extends court_cliam_statusCountArgs>(
      args?: Subset<T, court_cliam_statusCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Court_cliam_statusCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Court_cliam_status.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Court_cliam_statusAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Court_cliam_statusAggregateArgs>(args: Subset<T, Court_cliam_statusAggregateArgs>): Prisma.PrismaPromise<GetCourt_cliam_statusAggregateType<T>>

    /**
     * Group by Court_cliam_status.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {court_cliam_statusGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends court_cliam_statusGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: court_cliam_statusGroupByArgs['orderBy'] }
        : { orderBy?: court_cliam_statusGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, court_cliam_statusGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCourt_cliam_statusGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the court_cliam_status model
   */
  readonly fields: court_cliam_statusFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for court_cliam_status.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__court_cliam_statusClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the court_cliam_status model
   */
  interface court_cliam_statusFieldRefs {
    readonly id: FieldRef<"court_cliam_status", 'Int'>
    readonly court_level: FieldRef<"court_cliam_status", 'Int'>
    readonly name: FieldRef<"court_cliam_status", 'String'>
    readonly button_value: FieldRef<"court_cliam_status", 'String'>
  }
    

  // Custom InputTypes
  /**
   * court_cliam_status findUnique
   */
  export type court_cliam_statusFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the court_cliam_status
     */
    select?: court_cliam_statusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the court_cliam_status
     */
    omit?: court_cliam_statusOmit<ExtArgs> | null
    /**
     * Filter, which court_cliam_status to fetch.
     */
    where: court_cliam_statusWhereUniqueInput
  }

  /**
   * court_cliam_status findUniqueOrThrow
   */
  export type court_cliam_statusFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the court_cliam_status
     */
    select?: court_cliam_statusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the court_cliam_status
     */
    omit?: court_cliam_statusOmit<ExtArgs> | null
    /**
     * Filter, which court_cliam_status to fetch.
     */
    where: court_cliam_statusWhereUniqueInput
  }

  /**
   * court_cliam_status findFirst
   */
  export type court_cliam_statusFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the court_cliam_status
     */
    select?: court_cliam_statusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the court_cliam_status
     */
    omit?: court_cliam_statusOmit<ExtArgs> | null
    /**
     * Filter, which court_cliam_status to fetch.
     */
    where?: court_cliam_statusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of court_cliam_statuses to fetch.
     */
    orderBy?: court_cliam_statusOrderByWithRelationInput | court_cliam_statusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for court_cliam_statuses.
     */
    cursor?: court_cliam_statusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` court_cliam_statuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` court_cliam_statuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of court_cliam_statuses.
     */
    distinct?: Court_cliam_statusScalarFieldEnum | Court_cliam_statusScalarFieldEnum[]
  }

  /**
   * court_cliam_status findFirstOrThrow
   */
  export type court_cliam_statusFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the court_cliam_status
     */
    select?: court_cliam_statusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the court_cliam_status
     */
    omit?: court_cliam_statusOmit<ExtArgs> | null
    /**
     * Filter, which court_cliam_status to fetch.
     */
    where?: court_cliam_statusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of court_cliam_statuses to fetch.
     */
    orderBy?: court_cliam_statusOrderByWithRelationInput | court_cliam_statusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for court_cliam_statuses.
     */
    cursor?: court_cliam_statusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` court_cliam_statuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` court_cliam_statuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of court_cliam_statuses.
     */
    distinct?: Court_cliam_statusScalarFieldEnum | Court_cliam_statusScalarFieldEnum[]
  }

  /**
   * court_cliam_status findMany
   */
  export type court_cliam_statusFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the court_cliam_status
     */
    select?: court_cliam_statusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the court_cliam_status
     */
    omit?: court_cliam_statusOmit<ExtArgs> | null
    /**
     * Filter, which court_cliam_statuses to fetch.
     */
    where?: court_cliam_statusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of court_cliam_statuses to fetch.
     */
    orderBy?: court_cliam_statusOrderByWithRelationInput | court_cliam_statusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing court_cliam_statuses.
     */
    cursor?: court_cliam_statusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` court_cliam_statuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` court_cliam_statuses.
     */
    skip?: number
    distinct?: Court_cliam_statusScalarFieldEnum | Court_cliam_statusScalarFieldEnum[]
  }

  /**
   * court_cliam_status create
   */
  export type court_cliam_statusCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the court_cliam_status
     */
    select?: court_cliam_statusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the court_cliam_status
     */
    omit?: court_cliam_statusOmit<ExtArgs> | null
    /**
     * The data needed to create a court_cliam_status.
     */
    data: XOR<court_cliam_statusCreateInput, court_cliam_statusUncheckedCreateInput>
  }

  /**
   * court_cliam_status createMany
   */
  export type court_cliam_statusCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many court_cliam_statuses.
     */
    data: court_cliam_statusCreateManyInput | court_cliam_statusCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * court_cliam_status update
   */
  export type court_cliam_statusUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the court_cliam_status
     */
    select?: court_cliam_statusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the court_cliam_status
     */
    omit?: court_cliam_statusOmit<ExtArgs> | null
    /**
     * The data needed to update a court_cliam_status.
     */
    data: XOR<court_cliam_statusUpdateInput, court_cliam_statusUncheckedUpdateInput>
    /**
     * Choose, which court_cliam_status to update.
     */
    where: court_cliam_statusWhereUniqueInput
  }

  /**
   * court_cliam_status updateMany
   */
  export type court_cliam_statusUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update court_cliam_statuses.
     */
    data: XOR<court_cliam_statusUpdateManyMutationInput, court_cliam_statusUncheckedUpdateManyInput>
    /**
     * Filter which court_cliam_statuses to update
     */
    where?: court_cliam_statusWhereInput
    /**
     * Limit how many court_cliam_statuses to update.
     */
    limit?: number
  }

  /**
   * court_cliam_status upsert
   */
  export type court_cliam_statusUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the court_cliam_status
     */
    select?: court_cliam_statusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the court_cliam_status
     */
    omit?: court_cliam_statusOmit<ExtArgs> | null
    /**
     * The filter to search for the court_cliam_status to update in case it exists.
     */
    where: court_cliam_statusWhereUniqueInput
    /**
     * In case the court_cliam_status found by the `where` argument doesn't exist, create a new court_cliam_status with this data.
     */
    create: XOR<court_cliam_statusCreateInput, court_cliam_statusUncheckedCreateInput>
    /**
     * In case the court_cliam_status was found with the provided `where` argument, update it with this data.
     */
    update: XOR<court_cliam_statusUpdateInput, court_cliam_statusUncheckedUpdateInput>
  }

  /**
   * court_cliam_status delete
   */
  export type court_cliam_statusDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the court_cliam_status
     */
    select?: court_cliam_statusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the court_cliam_status
     */
    omit?: court_cliam_statusOmit<ExtArgs> | null
    /**
     * Filter which court_cliam_status to delete.
     */
    where: court_cliam_statusWhereUniqueInput
  }

  /**
   * court_cliam_status deleteMany
   */
  export type court_cliam_statusDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which court_cliam_statuses to delete
     */
    where?: court_cliam_statusWhereInput
    /**
     * Limit how many court_cliam_statuses to delete.
     */
    limit?: number
  }

  /**
   * court_cliam_status without action
   */
  export type court_cliam_statusDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the court_cliam_status
     */
    select?: court_cliam_statusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the court_cliam_status
     */
    omit?: court_cliam_statusOmit<ExtArgs> | null
  }


  /**
   * Model court_decision_types
   */

  export type AggregateCourt_decision_types = {
    _count: Court_decision_typesCountAggregateOutputType | null
    _avg: Court_decision_typesAvgAggregateOutputType | null
    _sum: Court_decision_typesSumAggregateOutputType | null
    _min: Court_decision_typesMinAggregateOutputType | null
    _max: Court_decision_typesMaxAggregateOutputType | null
  }

  export type Court_decision_typesAvgAggregateOutputType = {
    court_decision_type_id: number | null
    court_type: number | null
  }

  export type Court_decision_typesSumAggregateOutputType = {
    court_decision_type_id: number | null
    court_type: number | null
  }

  export type Court_decision_typesMinAggregateOutputType = {
    court_decision_type_id: number | null
    court_type: number | null
    court_decision: string | null
  }

  export type Court_decision_typesMaxAggregateOutputType = {
    court_decision_type_id: number | null
    court_type: number | null
    court_decision: string | null
  }

  export type Court_decision_typesCountAggregateOutputType = {
    court_decision_type_id: number
    court_type: number
    court_decision: number
    _all: number
  }


  export type Court_decision_typesAvgAggregateInputType = {
    court_decision_type_id?: true
    court_type?: true
  }

  export type Court_decision_typesSumAggregateInputType = {
    court_decision_type_id?: true
    court_type?: true
  }

  export type Court_decision_typesMinAggregateInputType = {
    court_decision_type_id?: true
    court_type?: true
    court_decision?: true
  }

  export type Court_decision_typesMaxAggregateInputType = {
    court_decision_type_id?: true
    court_type?: true
    court_decision?: true
  }

  export type Court_decision_typesCountAggregateInputType = {
    court_decision_type_id?: true
    court_type?: true
    court_decision?: true
    _all?: true
  }

  export type Court_decision_typesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which court_decision_types to aggregate.
     */
    where?: court_decision_typesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of court_decision_types to fetch.
     */
    orderBy?: court_decision_typesOrderByWithRelationInput | court_decision_typesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: court_decision_typesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` court_decision_types from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` court_decision_types.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned court_decision_types
    **/
    _count?: true | Court_decision_typesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Court_decision_typesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Court_decision_typesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Court_decision_typesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Court_decision_typesMaxAggregateInputType
  }

  export type GetCourt_decision_typesAggregateType<T extends Court_decision_typesAggregateArgs> = {
        [P in keyof T & keyof AggregateCourt_decision_types]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCourt_decision_types[P]>
      : GetScalarType<T[P], AggregateCourt_decision_types[P]>
  }




  export type court_decision_typesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: court_decision_typesWhereInput
    orderBy?: court_decision_typesOrderByWithAggregationInput | court_decision_typesOrderByWithAggregationInput[]
    by: Court_decision_typesScalarFieldEnum[] | Court_decision_typesScalarFieldEnum
    having?: court_decision_typesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Court_decision_typesCountAggregateInputType | true
    _avg?: Court_decision_typesAvgAggregateInputType
    _sum?: Court_decision_typesSumAggregateInputType
    _min?: Court_decision_typesMinAggregateInputType
    _max?: Court_decision_typesMaxAggregateInputType
  }

  export type Court_decision_typesGroupByOutputType = {
    court_decision_type_id: number
    court_type: number
    court_decision: string
    _count: Court_decision_typesCountAggregateOutputType | null
    _avg: Court_decision_typesAvgAggregateOutputType | null
    _sum: Court_decision_typesSumAggregateOutputType | null
    _min: Court_decision_typesMinAggregateOutputType | null
    _max: Court_decision_typesMaxAggregateOutputType | null
  }

  type GetCourt_decision_typesGroupByPayload<T extends court_decision_typesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Court_decision_typesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Court_decision_typesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Court_decision_typesGroupByOutputType[P]>
            : GetScalarType<T[P], Court_decision_typesGroupByOutputType[P]>
        }
      >
    >


  export type court_decision_typesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    court_decision_type_id?: boolean
    court_type?: boolean
    court_decision?: boolean
  }, ExtArgs["result"]["court_decision_types"]>



  export type court_decision_typesSelectScalar = {
    court_decision_type_id?: boolean
    court_type?: boolean
    court_decision?: boolean
  }

  export type court_decision_typesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"court_decision_type_id" | "court_type" | "court_decision", ExtArgs["result"]["court_decision_types"]>

  export type $court_decision_typesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "court_decision_types"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      court_decision_type_id: number
      court_type: number
      court_decision: string
    }, ExtArgs["result"]["court_decision_types"]>
    composites: {}
  }

  type court_decision_typesGetPayload<S extends boolean | null | undefined | court_decision_typesDefaultArgs> = $Result.GetResult<Prisma.$court_decision_typesPayload, S>

  type court_decision_typesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<court_decision_typesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Court_decision_typesCountAggregateInputType | true
    }

  export interface court_decision_typesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['court_decision_types'], meta: { name: 'court_decision_types' } }
    /**
     * Find zero or one Court_decision_types that matches the filter.
     * @param {court_decision_typesFindUniqueArgs} args - Arguments to find a Court_decision_types
     * @example
     * // Get one Court_decision_types
     * const court_decision_types = await prisma.court_decision_types.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends court_decision_typesFindUniqueArgs>(args: SelectSubset<T, court_decision_typesFindUniqueArgs<ExtArgs>>): Prisma__court_decision_typesClient<$Result.GetResult<Prisma.$court_decision_typesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Court_decision_types that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {court_decision_typesFindUniqueOrThrowArgs} args - Arguments to find a Court_decision_types
     * @example
     * // Get one Court_decision_types
     * const court_decision_types = await prisma.court_decision_types.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends court_decision_typesFindUniqueOrThrowArgs>(args: SelectSubset<T, court_decision_typesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__court_decision_typesClient<$Result.GetResult<Prisma.$court_decision_typesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Court_decision_types that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {court_decision_typesFindFirstArgs} args - Arguments to find a Court_decision_types
     * @example
     * // Get one Court_decision_types
     * const court_decision_types = await prisma.court_decision_types.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends court_decision_typesFindFirstArgs>(args?: SelectSubset<T, court_decision_typesFindFirstArgs<ExtArgs>>): Prisma__court_decision_typesClient<$Result.GetResult<Prisma.$court_decision_typesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Court_decision_types that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {court_decision_typesFindFirstOrThrowArgs} args - Arguments to find a Court_decision_types
     * @example
     * // Get one Court_decision_types
     * const court_decision_types = await prisma.court_decision_types.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends court_decision_typesFindFirstOrThrowArgs>(args?: SelectSubset<T, court_decision_typesFindFirstOrThrowArgs<ExtArgs>>): Prisma__court_decision_typesClient<$Result.GetResult<Prisma.$court_decision_typesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Court_decision_types that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {court_decision_typesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Court_decision_types
     * const court_decision_types = await prisma.court_decision_types.findMany()
     * 
     * // Get first 10 Court_decision_types
     * const court_decision_types = await prisma.court_decision_types.findMany({ take: 10 })
     * 
     * // Only select the `court_decision_type_id`
     * const court_decision_typesWithCourt_decision_type_idOnly = await prisma.court_decision_types.findMany({ select: { court_decision_type_id: true } })
     * 
     */
    findMany<T extends court_decision_typesFindManyArgs>(args?: SelectSubset<T, court_decision_typesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$court_decision_typesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Court_decision_types.
     * @param {court_decision_typesCreateArgs} args - Arguments to create a Court_decision_types.
     * @example
     * // Create one Court_decision_types
     * const Court_decision_types = await prisma.court_decision_types.create({
     *   data: {
     *     // ... data to create a Court_decision_types
     *   }
     * })
     * 
     */
    create<T extends court_decision_typesCreateArgs>(args: SelectSubset<T, court_decision_typesCreateArgs<ExtArgs>>): Prisma__court_decision_typesClient<$Result.GetResult<Prisma.$court_decision_typesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Court_decision_types.
     * @param {court_decision_typesCreateManyArgs} args - Arguments to create many Court_decision_types.
     * @example
     * // Create many Court_decision_types
     * const court_decision_types = await prisma.court_decision_types.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends court_decision_typesCreateManyArgs>(args?: SelectSubset<T, court_decision_typesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Court_decision_types.
     * @param {court_decision_typesDeleteArgs} args - Arguments to delete one Court_decision_types.
     * @example
     * // Delete one Court_decision_types
     * const Court_decision_types = await prisma.court_decision_types.delete({
     *   where: {
     *     // ... filter to delete one Court_decision_types
     *   }
     * })
     * 
     */
    delete<T extends court_decision_typesDeleteArgs>(args: SelectSubset<T, court_decision_typesDeleteArgs<ExtArgs>>): Prisma__court_decision_typesClient<$Result.GetResult<Prisma.$court_decision_typesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Court_decision_types.
     * @param {court_decision_typesUpdateArgs} args - Arguments to update one Court_decision_types.
     * @example
     * // Update one Court_decision_types
     * const court_decision_types = await prisma.court_decision_types.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends court_decision_typesUpdateArgs>(args: SelectSubset<T, court_decision_typesUpdateArgs<ExtArgs>>): Prisma__court_decision_typesClient<$Result.GetResult<Prisma.$court_decision_typesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Court_decision_types.
     * @param {court_decision_typesDeleteManyArgs} args - Arguments to filter Court_decision_types to delete.
     * @example
     * // Delete a few Court_decision_types
     * const { count } = await prisma.court_decision_types.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends court_decision_typesDeleteManyArgs>(args?: SelectSubset<T, court_decision_typesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Court_decision_types.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {court_decision_typesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Court_decision_types
     * const court_decision_types = await prisma.court_decision_types.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends court_decision_typesUpdateManyArgs>(args: SelectSubset<T, court_decision_typesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Court_decision_types.
     * @param {court_decision_typesUpsertArgs} args - Arguments to update or create a Court_decision_types.
     * @example
     * // Update or create a Court_decision_types
     * const court_decision_types = await prisma.court_decision_types.upsert({
     *   create: {
     *     // ... data to create a Court_decision_types
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Court_decision_types we want to update
     *   }
     * })
     */
    upsert<T extends court_decision_typesUpsertArgs>(args: SelectSubset<T, court_decision_typesUpsertArgs<ExtArgs>>): Prisma__court_decision_typesClient<$Result.GetResult<Prisma.$court_decision_typesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Court_decision_types.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {court_decision_typesCountArgs} args - Arguments to filter Court_decision_types to count.
     * @example
     * // Count the number of Court_decision_types
     * const count = await prisma.court_decision_types.count({
     *   where: {
     *     // ... the filter for the Court_decision_types we want to count
     *   }
     * })
    **/
    count<T extends court_decision_typesCountArgs>(
      args?: Subset<T, court_decision_typesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Court_decision_typesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Court_decision_types.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Court_decision_typesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Court_decision_typesAggregateArgs>(args: Subset<T, Court_decision_typesAggregateArgs>): Prisma.PrismaPromise<GetCourt_decision_typesAggregateType<T>>

    /**
     * Group by Court_decision_types.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {court_decision_typesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends court_decision_typesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: court_decision_typesGroupByArgs['orderBy'] }
        : { orderBy?: court_decision_typesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, court_decision_typesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCourt_decision_typesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the court_decision_types model
   */
  readonly fields: court_decision_typesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for court_decision_types.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__court_decision_typesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the court_decision_types model
   */
  interface court_decision_typesFieldRefs {
    readonly court_decision_type_id: FieldRef<"court_decision_types", 'Int'>
    readonly court_type: FieldRef<"court_decision_types", 'Int'>
    readonly court_decision: FieldRef<"court_decision_types", 'String'>
  }
    

  // Custom InputTypes
  /**
   * court_decision_types findUnique
   */
  export type court_decision_typesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the court_decision_types
     */
    select?: court_decision_typesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the court_decision_types
     */
    omit?: court_decision_typesOmit<ExtArgs> | null
    /**
     * Filter, which court_decision_types to fetch.
     */
    where: court_decision_typesWhereUniqueInput
  }

  /**
   * court_decision_types findUniqueOrThrow
   */
  export type court_decision_typesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the court_decision_types
     */
    select?: court_decision_typesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the court_decision_types
     */
    omit?: court_decision_typesOmit<ExtArgs> | null
    /**
     * Filter, which court_decision_types to fetch.
     */
    where: court_decision_typesWhereUniqueInput
  }

  /**
   * court_decision_types findFirst
   */
  export type court_decision_typesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the court_decision_types
     */
    select?: court_decision_typesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the court_decision_types
     */
    omit?: court_decision_typesOmit<ExtArgs> | null
    /**
     * Filter, which court_decision_types to fetch.
     */
    where?: court_decision_typesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of court_decision_types to fetch.
     */
    orderBy?: court_decision_typesOrderByWithRelationInput | court_decision_typesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for court_decision_types.
     */
    cursor?: court_decision_typesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` court_decision_types from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` court_decision_types.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of court_decision_types.
     */
    distinct?: Court_decision_typesScalarFieldEnum | Court_decision_typesScalarFieldEnum[]
  }

  /**
   * court_decision_types findFirstOrThrow
   */
  export type court_decision_typesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the court_decision_types
     */
    select?: court_decision_typesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the court_decision_types
     */
    omit?: court_decision_typesOmit<ExtArgs> | null
    /**
     * Filter, which court_decision_types to fetch.
     */
    where?: court_decision_typesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of court_decision_types to fetch.
     */
    orderBy?: court_decision_typesOrderByWithRelationInput | court_decision_typesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for court_decision_types.
     */
    cursor?: court_decision_typesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` court_decision_types from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` court_decision_types.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of court_decision_types.
     */
    distinct?: Court_decision_typesScalarFieldEnum | Court_decision_typesScalarFieldEnum[]
  }

  /**
   * court_decision_types findMany
   */
  export type court_decision_typesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the court_decision_types
     */
    select?: court_decision_typesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the court_decision_types
     */
    omit?: court_decision_typesOmit<ExtArgs> | null
    /**
     * Filter, which court_decision_types to fetch.
     */
    where?: court_decision_typesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of court_decision_types to fetch.
     */
    orderBy?: court_decision_typesOrderByWithRelationInput | court_decision_typesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing court_decision_types.
     */
    cursor?: court_decision_typesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` court_decision_types from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` court_decision_types.
     */
    skip?: number
    distinct?: Court_decision_typesScalarFieldEnum | Court_decision_typesScalarFieldEnum[]
  }

  /**
   * court_decision_types create
   */
  export type court_decision_typesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the court_decision_types
     */
    select?: court_decision_typesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the court_decision_types
     */
    omit?: court_decision_typesOmit<ExtArgs> | null
    /**
     * The data needed to create a court_decision_types.
     */
    data: XOR<court_decision_typesCreateInput, court_decision_typesUncheckedCreateInput>
  }

  /**
   * court_decision_types createMany
   */
  export type court_decision_typesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many court_decision_types.
     */
    data: court_decision_typesCreateManyInput | court_decision_typesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * court_decision_types update
   */
  export type court_decision_typesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the court_decision_types
     */
    select?: court_decision_typesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the court_decision_types
     */
    omit?: court_decision_typesOmit<ExtArgs> | null
    /**
     * The data needed to update a court_decision_types.
     */
    data: XOR<court_decision_typesUpdateInput, court_decision_typesUncheckedUpdateInput>
    /**
     * Choose, which court_decision_types to update.
     */
    where: court_decision_typesWhereUniqueInput
  }

  /**
   * court_decision_types updateMany
   */
  export type court_decision_typesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update court_decision_types.
     */
    data: XOR<court_decision_typesUpdateManyMutationInput, court_decision_typesUncheckedUpdateManyInput>
    /**
     * Filter which court_decision_types to update
     */
    where?: court_decision_typesWhereInput
    /**
     * Limit how many court_decision_types to update.
     */
    limit?: number
  }

  /**
   * court_decision_types upsert
   */
  export type court_decision_typesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the court_decision_types
     */
    select?: court_decision_typesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the court_decision_types
     */
    omit?: court_decision_typesOmit<ExtArgs> | null
    /**
     * The filter to search for the court_decision_types to update in case it exists.
     */
    where: court_decision_typesWhereUniqueInput
    /**
     * In case the court_decision_types found by the `where` argument doesn't exist, create a new court_decision_types with this data.
     */
    create: XOR<court_decision_typesCreateInput, court_decision_typesUncheckedCreateInput>
    /**
     * In case the court_decision_types was found with the provided `where` argument, update it with this data.
     */
    update: XOR<court_decision_typesUpdateInput, court_decision_typesUncheckedUpdateInput>
  }

  /**
   * court_decision_types delete
   */
  export type court_decision_typesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the court_decision_types
     */
    select?: court_decision_typesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the court_decision_types
     */
    omit?: court_decision_typesOmit<ExtArgs> | null
    /**
     * Filter which court_decision_types to delete.
     */
    where: court_decision_typesWhereUniqueInput
  }

  /**
   * court_decision_types deleteMany
   */
  export type court_decision_typesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which court_decision_types to delete
     */
    where?: court_decision_typesWhereInput
    /**
     * Limit how many court_decision_types to delete.
     */
    limit?: number
  }

  /**
   * court_decision_types without action
   */
  export type court_decision_typesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the court_decision_types
     */
    select?: court_decision_typesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the court_decision_types
     */
    omit?: court_decision_typesOmit<ExtArgs> | null
  }


  /**
   * Model court_decisions
   */

  export type AggregateCourt_decisions = {
    _count: Court_decisionsCountAggregateOutputType | null
    _avg: Court_decisionsAvgAggregateOutputType | null
    _sum: Court_decisionsSumAggregateOutputType | null
    _min: Court_decisionsMinAggregateOutputType | null
    _max: Court_decisionsMaxAggregateOutputType | null
  }

  export type Court_decisionsAvgAggregateOutputType = {
    court_decision_id: number | null
    appeal_id: number | null
    decission_type: number | null
    input_by: number | null
    actual: number | null
  }

  export type Court_decisionsSumAggregateOutputType = {
    court_decision_id: number | null
    appeal_id: number | null
    decission_type: number | null
    input_by: number | null
    actual: number | null
  }

  export type Court_decisionsMinAggregateOutputType = {
    court_decision_id: number | null
    appeal_id: number | null
    decission_type: number | null
    decison_date: Date | null
    decision_notification_date: Date | null
    input_date: Date | null
    input_by: number | null
    actual: number | null
  }

  export type Court_decisionsMaxAggregateOutputType = {
    court_decision_id: number | null
    appeal_id: number | null
    decission_type: number | null
    decison_date: Date | null
    decision_notification_date: Date | null
    input_date: Date | null
    input_by: number | null
    actual: number | null
  }

  export type Court_decisionsCountAggregateOutputType = {
    court_decision_id: number
    appeal_id: number
    decission_type: number
    decison_date: number
    decision_notification_date: number
    input_date: number
    input_by: number
    actual: number
    _all: number
  }


  export type Court_decisionsAvgAggregateInputType = {
    court_decision_id?: true
    appeal_id?: true
    decission_type?: true
    input_by?: true
    actual?: true
  }

  export type Court_decisionsSumAggregateInputType = {
    court_decision_id?: true
    appeal_id?: true
    decission_type?: true
    input_by?: true
    actual?: true
  }

  export type Court_decisionsMinAggregateInputType = {
    court_decision_id?: true
    appeal_id?: true
    decission_type?: true
    decison_date?: true
    decision_notification_date?: true
    input_date?: true
    input_by?: true
    actual?: true
  }

  export type Court_decisionsMaxAggregateInputType = {
    court_decision_id?: true
    appeal_id?: true
    decission_type?: true
    decison_date?: true
    decision_notification_date?: true
    input_date?: true
    input_by?: true
    actual?: true
  }

  export type Court_decisionsCountAggregateInputType = {
    court_decision_id?: true
    appeal_id?: true
    decission_type?: true
    decison_date?: true
    decision_notification_date?: true
    input_date?: true
    input_by?: true
    actual?: true
    _all?: true
  }

  export type Court_decisionsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which court_decisions to aggregate.
     */
    where?: court_decisionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of court_decisions to fetch.
     */
    orderBy?: court_decisionsOrderByWithRelationInput | court_decisionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: court_decisionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` court_decisions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` court_decisions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned court_decisions
    **/
    _count?: true | Court_decisionsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Court_decisionsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Court_decisionsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Court_decisionsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Court_decisionsMaxAggregateInputType
  }

  export type GetCourt_decisionsAggregateType<T extends Court_decisionsAggregateArgs> = {
        [P in keyof T & keyof AggregateCourt_decisions]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCourt_decisions[P]>
      : GetScalarType<T[P], AggregateCourt_decisions[P]>
  }




  export type court_decisionsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: court_decisionsWhereInput
    orderBy?: court_decisionsOrderByWithAggregationInput | court_decisionsOrderByWithAggregationInput[]
    by: Court_decisionsScalarFieldEnum[] | Court_decisionsScalarFieldEnum
    having?: court_decisionsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Court_decisionsCountAggregateInputType | true
    _avg?: Court_decisionsAvgAggregateInputType
    _sum?: Court_decisionsSumAggregateInputType
    _min?: Court_decisionsMinAggregateInputType
    _max?: Court_decisionsMaxAggregateInputType
  }

  export type Court_decisionsGroupByOutputType = {
    court_decision_id: number
    appeal_id: number
    decission_type: number
    decison_date: Date
    decision_notification_date: Date
    input_date: Date
    input_by: number
    actual: number
    _count: Court_decisionsCountAggregateOutputType | null
    _avg: Court_decisionsAvgAggregateOutputType | null
    _sum: Court_decisionsSumAggregateOutputType | null
    _min: Court_decisionsMinAggregateOutputType | null
    _max: Court_decisionsMaxAggregateOutputType | null
  }

  type GetCourt_decisionsGroupByPayload<T extends court_decisionsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Court_decisionsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Court_decisionsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Court_decisionsGroupByOutputType[P]>
            : GetScalarType<T[P], Court_decisionsGroupByOutputType[P]>
        }
      >
    >


  export type court_decisionsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    court_decision_id?: boolean
    appeal_id?: boolean
    decission_type?: boolean
    decison_date?: boolean
    decision_notification_date?: boolean
    input_date?: boolean
    input_by?: boolean
    actual?: boolean
  }, ExtArgs["result"]["court_decisions"]>



  export type court_decisionsSelectScalar = {
    court_decision_id?: boolean
    appeal_id?: boolean
    decission_type?: boolean
    decison_date?: boolean
    decision_notification_date?: boolean
    input_date?: boolean
    input_by?: boolean
    actual?: boolean
  }

  export type court_decisionsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"court_decision_id" | "appeal_id" | "decission_type" | "decison_date" | "decision_notification_date" | "input_date" | "input_by" | "actual", ExtArgs["result"]["court_decisions"]>

  export type $court_decisionsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "court_decisions"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      court_decision_id: number
      appeal_id: number
      decission_type: number
      decison_date: Date
      decision_notification_date: Date
      input_date: Date
      input_by: number
      actual: number
    }, ExtArgs["result"]["court_decisions"]>
    composites: {}
  }

  type court_decisionsGetPayload<S extends boolean | null | undefined | court_decisionsDefaultArgs> = $Result.GetResult<Prisma.$court_decisionsPayload, S>

  type court_decisionsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<court_decisionsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Court_decisionsCountAggregateInputType | true
    }

  export interface court_decisionsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['court_decisions'], meta: { name: 'court_decisions' } }
    /**
     * Find zero or one Court_decisions that matches the filter.
     * @param {court_decisionsFindUniqueArgs} args - Arguments to find a Court_decisions
     * @example
     * // Get one Court_decisions
     * const court_decisions = await prisma.court_decisions.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends court_decisionsFindUniqueArgs>(args: SelectSubset<T, court_decisionsFindUniqueArgs<ExtArgs>>): Prisma__court_decisionsClient<$Result.GetResult<Prisma.$court_decisionsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Court_decisions that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {court_decisionsFindUniqueOrThrowArgs} args - Arguments to find a Court_decisions
     * @example
     * // Get one Court_decisions
     * const court_decisions = await prisma.court_decisions.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends court_decisionsFindUniqueOrThrowArgs>(args: SelectSubset<T, court_decisionsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__court_decisionsClient<$Result.GetResult<Prisma.$court_decisionsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Court_decisions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {court_decisionsFindFirstArgs} args - Arguments to find a Court_decisions
     * @example
     * // Get one Court_decisions
     * const court_decisions = await prisma.court_decisions.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends court_decisionsFindFirstArgs>(args?: SelectSubset<T, court_decisionsFindFirstArgs<ExtArgs>>): Prisma__court_decisionsClient<$Result.GetResult<Prisma.$court_decisionsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Court_decisions that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {court_decisionsFindFirstOrThrowArgs} args - Arguments to find a Court_decisions
     * @example
     * // Get one Court_decisions
     * const court_decisions = await prisma.court_decisions.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends court_decisionsFindFirstOrThrowArgs>(args?: SelectSubset<T, court_decisionsFindFirstOrThrowArgs<ExtArgs>>): Prisma__court_decisionsClient<$Result.GetResult<Prisma.$court_decisionsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Court_decisions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {court_decisionsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Court_decisions
     * const court_decisions = await prisma.court_decisions.findMany()
     * 
     * // Get first 10 Court_decisions
     * const court_decisions = await prisma.court_decisions.findMany({ take: 10 })
     * 
     * // Only select the `court_decision_id`
     * const court_decisionsWithCourt_decision_idOnly = await prisma.court_decisions.findMany({ select: { court_decision_id: true } })
     * 
     */
    findMany<T extends court_decisionsFindManyArgs>(args?: SelectSubset<T, court_decisionsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$court_decisionsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Court_decisions.
     * @param {court_decisionsCreateArgs} args - Arguments to create a Court_decisions.
     * @example
     * // Create one Court_decisions
     * const Court_decisions = await prisma.court_decisions.create({
     *   data: {
     *     // ... data to create a Court_decisions
     *   }
     * })
     * 
     */
    create<T extends court_decisionsCreateArgs>(args: SelectSubset<T, court_decisionsCreateArgs<ExtArgs>>): Prisma__court_decisionsClient<$Result.GetResult<Prisma.$court_decisionsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Court_decisions.
     * @param {court_decisionsCreateManyArgs} args - Arguments to create many Court_decisions.
     * @example
     * // Create many Court_decisions
     * const court_decisions = await prisma.court_decisions.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends court_decisionsCreateManyArgs>(args?: SelectSubset<T, court_decisionsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Court_decisions.
     * @param {court_decisionsDeleteArgs} args - Arguments to delete one Court_decisions.
     * @example
     * // Delete one Court_decisions
     * const Court_decisions = await prisma.court_decisions.delete({
     *   where: {
     *     // ... filter to delete one Court_decisions
     *   }
     * })
     * 
     */
    delete<T extends court_decisionsDeleteArgs>(args: SelectSubset<T, court_decisionsDeleteArgs<ExtArgs>>): Prisma__court_decisionsClient<$Result.GetResult<Prisma.$court_decisionsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Court_decisions.
     * @param {court_decisionsUpdateArgs} args - Arguments to update one Court_decisions.
     * @example
     * // Update one Court_decisions
     * const court_decisions = await prisma.court_decisions.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends court_decisionsUpdateArgs>(args: SelectSubset<T, court_decisionsUpdateArgs<ExtArgs>>): Prisma__court_decisionsClient<$Result.GetResult<Prisma.$court_decisionsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Court_decisions.
     * @param {court_decisionsDeleteManyArgs} args - Arguments to filter Court_decisions to delete.
     * @example
     * // Delete a few Court_decisions
     * const { count } = await prisma.court_decisions.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends court_decisionsDeleteManyArgs>(args?: SelectSubset<T, court_decisionsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Court_decisions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {court_decisionsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Court_decisions
     * const court_decisions = await prisma.court_decisions.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends court_decisionsUpdateManyArgs>(args: SelectSubset<T, court_decisionsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Court_decisions.
     * @param {court_decisionsUpsertArgs} args - Arguments to update or create a Court_decisions.
     * @example
     * // Update or create a Court_decisions
     * const court_decisions = await prisma.court_decisions.upsert({
     *   create: {
     *     // ... data to create a Court_decisions
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Court_decisions we want to update
     *   }
     * })
     */
    upsert<T extends court_decisionsUpsertArgs>(args: SelectSubset<T, court_decisionsUpsertArgs<ExtArgs>>): Prisma__court_decisionsClient<$Result.GetResult<Prisma.$court_decisionsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Court_decisions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {court_decisionsCountArgs} args - Arguments to filter Court_decisions to count.
     * @example
     * // Count the number of Court_decisions
     * const count = await prisma.court_decisions.count({
     *   where: {
     *     // ... the filter for the Court_decisions we want to count
     *   }
     * })
    **/
    count<T extends court_decisionsCountArgs>(
      args?: Subset<T, court_decisionsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Court_decisionsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Court_decisions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Court_decisionsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Court_decisionsAggregateArgs>(args: Subset<T, Court_decisionsAggregateArgs>): Prisma.PrismaPromise<GetCourt_decisionsAggregateType<T>>

    /**
     * Group by Court_decisions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {court_decisionsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends court_decisionsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: court_decisionsGroupByArgs['orderBy'] }
        : { orderBy?: court_decisionsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, court_decisionsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCourt_decisionsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the court_decisions model
   */
  readonly fields: court_decisionsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for court_decisions.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__court_decisionsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the court_decisions model
   */
  interface court_decisionsFieldRefs {
    readonly court_decision_id: FieldRef<"court_decisions", 'Int'>
    readonly appeal_id: FieldRef<"court_decisions", 'Int'>
    readonly decission_type: FieldRef<"court_decisions", 'Int'>
    readonly decison_date: FieldRef<"court_decisions", 'DateTime'>
    readonly decision_notification_date: FieldRef<"court_decisions", 'DateTime'>
    readonly input_date: FieldRef<"court_decisions", 'DateTime'>
    readonly input_by: FieldRef<"court_decisions", 'Int'>
    readonly actual: FieldRef<"court_decisions", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * court_decisions findUnique
   */
  export type court_decisionsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the court_decisions
     */
    select?: court_decisionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the court_decisions
     */
    omit?: court_decisionsOmit<ExtArgs> | null
    /**
     * Filter, which court_decisions to fetch.
     */
    where: court_decisionsWhereUniqueInput
  }

  /**
   * court_decisions findUniqueOrThrow
   */
  export type court_decisionsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the court_decisions
     */
    select?: court_decisionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the court_decisions
     */
    omit?: court_decisionsOmit<ExtArgs> | null
    /**
     * Filter, which court_decisions to fetch.
     */
    where: court_decisionsWhereUniqueInput
  }

  /**
   * court_decisions findFirst
   */
  export type court_decisionsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the court_decisions
     */
    select?: court_decisionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the court_decisions
     */
    omit?: court_decisionsOmit<ExtArgs> | null
    /**
     * Filter, which court_decisions to fetch.
     */
    where?: court_decisionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of court_decisions to fetch.
     */
    orderBy?: court_decisionsOrderByWithRelationInput | court_decisionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for court_decisions.
     */
    cursor?: court_decisionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` court_decisions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` court_decisions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of court_decisions.
     */
    distinct?: Court_decisionsScalarFieldEnum | Court_decisionsScalarFieldEnum[]
  }

  /**
   * court_decisions findFirstOrThrow
   */
  export type court_decisionsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the court_decisions
     */
    select?: court_decisionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the court_decisions
     */
    omit?: court_decisionsOmit<ExtArgs> | null
    /**
     * Filter, which court_decisions to fetch.
     */
    where?: court_decisionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of court_decisions to fetch.
     */
    orderBy?: court_decisionsOrderByWithRelationInput | court_decisionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for court_decisions.
     */
    cursor?: court_decisionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` court_decisions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` court_decisions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of court_decisions.
     */
    distinct?: Court_decisionsScalarFieldEnum | Court_decisionsScalarFieldEnum[]
  }

  /**
   * court_decisions findMany
   */
  export type court_decisionsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the court_decisions
     */
    select?: court_decisionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the court_decisions
     */
    omit?: court_decisionsOmit<ExtArgs> | null
    /**
     * Filter, which court_decisions to fetch.
     */
    where?: court_decisionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of court_decisions to fetch.
     */
    orderBy?: court_decisionsOrderByWithRelationInput | court_decisionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing court_decisions.
     */
    cursor?: court_decisionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` court_decisions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` court_decisions.
     */
    skip?: number
    distinct?: Court_decisionsScalarFieldEnum | Court_decisionsScalarFieldEnum[]
  }

  /**
   * court_decisions create
   */
  export type court_decisionsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the court_decisions
     */
    select?: court_decisionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the court_decisions
     */
    omit?: court_decisionsOmit<ExtArgs> | null
    /**
     * The data needed to create a court_decisions.
     */
    data: XOR<court_decisionsCreateInput, court_decisionsUncheckedCreateInput>
  }

  /**
   * court_decisions createMany
   */
  export type court_decisionsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many court_decisions.
     */
    data: court_decisionsCreateManyInput | court_decisionsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * court_decisions update
   */
  export type court_decisionsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the court_decisions
     */
    select?: court_decisionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the court_decisions
     */
    omit?: court_decisionsOmit<ExtArgs> | null
    /**
     * The data needed to update a court_decisions.
     */
    data: XOR<court_decisionsUpdateInput, court_decisionsUncheckedUpdateInput>
    /**
     * Choose, which court_decisions to update.
     */
    where: court_decisionsWhereUniqueInput
  }

  /**
   * court_decisions updateMany
   */
  export type court_decisionsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update court_decisions.
     */
    data: XOR<court_decisionsUpdateManyMutationInput, court_decisionsUncheckedUpdateManyInput>
    /**
     * Filter which court_decisions to update
     */
    where?: court_decisionsWhereInput
    /**
     * Limit how many court_decisions to update.
     */
    limit?: number
  }

  /**
   * court_decisions upsert
   */
  export type court_decisionsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the court_decisions
     */
    select?: court_decisionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the court_decisions
     */
    omit?: court_decisionsOmit<ExtArgs> | null
    /**
     * The filter to search for the court_decisions to update in case it exists.
     */
    where: court_decisionsWhereUniqueInput
    /**
     * In case the court_decisions found by the `where` argument doesn't exist, create a new court_decisions with this data.
     */
    create: XOR<court_decisionsCreateInput, court_decisionsUncheckedCreateInput>
    /**
     * In case the court_decisions was found with the provided `where` argument, update it with this data.
     */
    update: XOR<court_decisionsUpdateInput, court_decisionsUncheckedUpdateInput>
  }

  /**
   * court_decisions delete
   */
  export type court_decisionsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the court_decisions
     */
    select?: court_decisionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the court_decisions
     */
    omit?: court_decisionsOmit<ExtArgs> | null
    /**
     * Filter which court_decisions to delete.
     */
    where: court_decisionsWhereUniqueInput
  }

  /**
   * court_decisions deleteMany
   */
  export type court_decisionsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which court_decisions to delete
     */
    where?: court_decisionsWhereInput
    /**
     * Limit how many court_decisions to delete.
     */
    limit?: number
  }

  /**
   * court_decisions without action
   */
  export type court_decisionsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the court_decisions
     */
    select?: court_decisionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the court_decisions
     */
    omit?: court_decisionsOmit<ExtArgs> | null
  }


  /**
   * Model court_levels
   */

  export type AggregateCourt_levels = {
    _count: Court_levelsCountAggregateOutputType | null
    _avg: Court_levelsAvgAggregateOutputType | null
    _sum: Court_levelsSumAggregateOutputType | null
    _min: Court_levelsMinAggregateOutputType | null
    _max: Court_levelsMaxAggregateOutputType | null
  }

  export type Court_levelsAvgAggregateOutputType = {
    court_id: number | null
  }

  export type Court_levelsSumAggregateOutputType = {
    court_id: number | null
  }

  export type Court_levelsMinAggregateOutputType = {
    court_id: number | null
    court_title: string | null
  }

  export type Court_levelsMaxAggregateOutputType = {
    court_id: number | null
    court_title: string | null
  }

  export type Court_levelsCountAggregateOutputType = {
    court_id: number
    court_title: number
    _all: number
  }


  export type Court_levelsAvgAggregateInputType = {
    court_id?: true
  }

  export type Court_levelsSumAggregateInputType = {
    court_id?: true
  }

  export type Court_levelsMinAggregateInputType = {
    court_id?: true
    court_title?: true
  }

  export type Court_levelsMaxAggregateInputType = {
    court_id?: true
    court_title?: true
  }

  export type Court_levelsCountAggregateInputType = {
    court_id?: true
    court_title?: true
    _all?: true
  }

  export type Court_levelsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which court_levels to aggregate.
     */
    where?: court_levelsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of court_levels to fetch.
     */
    orderBy?: court_levelsOrderByWithRelationInput | court_levelsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: court_levelsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` court_levels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` court_levels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned court_levels
    **/
    _count?: true | Court_levelsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Court_levelsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Court_levelsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Court_levelsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Court_levelsMaxAggregateInputType
  }

  export type GetCourt_levelsAggregateType<T extends Court_levelsAggregateArgs> = {
        [P in keyof T & keyof AggregateCourt_levels]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCourt_levels[P]>
      : GetScalarType<T[P], AggregateCourt_levels[P]>
  }




  export type court_levelsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: court_levelsWhereInput
    orderBy?: court_levelsOrderByWithAggregationInput | court_levelsOrderByWithAggregationInput[]
    by: Court_levelsScalarFieldEnum[] | Court_levelsScalarFieldEnum
    having?: court_levelsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Court_levelsCountAggregateInputType | true
    _avg?: Court_levelsAvgAggregateInputType
    _sum?: Court_levelsSumAggregateInputType
    _min?: Court_levelsMinAggregateInputType
    _max?: Court_levelsMaxAggregateInputType
  }

  export type Court_levelsGroupByOutputType = {
    court_id: number
    court_title: string
    _count: Court_levelsCountAggregateOutputType | null
    _avg: Court_levelsAvgAggregateOutputType | null
    _sum: Court_levelsSumAggregateOutputType | null
    _min: Court_levelsMinAggregateOutputType | null
    _max: Court_levelsMaxAggregateOutputType | null
  }

  type GetCourt_levelsGroupByPayload<T extends court_levelsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Court_levelsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Court_levelsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Court_levelsGroupByOutputType[P]>
            : GetScalarType<T[P], Court_levelsGroupByOutputType[P]>
        }
      >
    >


  export type court_levelsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    court_id?: boolean
    court_title?: boolean
  }, ExtArgs["result"]["court_levels"]>



  export type court_levelsSelectScalar = {
    court_id?: boolean
    court_title?: boolean
  }

  export type court_levelsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"court_id" | "court_title", ExtArgs["result"]["court_levels"]>

  export type $court_levelsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "court_levels"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      court_id: number
      court_title: string
    }, ExtArgs["result"]["court_levels"]>
    composites: {}
  }

  type court_levelsGetPayload<S extends boolean | null | undefined | court_levelsDefaultArgs> = $Result.GetResult<Prisma.$court_levelsPayload, S>

  type court_levelsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<court_levelsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Court_levelsCountAggregateInputType | true
    }

  export interface court_levelsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['court_levels'], meta: { name: 'court_levels' } }
    /**
     * Find zero or one Court_levels that matches the filter.
     * @param {court_levelsFindUniqueArgs} args - Arguments to find a Court_levels
     * @example
     * // Get one Court_levels
     * const court_levels = await prisma.court_levels.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends court_levelsFindUniqueArgs>(args: SelectSubset<T, court_levelsFindUniqueArgs<ExtArgs>>): Prisma__court_levelsClient<$Result.GetResult<Prisma.$court_levelsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Court_levels that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {court_levelsFindUniqueOrThrowArgs} args - Arguments to find a Court_levels
     * @example
     * // Get one Court_levels
     * const court_levels = await prisma.court_levels.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends court_levelsFindUniqueOrThrowArgs>(args: SelectSubset<T, court_levelsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__court_levelsClient<$Result.GetResult<Prisma.$court_levelsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Court_levels that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {court_levelsFindFirstArgs} args - Arguments to find a Court_levels
     * @example
     * // Get one Court_levels
     * const court_levels = await prisma.court_levels.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends court_levelsFindFirstArgs>(args?: SelectSubset<T, court_levelsFindFirstArgs<ExtArgs>>): Prisma__court_levelsClient<$Result.GetResult<Prisma.$court_levelsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Court_levels that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {court_levelsFindFirstOrThrowArgs} args - Arguments to find a Court_levels
     * @example
     * // Get one Court_levels
     * const court_levels = await prisma.court_levels.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends court_levelsFindFirstOrThrowArgs>(args?: SelectSubset<T, court_levelsFindFirstOrThrowArgs<ExtArgs>>): Prisma__court_levelsClient<$Result.GetResult<Prisma.$court_levelsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Court_levels that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {court_levelsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Court_levels
     * const court_levels = await prisma.court_levels.findMany()
     * 
     * // Get first 10 Court_levels
     * const court_levels = await prisma.court_levels.findMany({ take: 10 })
     * 
     * // Only select the `court_id`
     * const court_levelsWithCourt_idOnly = await prisma.court_levels.findMany({ select: { court_id: true } })
     * 
     */
    findMany<T extends court_levelsFindManyArgs>(args?: SelectSubset<T, court_levelsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$court_levelsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Court_levels.
     * @param {court_levelsCreateArgs} args - Arguments to create a Court_levels.
     * @example
     * // Create one Court_levels
     * const Court_levels = await prisma.court_levels.create({
     *   data: {
     *     // ... data to create a Court_levels
     *   }
     * })
     * 
     */
    create<T extends court_levelsCreateArgs>(args: SelectSubset<T, court_levelsCreateArgs<ExtArgs>>): Prisma__court_levelsClient<$Result.GetResult<Prisma.$court_levelsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Court_levels.
     * @param {court_levelsCreateManyArgs} args - Arguments to create many Court_levels.
     * @example
     * // Create many Court_levels
     * const court_levels = await prisma.court_levels.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends court_levelsCreateManyArgs>(args?: SelectSubset<T, court_levelsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Court_levels.
     * @param {court_levelsDeleteArgs} args - Arguments to delete one Court_levels.
     * @example
     * // Delete one Court_levels
     * const Court_levels = await prisma.court_levels.delete({
     *   where: {
     *     // ... filter to delete one Court_levels
     *   }
     * })
     * 
     */
    delete<T extends court_levelsDeleteArgs>(args: SelectSubset<T, court_levelsDeleteArgs<ExtArgs>>): Prisma__court_levelsClient<$Result.GetResult<Prisma.$court_levelsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Court_levels.
     * @param {court_levelsUpdateArgs} args - Arguments to update one Court_levels.
     * @example
     * // Update one Court_levels
     * const court_levels = await prisma.court_levels.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends court_levelsUpdateArgs>(args: SelectSubset<T, court_levelsUpdateArgs<ExtArgs>>): Prisma__court_levelsClient<$Result.GetResult<Prisma.$court_levelsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Court_levels.
     * @param {court_levelsDeleteManyArgs} args - Arguments to filter Court_levels to delete.
     * @example
     * // Delete a few Court_levels
     * const { count } = await prisma.court_levels.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends court_levelsDeleteManyArgs>(args?: SelectSubset<T, court_levelsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Court_levels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {court_levelsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Court_levels
     * const court_levels = await prisma.court_levels.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends court_levelsUpdateManyArgs>(args: SelectSubset<T, court_levelsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Court_levels.
     * @param {court_levelsUpsertArgs} args - Arguments to update or create a Court_levels.
     * @example
     * // Update or create a Court_levels
     * const court_levels = await prisma.court_levels.upsert({
     *   create: {
     *     // ... data to create a Court_levels
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Court_levels we want to update
     *   }
     * })
     */
    upsert<T extends court_levelsUpsertArgs>(args: SelectSubset<T, court_levelsUpsertArgs<ExtArgs>>): Prisma__court_levelsClient<$Result.GetResult<Prisma.$court_levelsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Court_levels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {court_levelsCountArgs} args - Arguments to filter Court_levels to count.
     * @example
     * // Count the number of Court_levels
     * const count = await prisma.court_levels.count({
     *   where: {
     *     // ... the filter for the Court_levels we want to count
     *   }
     * })
    **/
    count<T extends court_levelsCountArgs>(
      args?: Subset<T, court_levelsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Court_levelsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Court_levels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Court_levelsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Court_levelsAggregateArgs>(args: Subset<T, Court_levelsAggregateArgs>): Prisma.PrismaPromise<GetCourt_levelsAggregateType<T>>

    /**
     * Group by Court_levels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {court_levelsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends court_levelsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: court_levelsGroupByArgs['orderBy'] }
        : { orderBy?: court_levelsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, court_levelsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCourt_levelsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the court_levels model
   */
  readonly fields: court_levelsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for court_levels.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__court_levelsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the court_levels model
   */
  interface court_levelsFieldRefs {
    readonly court_id: FieldRef<"court_levels", 'Int'>
    readonly court_title: FieldRef<"court_levels", 'String'>
  }
    

  // Custom InputTypes
  /**
   * court_levels findUnique
   */
  export type court_levelsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the court_levels
     */
    select?: court_levelsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the court_levels
     */
    omit?: court_levelsOmit<ExtArgs> | null
    /**
     * Filter, which court_levels to fetch.
     */
    where: court_levelsWhereUniqueInput
  }

  /**
   * court_levels findUniqueOrThrow
   */
  export type court_levelsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the court_levels
     */
    select?: court_levelsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the court_levels
     */
    omit?: court_levelsOmit<ExtArgs> | null
    /**
     * Filter, which court_levels to fetch.
     */
    where: court_levelsWhereUniqueInput
  }

  /**
   * court_levels findFirst
   */
  export type court_levelsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the court_levels
     */
    select?: court_levelsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the court_levels
     */
    omit?: court_levelsOmit<ExtArgs> | null
    /**
     * Filter, which court_levels to fetch.
     */
    where?: court_levelsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of court_levels to fetch.
     */
    orderBy?: court_levelsOrderByWithRelationInput | court_levelsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for court_levels.
     */
    cursor?: court_levelsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` court_levels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` court_levels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of court_levels.
     */
    distinct?: Court_levelsScalarFieldEnum | Court_levelsScalarFieldEnum[]
  }

  /**
   * court_levels findFirstOrThrow
   */
  export type court_levelsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the court_levels
     */
    select?: court_levelsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the court_levels
     */
    omit?: court_levelsOmit<ExtArgs> | null
    /**
     * Filter, which court_levels to fetch.
     */
    where?: court_levelsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of court_levels to fetch.
     */
    orderBy?: court_levelsOrderByWithRelationInput | court_levelsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for court_levels.
     */
    cursor?: court_levelsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` court_levels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` court_levels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of court_levels.
     */
    distinct?: Court_levelsScalarFieldEnum | Court_levelsScalarFieldEnum[]
  }

  /**
   * court_levels findMany
   */
  export type court_levelsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the court_levels
     */
    select?: court_levelsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the court_levels
     */
    omit?: court_levelsOmit<ExtArgs> | null
    /**
     * Filter, which court_levels to fetch.
     */
    where?: court_levelsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of court_levels to fetch.
     */
    orderBy?: court_levelsOrderByWithRelationInput | court_levelsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing court_levels.
     */
    cursor?: court_levelsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` court_levels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` court_levels.
     */
    skip?: number
    distinct?: Court_levelsScalarFieldEnum | Court_levelsScalarFieldEnum[]
  }

  /**
   * court_levels create
   */
  export type court_levelsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the court_levels
     */
    select?: court_levelsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the court_levels
     */
    omit?: court_levelsOmit<ExtArgs> | null
    /**
     * The data needed to create a court_levels.
     */
    data: XOR<court_levelsCreateInput, court_levelsUncheckedCreateInput>
  }

  /**
   * court_levels createMany
   */
  export type court_levelsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many court_levels.
     */
    data: court_levelsCreateManyInput | court_levelsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * court_levels update
   */
  export type court_levelsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the court_levels
     */
    select?: court_levelsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the court_levels
     */
    omit?: court_levelsOmit<ExtArgs> | null
    /**
     * The data needed to update a court_levels.
     */
    data: XOR<court_levelsUpdateInput, court_levelsUncheckedUpdateInput>
    /**
     * Choose, which court_levels to update.
     */
    where: court_levelsWhereUniqueInput
  }

  /**
   * court_levels updateMany
   */
  export type court_levelsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update court_levels.
     */
    data: XOR<court_levelsUpdateManyMutationInput, court_levelsUncheckedUpdateManyInput>
    /**
     * Filter which court_levels to update
     */
    where?: court_levelsWhereInput
    /**
     * Limit how many court_levels to update.
     */
    limit?: number
  }

  /**
   * court_levels upsert
   */
  export type court_levelsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the court_levels
     */
    select?: court_levelsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the court_levels
     */
    omit?: court_levelsOmit<ExtArgs> | null
    /**
     * The filter to search for the court_levels to update in case it exists.
     */
    where: court_levelsWhereUniqueInput
    /**
     * In case the court_levels found by the `where` argument doesn't exist, create a new court_levels with this data.
     */
    create: XOR<court_levelsCreateInput, court_levelsUncheckedCreateInput>
    /**
     * In case the court_levels was found with the provided `where` argument, update it with this data.
     */
    update: XOR<court_levelsUpdateInput, court_levelsUncheckedUpdateInput>
  }

  /**
   * court_levels delete
   */
  export type court_levelsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the court_levels
     */
    select?: court_levelsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the court_levels
     */
    omit?: court_levelsOmit<ExtArgs> | null
    /**
     * Filter which court_levels to delete.
     */
    where: court_levelsWhereUniqueInput
  }

  /**
   * court_levels deleteMany
   */
  export type court_levelsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which court_levels to delete
     */
    where?: court_levelsWhereInput
    /**
     * Limit how many court_levels to delete.
     */
    limit?: number
  }

  /**
   * court_levels without action
   */
  export type court_levelsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the court_levels
     */
    select?: court_levelsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the court_levels
     */
    omit?: court_levelsOmit<ExtArgs> | null
  }


  /**
   * Model cover_sign_status
   */

  export type AggregateCover_sign_status = {
    _count: Cover_sign_statusCountAggregateOutputType | null
    _avg: Cover_sign_statusAvgAggregateOutputType | null
    _sum: Cover_sign_statusSumAggregateOutputType | null
    _min: Cover_sign_statusMinAggregateOutputType | null
    _max: Cover_sign_statusMaxAggregateOutputType | null
  }

  export type Cover_sign_statusAvgAggregateOutputType = {
    sign_status_id: number | null
  }

  export type Cover_sign_statusSumAggregateOutputType = {
    sign_status_id: number | null
  }

  export type Cover_sign_statusMinAggregateOutputType = {
    sign_status_id: number | null
    sign_status_name: string | null
  }

  export type Cover_sign_statusMaxAggregateOutputType = {
    sign_status_id: number | null
    sign_status_name: string | null
  }

  export type Cover_sign_statusCountAggregateOutputType = {
    sign_status_id: number
    sign_status_name: number
    _all: number
  }


  export type Cover_sign_statusAvgAggregateInputType = {
    sign_status_id?: true
  }

  export type Cover_sign_statusSumAggregateInputType = {
    sign_status_id?: true
  }

  export type Cover_sign_statusMinAggregateInputType = {
    sign_status_id?: true
    sign_status_name?: true
  }

  export type Cover_sign_statusMaxAggregateInputType = {
    sign_status_id?: true
    sign_status_name?: true
  }

  export type Cover_sign_statusCountAggregateInputType = {
    sign_status_id?: true
    sign_status_name?: true
    _all?: true
  }

  export type Cover_sign_statusAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which cover_sign_status to aggregate.
     */
    where?: cover_sign_statusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of cover_sign_statuses to fetch.
     */
    orderBy?: cover_sign_statusOrderByWithRelationInput | cover_sign_statusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: cover_sign_statusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` cover_sign_statuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` cover_sign_statuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned cover_sign_statuses
    **/
    _count?: true | Cover_sign_statusCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Cover_sign_statusAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Cover_sign_statusSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Cover_sign_statusMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Cover_sign_statusMaxAggregateInputType
  }

  export type GetCover_sign_statusAggregateType<T extends Cover_sign_statusAggregateArgs> = {
        [P in keyof T & keyof AggregateCover_sign_status]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCover_sign_status[P]>
      : GetScalarType<T[P], AggregateCover_sign_status[P]>
  }




  export type cover_sign_statusGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: cover_sign_statusWhereInput
    orderBy?: cover_sign_statusOrderByWithAggregationInput | cover_sign_statusOrderByWithAggregationInput[]
    by: Cover_sign_statusScalarFieldEnum[] | Cover_sign_statusScalarFieldEnum
    having?: cover_sign_statusScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Cover_sign_statusCountAggregateInputType | true
    _avg?: Cover_sign_statusAvgAggregateInputType
    _sum?: Cover_sign_statusSumAggregateInputType
    _min?: Cover_sign_statusMinAggregateInputType
    _max?: Cover_sign_statusMaxAggregateInputType
  }

  export type Cover_sign_statusGroupByOutputType = {
    sign_status_id: number
    sign_status_name: string
    _count: Cover_sign_statusCountAggregateOutputType | null
    _avg: Cover_sign_statusAvgAggregateOutputType | null
    _sum: Cover_sign_statusSumAggregateOutputType | null
    _min: Cover_sign_statusMinAggregateOutputType | null
    _max: Cover_sign_statusMaxAggregateOutputType | null
  }

  type GetCover_sign_statusGroupByPayload<T extends cover_sign_statusGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Cover_sign_statusGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Cover_sign_statusGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Cover_sign_statusGroupByOutputType[P]>
            : GetScalarType<T[P], Cover_sign_statusGroupByOutputType[P]>
        }
      >
    >


  export type cover_sign_statusSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    sign_status_id?: boolean
    sign_status_name?: boolean
  }, ExtArgs["result"]["cover_sign_status"]>



  export type cover_sign_statusSelectScalar = {
    sign_status_id?: boolean
    sign_status_name?: boolean
  }

  export type cover_sign_statusOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"sign_status_id" | "sign_status_name", ExtArgs["result"]["cover_sign_status"]>

  export type $cover_sign_statusPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "cover_sign_status"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      sign_status_id: number
      sign_status_name: string
    }, ExtArgs["result"]["cover_sign_status"]>
    composites: {}
  }

  type cover_sign_statusGetPayload<S extends boolean | null | undefined | cover_sign_statusDefaultArgs> = $Result.GetResult<Prisma.$cover_sign_statusPayload, S>

  type cover_sign_statusCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<cover_sign_statusFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Cover_sign_statusCountAggregateInputType | true
    }

  export interface cover_sign_statusDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['cover_sign_status'], meta: { name: 'cover_sign_status' } }
    /**
     * Find zero or one Cover_sign_status that matches the filter.
     * @param {cover_sign_statusFindUniqueArgs} args - Arguments to find a Cover_sign_status
     * @example
     * // Get one Cover_sign_status
     * const cover_sign_status = await prisma.cover_sign_status.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends cover_sign_statusFindUniqueArgs>(args: SelectSubset<T, cover_sign_statusFindUniqueArgs<ExtArgs>>): Prisma__cover_sign_statusClient<$Result.GetResult<Prisma.$cover_sign_statusPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Cover_sign_status that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {cover_sign_statusFindUniqueOrThrowArgs} args - Arguments to find a Cover_sign_status
     * @example
     * // Get one Cover_sign_status
     * const cover_sign_status = await prisma.cover_sign_status.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends cover_sign_statusFindUniqueOrThrowArgs>(args: SelectSubset<T, cover_sign_statusFindUniqueOrThrowArgs<ExtArgs>>): Prisma__cover_sign_statusClient<$Result.GetResult<Prisma.$cover_sign_statusPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Cover_sign_status that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cover_sign_statusFindFirstArgs} args - Arguments to find a Cover_sign_status
     * @example
     * // Get one Cover_sign_status
     * const cover_sign_status = await prisma.cover_sign_status.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends cover_sign_statusFindFirstArgs>(args?: SelectSubset<T, cover_sign_statusFindFirstArgs<ExtArgs>>): Prisma__cover_sign_statusClient<$Result.GetResult<Prisma.$cover_sign_statusPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Cover_sign_status that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cover_sign_statusFindFirstOrThrowArgs} args - Arguments to find a Cover_sign_status
     * @example
     * // Get one Cover_sign_status
     * const cover_sign_status = await prisma.cover_sign_status.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends cover_sign_statusFindFirstOrThrowArgs>(args?: SelectSubset<T, cover_sign_statusFindFirstOrThrowArgs<ExtArgs>>): Prisma__cover_sign_statusClient<$Result.GetResult<Prisma.$cover_sign_statusPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Cover_sign_statuses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cover_sign_statusFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Cover_sign_statuses
     * const cover_sign_statuses = await prisma.cover_sign_status.findMany()
     * 
     * // Get first 10 Cover_sign_statuses
     * const cover_sign_statuses = await prisma.cover_sign_status.findMany({ take: 10 })
     * 
     * // Only select the `sign_status_id`
     * const cover_sign_statusWithSign_status_idOnly = await prisma.cover_sign_status.findMany({ select: { sign_status_id: true } })
     * 
     */
    findMany<T extends cover_sign_statusFindManyArgs>(args?: SelectSubset<T, cover_sign_statusFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$cover_sign_statusPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Cover_sign_status.
     * @param {cover_sign_statusCreateArgs} args - Arguments to create a Cover_sign_status.
     * @example
     * // Create one Cover_sign_status
     * const Cover_sign_status = await prisma.cover_sign_status.create({
     *   data: {
     *     // ... data to create a Cover_sign_status
     *   }
     * })
     * 
     */
    create<T extends cover_sign_statusCreateArgs>(args: SelectSubset<T, cover_sign_statusCreateArgs<ExtArgs>>): Prisma__cover_sign_statusClient<$Result.GetResult<Prisma.$cover_sign_statusPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Cover_sign_statuses.
     * @param {cover_sign_statusCreateManyArgs} args - Arguments to create many Cover_sign_statuses.
     * @example
     * // Create many Cover_sign_statuses
     * const cover_sign_status = await prisma.cover_sign_status.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends cover_sign_statusCreateManyArgs>(args?: SelectSubset<T, cover_sign_statusCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Cover_sign_status.
     * @param {cover_sign_statusDeleteArgs} args - Arguments to delete one Cover_sign_status.
     * @example
     * // Delete one Cover_sign_status
     * const Cover_sign_status = await prisma.cover_sign_status.delete({
     *   where: {
     *     // ... filter to delete one Cover_sign_status
     *   }
     * })
     * 
     */
    delete<T extends cover_sign_statusDeleteArgs>(args: SelectSubset<T, cover_sign_statusDeleteArgs<ExtArgs>>): Prisma__cover_sign_statusClient<$Result.GetResult<Prisma.$cover_sign_statusPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Cover_sign_status.
     * @param {cover_sign_statusUpdateArgs} args - Arguments to update one Cover_sign_status.
     * @example
     * // Update one Cover_sign_status
     * const cover_sign_status = await prisma.cover_sign_status.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends cover_sign_statusUpdateArgs>(args: SelectSubset<T, cover_sign_statusUpdateArgs<ExtArgs>>): Prisma__cover_sign_statusClient<$Result.GetResult<Prisma.$cover_sign_statusPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Cover_sign_statuses.
     * @param {cover_sign_statusDeleteManyArgs} args - Arguments to filter Cover_sign_statuses to delete.
     * @example
     * // Delete a few Cover_sign_statuses
     * const { count } = await prisma.cover_sign_status.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends cover_sign_statusDeleteManyArgs>(args?: SelectSubset<T, cover_sign_statusDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Cover_sign_statuses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cover_sign_statusUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Cover_sign_statuses
     * const cover_sign_status = await prisma.cover_sign_status.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends cover_sign_statusUpdateManyArgs>(args: SelectSubset<T, cover_sign_statusUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Cover_sign_status.
     * @param {cover_sign_statusUpsertArgs} args - Arguments to update or create a Cover_sign_status.
     * @example
     * // Update or create a Cover_sign_status
     * const cover_sign_status = await prisma.cover_sign_status.upsert({
     *   create: {
     *     // ... data to create a Cover_sign_status
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Cover_sign_status we want to update
     *   }
     * })
     */
    upsert<T extends cover_sign_statusUpsertArgs>(args: SelectSubset<T, cover_sign_statusUpsertArgs<ExtArgs>>): Prisma__cover_sign_statusClient<$Result.GetResult<Prisma.$cover_sign_statusPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Cover_sign_statuses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cover_sign_statusCountArgs} args - Arguments to filter Cover_sign_statuses to count.
     * @example
     * // Count the number of Cover_sign_statuses
     * const count = await prisma.cover_sign_status.count({
     *   where: {
     *     // ... the filter for the Cover_sign_statuses we want to count
     *   }
     * })
    **/
    count<T extends cover_sign_statusCountArgs>(
      args?: Subset<T, cover_sign_statusCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Cover_sign_statusCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Cover_sign_status.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Cover_sign_statusAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Cover_sign_statusAggregateArgs>(args: Subset<T, Cover_sign_statusAggregateArgs>): Prisma.PrismaPromise<GetCover_sign_statusAggregateType<T>>

    /**
     * Group by Cover_sign_status.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cover_sign_statusGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends cover_sign_statusGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: cover_sign_statusGroupByArgs['orderBy'] }
        : { orderBy?: cover_sign_statusGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, cover_sign_statusGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCover_sign_statusGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the cover_sign_status model
   */
  readonly fields: cover_sign_statusFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for cover_sign_status.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__cover_sign_statusClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the cover_sign_status model
   */
  interface cover_sign_statusFieldRefs {
    readonly sign_status_id: FieldRef<"cover_sign_status", 'Int'>
    readonly sign_status_name: FieldRef<"cover_sign_status", 'String'>
  }
    

  // Custom InputTypes
  /**
   * cover_sign_status findUnique
   */
  export type cover_sign_statusFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cover_sign_status
     */
    select?: cover_sign_statusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cover_sign_status
     */
    omit?: cover_sign_statusOmit<ExtArgs> | null
    /**
     * Filter, which cover_sign_status to fetch.
     */
    where: cover_sign_statusWhereUniqueInput
  }

  /**
   * cover_sign_status findUniqueOrThrow
   */
  export type cover_sign_statusFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cover_sign_status
     */
    select?: cover_sign_statusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cover_sign_status
     */
    omit?: cover_sign_statusOmit<ExtArgs> | null
    /**
     * Filter, which cover_sign_status to fetch.
     */
    where: cover_sign_statusWhereUniqueInput
  }

  /**
   * cover_sign_status findFirst
   */
  export type cover_sign_statusFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cover_sign_status
     */
    select?: cover_sign_statusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cover_sign_status
     */
    omit?: cover_sign_statusOmit<ExtArgs> | null
    /**
     * Filter, which cover_sign_status to fetch.
     */
    where?: cover_sign_statusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of cover_sign_statuses to fetch.
     */
    orderBy?: cover_sign_statusOrderByWithRelationInput | cover_sign_statusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for cover_sign_statuses.
     */
    cursor?: cover_sign_statusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` cover_sign_statuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` cover_sign_statuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of cover_sign_statuses.
     */
    distinct?: Cover_sign_statusScalarFieldEnum | Cover_sign_statusScalarFieldEnum[]
  }

  /**
   * cover_sign_status findFirstOrThrow
   */
  export type cover_sign_statusFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cover_sign_status
     */
    select?: cover_sign_statusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cover_sign_status
     */
    omit?: cover_sign_statusOmit<ExtArgs> | null
    /**
     * Filter, which cover_sign_status to fetch.
     */
    where?: cover_sign_statusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of cover_sign_statuses to fetch.
     */
    orderBy?: cover_sign_statusOrderByWithRelationInput | cover_sign_statusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for cover_sign_statuses.
     */
    cursor?: cover_sign_statusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` cover_sign_statuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` cover_sign_statuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of cover_sign_statuses.
     */
    distinct?: Cover_sign_statusScalarFieldEnum | Cover_sign_statusScalarFieldEnum[]
  }

  /**
   * cover_sign_status findMany
   */
  export type cover_sign_statusFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cover_sign_status
     */
    select?: cover_sign_statusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cover_sign_status
     */
    omit?: cover_sign_statusOmit<ExtArgs> | null
    /**
     * Filter, which cover_sign_statuses to fetch.
     */
    where?: cover_sign_statusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of cover_sign_statuses to fetch.
     */
    orderBy?: cover_sign_statusOrderByWithRelationInput | cover_sign_statusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing cover_sign_statuses.
     */
    cursor?: cover_sign_statusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` cover_sign_statuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` cover_sign_statuses.
     */
    skip?: number
    distinct?: Cover_sign_statusScalarFieldEnum | Cover_sign_statusScalarFieldEnum[]
  }

  /**
   * cover_sign_status create
   */
  export type cover_sign_statusCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cover_sign_status
     */
    select?: cover_sign_statusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cover_sign_status
     */
    omit?: cover_sign_statusOmit<ExtArgs> | null
    /**
     * The data needed to create a cover_sign_status.
     */
    data: XOR<cover_sign_statusCreateInput, cover_sign_statusUncheckedCreateInput>
  }

  /**
   * cover_sign_status createMany
   */
  export type cover_sign_statusCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many cover_sign_statuses.
     */
    data: cover_sign_statusCreateManyInput | cover_sign_statusCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * cover_sign_status update
   */
  export type cover_sign_statusUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cover_sign_status
     */
    select?: cover_sign_statusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cover_sign_status
     */
    omit?: cover_sign_statusOmit<ExtArgs> | null
    /**
     * The data needed to update a cover_sign_status.
     */
    data: XOR<cover_sign_statusUpdateInput, cover_sign_statusUncheckedUpdateInput>
    /**
     * Choose, which cover_sign_status to update.
     */
    where: cover_sign_statusWhereUniqueInput
  }

  /**
   * cover_sign_status updateMany
   */
  export type cover_sign_statusUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update cover_sign_statuses.
     */
    data: XOR<cover_sign_statusUpdateManyMutationInput, cover_sign_statusUncheckedUpdateManyInput>
    /**
     * Filter which cover_sign_statuses to update
     */
    where?: cover_sign_statusWhereInput
    /**
     * Limit how many cover_sign_statuses to update.
     */
    limit?: number
  }

  /**
   * cover_sign_status upsert
   */
  export type cover_sign_statusUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cover_sign_status
     */
    select?: cover_sign_statusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cover_sign_status
     */
    omit?: cover_sign_statusOmit<ExtArgs> | null
    /**
     * The filter to search for the cover_sign_status to update in case it exists.
     */
    where: cover_sign_statusWhereUniqueInput
    /**
     * In case the cover_sign_status found by the `where` argument doesn't exist, create a new cover_sign_status with this data.
     */
    create: XOR<cover_sign_statusCreateInput, cover_sign_statusUncheckedCreateInput>
    /**
     * In case the cover_sign_status was found with the provided `where` argument, update it with this data.
     */
    update: XOR<cover_sign_statusUpdateInput, cover_sign_statusUncheckedUpdateInput>
  }

  /**
   * cover_sign_status delete
   */
  export type cover_sign_statusDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cover_sign_status
     */
    select?: cover_sign_statusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cover_sign_status
     */
    omit?: cover_sign_statusOmit<ExtArgs> | null
    /**
     * Filter which cover_sign_status to delete.
     */
    where: cover_sign_statusWhereUniqueInput
  }

  /**
   * cover_sign_status deleteMany
   */
  export type cover_sign_statusDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which cover_sign_statuses to delete
     */
    where?: cover_sign_statusWhereInput
    /**
     * Limit how many cover_sign_statuses to delete.
     */
    limit?: number
  }

  /**
   * cover_sign_status without action
   */
  export type cover_sign_statusDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cover_sign_status
     */
    select?: cover_sign_statusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cover_sign_status
     */
    omit?: cover_sign_statusOmit<ExtArgs> | null
  }


  /**
   * Model files
   */

  export type AggregateFiles = {
    _count: FilesCountAggregateOutputType | null
    _avg: FilesAvgAggregateOutputType | null
    _sum: FilesSumAggregateOutputType | null
    _min: FilesMinAggregateOutputType | null
    _max: FilesMaxAggregateOutputType | null
  }

  export type FilesAvgAggregateOutputType = {
    id: number | null
    file_type: number | null
    uploader: number | null
    case_id: number | null
    decision_id: number | null
    inter_id: number | null
    coi_id: number | null
    person_id: number | null
    draft_id: number | null
    claim_id: number | null
    appeal_id: number | null
    process_type_id: number | null
    actual: number | null
  }

  export type FilesSumAggregateOutputType = {
    id: number | null
    file_type: number | null
    uploader: number | null
    case_id: number | null
    decision_id: number | null
    inter_id: number | null
    coi_id: number | null
    person_id: number | null
    draft_id: number | null
    claim_id: number | null
    appeal_id: number | null
    process_type_id: number | null
    actual: number | null
  }

  export type FilesMinAggregateOutputType = {
    id: number | null
    file_name: string | null
    uploaded_on: Date | null
    file_type: number | null
    uploader: number | null
    case_id: number | null
    decision_id: number | null
    inter_id: number | null
    coi_id: number | null
    person_id: number | null
    draft_id: number | null
    claim_id: number | null
    appeal_id: number | null
    file_path: string | null
    process_type_id: number | null
    actual: number | null
  }

  export type FilesMaxAggregateOutputType = {
    id: number | null
    file_name: string | null
    uploaded_on: Date | null
    file_type: number | null
    uploader: number | null
    case_id: number | null
    decision_id: number | null
    inter_id: number | null
    coi_id: number | null
    person_id: number | null
    draft_id: number | null
    claim_id: number | null
    appeal_id: number | null
    file_path: string | null
    process_type_id: number | null
    actual: number | null
  }

  export type FilesCountAggregateOutputType = {
    id: number
    file_name: number
    uploaded_on: number
    file_type: number
    uploader: number
    case_id: number
    decision_id: number
    inter_id: number
    coi_id: number
    person_id: number
    draft_id: number
    claim_id: number
    appeal_id: number
    file_path: number
    process_type_id: number
    actual: number
    _all: number
  }


  export type FilesAvgAggregateInputType = {
    id?: true
    file_type?: true
    uploader?: true
    case_id?: true
    decision_id?: true
    inter_id?: true
    coi_id?: true
    person_id?: true
    draft_id?: true
    claim_id?: true
    appeal_id?: true
    process_type_id?: true
    actual?: true
  }

  export type FilesSumAggregateInputType = {
    id?: true
    file_type?: true
    uploader?: true
    case_id?: true
    decision_id?: true
    inter_id?: true
    coi_id?: true
    person_id?: true
    draft_id?: true
    claim_id?: true
    appeal_id?: true
    process_type_id?: true
    actual?: true
  }

  export type FilesMinAggregateInputType = {
    id?: true
    file_name?: true
    uploaded_on?: true
    file_type?: true
    uploader?: true
    case_id?: true
    decision_id?: true
    inter_id?: true
    coi_id?: true
    person_id?: true
    draft_id?: true
    claim_id?: true
    appeal_id?: true
    file_path?: true
    process_type_id?: true
    actual?: true
  }

  export type FilesMaxAggregateInputType = {
    id?: true
    file_name?: true
    uploaded_on?: true
    file_type?: true
    uploader?: true
    case_id?: true
    decision_id?: true
    inter_id?: true
    coi_id?: true
    person_id?: true
    draft_id?: true
    claim_id?: true
    appeal_id?: true
    file_path?: true
    process_type_id?: true
    actual?: true
  }

  export type FilesCountAggregateInputType = {
    id?: true
    file_name?: true
    uploaded_on?: true
    file_type?: true
    uploader?: true
    case_id?: true
    decision_id?: true
    inter_id?: true
    coi_id?: true
    person_id?: true
    draft_id?: true
    claim_id?: true
    appeal_id?: true
    file_path?: true
    process_type_id?: true
    actual?: true
    _all?: true
  }

  export type FilesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which files to aggregate.
     */
    where?: filesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of files to fetch.
     */
    orderBy?: filesOrderByWithRelationInput | filesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: filesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` files from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` files.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned files
    **/
    _count?: true | FilesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FilesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FilesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FilesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FilesMaxAggregateInputType
  }

  export type GetFilesAggregateType<T extends FilesAggregateArgs> = {
        [P in keyof T & keyof AggregateFiles]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFiles[P]>
      : GetScalarType<T[P], AggregateFiles[P]>
  }




  export type filesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: filesWhereInput
    orderBy?: filesOrderByWithAggregationInput | filesOrderByWithAggregationInput[]
    by: FilesScalarFieldEnum[] | FilesScalarFieldEnum
    having?: filesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FilesCountAggregateInputType | true
    _avg?: FilesAvgAggregateInputType
    _sum?: FilesSumAggregateInputType
    _min?: FilesMinAggregateInputType
    _max?: FilesMaxAggregateInputType
  }

  export type FilesGroupByOutputType = {
    id: number
    file_name: string
    uploaded_on: Date
    file_type: number | null
    uploader: number
    case_id: number
    decision_id: number | null
    inter_id: number | null
    coi_id: number | null
    person_id: number | null
    draft_id: number | null
    claim_id: number | null
    appeal_id: number | null
    file_path: string | null
    process_type_id: number | null
    actual: number
    _count: FilesCountAggregateOutputType | null
    _avg: FilesAvgAggregateOutputType | null
    _sum: FilesSumAggregateOutputType | null
    _min: FilesMinAggregateOutputType | null
    _max: FilesMaxAggregateOutputType | null
  }

  type GetFilesGroupByPayload<T extends filesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FilesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FilesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FilesGroupByOutputType[P]>
            : GetScalarType<T[P], FilesGroupByOutputType[P]>
        }
      >
    >


  export type filesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    file_name?: boolean
    uploaded_on?: boolean
    file_type?: boolean
    uploader?: boolean
    case_id?: boolean
    decision_id?: boolean
    inter_id?: boolean
    coi_id?: boolean
    person_id?: boolean
    draft_id?: boolean
    claim_id?: boolean
    appeal_id?: boolean
    file_path?: boolean
    process_type_id?: boolean
    actual?: boolean
  }, ExtArgs["result"]["files"]>



  export type filesSelectScalar = {
    id?: boolean
    file_name?: boolean
    uploaded_on?: boolean
    file_type?: boolean
    uploader?: boolean
    case_id?: boolean
    decision_id?: boolean
    inter_id?: boolean
    coi_id?: boolean
    person_id?: boolean
    draft_id?: boolean
    claim_id?: boolean
    appeal_id?: boolean
    file_path?: boolean
    process_type_id?: boolean
    actual?: boolean
  }

  export type filesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "file_name" | "uploaded_on" | "file_type" | "uploader" | "case_id" | "decision_id" | "inter_id" | "coi_id" | "person_id" | "draft_id" | "claim_id" | "appeal_id" | "file_path" | "process_type_id" | "actual", ExtArgs["result"]["files"]>

  export type $filesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "files"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      file_name: string
      uploaded_on: Date
      file_type: number | null
      uploader: number
      case_id: number
      decision_id: number | null
      inter_id: number | null
      coi_id: number | null
      person_id: number | null
      draft_id: number | null
      claim_id: number | null
      appeal_id: number | null
      file_path: string | null
      process_type_id: number | null
      actual: number
    }, ExtArgs["result"]["files"]>
    composites: {}
  }

  type filesGetPayload<S extends boolean | null | undefined | filesDefaultArgs> = $Result.GetResult<Prisma.$filesPayload, S>

  type filesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<filesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FilesCountAggregateInputType | true
    }

  export interface filesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['files'], meta: { name: 'files' } }
    /**
     * Find zero or one Files that matches the filter.
     * @param {filesFindUniqueArgs} args - Arguments to find a Files
     * @example
     * // Get one Files
     * const files = await prisma.files.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends filesFindUniqueArgs>(args: SelectSubset<T, filesFindUniqueArgs<ExtArgs>>): Prisma__filesClient<$Result.GetResult<Prisma.$filesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Files that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {filesFindUniqueOrThrowArgs} args - Arguments to find a Files
     * @example
     * // Get one Files
     * const files = await prisma.files.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends filesFindUniqueOrThrowArgs>(args: SelectSubset<T, filesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__filesClient<$Result.GetResult<Prisma.$filesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Files that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {filesFindFirstArgs} args - Arguments to find a Files
     * @example
     * // Get one Files
     * const files = await prisma.files.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends filesFindFirstArgs>(args?: SelectSubset<T, filesFindFirstArgs<ExtArgs>>): Prisma__filesClient<$Result.GetResult<Prisma.$filesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Files that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {filesFindFirstOrThrowArgs} args - Arguments to find a Files
     * @example
     * // Get one Files
     * const files = await prisma.files.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends filesFindFirstOrThrowArgs>(args?: SelectSubset<T, filesFindFirstOrThrowArgs<ExtArgs>>): Prisma__filesClient<$Result.GetResult<Prisma.$filesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Files that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {filesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Files
     * const files = await prisma.files.findMany()
     * 
     * // Get first 10 Files
     * const files = await prisma.files.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const filesWithIdOnly = await prisma.files.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends filesFindManyArgs>(args?: SelectSubset<T, filesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$filesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Files.
     * @param {filesCreateArgs} args - Arguments to create a Files.
     * @example
     * // Create one Files
     * const Files = await prisma.files.create({
     *   data: {
     *     // ... data to create a Files
     *   }
     * })
     * 
     */
    create<T extends filesCreateArgs>(args: SelectSubset<T, filesCreateArgs<ExtArgs>>): Prisma__filesClient<$Result.GetResult<Prisma.$filesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Files.
     * @param {filesCreateManyArgs} args - Arguments to create many Files.
     * @example
     * // Create many Files
     * const files = await prisma.files.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends filesCreateManyArgs>(args?: SelectSubset<T, filesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Files.
     * @param {filesDeleteArgs} args - Arguments to delete one Files.
     * @example
     * // Delete one Files
     * const Files = await prisma.files.delete({
     *   where: {
     *     // ... filter to delete one Files
     *   }
     * })
     * 
     */
    delete<T extends filesDeleteArgs>(args: SelectSubset<T, filesDeleteArgs<ExtArgs>>): Prisma__filesClient<$Result.GetResult<Prisma.$filesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Files.
     * @param {filesUpdateArgs} args - Arguments to update one Files.
     * @example
     * // Update one Files
     * const files = await prisma.files.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends filesUpdateArgs>(args: SelectSubset<T, filesUpdateArgs<ExtArgs>>): Prisma__filesClient<$Result.GetResult<Prisma.$filesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Files.
     * @param {filesDeleteManyArgs} args - Arguments to filter Files to delete.
     * @example
     * // Delete a few Files
     * const { count } = await prisma.files.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends filesDeleteManyArgs>(args?: SelectSubset<T, filesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Files.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {filesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Files
     * const files = await prisma.files.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends filesUpdateManyArgs>(args: SelectSubset<T, filesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Files.
     * @param {filesUpsertArgs} args - Arguments to update or create a Files.
     * @example
     * // Update or create a Files
     * const files = await prisma.files.upsert({
     *   create: {
     *     // ... data to create a Files
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Files we want to update
     *   }
     * })
     */
    upsert<T extends filesUpsertArgs>(args: SelectSubset<T, filesUpsertArgs<ExtArgs>>): Prisma__filesClient<$Result.GetResult<Prisma.$filesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Files.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {filesCountArgs} args - Arguments to filter Files to count.
     * @example
     * // Count the number of Files
     * const count = await prisma.files.count({
     *   where: {
     *     // ... the filter for the Files we want to count
     *   }
     * })
    **/
    count<T extends filesCountArgs>(
      args?: Subset<T, filesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FilesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Files.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FilesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FilesAggregateArgs>(args: Subset<T, FilesAggregateArgs>): Prisma.PrismaPromise<GetFilesAggregateType<T>>

    /**
     * Group by Files.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {filesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends filesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: filesGroupByArgs['orderBy'] }
        : { orderBy?: filesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, filesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFilesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the files model
   */
  readonly fields: filesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for files.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__filesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the files model
   */
  interface filesFieldRefs {
    readonly id: FieldRef<"files", 'Int'>
    readonly file_name: FieldRef<"files", 'String'>
    readonly uploaded_on: FieldRef<"files", 'DateTime'>
    readonly file_type: FieldRef<"files", 'Int'>
    readonly uploader: FieldRef<"files", 'Int'>
    readonly case_id: FieldRef<"files", 'Int'>
    readonly decision_id: FieldRef<"files", 'Int'>
    readonly inter_id: FieldRef<"files", 'Int'>
    readonly coi_id: FieldRef<"files", 'Int'>
    readonly person_id: FieldRef<"files", 'Int'>
    readonly draft_id: FieldRef<"files", 'Int'>
    readonly claim_id: FieldRef<"files", 'Int'>
    readonly appeal_id: FieldRef<"files", 'Int'>
    readonly file_path: FieldRef<"files", 'String'>
    readonly process_type_id: FieldRef<"files", 'Int'>
    readonly actual: FieldRef<"files", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * files findUnique
   */
  export type filesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the files
     */
    select?: filesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the files
     */
    omit?: filesOmit<ExtArgs> | null
    /**
     * Filter, which files to fetch.
     */
    where: filesWhereUniqueInput
  }

  /**
   * files findUniqueOrThrow
   */
  export type filesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the files
     */
    select?: filesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the files
     */
    omit?: filesOmit<ExtArgs> | null
    /**
     * Filter, which files to fetch.
     */
    where: filesWhereUniqueInput
  }

  /**
   * files findFirst
   */
  export type filesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the files
     */
    select?: filesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the files
     */
    omit?: filesOmit<ExtArgs> | null
    /**
     * Filter, which files to fetch.
     */
    where?: filesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of files to fetch.
     */
    orderBy?: filesOrderByWithRelationInput | filesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for files.
     */
    cursor?: filesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` files from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` files.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of files.
     */
    distinct?: FilesScalarFieldEnum | FilesScalarFieldEnum[]
  }

  /**
   * files findFirstOrThrow
   */
  export type filesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the files
     */
    select?: filesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the files
     */
    omit?: filesOmit<ExtArgs> | null
    /**
     * Filter, which files to fetch.
     */
    where?: filesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of files to fetch.
     */
    orderBy?: filesOrderByWithRelationInput | filesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for files.
     */
    cursor?: filesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` files from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` files.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of files.
     */
    distinct?: FilesScalarFieldEnum | FilesScalarFieldEnum[]
  }

  /**
   * files findMany
   */
  export type filesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the files
     */
    select?: filesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the files
     */
    omit?: filesOmit<ExtArgs> | null
    /**
     * Filter, which files to fetch.
     */
    where?: filesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of files to fetch.
     */
    orderBy?: filesOrderByWithRelationInput | filesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing files.
     */
    cursor?: filesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` files from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` files.
     */
    skip?: number
    distinct?: FilesScalarFieldEnum | FilesScalarFieldEnum[]
  }

  /**
   * files create
   */
  export type filesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the files
     */
    select?: filesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the files
     */
    omit?: filesOmit<ExtArgs> | null
    /**
     * The data needed to create a files.
     */
    data: XOR<filesCreateInput, filesUncheckedCreateInput>
  }

  /**
   * files createMany
   */
  export type filesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many files.
     */
    data: filesCreateManyInput | filesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * files update
   */
  export type filesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the files
     */
    select?: filesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the files
     */
    omit?: filesOmit<ExtArgs> | null
    /**
     * The data needed to update a files.
     */
    data: XOR<filesUpdateInput, filesUncheckedUpdateInput>
    /**
     * Choose, which files to update.
     */
    where: filesWhereUniqueInput
  }

  /**
   * files updateMany
   */
  export type filesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update files.
     */
    data: XOR<filesUpdateManyMutationInput, filesUncheckedUpdateManyInput>
    /**
     * Filter which files to update
     */
    where?: filesWhereInput
    /**
     * Limit how many files to update.
     */
    limit?: number
  }

  /**
   * files upsert
   */
  export type filesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the files
     */
    select?: filesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the files
     */
    omit?: filesOmit<ExtArgs> | null
    /**
     * The filter to search for the files to update in case it exists.
     */
    where: filesWhereUniqueInput
    /**
     * In case the files found by the `where` argument doesn't exist, create a new files with this data.
     */
    create: XOR<filesCreateInput, filesUncheckedCreateInput>
    /**
     * In case the files was found with the provided `where` argument, update it with this data.
     */
    update: XOR<filesUpdateInput, filesUncheckedUpdateInput>
  }

  /**
   * files delete
   */
  export type filesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the files
     */
    select?: filesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the files
     */
    omit?: filesOmit<ExtArgs> | null
    /**
     * Filter which files to delete.
     */
    where: filesWhereUniqueInput
  }

  /**
   * files deleteMany
   */
  export type filesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which files to delete
     */
    where?: filesWhereInput
    /**
     * Limit how many files to delete.
     */
    limit?: number
  }

  /**
   * files without action
   */
  export type filesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the files
     */
    select?: filesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the files
     */
    omit?: filesOmit<ExtArgs> | null
  }


  /**
   * Model ips
   */

  export type AggregateIps = {
    _count: IpsCountAggregateOutputType | null
    _avg: IpsAvgAggregateOutputType | null
    _sum: IpsSumAggregateOutputType | null
    _min: IpsMinAggregateOutputType | null
    _max: IpsMaxAggregateOutputType | null
  }

  export type IpsAvgAggregateOutputType = {
    id: number | null
  }

  export type IpsSumAggregateOutputType = {
    id: number | null
  }

  export type IpsMinAggregateOutputType = {
    id: number | null
    ip: string | null
    created_at: Date | null
  }

  export type IpsMaxAggregateOutputType = {
    id: number | null
    ip: string | null
    created_at: Date | null
  }

  export type IpsCountAggregateOutputType = {
    id: number
    ip: number
    created_at: number
    _all: number
  }


  export type IpsAvgAggregateInputType = {
    id?: true
  }

  export type IpsSumAggregateInputType = {
    id?: true
  }

  export type IpsMinAggregateInputType = {
    id?: true
    ip?: true
    created_at?: true
  }

  export type IpsMaxAggregateInputType = {
    id?: true
    ip?: true
    created_at?: true
  }

  export type IpsCountAggregateInputType = {
    id?: true
    ip?: true
    created_at?: true
    _all?: true
  }

  export type IpsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ips to aggregate.
     */
    where?: ipsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ips to fetch.
     */
    orderBy?: ipsOrderByWithRelationInput | ipsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ipsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ips from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ips.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ips
    **/
    _count?: true | IpsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: IpsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: IpsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: IpsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: IpsMaxAggregateInputType
  }

  export type GetIpsAggregateType<T extends IpsAggregateArgs> = {
        [P in keyof T & keyof AggregateIps]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateIps[P]>
      : GetScalarType<T[P], AggregateIps[P]>
  }




  export type ipsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ipsWhereInput
    orderBy?: ipsOrderByWithAggregationInput | ipsOrderByWithAggregationInput[]
    by: IpsScalarFieldEnum[] | IpsScalarFieldEnum
    having?: ipsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: IpsCountAggregateInputType | true
    _avg?: IpsAvgAggregateInputType
    _sum?: IpsSumAggregateInputType
    _min?: IpsMinAggregateInputType
    _max?: IpsMaxAggregateInputType
  }

  export type IpsGroupByOutputType = {
    id: number
    ip: string
    created_at: Date
    _count: IpsCountAggregateOutputType | null
    _avg: IpsAvgAggregateOutputType | null
    _sum: IpsSumAggregateOutputType | null
    _min: IpsMinAggregateOutputType | null
    _max: IpsMaxAggregateOutputType | null
  }

  type GetIpsGroupByPayload<T extends ipsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<IpsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof IpsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], IpsGroupByOutputType[P]>
            : GetScalarType<T[P], IpsGroupByOutputType[P]>
        }
      >
    >


  export type ipsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ip?: boolean
    created_at?: boolean
  }, ExtArgs["result"]["ips"]>



  export type ipsSelectScalar = {
    id?: boolean
    ip?: boolean
    created_at?: boolean
  }

  export type ipsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "ip" | "created_at", ExtArgs["result"]["ips"]>

  export type $ipsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ips"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      ip: string
      created_at: Date
    }, ExtArgs["result"]["ips"]>
    composites: {}
  }

  type ipsGetPayload<S extends boolean | null | undefined | ipsDefaultArgs> = $Result.GetResult<Prisma.$ipsPayload, S>

  type ipsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ipsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: IpsCountAggregateInputType | true
    }

  export interface ipsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ips'], meta: { name: 'ips' } }
    /**
     * Find zero or one Ips that matches the filter.
     * @param {ipsFindUniqueArgs} args - Arguments to find a Ips
     * @example
     * // Get one Ips
     * const ips = await prisma.ips.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ipsFindUniqueArgs>(args: SelectSubset<T, ipsFindUniqueArgs<ExtArgs>>): Prisma__ipsClient<$Result.GetResult<Prisma.$ipsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Ips that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ipsFindUniqueOrThrowArgs} args - Arguments to find a Ips
     * @example
     * // Get one Ips
     * const ips = await prisma.ips.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ipsFindUniqueOrThrowArgs>(args: SelectSubset<T, ipsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ipsClient<$Result.GetResult<Prisma.$ipsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Ips that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ipsFindFirstArgs} args - Arguments to find a Ips
     * @example
     * // Get one Ips
     * const ips = await prisma.ips.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ipsFindFirstArgs>(args?: SelectSubset<T, ipsFindFirstArgs<ExtArgs>>): Prisma__ipsClient<$Result.GetResult<Prisma.$ipsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Ips that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ipsFindFirstOrThrowArgs} args - Arguments to find a Ips
     * @example
     * // Get one Ips
     * const ips = await prisma.ips.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ipsFindFirstOrThrowArgs>(args?: SelectSubset<T, ipsFindFirstOrThrowArgs<ExtArgs>>): Prisma__ipsClient<$Result.GetResult<Prisma.$ipsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Ips that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ipsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Ips
     * const ips = await prisma.ips.findMany()
     * 
     * // Get first 10 Ips
     * const ips = await prisma.ips.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ipsWithIdOnly = await prisma.ips.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ipsFindManyArgs>(args?: SelectSubset<T, ipsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ipsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Ips.
     * @param {ipsCreateArgs} args - Arguments to create a Ips.
     * @example
     * // Create one Ips
     * const Ips = await prisma.ips.create({
     *   data: {
     *     // ... data to create a Ips
     *   }
     * })
     * 
     */
    create<T extends ipsCreateArgs>(args: SelectSubset<T, ipsCreateArgs<ExtArgs>>): Prisma__ipsClient<$Result.GetResult<Prisma.$ipsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Ips.
     * @param {ipsCreateManyArgs} args - Arguments to create many Ips.
     * @example
     * // Create many Ips
     * const ips = await prisma.ips.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ipsCreateManyArgs>(args?: SelectSubset<T, ipsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Ips.
     * @param {ipsDeleteArgs} args - Arguments to delete one Ips.
     * @example
     * // Delete one Ips
     * const Ips = await prisma.ips.delete({
     *   where: {
     *     // ... filter to delete one Ips
     *   }
     * })
     * 
     */
    delete<T extends ipsDeleteArgs>(args: SelectSubset<T, ipsDeleteArgs<ExtArgs>>): Prisma__ipsClient<$Result.GetResult<Prisma.$ipsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Ips.
     * @param {ipsUpdateArgs} args - Arguments to update one Ips.
     * @example
     * // Update one Ips
     * const ips = await prisma.ips.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ipsUpdateArgs>(args: SelectSubset<T, ipsUpdateArgs<ExtArgs>>): Prisma__ipsClient<$Result.GetResult<Prisma.$ipsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Ips.
     * @param {ipsDeleteManyArgs} args - Arguments to filter Ips to delete.
     * @example
     * // Delete a few Ips
     * const { count } = await prisma.ips.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ipsDeleteManyArgs>(args?: SelectSubset<T, ipsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Ips.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ipsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Ips
     * const ips = await prisma.ips.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ipsUpdateManyArgs>(args: SelectSubset<T, ipsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Ips.
     * @param {ipsUpsertArgs} args - Arguments to update or create a Ips.
     * @example
     * // Update or create a Ips
     * const ips = await prisma.ips.upsert({
     *   create: {
     *     // ... data to create a Ips
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Ips we want to update
     *   }
     * })
     */
    upsert<T extends ipsUpsertArgs>(args: SelectSubset<T, ipsUpsertArgs<ExtArgs>>): Prisma__ipsClient<$Result.GetResult<Prisma.$ipsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Ips.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ipsCountArgs} args - Arguments to filter Ips to count.
     * @example
     * // Count the number of Ips
     * const count = await prisma.ips.count({
     *   where: {
     *     // ... the filter for the Ips we want to count
     *   }
     * })
    **/
    count<T extends ipsCountArgs>(
      args?: Subset<T, ipsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], IpsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Ips.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IpsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends IpsAggregateArgs>(args: Subset<T, IpsAggregateArgs>): Prisma.PrismaPromise<GetIpsAggregateType<T>>

    /**
     * Group by Ips.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ipsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ipsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ipsGroupByArgs['orderBy'] }
        : { orderBy?: ipsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ipsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetIpsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ips model
   */
  readonly fields: ipsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ips.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ipsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ips model
   */
  interface ipsFieldRefs {
    readonly id: FieldRef<"ips", 'Int'>
    readonly ip: FieldRef<"ips", 'String'>
    readonly created_at: FieldRef<"ips", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ips findUnique
   */
  export type ipsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ips
     */
    select?: ipsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ips
     */
    omit?: ipsOmit<ExtArgs> | null
    /**
     * Filter, which ips to fetch.
     */
    where: ipsWhereUniqueInput
  }

  /**
   * ips findUniqueOrThrow
   */
  export type ipsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ips
     */
    select?: ipsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ips
     */
    omit?: ipsOmit<ExtArgs> | null
    /**
     * Filter, which ips to fetch.
     */
    where: ipsWhereUniqueInput
  }

  /**
   * ips findFirst
   */
  export type ipsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ips
     */
    select?: ipsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ips
     */
    omit?: ipsOmit<ExtArgs> | null
    /**
     * Filter, which ips to fetch.
     */
    where?: ipsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ips to fetch.
     */
    orderBy?: ipsOrderByWithRelationInput | ipsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ips.
     */
    cursor?: ipsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ips from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ips.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ips.
     */
    distinct?: IpsScalarFieldEnum | IpsScalarFieldEnum[]
  }

  /**
   * ips findFirstOrThrow
   */
  export type ipsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ips
     */
    select?: ipsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ips
     */
    omit?: ipsOmit<ExtArgs> | null
    /**
     * Filter, which ips to fetch.
     */
    where?: ipsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ips to fetch.
     */
    orderBy?: ipsOrderByWithRelationInput | ipsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ips.
     */
    cursor?: ipsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ips from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ips.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ips.
     */
    distinct?: IpsScalarFieldEnum | IpsScalarFieldEnum[]
  }

  /**
   * ips findMany
   */
  export type ipsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ips
     */
    select?: ipsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ips
     */
    omit?: ipsOmit<ExtArgs> | null
    /**
     * Filter, which ips to fetch.
     */
    where?: ipsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ips to fetch.
     */
    orderBy?: ipsOrderByWithRelationInput | ipsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ips.
     */
    cursor?: ipsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ips from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ips.
     */
    skip?: number
    distinct?: IpsScalarFieldEnum | IpsScalarFieldEnum[]
  }

  /**
   * ips create
   */
  export type ipsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ips
     */
    select?: ipsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ips
     */
    omit?: ipsOmit<ExtArgs> | null
    /**
     * The data needed to create a ips.
     */
    data: XOR<ipsCreateInput, ipsUncheckedCreateInput>
  }

  /**
   * ips createMany
   */
  export type ipsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ips.
     */
    data: ipsCreateManyInput | ipsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ips update
   */
  export type ipsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ips
     */
    select?: ipsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ips
     */
    omit?: ipsOmit<ExtArgs> | null
    /**
     * The data needed to update a ips.
     */
    data: XOR<ipsUpdateInput, ipsUncheckedUpdateInput>
    /**
     * Choose, which ips to update.
     */
    where: ipsWhereUniqueInput
  }

  /**
   * ips updateMany
   */
  export type ipsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ips.
     */
    data: XOR<ipsUpdateManyMutationInput, ipsUncheckedUpdateManyInput>
    /**
     * Filter which ips to update
     */
    where?: ipsWhereInput
    /**
     * Limit how many ips to update.
     */
    limit?: number
  }

  /**
   * ips upsert
   */
  export type ipsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ips
     */
    select?: ipsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ips
     */
    omit?: ipsOmit<ExtArgs> | null
    /**
     * The filter to search for the ips to update in case it exists.
     */
    where: ipsWhereUniqueInput
    /**
     * In case the ips found by the `where` argument doesn't exist, create a new ips with this data.
     */
    create: XOR<ipsCreateInput, ipsUncheckedCreateInput>
    /**
     * In case the ips was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ipsUpdateInput, ipsUncheckedUpdateInput>
  }

  /**
   * ips delete
   */
  export type ipsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ips
     */
    select?: ipsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ips
     */
    omit?: ipsOmit<ExtArgs> | null
    /**
     * Filter which ips to delete.
     */
    where: ipsWhereUniqueInput
  }

  /**
   * ips deleteMany
   */
  export type ipsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ips to delete
     */
    where?: ipsWhereInput
    /**
     * Limit how many ips to delete.
     */
    limit?: number
  }

  /**
   * ips without action
   */
  export type ipsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ips
     */
    select?: ipsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ips
     */
    omit?: ipsOmit<ExtArgs> | null
  }


  /**
   * Model old_case_decisions
   */

  export type AggregateOld_case_decisions = {
    _count: Old_case_decisionsCountAggregateOutputType | null
    _avg: Old_case_decisionsAvgAggregateOutputType | null
    _sum: Old_case_decisionsSumAggregateOutputType | null
    _min: Old_case_decisionsMinAggregateOutputType | null
    _max: Old_case_decisionsMaxAggregateOutputType | null
  }

  export type Old_case_decisionsAvgAggregateOutputType = {
    old_decision_id: number | null
    old_case_id: number | null
    ms_decision: number | null
    final_decision: number | null
  }

  export type Old_case_decisionsSumAggregateOutputType = {
    old_decision_id: number | null
    old_case_id: number | null
    ms_decision: number | null
    final_decision: number | null
  }

  export type Old_case_decisionsMinAggregateOutputType = {
    old_decision_id: number | null
    old_case_id: number | null
    ms_decision: number | null
    ms_decision_date: Date | null
    final_decision: number | null
    final_decision_date: Date | null
  }

  export type Old_case_decisionsMaxAggregateOutputType = {
    old_decision_id: number | null
    old_case_id: number | null
    ms_decision: number | null
    ms_decision_date: Date | null
    final_decision: number | null
    final_decision_date: Date | null
  }

  export type Old_case_decisionsCountAggregateOutputType = {
    old_decision_id: number
    old_case_id: number
    ms_decision: number
    ms_decision_date: number
    final_decision: number
    final_decision_date: number
    _all: number
  }


  export type Old_case_decisionsAvgAggregateInputType = {
    old_decision_id?: true
    old_case_id?: true
    ms_decision?: true
    final_decision?: true
  }

  export type Old_case_decisionsSumAggregateInputType = {
    old_decision_id?: true
    old_case_id?: true
    ms_decision?: true
    final_decision?: true
  }

  export type Old_case_decisionsMinAggregateInputType = {
    old_decision_id?: true
    old_case_id?: true
    ms_decision?: true
    ms_decision_date?: true
    final_decision?: true
    final_decision_date?: true
  }

  export type Old_case_decisionsMaxAggregateInputType = {
    old_decision_id?: true
    old_case_id?: true
    ms_decision?: true
    ms_decision_date?: true
    final_decision?: true
    final_decision_date?: true
  }

  export type Old_case_decisionsCountAggregateInputType = {
    old_decision_id?: true
    old_case_id?: true
    ms_decision?: true
    ms_decision_date?: true
    final_decision?: true
    final_decision_date?: true
    _all?: true
  }

  export type Old_case_decisionsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which old_case_decisions to aggregate.
     */
    where?: old_case_decisionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of old_case_decisions to fetch.
     */
    orderBy?: old_case_decisionsOrderByWithRelationInput | old_case_decisionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: old_case_decisionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` old_case_decisions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` old_case_decisions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned old_case_decisions
    **/
    _count?: true | Old_case_decisionsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Old_case_decisionsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Old_case_decisionsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Old_case_decisionsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Old_case_decisionsMaxAggregateInputType
  }

  export type GetOld_case_decisionsAggregateType<T extends Old_case_decisionsAggregateArgs> = {
        [P in keyof T & keyof AggregateOld_case_decisions]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOld_case_decisions[P]>
      : GetScalarType<T[P], AggregateOld_case_decisions[P]>
  }




  export type old_case_decisionsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: old_case_decisionsWhereInput
    orderBy?: old_case_decisionsOrderByWithAggregationInput | old_case_decisionsOrderByWithAggregationInput[]
    by: Old_case_decisionsScalarFieldEnum[] | Old_case_decisionsScalarFieldEnum
    having?: old_case_decisionsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Old_case_decisionsCountAggregateInputType | true
    _avg?: Old_case_decisionsAvgAggregateInputType
    _sum?: Old_case_decisionsSumAggregateInputType
    _min?: Old_case_decisionsMinAggregateInputType
    _max?: Old_case_decisionsMaxAggregateInputType
  }

  export type Old_case_decisionsGroupByOutputType = {
    old_decision_id: number
    old_case_id: number
    ms_decision: number
    ms_decision_date: Date | null
    final_decision: number | null
    final_decision_date: Date | null
    _count: Old_case_decisionsCountAggregateOutputType | null
    _avg: Old_case_decisionsAvgAggregateOutputType | null
    _sum: Old_case_decisionsSumAggregateOutputType | null
    _min: Old_case_decisionsMinAggregateOutputType | null
    _max: Old_case_decisionsMaxAggregateOutputType | null
  }

  type GetOld_case_decisionsGroupByPayload<T extends old_case_decisionsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Old_case_decisionsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Old_case_decisionsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Old_case_decisionsGroupByOutputType[P]>
            : GetScalarType<T[P], Old_case_decisionsGroupByOutputType[P]>
        }
      >
    >


  export type old_case_decisionsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    old_decision_id?: boolean
    old_case_id?: boolean
    ms_decision?: boolean
    ms_decision_date?: boolean
    final_decision?: boolean
    final_decision_date?: boolean
  }, ExtArgs["result"]["old_case_decisions"]>



  export type old_case_decisionsSelectScalar = {
    old_decision_id?: boolean
    old_case_id?: boolean
    ms_decision?: boolean
    ms_decision_date?: boolean
    final_decision?: boolean
    final_decision_date?: boolean
  }

  export type old_case_decisionsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"old_decision_id" | "old_case_id" | "ms_decision" | "ms_decision_date" | "final_decision" | "final_decision_date", ExtArgs["result"]["old_case_decisions"]>

  export type $old_case_decisionsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "old_case_decisions"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      old_decision_id: number
      old_case_id: number
      ms_decision: number
      ms_decision_date: Date | null
      final_decision: number | null
      final_decision_date: Date | null
    }, ExtArgs["result"]["old_case_decisions"]>
    composites: {}
  }

  type old_case_decisionsGetPayload<S extends boolean | null | undefined | old_case_decisionsDefaultArgs> = $Result.GetResult<Prisma.$old_case_decisionsPayload, S>

  type old_case_decisionsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<old_case_decisionsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Old_case_decisionsCountAggregateInputType | true
    }

  export interface old_case_decisionsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['old_case_decisions'], meta: { name: 'old_case_decisions' } }
    /**
     * Find zero or one Old_case_decisions that matches the filter.
     * @param {old_case_decisionsFindUniqueArgs} args - Arguments to find a Old_case_decisions
     * @example
     * // Get one Old_case_decisions
     * const old_case_decisions = await prisma.old_case_decisions.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends old_case_decisionsFindUniqueArgs>(args: SelectSubset<T, old_case_decisionsFindUniqueArgs<ExtArgs>>): Prisma__old_case_decisionsClient<$Result.GetResult<Prisma.$old_case_decisionsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Old_case_decisions that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {old_case_decisionsFindUniqueOrThrowArgs} args - Arguments to find a Old_case_decisions
     * @example
     * // Get one Old_case_decisions
     * const old_case_decisions = await prisma.old_case_decisions.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends old_case_decisionsFindUniqueOrThrowArgs>(args: SelectSubset<T, old_case_decisionsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__old_case_decisionsClient<$Result.GetResult<Prisma.$old_case_decisionsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Old_case_decisions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {old_case_decisionsFindFirstArgs} args - Arguments to find a Old_case_decisions
     * @example
     * // Get one Old_case_decisions
     * const old_case_decisions = await prisma.old_case_decisions.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends old_case_decisionsFindFirstArgs>(args?: SelectSubset<T, old_case_decisionsFindFirstArgs<ExtArgs>>): Prisma__old_case_decisionsClient<$Result.GetResult<Prisma.$old_case_decisionsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Old_case_decisions that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {old_case_decisionsFindFirstOrThrowArgs} args - Arguments to find a Old_case_decisions
     * @example
     * // Get one Old_case_decisions
     * const old_case_decisions = await prisma.old_case_decisions.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends old_case_decisionsFindFirstOrThrowArgs>(args?: SelectSubset<T, old_case_decisionsFindFirstOrThrowArgs<ExtArgs>>): Prisma__old_case_decisionsClient<$Result.GetResult<Prisma.$old_case_decisionsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Old_case_decisions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {old_case_decisionsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Old_case_decisions
     * const old_case_decisions = await prisma.old_case_decisions.findMany()
     * 
     * // Get first 10 Old_case_decisions
     * const old_case_decisions = await prisma.old_case_decisions.findMany({ take: 10 })
     * 
     * // Only select the `old_decision_id`
     * const old_case_decisionsWithOld_decision_idOnly = await prisma.old_case_decisions.findMany({ select: { old_decision_id: true } })
     * 
     */
    findMany<T extends old_case_decisionsFindManyArgs>(args?: SelectSubset<T, old_case_decisionsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$old_case_decisionsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Old_case_decisions.
     * @param {old_case_decisionsCreateArgs} args - Arguments to create a Old_case_decisions.
     * @example
     * // Create one Old_case_decisions
     * const Old_case_decisions = await prisma.old_case_decisions.create({
     *   data: {
     *     // ... data to create a Old_case_decisions
     *   }
     * })
     * 
     */
    create<T extends old_case_decisionsCreateArgs>(args: SelectSubset<T, old_case_decisionsCreateArgs<ExtArgs>>): Prisma__old_case_decisionsClient<$Result.GetResult<Prisma.$old_case_decisionsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Old_case_decisions.
     * @param {old_case_decisionsCreateManyArgs} args - Arguments to create many Old_case_decisions.
     * @example
     * // Create many Old_case_decisions
     * const old_case_decisions = await prisma.old_case_decisions.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends old_case_decisionsCreateManyArgs>(args?: SelectSubset<T, old_case_decisionsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Old_case_decisions.
     * @param {old_case_decisionsDeleteArgs} args - Arguments to delete one Old_case_decisions.
     * @example
     * // Delete one Old_case_decisions
     * const Old_case_decisions = await prisma.old_case_decisions.delete({
     *   where: {
     *     // ... filter to delete one Old_case_decisions
     *   }
     * })
     * 
     */
    delete<T extends old_case_decisionsDeleteArgs>(args: SelectSubset<T, old_case_decisionsDeleteArgs<ExtArgs>>): Prisma__old_case_decisionsClient<$Result.GetResult<Prisma.$old_case_decisionsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Old_case_decisions.
     * @param {old_case_decisionsUpdateArgs} args - Arguments to update one Old_case_decisions.
     * @example
     * // Update one Old_case_decisions
     * const old_case_decisions = await prisma.old_case_decisions.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends old_case_decisionsUpdateArgs>(args: SelectSubset<T, old_case_decisionsUpdateArgs<ExtArgs>>): Prisma__old_case_decisionsClient<$Result.GetResult<Prisma.$old_case_decisionsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Old_case_decisions.
     * @param {old_case_decisionsDeleteManyArgs} args - Arguments to filter Old_case_decisions to delete.
     * @example
     * // Delete a few Old_case_decisions
     * const { count } = await prisma.old_case_decisions.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends old_case_decisionsDeleteManyArgs>(args?: SelectSubset<T, old_case_decisionsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Old_case_decisions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {old_case_decisionsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Old_case_decisions
     * const old_case_decisions = await prisma.old_case_decisions.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends old_case_decisionsUpdateManyArgs>(args: SelectSubset<T, old_case_decisionsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Old_case_decisions.
     * @param {old_case_decisionsUpsertArgs} args - Arguments to update or create a Old_case_decisions.
     * @example
     * // Update or create a Old_case_decisions
     * const old_case_decisions = await prisma.old_case_decisions.upsert({
     *   create: {
     *     // ... data to create a Old_case_decisions
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Old_case_decisions we want to update
     *   }
     * })
     */
    upsert<T extends old_case_decisionsUpsertArgs>(args: SelectSubset<T, old_case_decisionsUpsertArgs<ExtArgs>>): Prisma__old_case_decisionsClient<$Result.GetResult<Prisma.$old_case_decisionsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Old_case_decisions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {old_case_decisionsCountArgs} args - Arguments to filter Old_case_decisions to count.
     * @example
     * // Count the number of Old_case_decisions
     * const count = await prisma.old_case_decisions.count({
     *   where: {
     *     // ... the filter for the Old_case_decisions we want to count
     *   }
     * })
    **/
    count<T extends old_case_decisionsCountArgs>(
      args?: Subset<T, old_case_decisionsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Old_case_decisionsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Old_case_decisions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Old_case_decisionsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Old_case_decisionsAggregateArgs>(args: Subset<T, Old_case_decisionsAggregateArgs>): Prisma.PrismaPromise<GetOld_case_decisionsAggregateType<T>>

    /**
     * Group by Old_case_decisions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {old_case_decisionsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends old_case_decisionsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: old_case_decisionsGroupByArgs['orderBy'] }
        : { orderBy?: old_case_decisionsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, old_case_decisionsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOld_case_decisionsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the old_case_decisions model
   */
  readonly fields: old_case_decisionsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for old_case_decisions.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__old_case_decisionsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the old_case_decisions model
   */
  interface old_case_decisionsFieldRefs {
    readonly old_decision_id: FieldRef<"old_case_decisions", 'Int'>
    readonly old_case_id: FieldRef<"old_case_decisions", 'Int'>
    readonly ms_decision: FieldRef<"old_case_decisions", 'Int'>
    readonly ms_decision_date: FieldRef<"old_case_decisions", 'DateTime'>
    readonly final_decision: FieldRef<"old_case_decisions", 'Int'>
    readonly final_decision_date: FieldRef<"old_case_decisions", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * old_case_decisions findUnique
   */
  export type old_case_decisionsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the old_case_decisions
     */
    select?: old_case_decisionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the old_case_decisions
     */
    omit?: old_case_decisionsOmit<ExtArgs> | null
    /**
     * Filter, which old_case_decisions to fetch.
     */
    where: old_case_decisionsWhereUniqueInput
  }

  /**
   * old_case_decisions findUniqueOrThrow
   */
  export type old_case_decisionsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the old_case_decisions
     */
    select?: old_case_decisionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the old_case_decisions
     */
    omit?: old_case_decisionsOmit<ExtArgs> | null
    /**
     * Filter, which old_case_decisions to fetch.
     */
    where: old_case_decisionsWhereUniqueInput
  }

  /**
   * old_case_decisions findFirst
   */
  export type old_case_decisionsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the old_case_decisions
     */
    select?: old_case_decisionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the old_case_decisions
     */
    omit?: old_case_decisionsOmit<ExtArgs> | null
    /**
     * Filter, which old_case_decisions to fetch.
     */
    where?: old_case_decisionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of old_case_decisions to fetch.
     */
    orderBy?: old_case_decisionsOrderByWithRelationInput | old_case_decisionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for old_case_decisions.
     */
    cursor?: old_case_decisionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` old_case_decisions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` old_case_decisions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of old_case_decisions.
     */
    distinct?: Old_case_decisionsScalarFieldEnum | Old_case_decisionsScalarFieldEnum[]
  }

  /**
   * old_case_decisions findFirstOrThrow
   */
  export type old_case_decisionsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the old_case_decisions
     */
    select?: old_case_decisionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the old_case_decisions
     */
    omit?: old_case_decisionsOmit<ExtArgs> | null
    /**
     * Filter, which old_case_decisions to fetch.
     */
    where?: old_case_decisionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of old_case_decisions to fetch.
     */
    orderBy?: old_case_decisionsOrderByWithRelationInput | old_case_decisionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for old_case_decisions.
     */
    cursor?: old_case_decisionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` old_case_decisions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` old_case_decisions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of old_case_decisions.
     */
    distinct?: Old_case_decisionsScalarFieldEnum | Old_case_decisionsScalarFieldEnum[]
  }

  /**
   * old_case_decisions findMany
   */
  export type old_case_decisionsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the old_case_decisions
     */
    select?: old_case_decisionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the old_case_decisions
     */
    omit?: old_case_decisionsOmit<ExtArgs> | null
    /**
     * Filter, which old_case_decisions to fetch.
     */
    where?: old_case_decisionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of old_case_decisions to fetch.
     */
    orderBy?: old_case_decisionsOrderByWithRelationInput | old_case_decisionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing old_case_decisions.
     */
    cursor?: old_case_decisionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` old_case_decisions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` old_case_decisions.
     */
    skip?: number
    distinct?: Old_case_decisionsScalarFieldEnum | Old_case_decisionsScalarFieldEnum[]
  }

  /**
   * old_case_decisions create
   */
  export type old_case_decisionsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the old_case_decisions
     */
    select?: old_case_decisionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the old_case_decisions
     */
    omit?: old_case_decisionsOmit<ExtArgs> | null
    /**
     * The data needed to create a old_case_decisions.
     */
    data: XOR<old_case_decisionsCreateInput, old_case_decisionsUncheckedCreateInput>
  }

  /**
   * old_case_decisions createMany
   */
  export type old_case_decisionsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many old_case_decisions.
     */
    data: old_case_decisionsCreateManyInput | old_case_decisionsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * old_case_decisions update
   */
  export type old_case_decisionsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the old_case_decisions
     */
    select?: old_case_decisionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the old_case_decisions
     */
    omit?: old_case_decisionsOmit<ExtArgs> | null
    /**
     * The data needed to update a old_case_decisions.
     */
    data: XOR<old_case_decisionsUpdateInput, old_case_decisionsUncheckedUpdateInput>
    /**
     * Choose, which old_case_decisions to update.
     */
    where: old_case_decisionsWhereUniqueInput
  }

  /**
   * old_case_decisions updateMany
   */
  export type old_case_decisionsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update old_case_decisions.
     */
    data: XOR<old_case_decisionsUpdateManyMutationInput, old_case_decisionsUncheckedUpdateManyInput>
    /**
     * Filter which old_case_decisions to update
     */
    where?: old_case_decisionsWhereInput
    /**
     * Limit how many old_case_decisions to update.
     */
    limit?: number
  }

  /**
   * old_case_decisions upsert
   */
  export type old_case_decisionsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the old_case_decisions
     */
    select?: old_case_decisionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the old_case_decisions
     */
    omit?: old_case_decisionsOmit<ExtArgs> | null
    /**
     * The filter to search for the old_case_decisions to update in case it exists.
     */
    where: old_case_decisionsWhereUniqueInput
    /**
     * In case the old_case_decisions found by the `where` argument doesn't exist, create a new old_case_decisions with this data.
     */
    create: XOR<old_case_decisionsCreateInput, old_case_decisionsUncheckedCreateInput>
    /**
     * In case the old_case_decisions was found with the provided `where` argument, update it with this data.
     */
    update: XOR<old_case_decisionsUpdateInput, old_case_decisionsUncheckedUpdateInput>
  }

  /**
   * old_case_decisions delete
   */
  export type old_case_decisionsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the old_case_decisions
     */
    select?: old_case_decisionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the old_case_decisions
     */
    omit?: old_case_decisionsOmit<ExtArgs> | null
    /**
     * Filter which old_case_decisions to delete.
     */
    where: old_case_decisionsWhereUniqueInput
  }

  /**
   * old_case_decisions deleteMany
   */
  export type old_case_decisionsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which old_case_decisions to delete
     */
    where?: old_case_decisionsWhereInput
    /**
     * Limit how many old_case_decisions to delete.
     */
    limit?: number
  }

  /**
   * old_case_decisions without action
   */
  export type old_case_decisionsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the old_case_decisions
     */
    select?: old_case_decisionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the old_case_decisions
     */
    omit?: old_case_decisionsOmit<ExtArgs> | null
  }


  /**
   * Model old_case_person
   */

  export type AggregateOld_case_person = {
    _count: Old_case_personCountAggregateOutputType | null
    _avg: Old_case_personAvgAggregateOutputType | null
    _sum: Old_case_personSumAggregateOutputType | null
    _min: Old_case_personMinAggregateOutputType | null
    _max: Old_case_personMaxAggregateOutputType | null
  }

  export type Old_case_personAvgAggregateOutputType = {
    old_person_id: number | null
    old_case_id: number | null
    sex: number | null
    role: number | null
    citizenship_id: number | null
    etnicity: number | null
    religion: number | null
    invalid: number | null
    pregnant: number | null
    seriously_ill: number | null
    trafficking_victim: number | null
    violence_victim: number | null
    illegal_border: number | null
    transfer_moj: number | null
    deport_prescurator: number | null
    prison: number | null
    doc_type: number | null
    status: number | null
  }

  export type Old_case_personSumAggregateOutputType = {
    old_person_id: number | null
    old_case_id: number | null
    sex: number | null
    role: number | null
    citizenship_id: number | null
    etnicity: number | null
    religion: number | null
    invalid: number | null
    pregnant: number | null
    seriously_ill: number | null
    trafficking_victim: number | null
    violence_victim: number | null
    illegal_border: number | null
    transfer_moj: number | null
    deport_prescurator: number | null
    prison: number | null
    doc_type: number | null
    status: number | null
  }

  export type Old_case_personMinAggregateOutputType = {
    old_person_id: number | null
    old_case_id: number | null
    f_name_arm: string | null
    l_name_arm: string | null
    p_name_arm: string | null
    f_name_eng: string | null
    l_name_eng: string | null
    p_name_eng: string | null
    sex: number | null
    b_day: string | null
    b_month: string | null
    b_year: string | null
    role: number | null
    citizenship_id: number | null
    card_num: string | null
    doc_num: string | null
    etnicity: number | null
    religion: number | null
    invalid: number | null
    pregnant: number | null
    seriously_ill: number | null
    trafficking_victim: number | null
    violence_victim: number | null
    comment: string | null
    illegal_border: number | null
    transfer_moj: number | null
    deport_prescurator: number | null
    prison: number | null
    image: string | null
    pnum: string | null
    doc_type: number | null
    document_num: string | null
    status: number | null
  }

  export type Old_case_personMaxAggregateOutputType = {
    old_person_id: number | null
    old_case_id: number | null
    f_name_arm: string | null
    l_name_arm: string | null
    p_name_arm: string | null
    f_name_eng: string | null
    l_name_eng: string | null
    p_name_eng: string | null
    sex: number | null
    b_day: string | null
    b_month: string | null
    b_year: string | null
    role: number | null
    citizenship_id: number | null
    card_num: string | null
    doc_num: string | null
    etnicity: number | null
    religion: number | null
    invalid: number | null
    pregnant: number | null
    seriously_ill: number | null
    trafficking_victim: number | null
    violence_victim: number | null
    comment: string | null
    illegal_border: number | null
    transfer_moj: number | null
    deport_prescurator: number | null
    prison: number | null
    image: string | null
    pnum: string | null
    doc_type: number | null
    document_num: string | null
    status: number | null
  }

  export type Old_case_personCountAggregateOutputType = {
    old_person_id: number
    old_case_id: number
    f_name_arm: number
    l_name_arm: number
    p_name_arm: number
    f_name_eng: number
    l_name_eng: number
    p_name_eng: number
    sex: number
    b_day: number
    b_month: number
    b_year: number
    role: number
    citizenship_id: number
    card_num: number
    doc_num: number
    etnicity: number
    religion: number
    invalid: number
    pregnant: number
    seriously_ill: number
    trafficking_victim: number
    violence_victim: number
    comment: number
    illegal_border: number
    transfer_moj: number
    deport_prescurator: number
    prison: number
    image: number
    pnum: number
    doc_type: number
    document_num: number
    status: number
    _all: number
  }


  export type Old_case_personAvgAggregateInputType = {
    old_person_id?: true
    old_case_id?: true
    sex?: true
    role?: true
    citizenship_id?: true
    etnicity?: true
    religion?: true
    invalid?: true
    pregnant?: true
    seriously_ill?: true
    trafficking_victim?: true
    violence_victim?: true
    illegal_border?: true
    transfer_moj?: true
    deport_prescurator?: true
    prison?: true
    doc_type?: true
    status?: true
  }

  export type Old_case_personSumAggregateInputType = {
    old_person_id?: true
    old_case_id?: true
    sex?: true
    role?: true
    citizenship_id?: true
    etnicity?: true
    religion?: true
    invalid?: true
    pregnant?: true
    seriously_ill?: true
    trafficking_victim?: true
    violence_victim?: true
    illegal_border?: true
    transfer_moj?: true
    deport_prescurator?: true
    prison?: true
    doc_type?: true
    status?: true
  }

  export type Old_case_personMinAggregateInputType = {
    old_person_id?: true
    old_case_id?: true
    f_name_arm?: true
    l_name_arm?: true
    p_name_arm?: true
    f_name_eng?: true
    l_name_eng?: true
    p_name_eng?: true
    sex?: true
    b_day?: true
    b_month?: true
    b_year?: true
    role?: true
    citizenship_id?: true
    card_num?: true
    doc_num?: true
    etnicity?: true
    religion?: true
    invalid?: true
    pregnant?: true
    seriously_ill?: true
    trafficking_victim?: true
    violence_victim?: true
    comment?: true
    illegal_border?: true
    transfer_moj?: true
    deport_prescurator?: true
    prison?: true
    image?: true
    pnum?: true
    doc_type?: true
    document_num?: true
    status?: true
  }

  export type Old_case_personMaxAggregateInputType = {
    old_person_id?: true
    old_case_id?: true
    f_name_arm?: true
    l_name_arm?: true
    p_name_arm?: true
    f_name_eng?: true
    l_name_eng?: true
    p_name_eng?: true
    sex?: true
    b_day?: true
    b_month?: true
    b_year?: true
    role?: true
    citizenship_id?: true
    card_num?: true
    doc_num?: true
    etnicity?: true
    religion?: true
    invalid?: true
    pregnant?: true
    seriously_ill?: true
    trafficking_victim?: true
    violence_victim?: true
    comment?: true
    illegal_border?: true
    transfer_moj?: true
    deport_prescurator?: true
    prison?: true
    image?: true
    pnum?: true
    doc_type?: true
    document_num?: true
    status?: true
  }

  export type Old_case_personCountAggregateInputType = {
    old_person_id?: true
    old_case_id?: true
    f_name_arm?: true
    l_name_arm?: true
    p_name_arm?: true
    f_name_eng?: true
    l_name_eng?: true
    p_name_eng?: true
    sex?: true
    b_day?: true
    b_month?: true
    b_year?: true
    role?: true
    citizenship_id?: true
    card_num?: true
    doc_num?: true
    etnicity?: true
    religion?: true
    invalid?: true
    pregnant?: true
    seriously_ill?: true
    trafficking_victim?: true
    violence_victim?: true
    comment?: true
    illegal_border?: true
    transfer_moj?: true
    deport_prescurator?: true
    prison?: true
    image?: true
    pnum?: true
    doc_type?: true
    document_num?: true
    status?: true
    _all?: true
  }

  export type Old_case_personAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which old_case_person to aggregate.
     */
    where?: old_case_personWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of old_case_people to fetch.
     */
    orderBy?: old_case_personOrderByWithRelationInput | old_case_personOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: old_case_personWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` old_case_people from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` old_case_people.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned old_case_people
    **/
    _count?: true | Old_case_personCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Old_case_personAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Old_case_personSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Old_case_personMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Old_case_personMaxAggregateInputType
  }

  export type GetOld_case_personAggregateType<T extends Old_case_personAggregateArgs> = {
        [P in keyof T & keyof AggregateOld_case_person]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOld_case_person[P]>
      : GetScalarType<T[P], AggregateOld_case_person[P]>
  }




  export type old_case_personGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: old_case_personWhereInput
    orderBy?: old_case_personOrderByWithAggregationInput | old_case_personOrderByWithAggregationInput[]
    by: Old_case_personScalarFieldEnum[] | Old_case_personScalarFieldEnum
    having?: old_case_personScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Old_case_personCountAggregateInputType | true
    _avg?: Old_case_personAvgAggregateInputType
    _sum?: Old_case_personSumAggregateInputType
    _min?: Old_case_personMinAggregateInputType
    _max?: Old_case_personMaxAggregateInputType
  }

  export type Old_case_personGroupByOutputType = {
    old_person_id: number
    old_case_id: number
    f_name_arm: string | null
    l_name_arm: string | null
    p_name_arm: string | null
    f_name_eng: string | null
    l_name_eng: string | null
    p_name_eng: string | null
    sex: number
    b_day: string | null
    b_month: string | null
    b_year: string | null
    role: number
    citizenship_id: number | null
    card_num: string | null
    doc_num: string | null
    etnicity: number | null
    religion: number | null
    invalid: number
    pregnant: number
    seriously_ill: number
    trafficking_victim: number
    violence_victim: number
    comment: string | null
    illegal_border: number
    transfer_moj: number | null
    deport_prescurator: number
    prison: number
    image: string | null
    pnum: string | null
    doc_type: number | null
    document_num: string | null
    status: number | null
    _count: Old_case_personCountAggregateOutputType | null
    _avg: Old_case_personAvgAggregateOutputType | null
    _sum: Old_case_personSumAggregateOutputType | null
    _min: Old_case_personMinAggregateOutputType | null
    _max: Old_case_personMaxAggregateOutputType | null
  }

  type GetOld_case_personGroupByPayload<T extends old_case_personGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Old_case_personGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Old_case_personGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Old_case_personGroupByOutputType[P]>
            : GetScalarType<T[P], Old_case_personGroupByOutputType[P]>
        }
      >
    >


  export type old_case_personSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    old_person_id?: boolean
    old_case_id?: boolean
    f_name_arm?: boolean
    l_name_arm?: boolean
    p_name_arm?: boolean
    f_name_eng?: boolean
    l_name_eng?: boolean
    p_name_eng?: boolean
    sex?: boolean
    b_day?: boolean
    b_month?: boolean
    b_year?: boolean
    role?: boolean
    citizenship_id?: boolean
    card_num?: boolean
    doc_num?: boolean
    etnicity?: boolean
    religion?: boolean
    invalid?: boolean
    pregnant?: boolean
    seriously_ill?: boolean
    trafficking_victim?: boolean
    violence_victim?: boolean
    comment?: boolean
    illegal_border?: boolean
    transfer_moj?: boolean
    deport_prescurator?: boolean
    prison?: boolean
    image?: boolean
    pnum?: boolean
    doc_type?: boolean
    document_num?: boolean
    status?: boolean
  }, ExtArgs["result"]["old_case_person"]>



  export type old_case_personSelectScalar = {
    old_person_id?: boolean
    old_case_id?: boolean
    f_name_arm?: boolean
    l_name_arm?: boolean
    p_name_arm?: boolean
    f_name_eng?: boolean
    l_name_eng?: boolean
    p_name_eng?: boolean
    sex?: boolean
    b_day?: boolean
    b_month?: boolean
    b_year?: boolean
    role?: boolean
    citizenship_id?: boolean
    card_num?: boolean
    doc_num?: boolean
    etnicity?: boolean
    religion?: boolean
    invalid?: boolean
    pregnant?: boolean
    seriously_ill?: boolean
    trafficking_victim?: boolean
    violence_victim?: boolean
    comment?: boolean
    illegal_border?: boolean
    transfer_moj?: boolean
    deport_prescurator?: boolean
    prison?: boolean
    image?: boolean
    pnum?: boolean
    doc_type?: boolean
    document_num?: boolean
    status?: boolean
  }

  export type old_case_personOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"old_person_id" | "old_case_id" | "f_name_arm" | "l_name_arm" | "p_name_arm" | "f_name_eng" | "l_name_eng" | "p_name_eng" | "sex" | "b_day" | "b_month" | "b_year" | "role" | "citizenship_id" | "card_num" | "doc_num" | "etnicity" | "religion" | "invalid" | "pregnant" | "seriously_ill" | "trafficking_victim" | "violence_victim" | "comment" | "illegal_border" | "transfer_moj" | "deport_prescurator" | "prison" | "image" | "pnum" | "doc_type" | "document_num" | "status", ExtArgs["result"]["old_case_person"]>

  export type $old_case_personPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "old_case_person"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      old_person_id: number
      old_case_id: number
      f_name_arm: string | null
      l_name_arm: string | null
      p_name_arm: string | null
      f_name_eng: string | null
      l_name_eng: string | null
      p_name_eng: string | null
      sex: number
      b_day: string | null
      b_month: string | null
      b_year: string | null
      role: number
      citizenship_id: number | null
      card_num: string | null
      doc_num: string | null
      etnicity: number | null
      religion: number | null
      invalid: number
      pregnant: number
      seriously_ill: number
      trafficking_victim: number
      violence_victim: number
      comment: string | null
      illegal_border: number
      transfer_moj: number | null
      deport_prescurator: number
      prison: number
      image: string | null
      pnum: string | null
      doc_type: number | null
      document_num: string | null
      status: number | null
    }, ExtArgs["result"]["old_case_person"]>
    composites: {}
  }

  type old_case_personGetPayload<S extends boolean | null | undefined | old_case_personDefaultArgs> = $Result.GetResult<Prisma.$old_case_personPayload, S>

  type old_case_personCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<old_case_personFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Old_case_personCountAggregateInputType | true
    }

  export interface old_case_personDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['old_case_person'], meta: { name: 'old_case_person' } }
    /**
     * Find zero or one Old_case_person that matches the filter.
     * @param {old_case_personFindUniqueArgs} args - Arguments to find a Old_case_person
     * @example
     * // Get one Old_case_person
     * const old_case_person = await prisma.old_case_person.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends old_case_personFindUniqueArgs>(args: SelectSubset<T, old_case_personFindUniqueArgs<ExtArgs>>): Prisma__old_case_personClient<$Result.GetResult<Prisma.$old_case_personPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Old_case_person that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {old_case_personFindUniqueOrThrowArgs} args - Arguments to find a Old_case_person
     * @example
     * // Get one Old_case_person
     * const old_case_person = await prisma.old_case_person.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends old_case_personFindUniqueOrThrowArgs>(args: SelectSubset<T, old_case_personFindUniqueOrThrowArgs<ExtArgs>>): Prisma__old_case_personClient<$Result.GetResult<Prisma.$old_case_personPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Old_case_person that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {old_case_personFindFirstArgs} args - Arguments to find a Old_case_person
     * @example
     * // Get one Old_case_person
     * const old_case_person = await prisma.old_case_person.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends old_case_personFindFirstArgs>(args?: SelectSubset<T, old_case_personFindFirstArgs<ExtArgs>>): Prisma__old_case_personClient<$Result.GetResult<Prisma.$old_case_personPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Old_case_person that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {old_case_personFindFirstOrThrowArgs} args - Arguments to find a Old_case_person
     * @example
     * // Get one Old_case_person
     * const old_case_person = await prisma.old_case_person.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends old_case_personFindFirstOrThrowArgs>(args?: SelectSubset<T, old_case_personFindFirstOrThrowArgs<ExtArgs>>): Prisma__old_case_personClient<$Result.GetResult<Prisma.$old_case_personPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Old_case_people that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {old_case_personFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Old_case_people
     * const old_case_people = await prisma.old_case_person.findMany()
     * 
     * // Get first 10 Old_case_people
     * const old_case_people = await prisma.old_case_person.findMany({ take: 10 })
     * 
     * // Only select the `old_person_id`
     * const old_case_personWithOld_person_idOnly = await prisma.old_case_person.findMany({ select: { old_person_id: true } })
     * 
     */
    findMany<T extends old_case_personFindManyArgs>(args?: SelectSubset<T, old_case_personFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$old_case_personPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Old_case_person.
     * @param {old_case_personCreateArgs} args - Arguments to create a Old_case_person.
     * @example
     * // Create one Old_case_person
     * const Old_case_person = await prisma.old_case_person.create({
     *   data: {
     *     // ... data to create a Old_case_person
     *   }
     * })
     * 
     */
    create<T extends old_case_personCreateArgs>(args: SelectSubset<T, old_case_personCreateArgs<ExtArgs>>): Prisma__old_case_personClient<$Result.GetResult<Prisma.$old_case_personPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Old_case_people.
     * @param {old_case_personCreateManyArgs} args - Arguments to create many Old_case_people.
     * @example
     * // Create many Old_case_people
     * const old_case_person = await prisma.old_case_person.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends old_case_personCreateManyArgs>(args?: SelectSubset<T, old_case_personCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Old_case_person.
     * @param {old_case_personDeleteArgs} args - Arguments to delete one Old_case_person.
     * @example
     * // Delete one Old_case_person
     * const Old_case_person = await prisma.old_case_person.delete({
     *   where: {
     *     // ... filter to delete one Old_case_person
     *   }
     * })
     * 
     */
    delete<T extends old_case_personDeleteArgs>(args: SelectSubset<T, old_case_personDeleteArgs<ExtArgs>>): Prisma__old_case_personClient<$Result.GetResult<Prisma.$old_case_personPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Old_case_person.
     * @param {old_case_personUpdateArgs} args - Arguments to update one Old_case_person.
     * @example
     * // Update one Old_case_person
     * const old_case_person = await prisma.old_case_person.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends old_case_personUpdateArgs>(args: SelectSubset<T, old_case_personUpdateArgs<ExtArgs>>): Prisma__old_case_personClient<$Result.GetResult<Prisma.$old_case_personPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Old_case_people.
     * @param {old_case_personDeleteManyArgs} args - Arguments to filter Old_case_people to delete.
     * @example
     * // Delete a few Old_case_people
     * const { count } = await prisma.old_case_person.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends old_case_personDeleteManyArgs>(args?: SelectSubset<T, old_case_personDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Old_case_people.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {old_case_personUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Old_case_people
     * const old_case_person = await prisma.old_case_person.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends old_case_personUpdateManyArgs>(args: SelectSubset<T, old_case_personUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Old_case_person.
     * @param {old_case_personUpsertArgs} args - Arguments to update or create a Old_case_person.
     * @example
     * // Update or create a Old_case_person
     * const old_case_person = await prisma.old_case_person.upsert({
     *   create: {
     *     // ... data to create a Old_case_person
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Old_case_person we want to update
     *   }
     * })
     */
    upsert<T extends old_case_personUpsertArgs>(args: SelectSubset<T, old_case_personUpsertArgs<ExtArgs>>): Prisma__old_case_personClient<$Result.GetResult<Prisma.$old_case_personPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Old_case_people.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {old_case_personCountArgs} args - Arguments to filter Old_case_people to count.
     * @example
     * // Count the number of Old_case_people
     * const count = await prisma.old_case_person.count({
     *   where: {
     *     // ... the filter for the Old_case_people we want to count
     *   }
     * })
    **/
    count<T extends old_case_personCountArgs>(
      args?: Subset<T, old_case_personCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Old_case_personCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Old_case_person.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Old_case_personAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Old_case_personAggregateArgs>(args: Subset<T, Old_case_personAggregateArgs>): Prisma.PrismaPromise<GetOld_case_personAggregateType<T>>

    /**
     * Group by Old_case_person.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {old_case_personGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends old_case_personGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: old_case_personGroupByArgs['orderBy'] }
        : { orderBy?: old_case_personGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, old_case_personGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOld_case_personGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the old_case_person model
   */
  readonly fields: old_case_personFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for old_case_person.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__old_case_personClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the old_case_person model
   */
  interface old_case_personFieldRefs {
    readonly old_person_id: FieldRef<"old_case_person", 'Int'>
    readonly old_case_id: FieldRef<"old_case_person", 'Int'>
    readonly f_name_arm: FieldRef<"old_case_person", 'String'>
    readonly l_name_arm: FieldRef<"old_case_person", 'String'>
    readonly p_name_arm: FieldRef<"old_case_person", 'String'>
    readonly f_name_eng: FieldRef<"old_case_person", 'String'>
    readonly l_name_eng: FieldRef<"old_case_person", 'String'>
    readonly p_name_eng: FieldRef<"old_case_person", 'String'>
    readonly sex: FieldRef<"old_case_person", 'Int'>
    readonly b_day: FieldRef<"old_case_person", 'String'>
    readonly b_month: FieldRef<"old_case_person", 'String'>
    readonly b_year: FieldRef<"old_case_person", 'String'>
    readonly role: FieldRef<"old_case_person", 'Int'>
    readonly citizenship_id: FieldRef<"old_case_person", 'Int'>
    readonly card_num: FieldRef<"old_case_person", 'String'>
    readonly doc_num: FieldRef<"old_case_person", 'String'>
    readonly etnicity: FieldRef<"old_case_person", 'Int'>
    readonly religion: FieldRef<"old_case_person", 'Int'>
    readonly invalid: FieldRef<"old_case_person", 'Int'>
    readonly pregnant: FieldRef<"old_case_person", 'Int'>
    readonly seriously_ill: FieldRef<"old_case_person", 'Int'>
    readonly trafficking_victim: FieldRef<"old_case_person", 'Int'>
    readonly violence_victim: FieldRef<"old_case_person", 'Int'>
    readonly comment: FieldRef<"old_case_person", 'String'>
    readonly illegal_border: FieldRef<"old_case_person", 'Int'>
    readonly transfer_moj: FieldRef<"old_case_person", 'Int'>
    readonly deport_prescurator: FieldRef<"old_case_person", 'Int'>
    readonly prison: FieldRef<"old_case_person", 'Int'>
    readonly image: FieldRef<"old_case_person", 'String'>
    readonly pnum: FieldRef<"old_case_person", 'String'>
    readonly doc_type: FieldRef<"old_case_person", 'Int'>
    readonly document_num: FieldRef<"old_case_person", 'String'>
    readonly status: FieldRef<"old_case_person", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * old_case_person findUnique
   */
  export type old_case_personFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the old_case_person
     */
    select?: old_case_personSelect<ExtArgs> | null
    /**
     * Omit specific fields from the old_case_person
     */
    omit?: old_case_personOmit<ExtArgs> | null
    /**
     * Filter, which old_case_person to fetch.
     */
    where: old_case_personWhereUniqueInput
  }

  /**
   * old_case_person findUniqueOrThrow
   */
  export type old_case_personFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the old_case_person
     */
    select?: old_case_personSelect<ExtArgs> | null
    /**
     * Omit specific fields from the old_case_person
     */
    omit?: old_case_personOmit<ExtArgs> | null
    /**
     * Filter, which old_case_person to fetch.
     */
    where: old_case_personWhereUniqueInput
  }

  /**
   * old_case_person findFirst
   */
  export type old_case_personFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the old_case_person
     */
    select?: old_case_personSelect<ExtArgs> | null
    /**
     * Omit specific fields from the old_case_person
     */
    omit?: old_case_personOmit<ExtArgs> | null
    /**
     * Filter, which old_case_person to fetch.
     */
    where?: old_case_personWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of old_case_people to fetch.
     */
    orderBy?: old_case_personOrderByWithRelationInput | old_case_personOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for old_case_people.
     */
    cursor?: old_case_personWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` old_case_people from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` old_case_people.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of old_case_people.
     */
    distinct?: Old_case_personScalarFieldEnum | Old_case_personScalarFieldEnum[]
  }

  /**
   * old_case_person findFirstOrThrow
   */
  export type old_case_personFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the old_case_person
     */
    select?: old_case_personSelect<ExtArgs> | null
    /**
     * Omit specific fields from the old_case_person
     */
    omit?: old_case_personOmit<ExtArgs> | null
    /**
     * Filter, which old_case_person to fetch.
     */
    where?: old_case_personWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of old_case_people to fetch.
     */
    orderBy?: old_case_personOrderByWithRelationInput | old_case_personOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for old_case_people.
     */
    cursor?: old_case_personWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` old_case_people from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` old_case_people.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of old_case_people.
     */
    distinct?: Old_case_personScalarFieldEnum | Old_case_personScalarFieldEnum[]
  }

  /**
   * old_case_person findMany
   */
  export type old_case_personFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the old_case_person
     */
    select?: old_case_personSelect<ExtArgs> | null
    /**
     * Omit specific fields from the old_case_person
     */
    omit?: old_case_personOmit<ExtArgs> | null
    /**
     * Filter, which old_case_people to fetch.
     */
    where?: old_case_personWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of old_case_people to fetch.
     */
    orderBy?: old_case_personOrderByWithRelationInput | old_case_personOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing old_case_people.
     */
    cursor?: old_case_personWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` old_case_people from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` old_case_people.
     */
    skip?: number
    distinct?: Old_case_personScalarFieldEnum | Old_case_personScalarFieldEnum[]
  }

  /**
   * old_case_person create
   */
  export type old_case_personCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the old_case_person
     */
    select?: old_case_personSelect<ExtArgs> | null
    /**
     * Omit specific fields from the old_case_person
     */
    omit?: old_case_personOmit<ExtArgs> | null
    /**
     * The data needed to create a old_case_person.
     */
    data: XOR<old_case_personCreateInput, old_case_personUncheckedCreateInput>
  }

  /**
   * old_case_person createMany
   */
  export type old_case_personCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many old_case_people.
     */
    data: old_case_personCreateManyInput | old_case_personCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * old_case_person update
   */
  export type old_case_personUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the old_case_person
     */
    select?: old_case_personSelect<ExtArgs> | null
    /**
     * Omit specific fields from the old_case_person
     */
    omit?: old_case_personOmit<ExtArgs> | null
    /**
     * The data needed to update a old_case_person.
     */
    data: XOR<old_case_personUpdateInput, old_case_personUncheckedUpdateInput>
    /**
     * Choose, which old_case_person to update.
     */
    where: old_case_personWhereUniqueInput
  }

  /**
   * old_case_person updateMany
   */
  export type old_case_personUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update old_case_people.
     */
    data: XOR<old_case_personUpdateManyMutationInput, old_case_personUncheckedUpdateManyInput>
    /**
     * Filter which old_case_people to update
     */
    where?: old_case_personWhereInput
    /**
     * Limit how many old_case_people to update.
     */
    limit?: number
  }

  /**
   * old_case_person upsert
   */
  export type old_case_personUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the old_case_person
     */
    select?: old_case_personSelect<ExtArgs> | null
    /**
     * Omit specific fields from the old_case_person
     */
    omit?: old_case_personOmit<ExtArgs> | null
    /**
     * The filter to search for the old_case_person to update in case it exists.
     */
    where: old_case_personWhereUniqueInput
    /**
     * In case the old_case_person found by the `where` argument doesn't exist, create a new old_case_person with this data.
     */
    create: XOR<old_case_personCreateInput, old_case_personUncheckedCreateInput>
    /**
     * In case the old_case_person was found with the provided `where` argument, update it with this data.
     */
    update: XOR<old_case_personUpdateInput, old_case_personUncheckedUpdateInput>
  }

  /**
   * old_case_person delete
   */
  export type old_case_personDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the old_case_person
     */
    select?: old_case_personSelect<ExtArgs> | null
    /**
     * Omit specific fields from the old_case_person
     */
    omit?: old_case_personOmit<ExtArgs> | null
    /**
     * Filter which old_case_person to delete.
     */
    where: old_case_personWhereUniqueInput
  }

  /**
   * old_case_person deleteMany
   */
  export type old_case_personDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which old_case_people to delete
     */
    where?: old_case_personWhereInput
    /**
     * Limit how many old_case_people to delete.
     */
    limit?: number
  }

  /**
   * old_case_person without action
   */
  export type old_case_personDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the old_case_person
     */
    select?: old_case_personSelect<ExtArgs> | null
    /**
     * Omit specific fields from the old_case_person
     */
    omit?: old_case_personOmit<ExtArgs> | null
  }


  /**
   * Model old_cases
   */

  export type AggregateOld_cases = {
    _count: Old_casesCountAggregateOutputType | null
    _avg: Old_casesAvgAggregateOutputType | null
    _sum: Old_casesSumAggregateOutputType | null
    _min: Old_casesMinAggregateOutputType | null
    _max: Old_casesMaxAggregateOutputType | null
  }

  export type Old_casesAvgAggregateOutputType = {
    old_case_id: number | null
    citizenship: number | null
    marz_id: number | null
    community_id: number | null
    bnak_id: number | null
    unaccompanied_child: number | null
    separated_child: number | null
    single_parent: number | null
  }

  export type Old_casesSumAggregateOutputType = {
    old_case_id: number | null
    citizenship: number | null
    marz_id: number | null
    community_id: number | null
    bnak_id: number | null
    unaccompanied_child: number | null
    separated_child: number | null
    single_parent: number | null
  }

  export type Old_casesMinAggregateOutputType = {
    old_case_id: number | null
    application_date: Date | null
    citizenship: number | null
    RA_address: string | null
    building: string | null
    apartment: string | null
    marz_id: number | null
    community_id: number | null
    bnak_id: number | null
    unaccompanied_child: number | null
    separated_child: number | null
    single_parent: number | null
    prefered_language: string | null
    contact_tel: string | null
    comment: string | null
  }

  export type Old_casesMaxAggregateOutputType = {
    old_case_id: number | null
    application_date: Date | null
    citizenship: number | null
    RA_address: string | null
    building: string | null
    apartment: string | null
    marz_id: number | null
    community_id: number | null
    bnak_id: number | null
    unaccompanied_child: number | null
    separated_child: number | null
    single_parent: number | null
    prefered_language: string | null
    contact_tel: string | null
    comment: string | null
  }

  export type Old_casesCountAggregateOutputType = {
    old_case_id: number
    application_date: number
    citizenship: number
    RA_address: number
    building: number
    apartment: number
    marz_id: number
    community_id: number
    bnak_id: number
    unaccompanied_child: number
    separated_child: number
    single_parent: number
    prefered_language: number
    contact_tel: number
    comment: number
    _all: number
  }


  export type Old_casesAvgAggregateInputType = {
    old_case_id?: true
    citizenship?: true
    marz_id?: true
    community_id?: true
    bnak_id?: true
    unaccompanied_child?: true
    separated_child?: true
    single_parent?: true
  }

  export type Old_casesSumAggregateInputType = {
    old_case_id?: true
    citizenship?: true
    marz_id?: true
    community_id?: true
    bnak_id?: true
    unaccompanied_child?: true
    separated_child?: true
    single_parent?: true
  }

  export type Old_casesMinAggregateInputType = {
    old_case_id?: true
    application_date?: true
    citizenship?: true
    RA_address?: true
    building?: true
    apartment?: true
    marz_id?: true
    community_id?: true
    bnak_id?: true
    unaccompanied_child?: true
    separated_child?: true
    single_parent?: true
    prefered_language?: true
    contact_tel?: true
    comment?: true
  }

  export type Old_casesMaxAggregateInputType = {
    old_case_id?: true
    application_date?: true
    citizenship?: true
    RA_address?: true
    building?: true
    apartment?: true
    marz_id?: true
    community_id?: true
    bnak_id?: true
    unaccompanied_child?: true
    separated_child?: true
    single_parent?: true
    prefered_language?: true
    contact_tel?: true
    comment?: true
  }

  export type Old_casesCountAggregateInputType = {
    old_case_id?: true
    application_date?: true
    citizenship?: true
    RA_address?: true
    building?: true
    apartment?: true
    marz_id?: true
    community_id?: true
    bnak_id?: true
    unaccompanied_child?: true
    separated_child?: true
    single_parent?: true
    prefered_language?: true
    contact_tel?: true
    comment?: true
    _all?: true
  }

  export type Old_casesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which old_cases to aggregate.
     */
    where?: old_casesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of old_cases to fetch.
     */
    orderBy?: old_casesOrderByWithRelationInput | old_casesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: old_casesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` old_cases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` old_cases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned old_cases
    **/
    _count?: true | Old_casesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Old_casesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Old_casesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Old_casesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Old_casesMaxAggregateInputType
  }

  export type GetOld_casesAggregateType<T extends Old_casesAggregateArgs> = {
        [P in keyof T & keyof AggregateOld_cases]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOld_cases[P]>
      : GetScalarType<T[P], AggregateOld_cases[P]>
  }




  export type old_casesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: old_casesWhereInput
    orderBy?: old_casesOrderByWithAggregationInput | old_casesOrderByWithAggregationInput[]
    by: Old_casesScalarFieldEnum[] | Old_casesScalarFieldEnum
    having?: old_casesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Old_casesCountAggregateInputType | true
    _avg?: Old_casesAvgAggregateInputType
    _sum?: Old_casesSumAggregateInputType
    _min?: Old_casesMinAggregateInputType
    _max?: Old_casesMaxAggregateInputType
  }

  export type Old_casesGroupByOutputType = {
    old_case_id: number
    application_date: Date
    citizenship: number
    RA_address: string | null
    building: string | null
    apartment: string | null
    marz_id: number | null
    community_id: number | null
    bnak_id: number | null
    unaccompanied_child: number
    separated_child: number
    single_parent: number
    prefered_language: string | null
    contact_tel: string | null
    comment: string | null
    _count: Old_casesCountAggregateOutputType | null
    _avg: Old_casesAvgAggregateOutputType | null
    _sum: Old_casesSumAggregateOutputType | null
    _min: Old_casesMinAggregateOutputType | null
    _max: Old_casesMaxAggregateOutputType | null
  }

  type GetOld_casesGroupByPayload<T extends old_casesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Old_casesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Old_casesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Old_casesGroupByOutputType[P]>
            : GetScalarType<T[P], Old_casesGroupByOutputType[P]>
        }
      >
    >


  export type old_casesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    old_case_id?: boolean
    application_date?: boolean
    citizenship?: boolean
    RA_address?: boolean
    building?: boolean
    apartment?: boolean
    marz_id?: boolean
    community_id?: boolean
    bnak_id?: boolean
    unaccompanied_child?: boolean
    separated_child?: boolean
    single_parent?: boolean
    prefered_language?: boolean
    contact_tel?: boolean
    comment?: boolean
  }, ExtArgs["result"]["old_cases"]>



  export type old_casesSelectScalar = {
    old_case_id?: boolean
    application_date?: boolean
    citizenship?: boolean
    RA_address?: boolean
    building?: boolean
    apartment?: boolean
    marz_id?: boolean
    community_id?: boolean
    bnak_id?: boolean
    unaccompanied_child?: boolean
    separated_child?: boolean
    single_parent?: boolean
    prefered_language?: boolean
    contact_tel?: boolean
    comment?: boolean
  }

  export type old_casesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"old_case_id" | "application_date" | "citizenship" | "RA_address" | "building" | "apartment" | "marz_id" | "community_id" | "bnak_id" | "unaccompanied_child" | "separated_child" | "single_parent" | "prefered_language" | "contact_tel" | "comment", ExtArgs["result"]["old_cases"]>

  export type $old_casesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "old_cases"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      old_case_id: number
      application_date: Date
      citizenship: number
      RA_address: string | null
      building: string | null
      apartment: string | null
      marz_id: number | null
      community_id: number | null
      bnak_id: number | null
      unaccompanied_child: number
      separated_child: number
      single_parent: number
      prefered_language: string | null
      contact_tel: string | null
      comment: string | null
    }, ExtArgs["result"]["old_cases"]>
    composites: {}
  }

  type old_casesGetPayload<S extends boolean | null | undefined | old_casesDefaultArgs> = $Result.GetResult<Prisma.$old_casesPayload, S>

  type old_casesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<old_casesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Old_casesCountAggregateInputType | true
    }

  export interface old_casesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['old_cases'], meta: { name: 'old_cases' } }
    /**
     * Find zero or one Old_cases that matches the filter.
     * @param {old_casesFindUniqueArgs} args - Arguments to find a Old_cases
     * @example
     * // Get one Old_cases
     * const old_cases = await prisma.old_cases.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends old_casesFindUniqueArgs>(args: SelectSubset<T, old_casesFindUniqueArgs<ExtArgs>>): Prisma__old_casesClient<$Result.GetResult<Prisma.$old_casesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Old_cases that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {old_casesFindUniqueOrThrowArgs} args - Arguments to find a Old_cases
     * @example
     * // Get one Old_cases
     * const old_cases = await prisma.old_cases.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends old_casesFindUniqueOrThrowArgs>(args: SelectSubset<T, old_casesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__old_casesClient<$Result.GetResult<Prisma.$old_casesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Old_cases that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {old_casesFindFirstArgs} args - Arguments to find a Old_cases
     * @example
     * // Get one Old_cases
     * const old_cases = await prisma.old_cases.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends old_casesFindFirstArgs>(args?: SelectSubset<T, old_casesFindFirstArgs<ExtArgs>>): Prisma__old_casesClient<$Result.GetResult<Prisma.$old_casesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Old_cases that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {old_casesFindFirstOrThrowArgs} args - Arguments to find a Old_cases
     * @example
     * // Get one Old_cases
     * const old_cases = await prisma.old_cases.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends old_casesFindFirstOrThrowArgs>(args?: SelectSubset<T, old_casesFindFirstOrThrowArgs<ExtArgs>>): Prisma__old_casesClient<$Result.GetResult<Prisma.$old_casesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Old_cases that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {old_casesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Old_cases
     * const old_cases = await prisma.old_cases.findMany()
     * 
     * // Get first 10 Old_cases
     * const old_cases = await prisma.old_cases.findMany({ take: 10 })
     * 
     * // Only select the `old_case_id`
     * const old_casesWithOld_case_idOnly = await prisma.old_cases.findMany({ select: { old_case_id: true } })
     * 
     */
    findMany<T extends old_casesFindManyArgs>(args?: SelectSubset<T, old_casesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$old_casesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Old_cases.
     * @param {old_casesCreateArgs} args - Arguments to create a Old_cases.
     * @example
     * // Create one Old_cases
     * const Old_cases = await prisma.old_cases.create({
     *   data: {
     *     // ... data to create a Old_cases
     *   }
     * })
     * 
     */
    create<T extends old_casesCreateArgs>(args: SelectSubset<T, old_casesCreateArgs<ExtArgs>>): Prisma__old_casesClient<$Result.GetResult<Prisma.$old_casesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Old_cases.
     * @param {old_casesCreateManyArgs} args - Arguments to create many Old_cases.
     * @example
     * // Create many Old_cases
     * const old_cases = await prisma.old_cases.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends old_casesCreateManyArgs>(args?: SelectSubset<T, old_casesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Old_cases.
     * @param {old_casesDeleteArgs} args - Arguments to delete one Old_cases.
     * @example
     * // Delete one Old_cases
     * const Old_cases = await prisma.old_cases.delete({
     *   where: {
     *     // ... filter to delete one Old_cases
     *   }
     * })
     * 
     */
    delete<T extends old_casesDeleteArgs>(args: SelectSubset<T, old_casesDeleteArgs<ExtArgs>>): Prisma__old_casesClient<$Result.GetResult<Prisma.$old_casesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Old_cases.
     * @param {old_casesUpdateArgs} args - Arguments to update one Old_cases.
     * @example
     * // Update one Old_cases
     * const old_cases = await prisma.old_cases.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends old_casesUpdateArgs>(args: SelectSubset<T, old_casesUpdateArgs<ExtArgs>>): Prisma__old_casesClient<$Result.GetResult<Prisma.$old_casesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Old_cases.
     * @param {old_casesDeleteManyArgs} args - Arguments to filter Old_cases to delete.
     * @example
     * // Delete a few Old_cases
     * const { count } = await prisma.old_cases.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends old_casesDeleteManyArgs>(args?: SelectSubset<T, old_casesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Old_cases.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {old_casesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Old_cases
     * const old_cases = await prisma.old_cases.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends old_casesUpdateManyArgs>(args: SelectSubset<T, old_casesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Old_cases.
     * @param {old_casesUpsertArgs} args - Arguments to update or create a Old_cases.
     * @example
     * // Update or create a Old_cases
     * const old_cases = await prisma.old_cases.upsert({
     *   create: {
     *     // ... data to create a Old_cases
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Old_cases we want to update
     *   }
     * })
     */
    upsert<T extends old_casesUpsertArgs>(args: SelectSubset<T, old_casesUpsertArgs<ExtArgs>>): Prisma__old_casesClient<$Result.GetResult<Prisma.$old_casesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Old_cases.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {old_casesCountArgs} args - Arguments to filter Old_cases to count.
     * @example
     * // Count the number of Old_cases
     * const count = await prisma.old_cases.count({
     *   where: {
     *     // ... the filter for the Old_cases we want to count
     *   }
     * })
    **/
    count<T extends old_casesCountArgs>(
      args?: Subset<T, old_casesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Old_casesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Old_cases.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Old_casesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Old_casesAggregateArgs>(args: Subset<T, Old_casesAggregateArgs>): Prisma.PrismaPromise<GetOld_casesAggregateType<T>>

    /**
     * Group by Old_cases.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {old_casesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends old_casesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: old_casesGroupByArgs['orderBy'] }
        : { orderBy?: old_casesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, old_casesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOld_casesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the old_cases model
   */
  readonly fields: old_casesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for old_cases.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__old_casesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the old_cases model
   */
  interface old_casesFieldRefs {
    readonly old_case_id: FieldRef<"old_cases", 'Int'>
    readonly application_date: FieldRef<"old_cases", 'DateTime'>
    readonly citizenship: FieldRef<"old_cases", 'Int'>
    readonly RA_address: FieldRef<"old_cases", 'String'>
    readonly building: FieldRef<"old_cases", 'String'>
    readonly apartment: FieldRef<"old_cases", 'String'>
    readonly marz_id: FieldRef<"old_cases", 'Int'>
    readonly community_id: FieldRef<"old_cases", 'Int'>
    readonly bnak_id: FieldRef<"old_cases", 'Int'>
    readonly unaccompanied_child: FieldRef<"old_cases", 'Int'>
    readonly separated_child: FieldRef<"old_cases", 'Int'>
    readonly single_parent: FieldRef<"old_cases", 'Int'>
    readonly prefered_language: FieldRef<"old_cases", 'String'>
    readonly contact_tel: FieldRef<"old_cases", 'String'>
    readonly comment: FieldRef<"old_cases", 'String'>
  }
    

  // Custom InputTypes
  /**
   * old_cases findUnique
   */
  export type old_casesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the old_cases
     */
    select?: old_casesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the old_cases
     */
    omit?: old_casesOmit<ExtArgs> | null
    /**
     * Filter, which old_cases to fetch.
     */
    where: old_casesWhereUniqueInput
  }

  /**
   * old_cases findUniqueOrThrow
   */
  export type old_casesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the old_cases
     */
    select?: old_casesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the old_cases
     */
    omit?: old_casesOmit<ExtArgs> | null
    /**
     * Filter, which old_cases to fetch.
     */
    where: old_casesWhereUniqueInput
  }

  /**
   * old_cases findFirst
   */
  export type old_casesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the old_cases
     */
    select?: old_casesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the old_cases
     */
    omit?: old_casesOmit<ExtArgs> | null
    /**
     * Filter, which old_cases to fetch.
     */
    where?: old_casesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of old_cases to fetch.
     */
    orderBy?: old_casesOrderByWithRelationInput | old_casesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for old_cases.
     */
    cursor?: old_casesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` old_cases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` old_cases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of old_cases.
     */
    distinct?: Old_casesScalarFieldEnum | Old_casesScalarFieldEnum[]
  }

  /**
   * old_cases findFirstOrThrow
   */
  export type old_casesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the old_cases
     */
    select?: old_casesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the old_cases
     */
    omit?: old_casesOmit<ExtArgs> | null
    /**
     * Filter, which old_cases to fetch.
     */
    where?: old_casesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of old_cases to fetch.
     */
    orderBy?: old_casesOrderByWithRelationInput | old_casesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for old_cases.
     */
    cursor?: old_casesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` old_cases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` old_cases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of old_cases.
     */
    distinct?: Old_casesScalarFieldEnum | Old_casesScalarFieldEnum[]
  }

  /**
   * old_cases findMany
   */
  export type old_casesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the old_cases
     */
    select?: old_casesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the old_cases
     */
    omit?: old_casesOmit<ExtArgs> | null
    /**
     * Filter, which old_cases to fetch.
     */
    where?: old_casesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of old_cases to fetch.
     */
    orderBy?: old_casesOrderByWithRelationInput | old_casesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing old_cases.
     */
    cursor?: old_casesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` old_cases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` old_cases.
     */
    skip?: number
    distinct?: Old_casesScalarFieldEnum | Old_casesScalarFieldEnum[]
  }

  /**
   * old_cases create
   */
  export type old_casesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the old_cases
     */
    select?: old_casesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the old_cases
     */
    omit?: old_casesOmit<ExtArgs> | null
    /**
     * The data needed to create a old_cases.
     */
    data: XOR<old_casesCreateInput, old_casesUncheckedCreateInput>
  }

  /**
   * old_cases createMany
   */
  export type old_casesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many old_cases.
     */
    data: old_casesCreateManyInput | old_casesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * old_cases update
   */
  export type old_casesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the old_cases
     */
    select?: old_casesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the old_cases
     */
    omit?: old_casesOmit<ExtArgs> | null
    /**
     * The data needed to update a old_cases.
     */
    data: XOR<old_casesUpdateInput, old_casesUncheckedUpdateInput>
    /**
     * Choose, which old_cases to update.
     */
    where: old_casesWhereUniqueInput
  }

  /**
   * old_cases updateMany
   */
  export type old_casesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update old_cases.
     */
    data: XOR<old_casesUpdateManyMutationInput, old_casesUncheckedUpdateManyInput>
    /**
     * Filter which old_cases to update
     */
    where?: old_casesWhereInput
    /**
     * Limit how many old_cases to update.
     */
    limit?: number
  }

  /**
   * old_cases upsert
   */
  export type old_casesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the old_cases
     */
    select?: old_casesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the old_cases
     */
    omit?: old_casesOmit<ExtArgs> | null
    /**
     * The filter to search for the old_cases to update in case it exists.
     */
    where: old_casesWhereUniqueInput
    /**
     * In case the old_cases found by the `where` argument doesn't exist, create a new old_cases with this data.
     */
    create: XOR<old_casesCreateInput, old_casesUncheckedCreateInput>
    /**
     * In case the old_cases was found with the provided `where` argument, update it with this data.
     */
    update: XOR<old_casesUpdateInput, old_casesUncheckedUpdateInput>
  }

  /**
   * old_cases delete
   */
  export type old_casesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the old_cases
     */
    select?: old_casesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the old_cases
     */
    omit?: old_casesOmit<ExtArgs> | null
    /**
     * Filter which old_cases to delete.
     */
    where: old_casesWhereUniqueInput
  }

  /**
   * old_cases deleteMany
   */
  export type old_casesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which old_cases to delete
     */
    where?: old_casesWhereInput
    /**
     * Limit how many old_cases to delete.
     */
    limit?: number
  }

  /**
   * old_cases without action
   */
  export type old_casesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the old_cases
     */
    select?: old_casesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the old_cases
     */
    omit?: old_casesOmit<ExtArgs> | null
  }


  /**
   * Model tb_arm_com
   */

  export type AggregateTb_arm_com = {
    _count: Tb_arm_comCountAggregateOutputType | null
    _avg: Tb_arm_comAvgAggregateOutputType | null
    _sum: Tb_arm_comSumAggregateOutputType | null
    _min: Tb_arm_comMinAggregateOutputType | null
    _max: Tb_arm_comMaxAggregateOutputType | null
  }

  export type Tb_arm_comAvgAggregateOutputType = {
    community_id: number | null
    marz_id: number | null
    exist: number | null
    active: number | null
  }

  export type Tb_arm_comSumAggregateOutputType = {
    community_id: number | null
    marz_id: number | null
    exist: number | null
    active: number | null
  }

  export type Tb_arm_comMinAggregateOutputType = {
    community_id: number | null
    marz_id: number | null
    ADM3_PCODE: string | null
    ADM3_ARM: string | null
    ADM3_EN: string | null
    exist: number | null
    active: number | null
  }

  export type Tb_arm_comMaxAggregateOutputType = {
    community_id: number | null
    marz_id: number | null
    ADM3_PCODE: string | null
    ADM3_ARM: string | null
    ADM3_EN: string | null
    exist: number | null
    active: number | null
  }

  export type Tb_arm_comCountAggregateOutputType = {
    community_id: number
    marz_id: number
    ADM3_PCODE: number
    ADM3_ARM: number
    ADM3_EN: number
    exist: number
    active: number
    _all: number
  }


  export type Tb_arm_comAvgAggregateInputType = {
    community_id?: true
    marz_id?: true
    exist?: true
    active?: true
  }

  export type Tb_arm_comSumAggregateInputType = {
    community_id?: true
    marz_id?: true
    exist?: true
    active?: true
  }

  export type Tb_arm_comMinAggregateInputType = {
    community_id?: true
    marz_id?: true
    ADM3_PCODE?: true
    ADM3_ARM?: true
    ADM3_EN?: true
    exist?: true
    active?: true
  }

  export type Tb_arm_comMaxAggregateInputType = {
    community_id?: true
    marz_id?: true
    ADM3_PCODE?: true
    ADM3_ARM?: true
    ADM3_EN?: true
    exist?: true
    active?: true
  }

  export type Tb_arm_comCountAggregateInputType = {
    community_id?: true
    marz_id?: true
    ADM3_PCODE?: true
    ADM3_ARM?: true
    ADM3_EN?: true
    exist?: true
    active?: true
    _all?: true
  }

  export type Tb_arm_comAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tb_arm_com to aggregate.
     */
    where?: tb_arm_comWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tb_arm_coms to fetch.
     */
    orderBy?: tb_arm_comOrderByWithRelationInput | tb_arm_comOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: tb_arm_comWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tb_arm_coms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tb_arm_coms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned tb_arm_coms
    **/
    _count?: true | Tb_arm_comCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Tb_arm_comAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Tb_arm_comSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Tb_arm_comMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Tb_arm_comMaxAggregateInputType
  }

  export type GetTb_arm_comAggregateType<T extends Tb_arm_comAggregateArgs> = {
        [P in keyof T & keyof AggregateTb_arm_com]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTb_arm_com[P]>
      : GetScalarType<T[P], AggregateTb_arm_com[P]>
  }




  export type tb_arm_comGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: tb_arm_comWhereInput
    orderBy?: tb_arm_comOrderByWithAggregationInput | tb_arm_comOrderByWithAggregationInput[]
    by: Tb_arm_comScalarFieldEnum[] | Tb_arm_comScalarFieldEnum
    having?: tb_arm_comScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Tb_arm_comCountAggregateInputType | true
    _avg?: Tb_arm_comAvgAggregateInputType
    _sum?: Tb_arm_comSumAggregateInputType
    _min?: Tb_arm_comMinAggregateInputType
    _max?: Tb_arm_comMaxAggregateInputType
  }

  export type Tb_arm_comGroupByOutputType = {
    community_id: number
    marz_id: number
    ADM3_PCODE: string
    ADM3_ARM: string
    ADM3_EN: string
    exist: number
    active: number
    _count: Tb_arm_comCountAggregateOutputType | null
    _avg: Tb_arm_comAvgAggregateOutputType | null
    _sum: Tb_arm_comSumAggregateOutputType | null
    _min: Tb_arm_comMinAggregateOutputType | null
    _max: Tb_arm_comMaxAggregateOutputType | null
  }

  type GetTb_arm_comGroupByPayload<T extends tb_arm_comGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Tb_arm_comGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Tb_arm_comGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Tb_arm_comGroupByOutputType[P]>
            : GetScalarType<T[P], Tb_arm_comGroupByOutputType[P]>
        }
      >
    >


  export type tb_arm_comSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    community_id?: boolean
    marz_id?: boolean
    ADM3_PCODE?: boolean
    ADM3_ARM?: boolean
    ADM3_EN?: boolean
    exist?: boolean
    active?: boolean
  }, ExtArgs["result"]["tb_arm_com"]>



  export type tb_arm_comSelectScalar = {
    community_id?: boolean
    marz_id?: boolean
    ADM3_PCODE?: boolean
    ADM3_ARM?: boolean
    ADM3_EN?: boolean
    exist?: boolean
    active?: boolean
  }

  export type tb_arm_comOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"community_id" | "marz_id" | "ADM3_PCODE" | "ADM3_ARM" | "ADM3_EN" | "exist" | "active", ExtArgs["result"]["tb_arm_com"]>

  export type $tb_arm_comPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "tb_arm_com"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      community_id: number
      marz_id: number
      ADM3_PCODE: string
      ADM3_ARM: string
      ADM3_EN: string
      exist: number
      active: number
    }, ExtArgs["result"]["tb_arm_com"]>
    composites: {}
  }

  type tb_arm_comGetPayload<S extends boolean | null | undefined | tb_arm_comDefaultArgs> = $Result.GetResult<Prisma.$tb_arm_comPayload, S>

  type tb_arm_comCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<tb_arm_comFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Tb_arm_comCountAggregateInputType | true
    }

  export interface tb_arm_comDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['tb_arm_com'], meta: { name: 'tb_arm_com' } }
    /**
     * Find zero or one Tb_arm_com that matches the filter.
     * @param {tb_arm_comFindUniqueArgs} args - Arguments to find a Tb_arm_com
     * @example
     * // Get one Tb_arm_com
     * const tb_arm_com = await prisma.tb_arm_com.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends tb_arm_comFindUniqueArgs>(args: SelectSubset<T, tb_arm_comFindUniqueArgs<ExtArgs>>): Prisma__tb_arm_comClient<$Result.GetResult<Prisma.$tb_arm_comPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Tb_arm_com that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {tb_arm_comFindUniqueOrThrowArgs} args - Arguments to find a Tb_arm_com
     * @example
     * // Get one Tb_arm_com
     * const tb_arm_com = await prisma.tb_arm_com.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends tb_arm_comFindUniqueOrThrowArgs>(args: SelectSubset<T, tb_arm_comFindUniqueOrThrowArgs<ExtArgs>>): Prisma__tb_arm_comClient<$Result.GetResult<Prisma.$tb_arm_comPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tb_arm_com that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_arm_comFindFirstArgs} args - Arguments to find a Tb_arm_com
     * @example
     * // Get one Tb_arm_com
     * const tb_arm_com = await prisma.tb_arm_com.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends tb_arm_comFindFirstArgs>(args?: SelectSubset<T, tb_arm_comFindFirstArgs<ExtArgs>>): Prisma__tb_arm_comClient<$Result.GetResult<Prisma.$tb_arm_comPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tb_arm_com that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_arm_comFindFirstOrThrowArgs} args - Arguments to find a Tb_arm_com
     * @example
     * // Get one Tb_arm_com
     * const tb_arm_com = await prisma.tb_arm_com.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends tb_arm_comFindFirstOrThrowArgs>(args?: SelectSubset<T, tb_arm_comFindFirstOrThrowArgs<ExtArgs>>): Prisma__tb_arm_comClient<$Result.GetResult<Prisma.$tb_arm_comPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Tb_arm_coms that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_arm_comFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tb_arm_coms
     * const tb_arm_coms = await prisma.tb_arm_com.findMany()
     * 
     * // Get first 10 Tb_arm_coms
     * const tb_arm_coms = await prisma.tb_arm_com.findMany({ take: 10 })
     * 
     * // Only select the `community_id`
     * const tb_arm_comWithCommunity_idOnly = await prisma.tb_arm_com.findMany({ select: { community_id: true } })
     * 
     */
    findMany<T extends tb_arm_comFindManyArgs>(args?: SelectSubset<T, tb_arm_comFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tb_arm_comPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Tb_arm_com.
     * @param {tb_arm_comCreateArgs} args - Arguments to create a Tb_arm_com.
     * @example
     * // Create one Tb_arm_com
     * const Tb_arm_com = await prisma.tb_arm_com.create({
     *   data: {
     *     // ... data to create a Tb_arm_com
     *   }
     * })
     * 
     */
    create<T extends tb_arm_comCreateArgs>(args: SelectSubset<T, tb_arm_comCreateArgs<ExtArgs>>): Prisma__tb_arm_comClient<$Result.GetResult<Prisma.$tb_arm_comPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Tb_arm_coms.
     * @param {tb_arm_comCreateManyArgs} args - Arguments to create many Tb_arm_coms.
     * @example
     * // Create many Tb_arm_coms
     * const tb_arm_com = await prisma.tb_arm_com.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends tb_arm_comCreateManyArgs>(args?: SelectSubset<T, tb_arm_comCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Tb_arm_com.
     * @param {tb_arm_comDeleteArgs} args - Arguments to delete one Tb_arm_com.
     * @example
     * // Delete one Tb_arm_com
     * const Tb_arm_com = await prisma.tb_arm_com.delete({
     *   where: {
     *     // ... filter to delete one Tb_arm_com
     *   }
     * })
     * 
     */
    delete<T extends tb_arm_comDeleteArgs>(args: SelectSubset<T, tb_arm_comDeleteArgs<ExtArgs>>): Prisma__tb_arm_comClient<$Result.GetResult<Prisma.$tb_arm_comPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Tb_arm_com.
     * @param {tb_arm_comUpdateArgs} args - Arguments to update one Tb_arm_com.
     * @example
     * // Update one Tb_arm_com
     * const tb_arm_com = await prisma.tb_arm_com.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends tb_arm_comUpdateArgs>(args: SelectSubset<T, tb_arm_comUpdateArgs<ExtArgs>>): Prisma__tb_arm_comClient<$Result.GetResult<Prisma.$tb_arm_comPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Tb_arm_coms.
     * @param {tb_arm_comDeleteManyArgs} args - Arguments to filter Tb_arm_coms to delete.
     * @example
     * // Delete a few Tb_arm_coms
     * const { count } = await prisma.tb_arm_com.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends tb_arm_comDeleteManyArgs>(args?: SelectSubset<T, tb_arm_comDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tb_arm_coms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_arm_comUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tb_arm_coms
     * const tb_arm_com = await prisma.tb_arm_com.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends tb_arm_comUpdateManyArgs>(args: SelectSubset<T, tb_arm_comUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Tb_arm_com.
     * @param {tb_arm_comUpsertArgs} args - Arguments to update or create a Tb_arm_com.
     * @example
     * // Update or create a Tb_arm_com
     * const tb_arm_com = await prisma.tb_arm_com.upsert({
     *   create: {
     *     // ... data to create a Tb_arm_com
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tb_arm_com we want to update
     *   }
     * })
     */
    upsert<T extends tb_arm_comUpsertArgs>(args: SelectSubset<T, tb_arm_comUpsertArgs<ExtArgs>>): Prisma__tb_arm_comClient<$Result.GetResult<Prisma.$tb_arm_comPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Tb_arm_coms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_arm_comCountArgs} args - Arguments to filter Tb_arm_coms to count.
     * @example
     * // Count the number of Tb_arm_coms
     * const count = await prisma.tb_arm_com.count({
     *   where: {
     *     // ... the filter for the Tb_arm_coms we want to count
     *   }
     * })
    **/
    count<T extends tb_arm_comCountArgs>(
      args?: Subset<T, tb_arm_comCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Tb_arm_comCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tb_arm_com.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Tb_arm_comAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Tb_arm_comAggregateArgs>(args: Subset<T, Tb_arm_comAggregateArgs>): Prisma.PrismaPromise<GetTb_arm_comAggregateType<T>>

    /**
     * Group by Tb_arm_com.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_arm_comGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends tb_arm_comGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: tb_arm_comGroupByArgs['orderBy'] }
        : { orderBy?: tb_arm_comGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, tb_arm_comGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTb_arm_comGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the tb_arm_com model
   */
  readonly fields: tb_arm_comFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for tb_arm_com.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__tb_arm_comClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the tb_arm_com model
   */
  interface tb_arm_comFieldRefs {
    readonly community_id: FieldRef<"tb_arm_com", 'Int'>
    readonly marz_id: FieldRef<"tb_arm_com", 'Int'>
    readonly ADM3_PCODE: FieldRef<"tb_arm_com", 'String'>
    readonly ADM3_ARM: FieldRef<"tb_arm_com", 'String'>
    readonly ADM3_EN: FieldRef<"tb_arm_com", 'String'>
    readonly exist: FieldRef<"tb_arm_com", 'Int'>
    readonly active: FieldRef<"tb_arm_com", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * tb_arm_com findUnique
   */
  export type tb_arm_comFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_arm_com
     */
    select?: tb_arm_comSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_arm_com
     */
    omit?: tb_arm_comOmit<ExtArgs> | null
    /**
     * Filter, which tb_arm_com to fetch.
     */
    where: tb_arm_comWhereUniqueInput
  }

  /**
   * tb_arm_com findUniqueOrThrow
   */
  export type tb_arm_comFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_arm_com
     */
    select?: tb_arm_comSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_arm_com
     */
    omit?: tb_arm_comOmit<ExtArgs> | null
    /**
     * Filter, which tb_arm_com to fetch.
     */
    where: tb_arm_comWhereUniqueInput
  }

  /**
   * tb_arm_com findFirst
   */
  export type tb_arm_comFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_arm_com
     */
    select?: tb_arm_comSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_arm_com
     */
    omit?: tb_arm_comOmit<ExtArgs> | null
    /**
     * Filter, which tb_arm_com to fetch.
     */
    where?: tb_arm_comWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tb_arm_coms to fetch.
     */
    orderBy?: tb_arm_comOrderByWithRelationInput | tb_arm_comOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tb_arm_coms.
     */
    cursor?: tb_arm_comWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tb_arm_coms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tb_arm_coms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tb_arm_coms.
     */
    distinct?: Tb_arm_comScalarFieldEnum | Tb_arm_comScalarFieldEnum[]
  }

  /**
   * tb_arm_com findFirstOrThrow
   */
  export type tb_arm_comFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_arm_com
     */
    select?: tb_arm_comSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_arm_com
     */
    omit?: tb_arm_comOmit<ExtArgs> | null
    /**
     * Filter, which tb_arm_com to fetch.
     */
    where?: tb_arm_comWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tb_arm_coms to fetch.
     */
    orderBy?: tb_arm_comOrderByWithRelationInput | tb_arm_comOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tb_arm_coms.
     */
    cursor?: tb_arm_comWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tb_arm_coms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tb_arm_coms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tb_arm_coms.
     */
    distinct?: Tb_arm_comScalarFieldEnum | Tb_arm_comScalarFieldEnum[]
  }

  /**
   * tb_arm_com findMany
   */
  export type tb_arm_comFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_arm_com
     */
    select?: tb_arm_comSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_arm_com
     */
    omit?: tb_arm_comOmit<ExtArgs> | null
    /**
     * Filter, which tb_arm_coms to fetch.
     */
    where?: tb_arm_comWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tb_arm_coms to fetch.
     */
    orderBy?: tb_arm_comOrderByWithRelationInput | tb_arm_comOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing tb_arm_coms.
     */
    cursor?: tb_arm_comWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tb_arm_coms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tb_arm_coms.
     */
    skip?: number
    distinct?: Tb_arm_comScalarFieldEnum | Tb_arm_comScalarFieldEnum[]
  }

  /**
   * tb_arm_com create
   */
  export type tb_arm_comCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_arm_com
     */
    select?: tb_arm_comSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_arm_com
     */
    omit?: tb_arm_comOmit<ExtArgs> | null
    /**
     * The data needed to create a tb_arm_com.
     */
    data: XOR<tb_arm_comCreateInput, tb_arm_comUncheckedCreateInput>
  }

  /**
   * tb_arm_com createMany
   */
  export type tb_arm_comCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many tb_arm_coms.
     */
    data: tb_arm_comCreateManyInput | tb_arm_comCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * tb_arm_com update
   */
  export type tb_arm_comUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_arm_com
     */
    select?: tb_arm_comSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_arm_com
     */
    omit?: tb_arm_comOmit<ExtArgs> | null
    /**
     * The data needed to update a tb_arm_com.
     */
    data: XOR<tb_arm_comUpdateInput, tb_arm_comUncheckedUpdateInput>
    /**
     * Choose, which tb_arm_com to update.
     */
    where: tb_arm_comWhereUniqueInput
  }

  /**
   * tb_arm_com updateMany
   */
  export type tb_arm_comUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update tb_arm_coms.
     */
    data: XOR<tb_arm_comUpdateManyMutationInput, tb_arm_comUncheckedUpdateManyInput>
    /**
     * Filter which tb_arm_coms to update
     */
    where?: tb_arm_comWhereInput
    /**
     * Limit how many tb_arm_coms to update.
     */
    limit?: number
  }

  /**
   * tb_arm_com upsert
   */
  export type tb_arm_comUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_arm_com
     */
    select?: tb_arm_comSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_arm_com
     */
    omit?: tb_arm_comOmit<ExtArgs> | null
    /**
     * The filter to search for the tb_arm_com to update in case it exists.
     */
    where: tb_arm_comWhereUniqueInput
    /**
     * In case the tb_arm_com found by the `where` argument doesn't exist, create a new tb_arm_com with this data.
     */
    create: XOR<tb_arm_comCreateInput, tb_arm_comUncheckedCreateInput>
    /**
     * In case the tb_arm_com was found with the provided `where` argument, update it with this data.
     */
    update: XOR<tb_arm_comUpdateInput, tb_arm_comUncheckedUpdateInput>
  }

  /**
   * tb_arm_com delete
   */
  export type tb_arm_comDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_arm_com
     */
    select?: tb_arm_comSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_arm_com
     */
    omit?: tb_arm_comOmit<ExtArgs> | null
    /**
     * Filter which tb_arm_com to delete.
     */
    where: tb_arm_comWhereUniqueInput
  }

  /**
   * tb_arm_com deleteMany
   */
  export type tb_arm_comDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tb_arm_coms to delete
     */
    where?: tb_arm_comWhereInput
    /**
     * Limit how many tb_arm_coms to delete.
     */
    limit?: number
  }

  /**
   * tb_arm_com without action
   */
  export type tb_arm_comDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_arm_com
     */
    select?: tb_arm_comSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_arm_com
     */
    omit?: tb_arm_comOmit<ExtArgs> | null
  }


  /**
   * Model tb_arm_com__
   */

  export type AggregateTb_arm_com__ = {
    _count: Tb_arm_com__CountAggregateOutputType | null
    _avg: Tb_arm_com__AvgAggregateOutputType | null
    _sum: Tb_arm_com__SumAggregateOutputType | null
    _min: Tb_arm_com__MinAggregateOutputType | null
    _max: Tb_arm_com__MaxAggregateOutputType | null
  }

  export type Tb_arm_com__AvgAggregateOutputType = {
    community_id: number | null
    marz_id: number | null
  }

  export type Tb_arm_com__SumAggregateOutputType = {
    community_id: number | null
    marz_id: number | null
  }

  export type Tb_arm_com__MinAggregateOutputType = {
    community_id: number | null
    marz_id: number | null
    ADM3_PCODE: string | null
    ADM3_ARM: string | null
    ADM3_EN: string | null
  }

  export type Tb_arm_com__MaxAggregateOutputType = {
    community_id: number | null
    marz_id: number | null
    ADM3_PCODE: string | null
    ADM3_ARM: string | null
    ADM3_EN: string | null
  }

  export type Tb_arm_com__CountAggregateOutputType = {
    community_id: number
    marz_id: number
    ADM3_PCODE: number
    ADM3_ARM: number
    ADM3_EN: number
    _all: number
  }


  export type Tb_arm_com__AvgAggregateInputType = {
    community_id?: true
    marz_id?: true
  }

  export type Tb_arm_com__SumAggregateInputType = {
    community_id?: true
    marz_id?: true
  }

  export type Tb_arm_com__MinAggregateInputType = {
    community_id?: true
    marz_id?: true
    ADM3_PCODE?: true
    ADM3_ARM?: true
    ADM3_EN?: true
  }

  export type Tb_arm_com__MaxAggregateInputType = {
    community_id?: true
    marz_id?: true
    ADM3_PCODE?: true
    ADM3_ARM?: true
    ADM3_EN?: true
  }

  export type Tb_arm_com__CountAggregateInputType = {
    community_id?: true
    marz_id?: true
    ADM3_PCODE?: true
    ADM3_ARM?: true
    ADM3_EN?: true
    _all?: true
  }

  export type Tb_arm_com__AggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tb_arm_com__ to aggregate.
     */
    where?: tb_arm_com__WhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tb_arm_com__s to fetch.
     */
    orderBy?: tb_arm_com__OrderByWithRelationInput | tb_arm_com__OrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: tb_arm_com__WhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tb_arm_com__s from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tb_arm_com__s.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned tb_arm_com__s
    **/
    _count?: true | Tb_arm_com__CountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Tb_arm_com__AvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Tb_arm_com__SumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Tb_arm_com__MinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Tb_arm_com__MaxAggregateInputType
  }

  export type GetTb_arm_com__AggregateType<T extends Tb_arm_com__AggregateArgs> = {
        [P in keyof T & keyof AggregateTb_arm_com__]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTb_arm_com__[P]>
      : GetScalarType<T[P], AggregateTb_arm_com__[P]>
  }




  export type tb_arm_com__GroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: tb_arm_com__WhereInput
    orderBy?: tb_arm_com__OrderByWithAggregationInput | tb_arm_com__OrderByWithAggregationInput[]
    by: Tb_arm_com__ScalarFieldEnum[] | Tb_arm_com__ScalarFieldEnum
    having?: tb_arm_com__ScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Tb_arm_com__CountAggregateInputType | true
    _avg?: Tb_arm_com__AvgAggregateInputType
    _sum?: Tb_arm_com__SumAggregateInputType
    _min?: Tb_arm_com__MinAggregateInputType
    _max?: Tb_arm_com__MaxAggregateInputType
  }

  export type Tb_arm_com__GroupByOutputType = {
    community_id: number
    marz_id: number
    ADM3_PCODE: string
    ADM3_ARM: string
    ADM3_EN: string
    _count: Tb_arm_com__CountAggregateOutputType | null
    _avg: Tb_arm_com__AvgAggregateOutputType | null
    _sum: Tb_arm_com__SumAggregateOutputType | null
    _min: Tb_arm_com__MinAggregateOutputType | null
    _max: Tb_arm_com__MaxAggregateOutputType | null
  }

  type GetTb_arm_com__GroupByPayload<T extends tb_arm_com__GroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Tb_arm_com__GroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Tb_arm_com__GroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Tb_arm_com__GroupByOutputType[P]>
            : GetScalarType<T[P], Tb_arm_com__GroupByOutputType[P]>
        }
      >
    >


  export type tb_arm_com__Select<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    community_id?: boolean
    marz_id?: boolean
    ADM3_PCODE?: boolean
    ADM3_ARM?: boolean
    ADM3_EN?: boolean
  }, ExtArgs["result"]["tb_arm_com__"]>



  export type tb_arm_com__SelectScalar = {
    community_id?: boolean
    marz_id?: boolean
    ADM3_PCODE?: boolean
    ADM3_ARM?: boolean
    ADM3_EN?: boolean
  }

  export type tb_arm_com__Omit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"community_id" | "marz_id" | "ADM3_PCODE" | "ADM3_ARM" | "ADM3_EN", ExtArgs["result"]["tb_arm_com__"]>

  export type $tb_arm_com__Payload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "tb_arm_com__"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      community_id: number
      marz_id: number
      ADM3_PCODE: string
      ADM3_ARM: string
      ADM3_EN: string
    }, ExtArgs["result"]["tb_arm_com__"]>
    composites: {}
  }

  type tb_arm_com__GetPayload<S extends boolean | null | undefined | tb_arm_com__DefaultArgs> = $Result.GetResult<Prisma.$tb_arm_com__Payload, S>

  type tb_arm_com__CountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<tb_arm_com__FindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Tb_arm_com__CountAggregateInputType | true
    }

  export interface tb_arm_com__Delegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['tb_arm_com__'], meta: { name: 'tb_arm_com__' } }
    /**
     * Find zero or one Tb_arm_com__ that matches the filter.
     * @param {tb_arm_com__FindUniqueArgs} args - Arguments to find a Tb_arm_com__
     * @example
     * // Get one Tb_arm_com__
     * const tb_arm_com__ = await prisma.tb_arm_com__.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends tb_arm_com__FindUniqueArgs>(args: SelectSubset<T, tb_arm_com__FindUniqueArgs<ExtArgs>>): Prisma__tb_arm_com__Client<$Result.GetResult<Prisma.$tb_arm_com__Payload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Tb_arm_com__ that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {tb_arm_com__FindUniqueOrThrowArgs} args - Arguments to find a Tb_arm_com__
     * @example
     * // Get one Tb_arm_com__
     * const tb_arm_com__ = await prisma.tb_arm_com__.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends tb_arm_com__FindUniqueOrThrowArgs>(args: SelectSubset<T, tb_arm_com__FindUniqueOrThrowArgs<ExtArgs>>): Prisma__tb_arm_com__Client<$Result.GetResult<Prisma.$tb_arm_com__Payload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tb_arm_com__ that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_arm_com__FindFirstArgs} args - Arguments to find a Tb_arm_com__
     * @example
     * // Get one Tb_arm_com__
     * const tb_arm_com__ = await prisma.tb_arm_com__.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends tb_arm_com__FindFirstArgs>(args?: SelectSubset<T, tb_arm_com__FindFirstArgs<ExtArgs>>): Prisma__tb_arm_com__Client<$Result.GetResult<Prisma.$tb_arm_com__Payload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tb_arm_com__ that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_arm_com__FindFirstOrThrowArgs} args - Arguments to find a Tb_arm_com__
     * @example
     * // Get one Tb_arm_com__
     * const tb_arm_com__ = await prisma.tb_arm_com__.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends tb_arm_com__FindFirstOrThrowArgs>(args?: SelectSubset<T, tb_arm_com__FindFirstOrThrowArgs<ExtArgs>>): Prisma__tb_arm_com__Client<$Result.GetResult<Prisma.$tb_arm_com__Payload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Tb_arm_com__s that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_arm_com__FindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tb_arm_com__s
     * const tb_arm_com__s = await prisma.tb_arm_com__.findMany()
     * 
     * // Get first 10 Tb_arm_com__s
     * const tb_arm_com__s = await prisma.tb_arm_com__.findMany({ take: 10 })
     * 
     * // Only select the `community_id`
     * const tb_arm_com__WithCommunity_idOnly = await prisma.tb_arm_com__.findMany({ select: { community_id: true } })
     * 
     */
    findMany<T extends tb_arm_com__FindManyArgs>(args?: SelectSubset<T, tb_arm_com__FindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tb_arm_com__Payload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Tb_arm_com__.
     * @param {tb_arm_com__CreateArgs} args - Arguments to create a Tb_arm_com__.
     * @example
     * // Create one Tb_arm_com__
     * const Tb_arm_com__ = await prisma.tb_arm_com__.create({
     *   data: {
     *     // ... data to create a Tb_arm_com__
     *   }
     * })
     * 
     */
    create<T extends tb_arm_com__CreateArgs>(args: SelectSubset<T, tb_arm_com__CreateArgs<ExtArgs>>): Prisma__tb_arm_com__Client<$Result.GetResult<Prisma.$tb_arm_com__Payload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Tb_arm_com__s.
     * @param {tb_arm_com__CreateManyArgs} args - Arguments to create many Tb_arm_com__s.
     * @example
     * // Create many Tb_arm_com__s
     * const tb_arm_com__ = await prisma.tb_arm_com__.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends tb_arm_com__CreateManyArgs>(args?: SelectSubset<T, tb_arm_com__CreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Tb_arm_com__.
     * @param {tb_arm_com__DeleteArgs} args - Arguments to delete one Tb_arm_com__.
     * @example
     * // Delete one Tb_arm_com__
     * const Tb_arm_com__ = await prisma.tb_arm_com__.delete({
     *   where: {
     *     // ... filter to delete one Tb_arm_com__
     *   }
     * })
     * 
     */
    delete<T extends tb_arm_com__DeleteArgs>(args: SelectSubset<T, tb_arm_com__DeleteArgs<ExtArgs>>): Prisma__tb_arm_com__Client<$Result.GetResult<Prisma.$tb_arm_com__Payload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Tb_arm_com__.
     * @param {tb_arm_com__UpdateArgs} args - Arguments to update one Tb_arm_com__.
     * @example
     * // Update one Tb_arm_com__
     * const tb_arm_com__ = await prisma.tb_arm_com__.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends tb_arm_com__UpdateArgs>(args: SelectSubset<T, tb_arm_com__UpdateArgs<ExtArgs>>): Prisma__tb_arm_com__Client<$Result.GetResult<Prisma.$tb_arm_com__Payload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Tb_arm_com__s.
     * @param {tb_arm_com__DeleteManyArgs} args - Arguments to filter Tb_arm_com__s to delete.
     * @example
     * // Delete a few Tb_arm_com__s
     * const { count } = await prisma.tb_arm_com__.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends tb_arm_com__DeleteManyArgs>(args?: SelectSubset<T, tb_arm_com__DeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tb_arm_com__s.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_arm_com__UpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tb_arm_com__s
     * const tb_arm_com__ = await prisma.tb_arm_com__.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends tb_arm_com__UpdateManyArgs>(args: SelectSubset<T, tb_arm_com__UpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Tb_arm_com__.
     * @param {tb_arm_com__UpsertArgs} args - Arguments to update or create a Tb_arm_com__.
     * @example
     * // Update or create a Tb_arm_com__
     * const tb_arm_com__ = await prisma.tb_arm_com__.upsert({
     *   create: {
     *     // ... data to create a Tb_arm_com__
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tb_arm_com__ we want to update
     *   }
     * })
     */
    upsert<T extends tb_arm_com__UpsertArgs>(args: SelectSubset<T, tb_arm_com__UpsertArgs<ExtArgs>>): Prisma__tb_arm_com__Client<$Result.GetResult<Prisma.$tb_arm_com__Payload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Tb_arm_com__s.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_arm_com__CountArgs} args - Arguments to filter Tb_arm_com__s to count.
     * @example
     * // Count the number of Tb_arm_com__s
     * const count = await prisma.tb_arm_com__.count({
     *   where: {
     *     // ... the filter for the Tb_arm_com__s we want to count
     *   }
     * })
    **/
    count<T extends tb_arm_com__CountArgs>(
      args?: Subset<T, tb_arm_com__CountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Tb_arm_com__CountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tb_arm_com__.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Tb_arm_com__AggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Tb_arm_com__AggregateArgs>(args: Subset<T, Tb_arm_com__AggregateArgs>): Prisma.PrismaPromise<GetTb_arm_com__AggregateType<T>>

    /**
     * Group by Tb_arm_com__.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_arm_com__GroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends tb_arm_com__GroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: tb_arm_com__GroupByArgs['orderBy'] }
        : { orderBy?: tb_arm_com__GroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, tb_arm_com__GroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTb_arm_com__GroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the tb_arm_com__ model
   */
  readonly fields: tb_arm_com__FieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for tb_arm_com__.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__tb_arm_com__Client<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the tb_arm_com__ model
   */
  interface tb_arm_com__FieldRefs {
    readonly community_id: FieldRef<"tb_arm_com__", 'Int'>
    readonly marz_id: FieldRef<"tb_arm_com__", 'Int'>
    readonly ADM3_PCODE: FieldRef<"tb_arm_com__", 'String'>
    readonly ADM3_ARM: FieldRef<"tb_arm_com__", 'String'>
    readonly ADM3_EN: FieldRef<"tb_arm_com__", 'String'>
  }
    

  // Custom InputTypes
  /**
   * tb_arm_com__ findUnique
   */
  export type tb_arm_com__FindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_arm_com__
     */
    select?: tb_arm_com__Select<ExtArgs> | null
    /**
     * Omit specific fields from the tb_arm_com__
     */
    omit?: tb_arm_com__Omit<ExtArgs> | null
    /**
     * Filter, which tb_arm_com__ to fetch.
     */
    where: tb_arm_com__WhereUniqueInput
  }

  /**
   * tb_arm_com__ findUniqueOrThrow
   */
  export type tb_arm_com__FindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_arm_com__
     */
    select?: tb_arm_com__Select<ExtArgs> | null
    /**
     * Omit specific fields from the tb_arm_com__
     */
    omit?: tb_arm_com__Omit<ExtArgs> | null
    /**
     * Filter, which tb_arm_com__ to fetch.
     */
    where: tb_arm_com__WhereUniqueInput
  }

  /**
   * tb_arm_com__ findFirst
   */
  export type tb_arm_com__FindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_arm_com__
     */
    select?: tb_arm_com__Select<ExtArgs> | null
    /**
     * Omit specific fields from the tb_arm_com__
     */
    omit?: tb_arm_com__Omit<ExtArgs> | null
    /**
     * Filter, which tb_arm_com__ to fetch.
     */
    where?: tb_arm_com__WhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tb_arm_com__s to fetch.
     */
    orderBy?: tb_arm_com__OrderByWithRelationInput | tb_arm_com__OrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tb_arm_com__s.
     */
    cursor?: tb_arm_com__WhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tb_arm_com__s from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tb_arm_com__s.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tb_arm_com__s.
     */
    distinct?: Tb_arm_com__ScalarFieldEnum | Tb_arm_com__ScalarFieldEnum[]
  }

  /**
   * tb_arm_com__ findFirstOrThrow
   */
  export type tb_arm_com__FindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_arm_com__
     */
    select?: tb_arm_com__Select<ExtArgs> | null
    /**
     * Omit specific fields from the tb_arm_com__
     */
    omit?: tb_arm_com__Omit<ExtArgs> | null
    /**
     * Filter, which tb_arm_com__ to fetch.
     */
    where?: tb_arm_com__WhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tb_arm_com__s to fetch.
     */
    orderBy?: tb_arm_com__OrderByWithRelationInput | tb_arm_com__OrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tb_arm_com__s.
     */
    cursor?: tb_arm_com__WhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tb_arm_com__s from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tb_arm_com__s.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tb_arm_com__s.
     */
    distinct?: Tb_arm_com__ScalarFieldEnum | Tb_arm_com__ScalarFieldEnum[]
  }

  /**
   * tb_arm_com__ findMany
   */
  export type tb_arm_com__FindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_arm_com__
     */
    select?: tb_arm_com__Select<ExtArgs> | null
    /**
     * Omit specific fields from the tb_arm_com__
     */
    omit?: tb_arm_com__Omit<ExtArgs> | null
    /**
     * Filter, which tb_arm_com__s to fetch.
     */
    where?: tb_arm_com__WhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tb_arm_com__s to fetch.
     */
    orderBy?: tb_arm_com__OrderByWithRelationInput | tb_arm_com__OrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing tb_arm_com__s.
     */
    cursor?: tb_arm_com__WhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tb_arm_com__s from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tb_arm_com__s.
     */
    skip?: number
    distinct?: Tb_arm_com__ScalarFieldEnum | Tb_arm_com__ScalarFieldEnum[]
  }

  /**
   * tb_arm_com__ create
   */
  export type tb_arm_com__CreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_arm_com__
     */
    select?: tb_arm_com__Select<ExtArgs> | null
    /**
     * Omit specific fields from the tb_arm_com__
     */
    omit?: tb_arm_com__Omit<ExtArgs> | null
    /**
     * The data needed to create a tb_arm_com__.
     */
    data: XOR<tb_arm_com__CreateInput, tb_arm_com__UncheckedCreateInput>
  }

  /**
   * tb_arm_com__ createMany
   */
  export type tb_arm_com__CreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many tb_arm_com__s.
     */
    data: tb_arm_com__CreateManyInput | tb_arm_com__CreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * tb_arm_com__ update
   */
  export type tb_arm_com__UpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_arm_com__
     */
    select?: tb_arm_com__Select<ExtArgs> | null
    /**
     * Omit specific fields from the tb_arm_com__
     */
    omit?: tb_arm_com__Omit<ExtArgs> | null
    /**
     * The data needed to update a tb_arm_com__.
     */
    data: XOR<tb_arm_com__UpdateInput, tb_arm_com__UncheckedUpdateInput>
    /**
     * Choose, which tb_arm_com__ to update.
     */
    where: tb_arm_com__WhereUniqueInput
  }

  /**
   * tb_arm_com__ updateMany
   */
  export type tb_arm_com__UpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update tb_arm_com__s.
     */
    data: XOR<tb_arm_com__UpdateManyMutationInput, tb_arm_com__UncheckedUpdateManyInput>
    /**
     * Filter which tb_arm_com__s to update
     */
    where?: tb_arm_com__WhereInput
    /**
     * Limit how many tb_arm_com__s to update.
     */
    limit?: number
  }

  /**
   * tb_arm_com__ upsert
   */
  export type tb_arm_com__UpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_arm_com__
     */
    select?: tb_arm_com__Select<ExtArgs> | null
    /**
     * Omit specific fields from the tb_arm_com__
     */
    omit?: tb_arm_com__Omit<ExtArgs> | null
    /**
     * The filter to search for the tb_arm_com__ to update in case it exists.
     */
    where: tb_arm_com__WhereUniqueInput
    /**
     * In case the tb_arm_com__ found by the `where` argument doesn't exist, create a new tb_arm_com__ with this data.
     */
    create: XOR<tb_arm_com__CreateInput, tb_arm_com__UncheckedCreateInput>
    /**
     * In case the tb_arm_com__ was found with the provided `where` argument, update it with this data.
     */
    update: XOR<tb_arm_com__UpdateInput, tb_arm_com__UncheckedUpdateInput>
  }

  /**
   * tb_arm_com__ delete
   */
  export type tb_arm_com__DeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_arm_com__
     */
    select?: tb_arm_com__Select<ExtArgs> | null
    /**
     * Omit specific fields from the tb_arm_com__
     */
    omit?: tb_arm_com__Omit<ExtArgs> | null
    /**
     * Filter which tb_arm_com__ to delete.
     */
    where: tb_arm_com__WhereUniqueInput
  }

  /**
   * tb_arm_com__ deleteMany
   */
  export type tb_arm_com__DeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tb_arm_com__s to delete
     */
    where?: tb_arm_com__WhereInput
    /**
     * Limit how many tb_arm_com__s to delete.
     */
    limit?: number
  }

  /**
   * tb_arm_com__ without action
   */
  export type tb_arm_com__DefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_arm_com__
     */
    select?: tb_arm_com__Select<ExtArgs> | null
    /**
     * Omit specific fields from the tb_arm_com__
     */
    omit?: tb_arm_com__Omit<ExtArgs> | null
  }


  /**
   * Model tb_calendar
   */

  export type AggregateTb_calendar = {
    _count: Tb_calendarCountAggregateOutputType | null
    _avg: Tb_calendarAvgAggregateOutputType | null
    _sum: Tb_calendarSumAggregateOutputType | null
    _min: Tb_calendarMinAggregateOutputType | null
    _max: Tb_calendarMaxAggregateOutputType | null
  }

  export type Tb_calendarAvgAggregateOutputType = {
    interview_id: number | null
    case_id: number | null
    user_id: number | null
    actual_event: number | null
  }

  export type Tb_calendarSumAggregateOutputType = {
    interview_id: number | null
    case_id: number | null
    user_id: number | null
    actual_event: number | null
  }

  export type Tb_calendarMinAggregateOutputType = {
    interview_id: number | null
    case_id: number | null
    user_id: number | null
    inter_comment: string | null
    inter_date_from: Date | null
    inter_date_to: Date | null
    text_color: string | null
    border_color: string | null
    actual_event: number | null
  }

  export type Tb_calendarMaxAggregateOutputType = {
    interview_id: number | null
    case_id: number | null
    user_id: number | null
    inter_comment: string | null
    inter_date_from: Date | null
    inter_date_to: Date | null
    text_color: string | null
    border_color: string | null
    actual_event: number | null
  }

  export type Tb_calendarCountAggregateOutputType = {
    interview_id: number
    case_id: number
    user_id: number
    inter_comment: number
    inter_date_from: number
    inter_date_to: number
    text_color: number
    border_color: number
    actual_event: number
    _all: number
  }


  export type Tb_calendarAvgAggregateInputType = {
    interview_id?: true
    case_id?: true
    user_id?: true
    actual_event?: true
  }

  export type Tb_calendarSumAggregateInputType = {
    interview_id?: true
    case_id?: true
    user_id?: true
    actual_event?: true
  }

  export type Tb_calendarMinAggregateInputType = {
    interview_id?: true
    case_id?: true
    user_id?: true
    inter_comment?: true
    inter_date_from?: true
    inter_date_to?: true
    text_color?: true
    border_color?: true
    actual_event?: true
  }

  export type Tb_calendarMaxAggregateInputType = {
    interview_id?: true
    case_id?: true
    user_id?: true
    inter_comment?: true
    inter_date_from?: true
    inter_date_to?: true
    text_color?: true
    border_color?: true
    actual_event?: true
  }

  export type Tb_calendarCountAggregateInputType = {
    interview_id?: true
    case_id?: true
    user_id?: true
    inter_comment?: true
    inter_date_from?: true
    inter_date_to?: true
    text_color?: true
    border_color?: true
    actual_event?: true
    _all?: true
  }

  export type Tb_calendarAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tb_calendar to aggregate.
     */
    where?: tb_calendarWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tb_calendars to fetch.
     */
    orderBy?: tb_calendarOrderByWithRelationInput | tb_calendarOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: tb_calendarWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tb_calendars from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tb_calendars.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned tb_calendars
    **/
    _count?: true | Tb_calendarCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Tb_calendarAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Tb_calendarSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Tb_calendarMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Tb_calendarMaxAggregateInputType
  }

  export type GetTb_calendarAggregateType<T extends Tb_calendarAggregateArgs> = {
        [P in keyof T & keyof AggregateTb_calendar]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTb_calendar[P]>
      : GetScalarType<T[P], AggregateTb_calendar[P]>
  }




  export type tb_calendarGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: tb_calendarWhereInput
    orderBy?: tb_calendarOrderByWithAggregationInput | tb_calendarOrderByWithAggregationInput[]
    by: Tb_calendarScalarFieldEnum[] | Tb_calendarScalarFieldEnum
    having?: tb_calendarScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Tb_calendarCountAggregateInputType | true
    _avg?: Tb_calendarAvgAggregateInputType
    _sum?: Tb_calendarSumAggregateInputType
    _min?: Tb_calendarMinAggregateInputType
    _max?: Tb_calendarMaxAggregateInputType
  }

  export type Tb_calendarGroupByOutputType = {
    interview_id: number
    case_id: number
    user_id: number
    inter_comment: string
    inter_date_from: Date | null
    inter_date_to: Date | null
    text_color: string
    border_color: string
    actual_event: number
    _count: Tb_calendarCountAggregateOutputType | null
    _avg: Tb_calendarAvgAggregateOutputType | null
    _sum: Tb_calendarSumAggregateOutputType | null
    _min: Tb_calendarMinAggregateOutputType | null
    _max: Tb_calendarMaxAggregateOutputType | null
  }

  type GetTb_calendarGroupByPayload<T extends tb_calendarGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Tb_calendarGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Tb_calendarGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Tb_calendarGroupByOutputType[P]>
            : GetScalarType<T[P], Tb_calendarGroupByOutputType[P]>
        }
      >
    >


  export type tb_calendarSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    interview_id?: boolean
    case_id?: boolean
    user_id?: boolean
    inter_comment?: boolean
    inter_date_from?: boolean
    inter_date_to?: boolean
    text_color?: boolean
    border_color?: boolean
    actual_event?: boolean
  }, ExtArgs["result"]["tb_calendar"]>



  export type tb_calendarSelectScalar = {
    interview_id?: boolean
    case_id?: boolean
    user_id?: boolean
    inter_comment?: boolean
    inter_date_from?: boolean
    inter_date_to?: boolean
    text_color?: boolean
    border_color?: boolean
    actual_event?: boolean
  }

  export type tb_calendarOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"interview_id" | "case_id" | "user_id" | "inter_comment" | "inter_date_from" | "inter_date_to" | "text_color" | "border_color" | "actual_event", ExtArgs["result"]["tb_calendar"]>

  export type $tb_calendarPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "tb_calendar"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      interview_id: number
      case_id: number
      user_id: number
      inter_comment: string
      inter_date_from: Date | null
      inter_date_to: Date | null
      text_color: string
      border_color: string
      actual_event: number
    }, ExtArgs["result"]["tb_calendar"]>
    composites: {}
  }

  type tb_calendarGetPayload<S extends boolean | null | undefined | tb_calendarDefaultArgs> = $Result.GetResult<Prisma.$tb_calendarPayload, S>

  type tb_calendarCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<tb_calendarFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Tb_calendarCountAggregateInputType | true
    }

  export interface tb_calendarDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['tb_calendar'], meta: { name: 'tb_calendar' } }
    /**
     * Find zero or one Tb_calendar that matches the filter.
     * @param {tb_calendarFindUniqueArgs} args - Arguments to find a Tb_calendar
     * @example
     * // Get one Tb_calendar
     * const tb_calendar = await prisma.tb_calendar.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends tb_calendarFindUniqueArgs>(args: SelectSubset<T, tb_calendarFindUniqueArgs<ExtArgs>>): Prisma__tb_calendarClient<$Result.GetResult<Prisma.$tb_calendarPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Tb_calendar that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {tb_calendarFindUniqueOrThrowArgs} args - Arguments to find a Tb_calendar
     * @example
     * // Get one Tb_calendar
     * const tb_calendar = await prisma.tb_calendar.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends tb_calendarFindUniqueOrThrowArgs>(args: SelectSubset<T, tb_calendarFindUniqueOrThrowArgs<ExtArgs>>): Prisma__tb_calendarClient<$Result.GetResult<Prisma.$tb_calendarPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tb_calendar that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_calendarFindFirstArgs} args - Arguments to find a Tb_calendar
     * @example
     * // Get one Tb_calendar
     * const tb_calendar = await prisma.tb_calendar.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends tb_calendarFindFirstArgs>(args?: SelectSubset<T, tb_calendarFindFirstArgs<ExtArgs>>): Prisma__tb_calendarClient<$Result.GetResult<Prisma.$tb_calendarPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tb_calendar that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_calendarFindFirstOrThrowArgs} args - Arguments to find a Tb_calendar
     * @example
     * // Get one Tb_calendar
     * const tb_calendar = await prisma.tb_calendar.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends tb_calendarFindFirstOrThrowArgs>(args?: SelectSubset<T, tb_calendarFindFirstOrThrowArgs<ExtArgs>>): Prisma__tb_calendarClient<$Result.GetResult<Prisma.$tb_calendarPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Tb_calendars that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_calendarFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tb_calendars
     * const tb_calendars = await prisma.tb_calendar.findMany()
     * 
     * // Get first 10 Tb_calendars
     * const tb_calendars = await prisma.tb_calendar.findMany({ take: 10 })
     * 
     * // Only select the `interview_id`
     * const tb_calendarWithInterview_idOnly = await prisma.tb_calendar.findMany({ select: { interview_id: true } })
     * 
     */
    findMany<T extends tb_calendarFindManyArgs>(args?: SelectSubset<T, tb_calendarFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tb_calendarPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Tb_calendar.
     * @param {tb_calendarCreateArgs} args - Arguments to create a Tb_calendar.
     * @example
     * // Create one Tb_calendar
     * const Tb_calendar = await prisma.tb_calendar.create({
     *   data: {
     *     // ... data to create a Tb_calendar
     *   }
     * })
     * 
     */
    create<T extends tb_calendarCreateArgs>(args: SelectSubset<T, tb_calendarCreateArgs<ExtArgs>>): Prisma__tb_calendarClient<$Result.GetResult<Prisma.$tb_calendarPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Tb_calendars.
     * @param {tb_calendarCreateManyArgs} args - Arguments to create many Tb_calendars.
     * @example
     * // Create many Tb_calendars
     * const tb_calendar = await prisma.tb_calendar.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends tb_calendarCreateManyArgs>(args?: SelectSubset<T, tb_calendarCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Tb_calendar.
     * @param {tb_calendarDeleteArgs} args - Arguments to delete one Tb_calendar.
     * @example
     * // Delete one Tb_calendar
     * const Tb_calendar = await prisma.tb_calendar.delete({
     *   where: {
     *     // ... filter to delete one Tb_calendar
     *   }
     * })
     * 
     */
    delete<T extends tb_calendarDeleteArgs>(args: SelectSubset<T, tb_calendarDeleteArgs<ExtArgs>>): Prisma__tb_calendarClient<$Result.GetResult<Prisma.$tb_calendarPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Tb_calendar.
     * @param {tb_calendarUpdateArgs} args - Arguments to update one Tb_calendar.
     * @example
     * // Update one Tb_calendar
     * const tb_calendar = await prisma.tb_calendar.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends tb_calendarUpdateArgs>(args: SelectSubset<T, tb_calendarUpdateArgs<ExtArgs>>): Prisma__tb_calendarClient<$Result.GetResult<Prisma.$tb_calendarPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Tb_calendars.
     * @param {tb_calendarDeleteManyArgs} args - Arguments to filter Tb_calendars to delete.
     * @example
     * // Delete a few Tb_calendars
     * const { count } = await prisma.tb_calendar.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends tb_calendarDeleteManyArgs>(args?: SelectSubset<T, tb_calendarDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tb_calendars.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_calendarUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tb_calendars
     * const tb_calendar = await prisma.tb_calendar.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends tb_calendarUpdateManyArgs>(args: SelectSubset<T, tb_calendarUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Tb_calendar.
     * @param {tb_calendarUpsertArgs} args - Arguments to update or create a Tb_calendar.
     * @example
     * // Update or create a Tb_calendar
     * const tb_calendar = await prisma.tb_calendar.upsert({
     *   create: {
     *     // ... data to create a Tb_calendar
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tb_calendar we want to update
     *   }
     * })
     */
    upsert<T extends tb_calendarUpsertArgs>(args: SelectSubset<T, tb_calendarUpsertArgs<ExtArgs>>): Prisma__tb_calendarClient<$Result.GetResult<Prisma.$tb_calendarPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Tb_calendars.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_calendarCountArgs} args - Arguments to filter Tb_calendars to count.
     * @example
     * // Count the number of Tb_calendars
     * const count = await prisma.tb_calendar.count({
     *   where: {
     *     // ... the filter for the Tb_calendars we want to count
     *   }
     * })
    **/
    count<T extends tb_calendarCountArgs>(
      args?: Subset<T, tb_calendarCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Tb_calendarCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tb_calendar.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Tb_calendarAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Tb_calendarAggregateArgs>(args: Subset<T, Tb_calendarAggregateArgs>): Prisma.PrismaPromise<GetTb_calendarAggregateType<T>>

    /**
     * Group by Tb_calendar.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_calendarGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends tb_calendarGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: tb_calendarGroupByArgs['orderBy'] }
        : { orderBy?: tb_calendarGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, tb_calendarGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTb_calendarGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the tb_calendar model
   */
  readonly fields: tb_calendarFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for tb_calendar.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__tb_calendarClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the tb_calendar model
   */
  interface tb_calendarFieldRefs {
    readonly interview_id: FieldRef<"tb_calendar", 'Int'>
    readonly case_id: FieldRef<"tb_calendar", 'Int'>
    readonly user_id: FieldRef<"tb_calendar", 'Int'>
    readonly inter_comment: FieldRef<"tb_calendar", 'String'>
    readonly inter_date_from: FieldRef<"tb_calendar", 'DateTime'>
    readonly inter_date_to: FieldRef<"tb_calendar", 'DateTime'>
    readonly text_color: FieldRef<"tb_calendar", 'String'>
    readonly border_color: FieldRef<"tb_calendar", 'String'>
    readonly actual_event: FieldRef<"tb_calendar", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * tb_calendar findUnique
   */
  export type tb_calendarFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_calendar
     */
    select?: tb_calendarSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_calendar
     */
    omit?: tb_calendarOmit<ExtArgs> | null
    /**
     * Filter, which tb_calendar to fetch.
     */
    where: tb_calendarWhereUniqueInput
  }

  /**
   * tb_calendar findUniqueOrThrow
   */
  export type tb_calendarFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_calendar
     */
    select?: tb_calendarSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_calendar
     */
    omit?: tb_calendarOmit<ExtArgs> | null
    /**
     * Filter, which tb_calendar to fetch.
     */
    where: tb_calendarWhereUniqueInput
  }

  /**
   * tb_calendar findFirst
   */
  export type tb_calendarFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_calendar
     */
    select?: tb_calendarSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_calendar
     */
    omit?: tb_calendarOmit<ExtArgs> | null
    /**
     * Filter, which tb_calendar to fetch.
     */
    where?: tb_calendarWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tb_calendars to fetch.
     */
    orderBy?: tb_calendarOrderByWithRelationInput | tb_calendarOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tb_calendars.
     */
    cursor?: tb_calendarWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tb_calendars from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tb_calendars.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tb_calendars.
     */
    distinct?: Tb_calendarScalarFieldEnum | Tb_calendarScalarFieldEnum[]
  }

  /**
   * tb_calendar findFirstOrThrow
   */
  export type tb_calendarFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_calendar
     */
    select?: tb_calendarSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_calendar
     */
    omit?: tb_calendarOmit<ExtArgs> | null
    /**
     * Filter, which tb_calendar to fetch.
     */
    where?: tb_calendarWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tb_calendars to fetch.
     */
    orderBy?: tb_calendarOrderByWithRelationInput | tb_calendarOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tb_calendars.
     */
    cursor?: tb_calendarWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tb_calendars from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tb_calendars.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tb_calendars.
     */
    distinct?: Tb_calendarScalarFieldEnum | Tb_calendarScalarFieldEnum[]
  }

  /**
   * tb_calendar findMany
   */
  export type tb_calendarFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_calendar
     */
    select?: tb_calendarSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_calendar
     */
    omit?: tb_calendarOmit<ExtArgs> | null
    /**
     * Filter, which tb_calendars to fetch.
     */
    where?: tb_calendarWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tb_calendars to fetch.
     */
    orderBy?: tb_calendarOrderByWithRelationInput | tb_calendarOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing tb_calendars.
     */
    cursor?: tb_calendarWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tb_calendars from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tb_calendars.
     */
    skip?: number
    distinct?: Tb_calendarScalarFieldEnum | Tb_calendarScalarFieldEnum[]
  }

  /**
   * tb_calendar create
   */
  export type tb_calendarCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_calendar
     */
    select?: tb_calendarSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_calendar
     */
    omit?: tb_calendarOmit<ExtArgs> | null
    /**
     * The data needed to create a tb_calendar.
     */
    data: XOR<tb_calendarCreateInput, tb_calendarUncheckedCreateInput>
  }

  /**
   * tb_calendar createMany
   */
  export type tb_calendarCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many tb_calendars.
     */
    data: tb_calendarCreateManyInput | tb_calendarCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * tb_calendar update
   */
  export type tb_calendarUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_calendar
     */
    select?: tb_calendarSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_calendar
     */
    omit?: tb_calendarOmit<ExtArgs> | null
    /**
     * The data needed to update a tb_calendar.
     */
    data: XOR<tb_calendarUpdateInput, tb_calendarUncheckedUpdateInput>
    /**
     * Choose, which tb_calendar to update.
     */
    where: tb_calendarWhereUniqueInput
  }

  /**
   * tb_calendar updateMany
   */
  export type tb_calendarUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update tb_calendars.
     */
    data: XOR<tb_calendarUpdateManyMutationInput, tb_calendarUncheckedUpdateManyInput>
    /**
     * Filter which tb_calendars to update
     */
    where?: tb_calendarWhereInput
    /**
     * Limit how many tb_calendars to update.
     */
    limit?: number
  }

  /**
   * tb_calendar upsert
   */
  export type tb_calendarUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_calendar
     */
    select?: tb_calendarSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_calendar
     */
    omit?: tb_calendarOmit<ExtArgs> | null
    /**
     * The filter to search for the tb_calendar to update in case it exists.
     */
    where: tb_calendarWhereUniqueInput
    /**
     * In case the tb_calendar found by the `where` argument doesn't exist, create a new tb_calendar with this data.
     */
    create: XOR<tb_calendarCreateInput, tb_calendarUncheckedCreateInput>
    /**
     * In case the tb_calendar was found with the provided `where` argument, update it with this data.
     */
    update: XOR<tb_calendarUpdateInput, tb_calendarUncheckedUpdateInput>
  }

  /**
   * tb_calendar delete
   */
  export type tb_calendarDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_calendar
     */
    select?: tb_calendarSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_calendar
     */
    omit?: tb_calendarOmit<ExtArgs> | null
    /**
     * Filter which tb_calendar to delete.
     */
    where: tb_calendarWhereUniqueInput
  }

  /**
   * tb_calendar deleteMany
   */
  export type tb_calendarDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tb_calendars to delete
     */
    where?: tb_calendarWhereInput
    /**
     * Limit how many tb_calendars to delete.
     */
    limit?: number
  }

  /**
   * tb_calendar without action
   */
  export type tb_calendarDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_calendar
     */
    select?: tb_calendarSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_calendar
     */
    omit?: tb_calendarOmit<ExtArgs> | null
  }


  /**
   * Model tb_cancel
   */

  export type AggregateTb_cancel = {
    _count: Tb_cancelCountAggregateOutputType | null
    _avg: Tb_cancelAvgAggregateOutputType | null
    _sum: Tb_cancelSumAggregateOutputType | null
    _min: Tb_cancelMinAggregateOutputType | null
    _max: Tb_cancelMaxAggregateOutputType | null
  }

  export type Tb_cancelAvgAggregateOutputType = {
    id: number | null
    personal_id: number | null
    case_id: number | null
    uploader: number | null
    file_id: number | null
  }

  export type Tb_cancelSumAggregateOutputType = {
    id: number | null
    personal_id: number | null
    case_id: number | null
    uploader: number | null
    file_id: number | null
  }

  export type Tb_cancelMinAggregateOutputType = {
    id: number | null
    personal_id: number | null
    case_id: number | null
    decision_date: Date | null
    uploader: number | null
    uploaded: Date | null
    file_id: number | null
  }

  export type Tb_cancelMaxAggregateOutputType = {
    id: number | null
    personal_id: number | null
    case_id: number | null
    decision_date: Date | null
    uploader: number | null
    uploaded: Date | null
    file_id: number | null
  }

  export type Tb_cancelCountAggregateOutputType = {
    id: number
    personal_id: number
    case_id: number
    decision_date: number
    uploader: number
    uploaded: number
    file_id: number
    _all: number
  }


  export type Tb_cancelAvgAggregateInputType = {
    id?: true
    personal_id?: true
    case_id?: true
    uploader?: true
    file_id?: true
  }

  export type Tb_cancelSumAggregateInputType = {
    id?: true
    personal_id?: true
    case_id?: true
    uploader?: true
    file_id?: true
  }

  export type Tb_cancelMinAggregateInputType = {
    id?: true
    personal_id?: true
    case_id?: true
    decision_date?: true
    uploader?: true
    uploaded?: true
    file_id?: true
  }

  export type Tb_cancelMaxAggregateInputType = {
    id?: true
    personal_id?: true
    case_id?: true
    decision_date?: true
    uploader?: true
    uploaded?: true
    file_id?: true
  }

  export type Tb_cancelCountAggregateInputType = {
    id?: true
    personal_id?: true
    case_id?: true
    decision_date?: true
    uploader?: true
    uploaded?: true
    file_id?: true
    _all?: true
  }

  export type Tb_cancelAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tb_cancel to aggregate.
     */
    where?: tb_cancelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tb_cancels to fetch.
     */
    orderBy?: tb_cancelOrderByWithRelationInput | tb_cancelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: tb_cancelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tb_cancels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tb_cancels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned tb_cancels
    **/
    _count?: true | Tb_cancelCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Tb_cancelAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Tb_cancelSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Tb_cancelMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Tb_cancelMaxAggregateInputType
  }

  export type GetTb_cancelAggregateType<T extends Tb_cancelAggregateArgs> = {
        [P in keyof T & keyof AggregateTb_cancel]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTb_cancel[P]>
      : GetScalarType<T[P], AggregateTb_cancel[P]>
  }




  export type tb_cancelGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: tb_cancelWhereInput
    orderBy?: tb_cancelOrderByWithAggregationInput | tb_cancelOrderByWithAggregationInput[]
    by: Tb_cancelScalarFieldEnum[] | Tb_cancelScalarFieldEnum
    having?: tb_cancelScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Tb_cancelCountAggregateInputType | true
    _avg?: Tb_cancelAvgAggregateInputType
    _sum?: Tb_cancelSumAggregateInputType
    _min?: Tb_cancelMinAggregateInputType
    _max?: Tb_cancelMaxAggregateInputType
  }

  export type Tb_cancelGroupByOutputType = {
    id: number
    personal_id: number
    case_id: number
    decision_date: Date
    uploader: number
    uploaded: Date
    file_id: number
    _count: Tb_cancelCountAggregateOutputType | null
    _avg: Tb_cancelAvgAggregateOutputType | null
    _sum: Tb_cancelSumAggregateOutputType | null
    _min: Tb_cancelMinAggregateOutputType | null
    _max: Tb_cancelMaxAggregateOutputType | null
  }

  type GetTb_cancelGroupByPayload<T extends tb_cancelGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Tb_cancelGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Tb_cancelGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Tb_cancelGroupByOutputType[P]>
            : GetScalarType<T[P], Tb_cancelGroupByOutputType[P]>
        }
      >
    >


  export type tb_cancelSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    personal_id?: boolean
    case_id?: boolean
    decision_date?: boolean
    uploader?: boolean
    uploaded?: boolean
    file_id?: boolean
  }, ExtArgs["result"]["tb_cancel"]>



  export type tb_cancelSelectScalar = {
    id?: boolean
    personal_id?: boolean
    case_id?: boolean
    decision_date?: boolean
    uploader?: boolean
    uploaded?: boolean
    file_id?: boolean
  }

  export type tb_cancelOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "personal_id" | "case_id" | "decision_date" | "uploader" | "uploaded" | "file_id", ExtArgs["result"]["tb_cancel"]>

  export type $tb_cancelPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "tb_cancel"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      personal_id: number
      case_id: number
      decision_date: Date
      uploader: number
      uploaded: Date
      file_id: number
    }, ExtArgs["result"]["tb_cancel"]>
    composites: {}
  }

  type tb_cancelGetPayload<S extends boolean | null | undefined | tb_cancelDefaultArgs> = $Result.GetResult<Prisma.$tb_cancelPayload, S>

  type tb_cancelCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<tb_cancelFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Tb_cancelCountAggregateInputType | true
    }

  export interface tb_cancelDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['tb_cancel'], meta: { name: 'tb_cancel' } }
    /**
     * Find zero or one Tb_cancel that matches the filter.
     * @param {tb_cancelFindUniqueArgs} args - Arguments to find a Tb_cancel
     * @example
     * // Get one Tb_cancel
     * const tb_cancel = await prisma.tb_cancel.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends tb_cancelFindUniqueArgs>(args: SelectSubset<T, tb_cancelFindUniqueArgs<ExtArgs>>): Prisma__tb_cancelClient<$Result.GetResult<Prisma.$tb_cancelPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Tb_cancel that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {tb_cancelFindUniqueOrThrowArgs} args - Arguments to find a Tb_cancel
     * @example
     * // Get one Tb_cancel
     * const tb_cancel = await prisma.tb_cancel.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends tb_cancelFindUniqueOrThrowArgs>(args: SelectSubset<T, tb_cancelFindUniqueOrThrowArgs<ExtArgs>>): Prisma__tb_cancelClient<$Result.GetResult<Prisma.$tb_cancelPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tb_cancel that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_cancelFindFirstArgs} args - Arguments to find a Tb_cancel
     * @example
     * // Get one Tb_cancel
     * const tb_cancel = await prisma.tb_cancel.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends tb_cancelFindFirstArgs>(args?: SelectSubset<T, tb_cancelFindFirstArgs<ExtArgs>>): Prisma__tb_cancelClient<$Result.GetResult<Prisma.$tb_cancelPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tb_cancel that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_cancelFindFirstOrThrowArgs} args - Arguments to find a Tb_cancel
     * @example
     * // Get one Tb_cancel
     * const tb_cancel = await prisma.tb_cancel.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends tb_cancelFindFirstOrThrowArgs>(args?: SelectSubset<T, tb_cancelFindFirstOrThrowArgs<ExtArgs>>): Prisma__tb_cancelClient<$Result.GetResult<Prisma.$tb_cancelPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Tb_cancels that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_cancelFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tb_cancels
     * const tb_cancels = await prisma.tb_cancel.findMany()
     * 
     * // Get first 10 Tb_cancels
     * const tb_cancels = await prisma.tb_cancel.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tb_cancelWithIdOnly = await prisma.tb_cancel.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends tb_cancelFindManyArgs>(args?: SelectSubset<T, tb_cancelFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tb_cancelPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Tb_cancel.
     * @param {tb_cancelCreateArgs} args - Arguments to create a Tb_cancel.
     * @example
     * // Create one Tb_cancel
     * const Tb_cancel = await prisma.tb_cancel.create({
     *   data: {
     *     // ... data to create a Tb_cancel
     *   }
     * })
     * 
     */
    create<T extends tb_cancelCreateArgs>(args: SelectSubset<T, tb_cancelCreateArgs<ExtArgs>>): Prisma__tb_cancelClient<$Result.GetResult<Prisma.$tb_cancelPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Tb_cancels.
     * @param {tb_cancelCreateManyArgs} args - Arguments to create many Tb_cancels.
     * @example
     * // Create many Tb_cancels
     * const tb_cancel = await prisma.tb_cancel.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends tb_cancelCreateManyArgs>(args?: SelectSubset<T, tb_cancelCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Tb_cancel.
     * @param {tb_cancelDeleteArgs} args - Arguments to delete one Tb_cancel.
     * @example
     * // Delete one Tb_cancel
     * const Tb_cancel = await prisma.tb_cancel.delete({
     *   where: {
     *     // ... filter to delete one Tb_cancel
     *   }
     * })
     * 
     */
    delete<T extends tb_cancelDeleteArgs>(args: SelectSubset<T, tb_cancelDeleteArgs<ExtArgs>>): Prisma__tb_cancelClient<$Result.GetResult<Prisma.$tb_cancelPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Tb_cancel.
     * @param {tb_cancelUpdateArgs} args - Arguments to update one Tb_cancel.
     * @example
     * // Update one Tb_cancel
     * const tb_cancel = await prisma.tb_cancel.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends tb_cancelUpdateArgs>(args: SelectSubset<T, tb_cancelUpdateArgs<ExtArgs>>): Prisma__tb_cancelClient<$Result.GetResult<Prisma.$tb_cancelPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Tb_cancels.
     * @param {tb_cancelDeleteManyArgs} args - Arguments to filter Tb_cancels to delete.
     * @example
     * // Delete a few Tb_cancels
     * const { count } = await prisma.tb_cancel.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends tb_cancelDeleteManyArgs>(args?: SelectSubset<T, tb_cancelDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tb_cancels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_cancelUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tb_cancels
     * const tb_cancel = await prisma.tb_cancel.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends tb_cancelUpdateManyArgs>(args: SelectSubset<T, tb_cancelUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Tb_cancel.
     * @param {tb_cancelUpsertArgs} args - Arguments to update or create a Tb_cancel.
     * @example
     * // Update or create a Tb_cancel
     * const tb_cancel = await prisma.tb_cancel.upsert({
     *   create: {
     *     // ... data to create a Tb_cancel
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tb_cancel we want to update
     *   }
     * })
     */
    upsert<T extends tb_cancelUpsertArgs>(args: SelectSubset<T, tb_cancelUpsertArgs<ExtArgs>>): Prisma__tb_cancelClient<$Result.GetResult<Prisma.$tb_cancelPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Tb_cancels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_cancelCountArgs} args - Arguments to filter Tb_cancels to count.
     * @example
     * // Count the number of Tb_cancels
     * const count = await prisma.tb_cancel.count({
     *   where: {
     *     // ... the filter for the Tb_cancels we want to count
     *   }
     * })
    **/
    count<T extends tb_cancelCountArgs>(
      args?: Subset<T, tb_cancelCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Tb_cancelCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tb_cancel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Tb_cancelAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Tb_cancelAggregateArgs>(args: Subset<T, Tb_cancelAggregateArgs>): Prisma.PrismaPromise<GetTb_cancelAggregateType<T>>

    /**
     * Group by Tb_cancel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_cancelGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends tb_cancelGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: tb_cancelGroupByArgs['orderBy'] }
        : { orderBy?: tb_cancelGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, tb_cancelGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTb_cancelGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the tb_cancel model
   */
  readonly fields: tb_cancelFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for tb_cancel.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__tb_cancelClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the tb_cancel model
   */
  interface tb_cancelFieldRefs {
    readonly id: FieldRef<"tb_cancel", 'Int'>
    readonly personal_id: FieldRef<"tb_cancel", 'Int'>
    readonly case_id: FieldRef<"tb_cancel", 'Int'>
    readonly decision_date: FieldRef<"tb_cancel", 'DateTime'>
    readonly uploader: FieldRef<"tb_cancel", 'Int'>
    readonly uploaded: FieldRef<"tb_cancel", 'DateTime'>
    readonly file_id: FieldRef<"tb_cancel", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * tb_cancel findUnique
   */
  export type tb_cancelFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_cancel
     */
    select?: tb_cancelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_cancel
     */
    omit?: tb_cancelOmit<ExtArgs> | null
    /**
     * Filter, which tb_cancel to fetch.
     */
    where: tb_cancelWhereUniqueInput
  }

  /**
   * tb_cancel findUniqueOrThrow
   */
  export type tb_cancelFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_cancel
     */
    select?: tb_cancelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_cancel
     */
    omit?: tb_cancelOmit<ExtArgs> | null
    /**
     * Filter, which tb_cancel to fetch.
     */
    where: tb_cancelWhereUniqueInput
  }

  /**
   * tb_cancel findFirst
   */
  export type tb_cancelFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_cancel
     */
    select?: tb_cancelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_cancel
     */
    omit?: tb_cancelOmit<ExtArgs> | null
    /**
     * Filter, which tb_cancel to fetch.
     */
    where?: tb_cancelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tb_cancels to fetch.
     */
    orderBy?: tb_cancelOrderByWithRelationInput | tb_cancelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tb_cancels.
     */
    cursor?: tb_cancelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tb_cancels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tb_cancels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tb_cancels.
     */
    distinct?: Tb_cancelScalarFieldEnum | Tb_cancelScalarFieldEnum[]
  }

  /**
   * tb_cancel findFirstOrThrow
   */
  export type tb_cancelFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_cancel
     */
    select?: tb_cancelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_cancel
     */
    omit?: tb_cancelOmit<ExtArgs> | null
    /**
     * Filter, which tb_cancel to fetch.
     */
    where?: tb_cancelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tb_cancels to fetch.
     */
    orderBy?: tb_cancelOrderByWithRelationInput | tb_cancelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tb_cancels.
     */
    cursor?: tb_cancelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tb_cancels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tb_cancels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tb_cancels.
     */
    distinct?: Tb_cancelScalarFieldEnum | Tb_cancelScalarFieldEnum[]
  }

  /**
   * tb_cancel findMany
   */
  export type tb_cancelFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_cancel
     */
    select?: tb_cancelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_cancel
     */
    omit?: tb_cancelOmit<ExtArgs> | null
    /**
     * Filter, which tb_cancels to fetch.
     */
    where?: tb_cancelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tb_cancels to fetch.
     */
    orderBy?: tb_cancelOrderByWithRelationInput | tb_cancelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing tb_cancels.
     */
    cursor?: tb_cancelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tb_cancels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tb_cancels.
     */
    skip?: number
    distinct?: Tb_cancelScalarFieldEnum | Tb_cancelScalarFieldEnum[]
  }

  /**
   * tb_cancel create
   */
  export type tb_cancelCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_cancel
     */
    select?: tb_cancelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_cancel
     */
    omit?: tb_cancelOmit<ExtArgs> | null
    /**
     * The data needed to create a tb_cancel.
     */
    data: XOR<tb_cancelCreateInput, tb_cancelUncheckedCreateInput>
  }

  /**
   * tb_cancel createMany
   */
  export type tb_cancelCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many tb_cancels.
     */
    data: tb_cancelCreateManyInput | tb_cancelCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * tb_cancel update
   */
  export type tb_cancelUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_cancel
     */
    select?: tb_cancelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_cancel
     */
    omit?: tb_cancelOmit<ExtArgs> | null
    /**
     * The data needed to update a tb_cancel.
     */
    data: XOR<tb_cancelUpdateInput, tb_cancelUncheckedUpdateInput>
    /**
     * Choose, which tb_cancel to update.
     */
    where: tb_cancelWhereUniqueInput
  }

  /**
   * tb_cancel updateMany
   */
  export type tb_cancelUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update tb_cancels.
     */
    data: XOR<tb_cancelUpdateManyMutationInput, tb_cancelUncheckedUpdateManyInput>
    /**
     * Filter which tb_cancels to update
     */
    where?: tb_cancelWhereInput
    /**
     * Limit how many tb_cancels to update.
     */
    limit?: number
  }

  /**
   * tb_cancel upsert
   */
  export type tb_cancelUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_cancel
     */
    select?: tb_cancelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_cancel
     */
    omit?: tb_cancelOmit<ExtArgs> | null
    /**
     * The filter to search for the tb_cancel to update in case it exists.
     */
    where: tb_cancelWhereUniqueInput
    /**
     * In case the tb_cancel found by the `where` argument doesn't exist, create a new tb_cancel with this data.
     */
    create: XOR<tb_cancelCreateInput, tb_cancelUncheckedCreateInput>
    /**
     * In case the tb_cancel was found with the provided `where` argument, update it with this data.
     */
    update: XOR<tb_cancelUpdateInput, tb_cancelUncheckedUpdateInput>
  }

  /**
   * tb_cancel delete
   */
  export type tb_cancelDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_cancel
     */
    select?: tb_cancelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_cancel
     */
    omit?: tb_cancelOmit<ExtArgs> | null
    /**
     * Filter which tb_cancel to delete.
     */
    where: tb_cancelWhereUniqueInput
  }

  /**
   * tb_cancel deleteMany
   */
  export type tb_cancelDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tb_cancels to delete
     */
    where?: tb_cancelWhereInput
    /**
     * Limit how many tb_cancels to delete.
     */
    limit?: number
  }

  /**
   * tb_cancel without action
   */
  export type tb_cancelDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_cancel
     */
    select?: tb_cancelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_cancel
     */
    omit?: tb_cancelOmit<ExtArgs> | null
  }


  /**
   * Model tb_cards
   */

  export type AggregateTb_cards = {
    _count: Tb_cardsCountAggregateOutputType | null
    _avg: Tb_cardsAvgAggregateOutputType | null
    _sum: Tb_cardsSumAggregateOutputType | null
    _min: Tb_cardsMinAggregateOutputType | null
    _max: Tb_cardsMaxAggregateOutputType | null
  }

  export type Tb_cardsAvgAggregateOutputType = {
    card_id: number | null
    card_number: number | null
    personal_id: number | null
    actual_card: number | null
  }

  export type Tb_cardsSumAggregateOutputType = {
    card_id: number | null
    card_number: number | null
    personal_id: number | null
    actual_card: number | null
  }

  export type Tb_cardsMinAggregateOutputType = {
    card_id: number | null
    serial: string | null
    card_number: number | null
    personal_id: number | null
    issued: Date | null
    full_address: string | null
    valid: Date | null
    bar: string | null
    printed: Date | null
    actual_card: number | null
  }

  export type Tb_cardsMaxAggregateOutputType = {
    card_id: number | null
    serial: string | null
    card_number: number | null
    personal_id: number | null
    issued: Date | null
    full_address: string | null
    valid: Date | null
    bar: string | null
    printed: Date | null
    actual_card: number | null
  }

  export type Tb_cardsCountAggregateOutputType = {
    card_id: number
    serial: number
    card_number: number
    personal_id: number
    issued: number
    full_address: number
    valid: number
    bar: number
    printed: number
    actual_card: number
    _all: number
  }


  export type Tb_cardsAvgAggregateInputType = {
    card_id?: true
    card_number?: true
    personal_id?: true
    actual_card?: true
  }

  export type Tb_cardsSumAggregateInputType = {
    card_id?: true
    card_number?: true
    personal_id?: true
    actual_card?: true
  }

  export type Tb_cardsMinAggregateInputType = {
    card_id?: true
    serial?: true
    card_number?: true
    personal_id?: true
    issued?: true
    full_address?: true
    valid?: true
    bar?: true
    printed?: true
    actual_card?: true
  }

  export type Tb_cardsMaxAggregateInputType = {
    card_id?: true
    serial?: true
    card_number?: true
    personal_id?: true
    issued?: true
    full_address?: true
    valid?: true
    bar?: true
    printed?: true
    actual_card?: true
  }

  export type Tb_cardsCountAggregateInputType = {
    card_id?: true
    serial?: true
    card_number?: true
    personal_id?: true
    issued?: true
    full_address?: true
    valid?: true
    bar?: true
    printed?: true
    actual_card?: true
    _all?: true
  }

  export type Tb_cardsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tb_cards to aggregate.
     */
    where?: tb_cardsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tb_cards to fetch.
     */
    orderBy?: tb_cardsOrderByWithRelationInput | tb_cardsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: tb_cardsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tb_cards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tb_cards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned tb_cards
    **/
    _count?: true | Tb_cardsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Tb_cardsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Tb_cardsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Tb_cardsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Tb_cardsMaxAggregateInputType
  }

  export type GetTb_cardsAggregateType<T extends Tb_cardsAggregateArgs> = {
        [P in keyof T & keyof AggregateTb_cards]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTb_cards[P]>
      : GetScalarType<T[P], AggregateTb_cards[P]>
  }




  export type tb_cardsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: tb_cardsWhereInput
    orderBy?: tb_cardsOrderByWithAggregationInput | tb_cardsOrderByWithAggregationInput[]
    by: Tb_cardsScalarFieldEnum[] | Tb_cardsScalarFieldEnum
    having?: tb_cardsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Tb_cardsCountAggregateInputType | true
    _avg?: Tb_cardsAvgAggregateInputType
    _sum?: Tb_cardsSumAggregateInputType
    _min?: Tb_cardsMinAggregateInputType
    _max?: Tb_cardsMaxAggregateInputType
  }

  export type Tb_cardsGroupByOutputType = {
    card_id: number
    serial: string
    card_number: number
    personal_id: number
    issued: Date
    full_address: string | null
    valid: Date
    bar: string
    printed: Date
    actual_card: number
    _count: Tb_cardsCountAggregateOutputType | null
    _avg: Tb_cardsAvgAggregateOutputType | null
    _sum: Tb_cardsSumAggregateOutputType | null
    _min: Tb_cardsMinAggregateOutputType | null
    _max: Tb_cardsMaxAggregateOutputType | null
  }

  type GetTb_cardsGroupByPayload<T extends tb_cardsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Tb_cardsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Tb_cardsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Tb_cardsGroupByOutputType[P]>
            : GetScalarType<T[P], Tb_cardsGroupByOutputType[P]>
        }
      >
    >


  export type tb_cardsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    card_id?: boolean
    serial?: boolean
    card_number?: boolean
    personal_id?: boolean
    issued?: boolean
    full_address?: boolean
    valid?: boolean
    bar?: boolean
    printed?: boolean
    actual_card?: boolean
  }, ExtArgs["result"]["tb_cards"]>



  export type tb_cardsSelectScalar = {
    card_id?: boolean
    serial?: boolean
    card_number?: boolean
    personal_id?: boolean
    issued?: boolean
    full_address?: boolean
    valid?: boolean
    bar?: boolean
    printed?: boolean
    actual_card?: boolean
  }

  export type tb_cardsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"card_id" | "serial" | "card_number" | "personal_id" | "issued" | "full_address" | "valid" | "bar" | "printed" | "actual_card", ExtArgs["result"]["tb_cards"]>

  export type $tb_cardsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "tb_cards"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      card_id: number
      serial: string
      card_number: number
      personal_id: number
      issued: Date
      full_address: string | null
      valid: Date
      bar: string
      printed: Date
      actual_card: number
    }, ExtArgs["result"]["tb_cards"]>
    composites: {}
  }

  type tb_cardsGetPayload<S extends boolean | null | undefined | tb_cardsDefaultArgs> = $Result.GetResult<Prisma.$tb_cardsPayload, S>

  type tb_cardsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<tb_cardsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Tb_cardsCountAggregateInputType | true
    }

  export interface tb_cardsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['tb_cards'], meta: { name: 'tb_cards' } }
    /**
     * Find zero or one Tb_cards that matches the filter.
     * @param {tb_cardsFindUniqueArgs} args - Arguments to find a Tb_cards
     * @example
     * // Get one Tb_cards
     * const tb_cards = await prisma.tb_cards.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends tb_cardsFindUniqueArgs>(args: SelectSubset<T, tb_cardsFindUniqueArgs<ExtArgs>>): Prisma__tb_cardsClient<$Result.GetResult<Prisma.$tb_cardsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Tb_cards that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {tb_cardsFindUniqueOrThrowArgs} args - Arguments to find a Tb_cards
     * @example
     * // Get one Tb_cards
     * const tb_cards = await prisma.tb_cards.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends tb_cardsFindUniqueOrThrowArgs>(args: SelectSubset<T, tb_cardsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__tb_cardsClient<$Result.GetResult<Prisma.$tb_cardsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tb_cards that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_cardsFindFirstArgs} args - Arguments to find a Tb_cards
     * @example
     * // Get one Tb_cards
     * const tb_cards = await prisma.tb_cards.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends tb_cardsFindFirstArgs>(args?: SelectSubset<T, tb_cardsFindFirstArgs<ExtArgs>>): Prisma__tb_cardsClient<$Result.GetResult<Prisma.$tb_cardsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tb_cards that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_cardsFindFirstOrThrowArgs} args - Arguments to find a Tb_cards
     * @example
     * // Get one Tb_cards
     * const tb_cards = await prisma.tb_cards.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends tb_cardsFindFirstOrThrowArgs>(args?: SelectSubset<T, tb_cardsFindFirstOrThrowArgs<ExtArgs>>): Prisma__tb_cardsClient<$Result.GetResult<Prisma.$tb_cardsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Tb_cards that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_cardsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tb_cards
     * const tb_cards = await prisma.tb_cards.findMany()
     * 
     * // Get first 10 Tb_cards
     * const tb_cards = await prisma.tb_cards.findMany({ take: 10 })
     * 
     * // Only select the `card_id`
     * const tb_cardsWithCard_idOnly = await prisma.tb_cards.findMany({ select: { card_id: true } })
     * 
     */
    findMany<T extends tb_cardsFindManyArgs>(args?: SelectSubset<T, tb_cardsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tb_cardsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Tb_cards.
     * @param {tb_cardsCreateArgs} args - Arguments to create a Tb_cards.
     * @example
     * // Create one Tb_cards
     * const Tb_cards = await prisma.tb_cards.create({
     *   data: {
     *     // ... data to create a Tb_cards
     *   }
     * })
     * 
     */
    create<T extends tb_cardsCreateArgs>(args: SelectSubset<T, tb_cardsCreateArgs<ExtArgs>>): Prisma__tb_cardsClient<$Result.GetResult<Prisma.$tb_cardsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Tb_cards.
     * @param {tb_cardsCreateManyArgs} args - Arguments to create many Tb_cards.
     * @example
     * // Create many Tb_cards
     * const tb_cards = await prisma.tb_cards.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends tb_cardsCreateManyArgs>(args?: SelectSubset<T, tb_cardsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Tb_cards.
     * @param {tb_cardsDeleteArgs} args - Arguments to delete one Tb_cards.
     * @example
     * // Delete one Tb_cards
     * const Tb_cards = await prisma.tb_cards.delete({
     *   where: {
     *     // ... filter to delete one Tb_cards
     *   }
     * })
     * 
     */
    delete<T extends tb_cardsDeleteArgs>(args: SelectSubset<T, tb_cardsDeleteArgs<ExtArgs>>): Prisma__tb_cardsClient<$Result.GetResult<Prisma.$tb_cardsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Tb_cards.
     * @param {tb_cardsUpdateArgs} args - Arguments to update one Tb_cards.
     * @example
     * // Update one Tb_cards
     * const tb_cards = await prisma.tb_cards.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends tb_cardsUpdateArgs>(args: SelectSubset<T, tb_cardsUpdateArgs<ExtArgs>>): Prisma__tb_cardsClient<$Result.GetResult<Prisma.$tb_cardsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Tb_cards.
     * @param {tb_cardsDeleteManyArgs} args - Arguments to filter Tb_cards to delete.
     * @example
     * // Delete a few Tb_cards
     * const { count } = await prisma.tb_cards.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends tb_cardsDeleteManyArgs>(args?: SelectSubset<T, tb_cardsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tb_cards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_cardsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tb_cards
     * const tb_cards = await prisma.tb_cards.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends tb_cardsUpdateManyArgs>(args: SelectSubset<T, tb_cardsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Tb_cards.
     * @param {tb_cardsUpsertArgs} args - Arguments to update or create a Tb_cards.
     * @example
     * // Update or create a Tb_cards
     * const tb_cards = await prisma.tb_cards.upsert({
     *   create: {
     *     // ... data to create a Tb_cards
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tb_cards we want to update
     *   }
     * })
     */
    upsert<T extends tb_cardsUpsertArgs>(args: SelectSubset<T, tb_cardsUpsertArgs<ExtArgs>>): Prisma__tb_cardsClient<$Result.GetResult<Prisma.$tb_cardsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Tb_cards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_cardsCountArgs} args - Arguments to filter Tb_cards to count.
     * @example
     * // Count the number of Tb_cards
     * const count = await prisma.tb_cards.count({
     *   where: {
     *     // ... the filter for the Tb_cards we want to count
     *   }
     * })
    **/
    count<T extends tb_cardsCountArgs>(
      args?: Subset<T, tb_cardsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Tb_cardsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tb_cards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Tb_cardsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Tb_cardsAggregateArgs>(args: Subset<T, Tb_cardsAggregateArgs>): Prisma.PrismaPromise<GetTb_cardsAggregateType<T>>

    /**
     * Group by Tb_cards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_cardsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends tb_cardsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: tb_cardsGroupByArgs['orderBy'] }
        : { orderBy?: tb_cardsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, tb_cardsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTb_cardsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the tb_cards model
   */
  readonly fields: tb_cardsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for tb_cards.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__tb_cardsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the tb_cards model
   */
  interface tb_cardsFieldRefs {
    readonly card_id: FieldRef<"tb_cards", 'Int'>
    readonly serial: FieldRef<"tb_cards", 'String'>
    readonly card_number: FieldRef<"tb_cards", 'Int'>
    readonly personal_id: FieldRef<"tb_cards", 'Int'>
    readonly issued: FieldRef<"tb_cards", 'DateTime'>
    readonly full_address: FieldRef<"tb_cards", 'String'>
    readonly valid: FieldRef<"tb_cards", 'DateTime'>
    readonly bar: FieldRef<"tb_cards", 'String'>
    readonly printed: FieldRef<"tb_cards", 'DateTime'>
    readonly actual_card: FieldRef<"tb_cards", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * tb_cards findUnique
   */
  export type tb_cardsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_cards
     */
    select?: tb_cardsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_cards
     */
    omit?: tb_cardsOmit<ExtArgs> | null
    /**
     * Filter, which tb_cards to fetch.
     */
    where: tb_cardsWhereUniqueInput
  }

  /**
   * tb_cards findUniqueOrThrow
   */
  export type tb_cardsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_cards
     */
    select?: tb_cardsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_cards
     */
    omit?: tb_cardsOmit<ExtArgs> | null
    /**
     * Filter, which tb_cards to fetch.
     */
    where: tb_cardsWhereUniqueInput
  }

  /**
   * tb_cards findFirst
   */
  export type tb_cardsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_cards
     */
    select?: tb_cardsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_cards
     */
    omit?: tb_cardsOmit<ExtArgs> | null
    /**
     * Filter, which tb_cards to fetch.
     */
    where?: tb_cardsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tb_cards to fetch.
     */
    orderBy?: tb_cardsOrderByWithRelationInput | tb_cardsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tb_cards.
     */
    cursor?: tb_cardsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tb_cards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tb_cards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tb_cards.
     */
    distinct?: Tb_cardsScalarFieldEnum | Tb_cardsScalarFieldEnum[]
  }

  /**
   * tb_cards findFirstOrThrow
   */
  export type tb_cardsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_cards
     */
    select?: tb_cardsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_cards
     */
    omit?: tb_cardsOmit<ExtArgs> | null
    /**
     * Filter, which tb_cards to fetch.
     */
    where?: tb_cardsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tb_cards to fetch.
     */
    orderBy?: tb_cardsOrderByWithRelationInput | tb_cardsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tb_cards.
     */
    cursor?: tb_cardsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tb_cards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tb_cards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tb_cards.
     */
    distinct?: Tb_cardsScalarFieldEnum | Tb_cardsScalarFieldEnum[]
  }

  /**
   * tb_cards findMany
   */
  export type tb_cardsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_cards
     */
    select?: tb_cardsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_cards
     */
    omit?: tb_cardsOmit<ExtArgs> | null
    /**
     * Filter, which tb_cards to fetch.
     */
    where?: tb_cardsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tb_cards to fetch.
     */
    orderBy?: tb_cardsOrderByWithRelationInput | tb_cardsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing tb_cards.
     */
    cursor?: tb_cardsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tb_cards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tb_cards.
     */
    skip?: number
    distinct?: Tb_cardsScalarFieldEnum | Tb_cardsScalarFieldEnum[]
  }

  /**
   * tb_cards create
   */
  export type tb_cardsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_cards
     */
    select?: tb_cardsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_cards
     */
    omit?: tb_cardsOmit<ExtArgs> | null
    /**
     * The data needed to create a tb_cards.
     */
    data: XOR<tb_cardsCreateInput, tb_cardsUncheckedCreateInput>
  }

  /**
   * tb_cards createMany
   */
  export type tb_cardsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many tb_cards.
     */
    data: tb_cardsCreateManyInput | tb_cardsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * tb_cards update
   */
  export type tb_cardsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_cards
     */
    select?: tb_cardsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_cards
     */
    omit?: tb_cardsOmit<ExtArgs> | null
    /**
     * The data needed to update a tb_cards.
     */
    data: XOR<tb_cardsUpdateInput, tb_cardsUncheckedUpdateInput>
    /**
     * Choose, which tb_cards to update.
     */
    where: tb_cardsWhereUniqueInput
  }

  /**
   * tb_cards updateMany
   */
  export type tb_cardsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update tb_cards.
     */
    data: XOR<tb_cardsUpdateManyMutationInput, tb_cardsUncheckedUpdateManyInput>
    /**
     * Filter which tb_cards to update
     */
    where?: tb_cardsWhereInput
    /**
     * Limit how many tb_cards to update.
     */
    limit?: number
  }

  /**
   * tb_cards upsert
   */
  export type tb_cardsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_cards
     */
    select?: tb_cardsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_cards
     */
    omit?: tb_cardsOmit<ExtArgs> | null
    /**
     * The filter to search for the tb_cards to update in case it exists.
     */
    where: tb_cardsWhereUniqueInput
    /**
     * In case the tb_cards found by the `where` argument doesn't exist, create a new tb_cards with this data.
     */
    create: XOR<tb_cardsCreateInput, tb_cardsUncheckedCreateInput>
    /**
     * In case the tb_cards was found with the provided `where` argument, update it with this data.
     */
    update: XOR<tb_cardsUpdateInput, tb_cardsUncheckedUpdateInput>
  }

  /**
   * tb_cards delete
   */
  export type tb_cardsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_cards
     */
    select?: tb_cardsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_cards
     */
    omit?: tb_cardsOmit<ExtArgs> | null
    /**
     * Filter which tb_cards to delete.
     */
    where: tb_cardsWhereUniqueInput
  }

  /**
   * tb_cards deleteMany
   */
  export type tb_cardsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tb_cards to delete
     */
    where?: tb_cardsWhereInput
    /**
     * Limit how many tb_cards to delete.
     */
    limit?: number
  }

  /**
   * tb_cards without action
   */
  export type tb_cardsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_cards
     */
    select?: tb_cardsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_cards
     */
    omit?: tb_cardsOmit<ExtArgs> | null
  }


  /**
   * Model tb_case
   */

  export type AggregateTb_case = {
    _count: Tb_caseCountAggregateOutputType | null
    _avg: Tb_caseAvgAggregateOutputType | null
    _sum: Tb_caseSumAggregateOutputType | null
    _min: Tb_caseMinAggregateOutputType | null
    _max: Tb_caseMaxAggregateOutputType | null
  }

  export type Tb_caseAvgAggregateOutputType = {
    case_id: number | null
    reg_by: number | null
    officer: number | null
    preferred_lawyer: number | null
    unaccompanied_child: number | null
    separated_child: number | null
    single_parent: number | null
    RA_marz: number | null
    RA_community: number | null
    RA_settlement: number | null
    case_status: number | null
    MS_lawyer: number | null
    special: number | null
    reopened: number | null
    attached_case: number | null
  }

  export type Tb_caseSumAggregateOutputType = {
    case_id: number | null
    reg_by: number | null
    officer: number | null
    preferred_lawyer: number | null
    unaccompanied_child: number | null
    separated_child: number | null
    single_parent: number | null
    RA_marz: number | null
    RA_community: number | null
    RA_settlement: number | null
    case_status: number | null
    MS_lawyer: number | null
    special: number | null
    reopened: number | null
    attached_case: number | null
  }

  export type Tb_caseMinAggregateOutputType = {
    case_id: number | null
    application_date: Date | null
    input_date: Date | null
    reg_by: number | null
    officer: number | null
    preferred_lawyer: number | null
    unaccompanied_child: number | null
    separated_child: number | null
    single_parent: number | null
    prefered_language: string | null
    RA_marz: number | null
    RA_community: number | null
    RA_settlement: number | null
    RA_street: string | null
    RA_building: string | null
    RA_apartment: string | null
    contact_tel: string | null
    contact_email: string | null
    comment: string | null
    case_status: number | null
    mul_num: string | null
    mul_date: Date | null
    MS_lawyer: number | null
    special: number | null
    reopened: number | null
    attached_case: number | null
  }

  export type Tb_caseMaxAggregateOutputType = {
    case_id: number | null
    application_date: Date | null
    input_date: Date | null
    reg_by: number | null
    officer: number | null
    preferred_lawyer: number | null
    unaccompanied_child: number | null
    separated_child: number | null
    single_parent: number | null
    prefered_language: string | null
    RA_marz: number | null
    RA_community: number | null
    RA_settlement: number | null
    RA_street: string | null
    RA_building: string | null
    RA_apartment: string | null
    contact_tel: string | null
    contact_email: string | null
    comment: string | null
    case_status: number | null
    mul_num: string | null
    mul_date: Date | null
    MS_lawyer: number | null
    special: number | null
    reopened: number | null
    attached_case: number | null
  }

  export type Tb_caseCountAggregateOutputType = {
    case_id: number
    application_date: number
    input_date: number
    reg_by: number
    officer: number
    preferred_lawyer: number
    unaccompanied_child: number
    separated_child: number
    single_parent: number
    prefered_language: number
    RA_marz: number
    RA_community: number
    RA_settlement: number
    RA_street: number
    RA_building: number
    RA_apartment: number
    contact_tel: number
    contact_email: number
    comment: number
    case_status: number
    mul_num: number
    mul_date: number
    MS_lawyer: number
    special: number
    reopened: number
    attached_case: number
    _all: number
  }


  export type Tb_caseAvgAggregateInputType = {
    case_id?: true
    reg_by?: true
    officer?: true
    preferred_lawyer?: true
    unaccompanied_child?: true
    separated_child?: true
    single_parent?: true
    RA_marz?: true
    RA_community?: true
    RA_settlement?: true
    case_status?: true
    MS_lawyer?: true
    special?: true
    reopened?: true
    attached_case?: true
  }

  export type Tb_caseSumAggregateInputType = {
    case_id?: true
    reg_by?: true
    officer?: true
    preferred_lawyer?: true
    unaccompanied_child?: true
    separated_child?: true
    single_parent?: true
    RA_marz?: true
    RA_community?: true
    RA_settlement?: true
    case_status?: true
    MS_lawyer?: true
    special?: true
    reopened?: true
    attached_case?: true
  }

  export type Tb_caseMinAggregateInputType = {
    case_id?: true
    application_date?: true
    input_date?: true
    reg_by?: true
    officer?: true
    preferred_lawyer?: true
    unaccompanied_child?: true
    separated_child?: true
    single_parent?: true
    prefered_language?: true
    RA_marz?: true
    RA_community?: true
    RA_settlement?: true
    RA_street?: true
    RA_building?: true
    RA_apartment?: true
    contact_tel?: true
    contact_email?: true
    comment?: true
    case_status?: true
    mul_num?: true
    mul_date?: true
    MS_lawyer?: true
    special?: true
    reopened?: true
    attached_case?: true
  }

  export type Tb_caseMaxAggregateInputType = {
    case_id?: true
    application_date?: true
    input_date?: true
    reg_by?: true
    officer?: true
    preferred_lawyer?: true
    unaccompanied_child?: true
    separated_child?: true
    single_parent?: true
    prefered_language?: true
    RA_marz?: true
    RA_community?: true
    RA_settlement?: true
    RA_street?: true
    RA_building?: true
    RA_apartment?: true
    contact_tel?: true
    contact_email?: true
    comment?: true
    case_status?: true
    mul_num?: true
    mul_date?: true
    MS_lawyer?: true
    special?: true
    reopened?: true
    attached_case?: true
  }

  export type Tb_caseCountAggregateInputType = {
    case_id?: true
    application_date?: true
    input_date?: true
    reg_by?: true
    officer?: true
    preferred_lawyer?: true
    unaccompanied_child?: true
    separated_child?: true
    single_parent?: true
    prefered_language?: true
    RA_marz?: true
    RA_community?: true
    RA_settlement?: true
    RA_street?: true
    RA_building?: true
    RA_apartment?: true
    contact_tel?: true
    contact_email?: true
    comment?: true
    case_status?: true
    mul_num?: true
    mul_date?: true
    MS_lawyer?: true
    special?: true
    reopened?: true
    attached_case?: true
    _all?: true
  }

  export type Tb_caseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tb_case to aggregate.
     */
    where?: tb_caseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tb_cases to fetch.
     */
    orderBy?: tb_caseOrderByWithRelationInput | tb_caseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: tb_caseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tb_cases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tb_cases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned tb_cases
    **/
    _count?: true | Tb_caseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Tb_caseAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Tb_caseSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Tb_caseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Tb_caseMaxAggregateInputType
  }

  export type GetTb_caseAggregateType<T extends Tb_caseAggregateArgs> = {
        [P in keyof T & keyof AggregateTb_case]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTb_case[P]>
      : GetScalarType<T[P], AggregateTb_case[P]>
  }




  export type tb_caseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: tb_caseWhereInput
    orderBy?: tb_caseOrderByWithAggregationInput | tb_caseOrderByWithAggregationInput[]
    by: Tb_caseScalarFieldEnum[] | Tb_caseScalarFieldEnum
    having?: tb_caseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Tb_caseCountAggregateInputType | true
    _avg?: Tb_caseAvgAggregateInputType
    _sum?: Tb_caseSumAggregateInputType
    _min?: Tb_caseMinAggregateInputType
    _max?: Tb_caseMaxAggregateInputType
  }

  export type Tb_caseGroupByOutputType = {
    case_id: number
    application_date: Date
    input_date: Date
    reg_by: number
    officer: number | null
    preferred_lawyer: number
    unaccompanied_child: number
    separated_child: number
    single_parent: number
    prefered_language: string | null
    RA_marz: number | null
    RA_community: number | null
    RA_settlement: number | null
    RA_street: string | null
    RA_building: string | null
    RA_apartment: string | null
    contact_tel: string | null
    contact_email: string | null
    comment: string | null
    case_status: number | null
    mul_num: string | null
    mul_date: Date | null
    MS_lawyer: number | null
    special: number
    reopened: number
    attached_case: number | null
    _count: Tb_caseCountAggregateOutputType | null
    _avg: Tb_caseAvgAggregateOutputType | null
    _sum: Tb_caseSumAggregateOutputType | null
    _min: Tb_caseMinAggregateOutputType | null
    _max: Tb_caseMaxAggregateOutputType | null
  }

  type GetTb_caseGroupByPayload<T extends tb_caseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Tb_caseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Tb_caseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Tb_caseGroupByOutputType[P]>
            : GetScalarType<T[P], Tb_caseGroupByOutputType[P]>
        }
      >
    >


  export type tb_caseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    case_id?: boolean
    application_date?: boolean
    input_date?: boolean
    reg_by?: boolean
    officer?: boolean
    preferred_lawyer?: boolean
    unaccompanied_child?: boolean
    separated_child?: boolean
    single_parent?: boolean
    prefered_language?: boolean
    RA_marz?: boolean
    RA_community?: boolean
    RA_settlement?: boolean
    RA_street?: boolean
    RA_building?: boolean
    RA_apartment?: boolean
    contact_tel?: boolean
    contact_email?: boolean
    comment?: boolean
    case_status?: boolean
    mul_num?: boolean
    mul_date?: boolean
    MS_lawyer?: boolean
    special?: boolean
    reopened?: boolean
    attached_case?: boolean
  }, ExtArgs["result"]["tb_case"]>



  export type tb_caseSelectScalar = {
    case_id?: boolean
    application_date?: boolean
    input_date?: boolean
    reg_by?: boolean
    officer?: boolean
    preferred_lawyer?: boolean
    unaccompanied_child?: boolean
    separated_child?: boolean
    single_parent?: boolean
    prefered_language?: boolean
    RA_marz?: boolean
    RA_community?: boolean
    RA_settlement?: boolean
    RA_street?: boolean
    RA_building?: boolean
    RA_apartment?: boolean
    contact_tel?: boolean
    contact_email?: boolean
    comment?: boolean
    case_status?: boolean
    mul_num?: boolean
    mul_date?: boolean
    MS_lawyer?: boolean
    special?: boolean
    reopened?: boolean
    attached_case?: boolean
  }

  export type tb_caseOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"case_id" | "application_date" | "input_date" | "reg_by" | "officer" | "preferred_lawyer" | "unaccompanied_child" | "separated_child" | "single_parent" | "prefered_language" | "RA_marz" | "RA_community" | "RA_settlement" | "RA_street" | "RA_building" | "RA_apartment" | "contact_tel" | "contact_email" | "comment" | "case_status" | "mul_num" | "mul_date" | "MS_lawyer" | "special" | "reopened" | "attached_case", ExtArgs["result"]["tb_case"]>

  export type $tb_casePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "tb_case"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      case_id: number
      application_date: Date
      input_date: Date
      reg_by: number
      officer: number | null
      preferred_lawyer: number
      unaccompanied_child: number
      separated_child: number
      single_parent: number
      prefered_language: string | null
      RA_marz: number | null
      RA_community: number | null
      RA_settlement: number | null
      RA_street: string | null
      RA_building: string | null
      RA_apartment: string | null
      contact_tel: string | null
      contact_email: string | null
      comment: string | null
      case_status: number | null
      mul_num: string | null
      mul_date: Date | null
      MS_lawyer: number | null
      special: number
      reopened: number
      attached_case: number | null
    }, ExtArgs["result"]["tb_case"]>
    composites: {}
  }

  type tb_caseGetPayload<S extends boolean | null | undefined | tb_caseDefaultArgs> = $Result.GetResult<Prisma.$tb_casePayload, S>

  type tb_caseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<tb_caseFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Tb_caseCountAggregateInputType | true
    }

  export interface tb_caseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['tb_case'], meta: { name: 'tb_case' } }
    /**
     * Find zero or one Tb_case that matches the filter.
     * @param {tb_caseFindUniqueArgs} args - Arguments to find a Tb_case
     * @example
     * // Get one Tb_case
     * const tb_case = await prisma.tb_case.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends tb_caseFindUniqueArgs>(args: SelectSubset<T, tb_caseFindUniqueArgs<ExtArgs>>): Prisma__tb_caseClient<$Result.GetResult<Prisma.$tb_casePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Tb_case that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {tb_caseFindUniqueOrThrowArgs} args - Arguments to find a Tb_case
     * @example
     * // Get one Tb_case
     * const tb_case = await prisma.tb_case.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends tb_caseFindUniqueOrThrowArgs>(args: SelectSubset<T, tb_caseFindUniqueOrThrowArgs<ExtArgs>>): Prisma__tb_caseClient<$Result.GetResult<Prisma.$tb_casePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tb_case that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_caseFindFirstArgs} args - Arguments to find a Tb_case
     * @example
     * // Get one Tb_case
     * const tb_case = await prisma.tb_case.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends tb_caseFindFirstArgs>(args?: SelectSubset<T, tb_caseFindFirstArgs<ExtArgs>>): Prisma__tb_caseClient<$Result.GetResult<Prisma.$tb_casePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tb_case that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_caseFindFirstOrThrowArgs} args - Arguments to find a Tb_case
     * @example
     * // Get one Tb_case
     * const tb_case = await prisma.tb_case.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends tb_caseFindFirstOrThrowArgs>(args?: SelectSubset<T, tb_caseFindFirstOrThrowArgs<ExtArgs>>): Prisma__tb_caseClient<$Result.GetResult<Prisma.$tb_casePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Tb_cases that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_caseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tb_cases
     * const tb_cases = await prisma.tb_case.findMany()
     * 
     * // Get first 10 Tb_cases
     * const tb_cases = await prisma.tb_case.findMany({ take: 10 })
     * 
     * // Only select the `case_id`
     * const tb_caseWithCase_idOnly = await prisma.tb_case.findMany({ select: { case_id: true } })
     * 
     */
    findMany<T extends tb_caseFindManyArgs>(args?: SelectSubset<T, tb_caseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tb_casePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Tb_case.
     * @param {tb_caseCreateArgs} args - Arguments to create a Tb_case.
     * @example
     * // Create one Tb_case
     * const Tb_case = await prisma.tb_case.create({
     *   data: {
     *     // ... data to create a Tb_case
     *   }
     * })
     * 
     */
    create<T extends tb_caseCreateArgs>(args: SelectSubset<T, tb_caseCreateArgs<ExtArgs>>): Prisma__tb_caseClient<$Result.GetResult<Prisma.$tb_casePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Tb_cases.
     * @param {tb_caseCreateManyArgs} args - Arguments to create many Tb_cases.
     * @example
     * // Create many Tb_cases
     * const tb_case = await prisma.tb_case.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends tb_caseCreateManyArgs>(args?: SelectSubset<T, tb_caseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Tb_case.
     * @param {tb_caseDeleteArgs} args - Arguments to delete one Tb_case.
     * @example
     * // Delete one Tb_case
     * const Tb_case = await prisma.tb_case.delete({
     *   where: {
     *     // ... filter to delete one Tb_case
     *   }
     * })
     * 
     */
    delete<T extends tb_caseDeleteArgs>(args: SelectSubset<T, tb_caseDeleteArgs<ExtArgs>>): Prisma__tb_caseClient<$Result.GetResult<Prisma.$tb_casePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Tb_case.
     * @param {tb_caseUpdateArgs} args - Arguments to update one Tb_case.
     * @example
     * // Update one Tb_case
     * const tb_case = await prisma.tb_case.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends tb_caseUpdateArgs>(args: SelectSubset<T, tb_caseUpdateArgs<ExtArgs>>): Prisma__tb_caseClient<$Result.GetResult<Prisma.$tb_casePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Tb_cases.
     * @param {tb_caseDeleteManyArgs} args - Arguments to filter Tb_cases to delete.
     * @example
     * // Delete a few Tb_cases
     * const { count } = await prisma.tb_case.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends tb_caseDeleteManyArgs>(args?: SelectSubset<T, tb_caseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tb_cases.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_caseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tb_cases
     * const tb_case = await prisma.tb_case.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends tb_caseUpdateManyArgs>(args: SelectSubset<T, tb_caseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Tb_case.
     * @param {tb_caseUpsertArgs} args - Arguments to update or create a Tb_case.
     * @example
     * // Update or create a Tb_case
     * const tb_case = await prisma.tb_case.upsert({
     *   create: {
     *     // ... data to create a Tb_case
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tb_case we want to update
     *   }
     * })
     */
    upsert<T extends tb_caseUpsertArgs>(args: SelectSubset<T, tb_caseUpsertArgs<ExtArgs>>): Prisma__tb_caseClient<$Result.GetResult<Prisma.$tb_casePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Tb_cases.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_caseCountArgs} args - Arguments to filter Tb_cases to count.
     * @example
     * // Count the number of Tb_cases
     * const count = await prisma.tb_case.count({
     *   where: {
     *     // ... the filter for the Tb_cases we want to count
     *   }
     * })
    **/
    count<T extends tb_caseCountArgs>(
      args?: Subset<T, tb_caseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Tb_caseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tb_case.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Tb_caseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Tb_caseAggregateArgs>(args: Subset<T, Tb_caseAggregateArgs>): Prisma.PrismaPromise<GetTb_caseAggregateType<T>>

    /**
     * Group by Tb_case.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_caseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends tb_caseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: tb_caseGroupByArgs['orderBy'] }
        : { orderBy?: tb_caseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, tb_caseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTb_caseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the tb_case model
   */
  readonly fields: tb_caseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for tb_case.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__tb_caseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the tb_case model
   */
  interface tb_caseFieldRefs {
    readonly case_id: FieldRef<"tb_case", 'Int'>
    readonly application_date: FieldRef<"tb_case", 'DateTime'>
    readonly input_date: FieldRef<"tb_case", 'DateTime'>
    readonly reg_by: FieldRef<"tb_case", 'Int'>
    readonly officer: FieldRef<"tb_case", 'Int'>
    readonly preferred_lawyer: FieldRef<"tb_case", 'Int'>
    readonly unaccompanied_child: FieldRef<"tb_case", 'Int'>
    readonly separated_child: FieldRef<"tb_case", 'Int'>
    readonly single_parent: FieldRef<"tb_case", 'Int'>
    readonly prefered_language: FieldRef<"tb_case", 'String'>
    readonly RA_marz: FieldRef<"tb_case", 'Int'>
    readonly RA_community: FieldRef<"tb_case", 'Int'>
    readonly RA_settlement: FieldRef<"tb_case", 'Int'>
    readonly RA_street: FieldRef<"tb_case", 'String'>
    readonly RA_building: FieldRef<"tb_case", 'String'>
    readonly RA_apartment: FieldRef<"tb_case", 'String'>
    readonly contact_tel: FieldRef<"tb_case", 'String'>
    readonly contact_email: FieldRef<"tb_case", 'String'>
    readonly comment: FieldRef<"tb_case", 'String'>
    readonly case_status: FieldRef<"tb_case", 'Int'>
    readonly mul_num: FieldRef<"tb_case", 'String'>
    readonly mul_date: FieldRef<"tb_case", 'DateTime'>
    readonly MS_lawyer: FieldRef<"tb_case", 'Int'>
    readonly special: FieldRef<"tb_case", 'Int'>
    readonly reopened: FieldRef<"tb_case", 'Int'>
    readonly attached_case: FieldRef<"tb_case", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * tb_case findUnique
   */
  export type tb_caseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_case
     */
    select?: tb_caseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_case
     */
    omit?: tb_caseOmit<ExtArgs> | null
    /**
     * Filter, which tb_case to fetch.
     */
    where: tb_caseWhereUniqueInput
  }

  /**
   * tb_case findUniqueOrThrow
   */
  export type tb_caseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_case
     */
    select?: tb_caseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_case
     */
    omit?: tb_caseOmit<ExtArgs> | null
    /**
     * Filter, which tb_case to fetch.
     */
    where: tb_caseWhereUniqueInput
  }

  /**
   * tb_case findFirst
   */
  export type tb_caseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_case
     */
    select?: tb_caseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_case
     */
    omit?: tb_caseOmit<ExtArgs> | null
    /**
     * Filter, which tb_case to fetch.
     */
    where?: tb_caseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tb_cases to fetch.
     */
    orderBy?: tb_caseOrderByWithRelationInput | tb_caseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tb_cases.
     */
    cursor?: tb_caseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tb_cases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tb_cases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tb_cases.
     */
    distinct?: Tb_caseScalarFieldEnum | Tb_caseScalarFieldEnum[]
  }

  /**
   * tb_case findFirstOrThrow
   */
  export type tb_caseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_case
     */
    select?: tb_caseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_case
     */
    omit?: tb_caseOmit<ExtArgs> | null
    /**
     * Filter, which tb_case to fetch.
     */
    where?: tb_caseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tb_cases to fetch.
     */
    orderBy?: tb_caseOrderByWithRelationInput | tb_caseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tb_cases.
     */
    cursor?: tb_caseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tb_cases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tb_cases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tb_cases.
     */
    distinct?: Tb_caseScalarFieldEnum | Tb_caseScalarFieldEnum[]
  }

  /**
   * tb_case findMany
   */
  export type tb_caseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_case
     */
    select?: tb_caseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_case
     */
    omit?: tb_caseOmit<ExtArgs> | null
    /**
     * Filter, which tb_cases to fetch.
     */
    where?: tb_caseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tb_cases to fetch.
     */
    orderBy?: tb_caseOrderByWithRelationInput | tb_caseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing tb_cases.
     */
    cursor?: tb_caseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tb_cases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tb_cases.
     */
    skip?: number
    distinct?: Tb_caseScalarFieldEnum | Tb_caseScalarFieldEnum[]
  }

  /**
   * tb_case create
   */
  export type tb_caseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_case
     */
    select?: tb_caseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_case
     */
    omit?: tb_caseOmit<ExtArgs> | null
    /**
     * The data needed to create a tb_case.
     */
    data: XOR<tb_caseCreateInput, tb_caseUncheckedCreateInput>
  }

  /**
   * tb_case createMany
   */
  export type tb_caseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many tb_cases.
     */
    data: tb_caseCreateManyInput | tb_caseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * tb_case update
   */
  export type tb_caseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_case
     */
    select?: tb_caseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_case
     */
    omit?: tb_caseOmit<ExtArgs> | null
    /**
     * The data needed to update a tb_case.
     */
    data: XOR<tb_caseUpdateInput, tb_caseUncheckedUpdateInput>
    /**
     * Choose, which tb_case to update.
     */
    where: tb_caseWhereUniqueInput
  }

  /**
   * tb_case updateMany
   */
  export type tb_caseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update tb_cases.
     */
    data: XOR<tb_caseUpdateManyMutationInput, tb_caseUncheckedUpdateManyInput>
    /**
     * Filter which tb_cases to update
     */
    where?: tb_caseWhereInput
    /**
     * Limit how many tb_cases to update.
     */
    limit?: number
  }

  /**
   * tb_case upsert
   */
  export type tb_caseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_case
     */
    select?: tb_caseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_case
     */
    omit?: tb_caseOmit<ExtArgs> | null
    /**
     * The filter to search for the tb_case to update in case it exists.
     */
    where: tb_caseWhereUniqueInput
    /**
     * In case the tb_case found by the `where` argument doesn't exist, create a new tb_case with this data.
     */
    create: XOR<tb_caseCreateInput, tb_caseUncheckedCreateInput>
    /**
     * In case the tb_case was found with the provided `where` argument, update it with this data.
     */
    update: XOR<tb_caseUpdateInput, tb_caseUncheckedUpdateInput>
  }

  /**
   * tb_case delete
   */
  export type tb_caseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_case
     */
    select?: tb_caseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_case
     */
    omit?: tb_caseOmit<ExtArgs> | null
    /**
     * Filter which tb_case to delete.
     */
    where: tb_caseWhereUniqueInput
  }

  /**
   * tb_case deleteMany
   */
  export type tb_caseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tb_cases to delete
     */
    where?: tb_caseWhereInput
    /**
     * Limit how many tb_cases to delete.
     */
    limit?: number
  }

  /**
   * tb_case without action
   */
  export type tb_caseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_case
     */
    select?: tb_caseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_case
     */
    omit?: tb_caseOmit<ExtArgs> | null
  }


  /**
   * Model tb_case_status
   */

  export type AggregateTb_case_status = {
    _count: Tb_case_statusCountAggregateOutputType | null
    _avg: Tb_case_statusAvgAggregateOutputType | null
    _sum: Tb_case_statusSumAggregateOutputType | null
    _min: Tb_case_statusMinAggregateOutputType | null
    _max: Tb_case_statusMaxAggregateOutputType | null
  }

  export type Tb_case_statusAvgAggregateOutputType = {
    case_status_id: number | null
  }

  export type Tb_case_statusSumAggregateOutputType = {
    case_status_id: number | null
  }

  export type Tb_case_statusMinAggregateOutputType = {
    case_status_id: number | null
    case_status: string | null
    case_status_eng: string | null
  }

  export type Tb_case_statusMaxAggregateOutputType = {
    case_status_id: number | null
    case_status: string | null
    case_status_eng: string | null
  }

  export type Tb_case_statusCountAggregateOutputType = {
    case_status_id: number
    case_status: number
    case_status_eng: number
    _all: number
  }


  export type Tb_case_statusAvgAggregateInputType = {
    case_status_id?: true
  }

  export type Tb_case_statusSumAggregateInputType = {
    case_status_id?: true
  }

  export type Tb_case_statusMinAggregateInputType = {
    case_status_id?: true
    case_status?: true
    case_status_eng?: true
  }

  export type Tb_case_statusMaxAggregateInputType = {
    case_status_id?: true
    case_status?: true
    case_status_eng?: true
  }

  export type Tb_case_statusCountAggregateInputType = {
    case_status_id?: true
    case_status?: true
    case_status_eng?: true
    _all?: true
  }

  export type Tb_case_statusAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tb_case_status to aggregate.
     */
    where?: tb_case_statusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tb_case_statuses to fetch.
     */
    orderBy?: tb_case_statusOrderByWithRelationInput | tb_case_statusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: tb_case_statusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tb_case_statuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tb_case_statuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned tb_case_statuses
    **/
    _count?: true | Tb_case_statusCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Tb_case_statusAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Tb_case_statusSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Tb_case_statusMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Tb_case_statusMaxAggregateInputType
  }

  export type GetTb_case_statusAggregateType<T extends Tb_case_statusAggregateArgs> = {
        [P in keyof T & keyof AggregateTb_case_status]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTb_case_status[P]>
      : GetScalarType<T[P], AggregateTb_case_status[P]>
  }




  export type tb_case_statusGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: tb_case_statusWhereInput
    orderBy?: tb_case_statusOrderByWithAggregationInput | tb_case_statusOrderByWithAggregationInput[]
    by: Tb_case_statusScalarFieldEnum[] | Tb_case_statusScalarFieldEnum
    having?: tb_case_statusScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Tb_case_statusCountAggregateInputType | true
    _avg?: Tb_case_statusAvgAggregateInputType
    _sum?: Tb_case_statusSumAggregateInputType
    _min?: Tb_case_statusMinAggregateInputType
    _max?: Tb_case_statusMaxAggregateInputType
  }

  export type Tb_case_statusGroupByOutputType = {
    case_status_id: number
    case_status: string
    case_status_eng: string | null
    _count: Tb_case_statusCountAggregateOutputType | null
    _avg: Tb_case_statusAvgAggregateOutputType | null
    _sum: Tb_case_statusSumAggregateOutputType | null
    _min: Tb_case_statusMinAggregateOutputType | null
    _max: Tb_case_statusMaxAggregateOutputType | null
  }

  type GetTb_case_statusGroupByPayload<T extends tb_case_statusGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Tb_case_statusGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Tb_case_statusGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Tb_case_statusGroupByOutputType[P]>
            : GetScalarType<T[P], Tb_case_statusGroupByOutputType[P]>
        }
      >
    >


  export type tb_case_statusSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    case_status_id?: boolean
    case_status?: boolean
    case_status_eng?: boolean
  }, ExtArgs["result"]["tb_case_status"]>



  export type tb_case_statusSelectScalar = {
    case_status_id?: boolean
    case_status?: boolean
    case_status_eng?: boolean
  }

  export type tb_case_statusOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"case_status_id" | "case_status" | "case_status_eng", ExtArgs["result"]["tb_case_status"]>

  export type $tb_case_statusPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "tb_case_status"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      case_status_id: number
      case_status: string
      case_status_eng: string | null
    }, ExtArgs["result"]["tb_case_status"]>
    composites: {}
  }

  type tb_case_statusGetPayload<S extends boolean | null | undefined | tb_case_statusDefaultArgs> = $Result.GetResult<Prisma.$tb_case_statusPayload, S>

  type tb_case_statusCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<tb_case_statusFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Tb_case_statusCountAggregateInputType | true
    }

  export interface tb_case_statusDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['tb_case_status'], meta: { name: 'tb_case_status' } }
    /**
     * Find zero or one Tb_case_status that matches the filter.
     * @param {tb_case_statusFindUniqueArgs} args - Arguments to find a Tb_case_status
     * @example
     * // Get one Tb_case_status
     * const tb_case_status = await prisma.tb_case_status.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends tb_case_statusFindUniqueArgs>(args: SelectSubset<T, tb_case_statusFindUniqueArgs<ExtArgs>>): Prisma__tb_case_statusClient<$Result.GetResult<Prisma.$tb_case_statusPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Tb_case_status that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {tb_case_statusFindUniqueOrThrowArgs} args - Arguments to find a Tb_case_status
     * @example
     * // Get one Tb_case_status
     * const tb_case_status = await prisma.tb_case_status.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends tb_case_statusFindUniqueOrThrowArgs>(args: SelectSubset<T, tb_case_statusFindUniqueOrThrowArgs<ExtArgs>>): Prisma__tb_case_statusClient<$Result.GetResult<Prisma.$tb_case_statusPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tb_case_status that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_case_statusFindFirstArgs} args - Arguments to find a Tb_case_status
     * @example
     * // Get one Tb_case_status
     * const tb_case_status = await prisma.tb_case_status.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends tb_case_statusFindFirstArgs>(args?: SelectSubset<T, tb_case_statusFindFirstArgs<ExtArgs>>): Prisma__tb_case_statusClient<$Result.GetResult<Prisma.$tb_case_statusPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tb_case_status that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_case_statusFindFirstOrThrowArgs} args - Arguments to find a Tb_case_status
     * @example
     * // Get one Tb_case_status
     * const tb_case_status = await prisma.tb_case_status.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends tb_case_statusFindFirstOrThrowArgs>(args?: SelectSubset<T, tb_case_statusFindFirstOrThrowArgs<ExtArgs>>): Prisma__tb_case_statusClient<$Result.GetResult<Prisma.$tb_case_statusPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Tb_case_statuses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_case_statusFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tb_case_statuses
     * const tb_case_statuses = await prisma.tb_case_status.findMany()
     * 
     * // Get first 10 Tb_case_statuses
     * const tb_case_statuses = await prisma.tb_case_status.findMany({ take: 10 })
     * 
     * // Only select the `case_status_id`
     * const tb_case_statusWithCase_status_idOnly = await prisma.tb_case_status.findMany({ select: { case_status_id: true } })
     * 
     */
    findMany<T extends tb_case_statusFindManyArgs>(args?: SelectSubset<T, tb_case_statusFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tb_case_statusPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Tb_case_status.
     * @param {tb_case_statusCreateArgs} args - Arguments to create a Tb_case_status.
     * @example
     * // Create one Tb_case_status
     * const Tb_case_status = await prisma.tb_case_status.create({
     *   data: {
     *     // ... data to create a Tb_case_status
     *   }
     * })
     * 
     */
    create<T extends tb_case_statusCreateArgs>(args: SelectSubset<T, tb_case_statusCreateArgs<ExtArgs>>): Prisma__tb_case_statusClient<$Result.GetResult<Prisma.$tb_case_statusPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Tb_case_statuses.
     * @param {tb_case_statusCreateManyArgs} args - Arguments to create many Tb_case_statuses.
     * @example
     * // Create many Tb_case_statuses
     * const tb_case_status = await prisma.tb_case_status.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends tb_case_statusCreateManyArgs>(args?: SelectSubset<T, tb_case_statusCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Tb_case_status.
     * @param {tb_case_statusDeleteArgs} args - Arguments to delete one Tb_case_status.
     * @example
     * // Delete one Tb_case_status
     * const Tb_case_status = await prisma.tb_case_status.delete({
     *   where: {
     *     // ... filter to delete one Tb_case_status
     *   }
     * })
     * 
     */
    delete<T extends tb_case_statusDeleteArgs>(args: SelectSubset<T, tb_case_statusDeleteArgs<ExtArgs>>): Prisma__tb_case_statusClient<$Result.GetResult<Prisma.$tb_case_statusPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Tb_case_status.
     * @param {tb_case_statusUpdateArgs} args - Arguments to update one Tb_case_status.
     * @example
     * // Update one Tb_case_status
     * const tb_case_status = await prisma.tb_case_status.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends tb_case_statusUpdateArgs>(args: SelectSubset<T, tb_case_statusUpdateArgs<ExtArgs>>): Prisma__tb_case_statusClient<$Result.GetResult<Prisma.$tb_case_statusPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Tb_case_statuses.
     * @param {tb_case_statusDeleteManyArgs} args - Arguments to filter Tb_case_statuses to delete.
     * @example
     * // Delete a few Tb_case_statuses
     * const { count } = await prisma.tb_case_status.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends tb_case_statusDeleteManyArgs>(args?: SelectSubset<T, tb_case_statusDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tb_case_statuses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_case_statusUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tb_case_statuses
     * const tb_case_status = await prisma.tb_case_status.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends tb_case_statusUpdateManyArgs>(args: SelectSubset<T, tb_case_statusUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Tb_case_status.
     * @param {tb_case_statusUpsertArgs} args - Arguments to update or create a Tb_case_status.
     * @example
     * // Update or create a Tb_case_status
     * const tb_case_status = await prisma.tb_case_status.upsert({
     *   create: {
     *     // ... data to create a Tb_case_status
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tb_case_status we want to update
     *   }
     * })
     */
    upsert<T extends tb_case_statusUpsertArgs>(args: SelectSubset<T, tb_case_statusUpsertArgs<ExtArgs>>): Prisma__tb_case_statusClient<$Result.GetResult<Prisma.$tb_case_statusPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Tb_case_statuses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_case_statusCountArgs} args - Arguments to filter Tb_case_statuses to count.
     * @example
     * // Count the number of Tb_case_statuses
     * const count = await prisma.tb_case_status.count({
     *   where: {
     *     // ... the filter for the Tb_case_statuses we want to count
     *   }
     * })
    **/
    count<T extends tb_case_statusCountArgs>(
      args?: Subset<T, tb_case_statusCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Tb_case_statusCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tb_case_status.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Tb_case_statusAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Tb_case_statusAggregateArgs>(args: Subset<T, Tb_case_statusAggregateArgs>): Prisma.PrismaPromise<GetTb_case_statusAggregateType<T>>

    /**
     * Group by Tb_case_status.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_case_statusGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends tb_case_statusGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: tb_case_statusGroupByArgs['orderBy'] }
        : { orderBy?: tb_case_statusGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, tb_case_statusGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTb_case_statusGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the tb_case_status model
   */
  readonly fields: tb_case_statusFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for tb_case_status.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__tb_case_statusClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the tb_case_status model
   */
  interface tb_case_statusFieldRefs {
    readonly case_status_id: FieldRef<"tb_case_status", 'Int'>
    readonly case_status: FieldRef<"tb_case_status", 'String'>
    readonly case_status_eng: FieldRef<"tb_case_status", 'String'>
  }
    

  // Custom InputTypes
  /**
   * tb_case_status findUnique
   */
  export type tb_case_statusFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_case_status
     */
    select?: tb_case_statusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_case_status
     */
    omit?: tb_case_statusOmit<ExtArgs> | null
    /**
     * Filter, which tb_case_status to fetch.
     */
    where: tb_case_statusWhereUniqueInput
  }

  /**
   * tb_case_status findUniqueOrThrow
   */
  export type tb_case_statusFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_case_status
     */
    select?: tb_case_statusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_case_status
     */
    omit?: tb_case_statusOmit<ExtArgs> | null
    /**
     * Filter, which tb_case_status to fetch.
     */
    where: tb_case_statusWhereUniqueInput
  }

  /**
   * tb_case_status findFirst
   */
  export type tb_case_statusFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_case_status
     */
    select?: tb_case_statusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_case_status
     */
    omit?: tb_case_statusOmit<ExtArgs> | null
    /**
     * Filter, which tb_case_status to fetch.
     */
    where?: tb_case_statusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tb_case_statuses to fetch.
     */
    orderBy?: tb_case_statusOrderByWithRelationInput | tb_case_statusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tb_case_statuses.
     */
    cursor?: tb_case_statusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tb_case_statuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tb_case_statuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tb_case_statuses.
     */
    distinct?: Tb_case_statusScalarFieldEnum | Tb_case_statusScalarFieldEnum[]
  }

  /**
   * tb_case_status findFirstOrThrow
   */
  export type tb_case_statusFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_case_status
     */
    select?: tb_case_statusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_case_status
     */
    omit?: tb_case_statusOmit<ExtArgs> | null
    /**
     * Filter, which tb_case_status to fetch.
     */
    where?: tb_case_statusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tb_case_statuses to fetch.
     */
    orderBy?: tb_case_statusOrderByWithRelationInput | tb_case_statusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tb_case_statuses.
     */
    cursor?: tb_case_statusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tb_case_statuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tb_case_statuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tb_case_statuses.
     */
    distinct?: Tb_case_statusScalarFieldEnum | Tb_case_statusScalarFieldEnum[]
  }

  /**
   * tb_case_status findMany
   */
  export type tb_case_statusFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_case_status
     */
    select?: tb_case_statusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_case_status
     */
    omit?: tb_case_statusOmit<ExtArgs> | null
    /**
     * Filter, which tb_case_statuses to fetch.
     */
    where?: tb_case_statusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tb_case_statuses to fetch.
     */
    orderBy?: tb_case_statusOrderByWithRelationInput | tb_case_statusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing tb_case_statuses.
     */
    cursor?: tb_case_statusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tb_case_statuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tb_case_statuses.
     */
    skip?: number
    distinct?: Tb_case_statusScalarFieldEnum | Tb_case_statusScalarFieldEnum[]
  }

  /**
   * tb_case_status create
   */
  export type tb_case_statusCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_case_status
     */
    select?: tb_case_statusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_case_status
     */
    omit?: tb_case_statusOmit<ExtArgs> | null
    /**
     * The data needed to create a tb_case_status.
     */
    data: XOR<tb_case_statusCreateInput, tb_case_statusUncheckedCreateInput>
  }

  /**
   * tb_case_status createMany
   */
  export type tb_case_statusCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many tb_case_statuses.
     */
    data: tb_case_statusCreateManyInput | tb_case_statusCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * tb_case_status update
   */
  export type tb_case_statusUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_case_status
     */
    select?: tb_case_statusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_case_status
     */
    omit?: tb_case_statusOmit<ExtArgs> | null
    /**
     * The data needed to update a tb_case_status.
     */
    data: XOR<tb_case_statusUpdateInput, tb_case_statusUncheckedUpdateInput>
    /**
     * Choose, which tb_case_status to update.
     */
    where: tb_case_statusWhereUniqueInput
  }

  /**
   * tb_case_status updateMany
   */
  export type tb_case_statusUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update tb_case_statuses.
     */
    data: XOR<tb_case_statusUpdateManyMutationInput, tb_case_statusUncheckedUpdateManyInput>
    /**
     * Filter which tb_case_statuses to update
     */
    where?: tb_case_statusWhereInput
    /**
     * Limit how many tb_case_statuses to update.
     */
    limit?: number
  }

  /**
   * tb_case_status upsert
   */
  export type tb_case_statusUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_case_status
     */
    select?: tb_case_statusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_case_status
     */
    omit?: tb_case_statusOmit<ExtArgs> | null
    /**
     * The filter to search for the tb_case_status to update in case it exists.
     */
    where: tb_case_statusWhereUniqueInput
    /**
     * In case the tb_case_status found by the `where` argument doesn't exist, create a new tb_case_status with this data.
     */
    create: XOR<tb_case_statusCreateInput, tb_case_statusUncheckedCreateInput>
    /**
     * In case the tb_case_status was found with the provided `where` argument, update it with this data.
     */
    update: XOR<tb_case_statusUpdateInput, tb_case_statusUncheckedUpdateInput>
  }

  /**
   * tb_case_status delete
   */
  export type tb_case_statusDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_case_status
     */
    select?: tb_case_statusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_case_status
     */
    omit?: tb_case_statusOmit<ExtArgs> | null
    /**
     * Filter which tb_case_status to delete.
     */
    where: tb_case_statusWhereUniqueInput
  }

  /**
   * tb_case_status deleteMany
   */
  export type tb_case_statusDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tb_case_statuses to delete
     */
    where?: tb_case_statusWhereInput
    /**
     * Limit how many tb_case_statuses to delete.
     */
    limit?: number
  }

  /**
   * tb_case_status without action
   */
  export type tb_case_statusDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_case_status
     */
    select?: tb_case_statusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_case_status
     */
    omit?: tb_case_statusOmit<ExtArgs> | null
  }


  /**
   * Model tb_checkin
   */

  export type AggregateTb_checkin = {
    _count: Tb_checkinCountAggregateOutputType | null
    _avg: Tb_checkinAvgAggregateOutputType | null
    _sum: Tb_checkinSumAggregateOutputType | null
    _min: Tb_checkinMinAggregateOutputType | null
    _max: Tb_checkinMaxAggregateOutputType | null
  }

  export type Tb_checkinAvgAggregateOutputType = {
    checkin_id: number | null
    personal_id: number | null
    order_id: number | null
    status: number | null
    doss_id: number | null
  }

  export type Tb_checkinSumAggregateOutputType = {
    checkin_id: number | null
    personal_id: number | null
    order_id: number | null
    status: number | null
    doss_id: number | null
  }

  export type Tb_checkinMinAggregateOutputType = {
    checkin_id: number | null
    checkin_date: Date | null
    checkout_date: Date | null
    personal_id: number | null
    order_id: number | null
    status: number | null
    doss_id: number | null
  }

  export type Tb_checkinMaxAggregateOutputType = {
    checkin_id: number | null
    checkin_date: Date | null
    checkout_date: Date | null
    personal_id: number | null
    order_id: number | null
    status: number | null
    doss_id: number | null
  }

  export type Tb_checkinCountAggregateOutputType = {
    checkin_id: number
    checkin_date: number
    checkout_date: number
    personal_id: number
    order_id: number
    status: number
    doss_id: number
    _all: number
  }


  export type Tb_checkinAvgAggregateInputType = {
    checkin_id?: true
    personal_id?: true
    order_id?: true
    status?: true
    doss_id?: true
  }

  export type Tb_checkinSumAggregateInputType = {
    checkin_id?: true
    personal_id?: true
    order_id?: true
    status?: true
    doss_id?: true
  }

  export type Tb_checkinMinAggregateInputType = {
    checkin_id?: true
    checkin_date?: true
    checkout_date?: true
    personal_id?: true
    order_id?: true
    status?: true
    doss_id?: true
  }

  export type Tb_checkinMaxAggregateInputType = {
    checkin_id?: true
    checkin_date?: true
    checkout_date?: true
    personal_id?: true
    order_id?: true
    status?: true
    doss_id?: true
  }

  export type Tb_checkinCountAggregateInputType = {
    checkin_id?: true
    checkin_date?: true
    checkout_date?: true
    personal_id?: true
    order_id?: true
    status?: true
    doss_id?: true
    _all?: true
  }

  export type Tb_checkinAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tb_checkin to aggregate.
     */
    where?: tb_checkinWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tb_checkins to fetch.
     */
    orderBy?: tb_checkinOrderByWithRelationInput | tb_checkinOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: tb_checkinWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tb_checkins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tb_checkins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned tb_checkins
    **/
    _count?: true | Tb_checkinCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Tb_checkinAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Tb_checkinSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Tb_checkinMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Tb_checkinMaxAggregateInputType
  }

  export type GetTb_checkinAggregateType<T extends Tb_checkinAggregateArgs> = {
        [P in keyof T & keyof AggregateTb_checkin]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTb_checkin[P]>
      : GetScalarType<T[P], AggregateTb_checkin[P]>
  }




  export type tb_checkinGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: tb_checkinWhereInput
    orderBy?: tb_checkinOrderByWithAggregationInput | tb_checkinOrderByWithAggregationInput[]
    by: Tb_checkinScalarFieldEnum[] | Tb_checkinScalarFieldEnum
    having?: tb_checkinScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Tb_checkinCountAggregateInputType | true
    _avg?: Tb_checkinAvgAggregateInputType
    _sum?: Tb_checkinSumAggregateInputType
    _min?: Tb_checkinMinAggregateInputType
    _max?: Tb_checkinMaxAggregateInputType
  }

  export type Tb_checkinGroupByOutputType = {
    checkin_id: number
    checkin_date: Date | null
    checkout_date: Date | null
    personal_id: number
    order_id: number
    status: number
    doss_id: number
    _count: Tb_checkinCountAggregateOutputType | null
    _avg: Tb_checkinAvgAggregateOutputType | null
    _sum: Tb_checkinSumAggregateOutputType | null
    _min: Tb_checkinMinAggregateOutputType | null
    _max: Tb_checkinMaxAggregateOutputType | null
  }

  type GetTb_checkinGroupByPayload<T extends tb_checkinGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Tb_checkinGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Tb_checkinGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Tb_checkinGroupByOutputType[P]>
            : GetScalarType<T[P], Tb_checkinGroupByOutputType[P]>
        }
      >
    >


  export type tb_checkinSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    checkin_id?: boolean
    checkin_date?: boolean
    checkout_date?: boolean
    personal_id?: boolean
    order_id?: boolean
    status?: boolean
    doss_id?: boolean
  }, ExtArgs["result"]["tb_checkin"]>



  export type tb_checkinSelectScalar = {
    checkin_id?: boolean
    checkin_date?: boolean
    checkout_date?: boolean
    personal_id?: boolean
    order_id?: boolean
    status?: boolean
    doss_id?: boolean
  }

  export type tb_checkinOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"checkin_id" | "checkin_date" | "checkout_date" | "personal_id" | "order_id" | "status" | "doss_id", ExtArgs["result"]["tb_checkin"]>

  export type $tb_checkinPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "tb_checkin"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      checkin_id: number
      checkin_date: Date | null
      checkout_date: Date | null
      personal_id: number
      order_id: number
      status: number
      doss_id: number
    }, ExtArgs["result"]["tb_checkin"]>
    composites: {}
  }

  type tb_checkinGetPayload<S extends boolean | null | undefined | tb_checkinDefaultArgs> = $Result.GetResult<Prisma.$tb_checkinPayload, S>

  type tb_checkinCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<tb_checkinFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Tb_checkinCountAggregateInputType | true
    }

  export interface tb_checkinDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['tb_checkin'], meta: { name: 'tb_checkin' } }
    /**
     * Find zero or one Tb_checkin that matches the filter.
     * @param {tb_checkinFindUniqueArgs} args - Arguments to find a Tb_checkin
     * @example
     * // Get one Tb_checkin
     * const tb_checkin = await prisma.tb_checkin.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends tb_checkinFindUniqueArgs>(args: SelectSubset<T, tb_checkinFindUniqueArgs<ExtArgs>>): Prisma__tb_checkinClient<$Result.GetResult<Prisma.$tb_checkinPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Tb_checkin that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {tb_checkinFindUniqueOrThrowArgs} args - Arguments to find a Tb_checkin
     * @example
     * // Get one Tb_checkin
     * const tb_checkin = await prisma.tb_checkin.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends tb_checkinFindUniqueOrThrowArgs>(args: SelectSubset<T, tb_checkinFindUniqueOrThrowArgs<ExtArgs>>): Prisma__tb_checkinClient<$Result.GetResult<Prisma.$tb_checkinPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tb_checkin that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_checkinFindFirstArgs} args - Arguments to find a Tb_checkin
     * @example
     * // Get one Tb_checkin
     * const tb_checkin = await prisma.tb_checkin.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends tb_checkinFindFirstArgs>(args?: SelectSubset<T, tb_checkinFindFirstArgs<ExtArgs>>): Prisma__tb_checkinClient<$Result.GetResult<Prisma.$tb_checkinPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tb_checkin that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_checkinFindFirstOrThrowArgs} args - Arguments to find a Tb_checkin
     * @example
     * // Get one Tb_checkin
     * const tb_checkin = await prisma.tb_checkin.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends tb_checkinFindFirstOrThrowArgs>(args?: SelectSubset<T, tb_checkinFindFirstOrThrowArgs<ExtArgs>>): Prisma__tb_checkinClient<$Result.GetResult<Prisma.$tb_checkinPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Tb_checkins that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_checkinFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tb_checkins
     * const tb_checkins = await prisma.tb_checkin.findMany()
     * 
     * // Get first 10 Tb_checkins
     * const tb_checkins = await prisma.tb_checkin.findMany({ take: 10 })
     * 
     * // Only select the `checkin_id`
     * const tb_checkinWithCheckin_idOnly = await prisma.tb_checkin.findMany({ select: { checkin_id: true } })
     * 
     */
    findMany<T extends tb_checkinFindManyArgs>(args?: SelectSubset<T, tb_checkinFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tb_checkinPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Tb_checkin.
     * @param {tb_checkinCreateArgs} args - Arguments to create a Tb_checkin.
     * @example
     * // Create one Tb_checkin
     * const Tb_checkin = await prisma.tb_checkin.create({
     *   data: {
     *     // ... data to create a Tb_checkin
     *   }
     * })
     * 
     */
    create<T extends tb_checkinCreateArgs>(args: SelectSubset<T, tb_checkinCreateArgs<ExtArgs>>): Prisma__tb_checkinClient<$Result.GetResult<Prisma.$tb_checkinPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Tb_checkins.
     * @param {tb_checkinCreateManyArgs} args - Arguments to create many Tb_checkins.
     * @example
     * // Create many Tb_checkins
     * const tb_checkin = await prisma.tb_checkin.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends tb_checkinCreateManyArgs>(args?: SelectSubset<T, tb_checkinCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Tb_checkin.
     * @param {tb_checkinDeleteArgs} args - Arguments to delete one Tb_checkin.
     * @example
     * // Delete one Tb_checkin
     * const Tb_checkin = await prisma.tb_checkin.delete({
     *   where: {
     *     // ... filter to delete one Tb_checkin
     *   }
     * })
     * 
     */
    delete<T extends tb_checkinDeleteArgs>(args: SelectSubset<T, tb_checkinDeleteArgs<ExtArgs>>): Prisma__tb_checkinClient<$Result.GetResult<Prisma.$tb_checkinPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Tb_checkin.
     * @param {tb_checkinUpdateArgs} args - Arguments to update one Tb_checkin.
     * @example
     * // Update one Tb_checkin
     * const tb_checkin = await prisma.tb_checkin.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends tb_checkinUpdateArgs>(args: SelectSubset<T, tb_checkinUpdateArgs<ExtArgs>>): Prisma__tb_checkinClient<$Result.GetResult<Prisma.$tb_checkinPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Tb_checkins.
     * @param {tb_checkinDeleteManyArgs} args - Arguments to filter Tb_checkins to delete.
     * @example
     * // Delete a few Tb_checkins
     * const { count } = await prisma.tb_checkin.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends tb_checkinDeleteManyArgs>(args?: SelectSubset<T, tb_checkinDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tb_checkins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_checkinUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tb_checkins
     * const tb_checkin = await prisma.tb_checkin.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends tb_checkinUpdateManyArgs>(args: SelectSubset<T, tb_checkinUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Tb_checkin.
     * @param {tb_checkinUpsertArgs} args - Arguments to update or create a Tb_checkin.
     * @example
     * // Update or create a Tb_checkin
     * const tb_checkin = await prisma.tb_checkin.upsert({
     *   create: {
     *     // ... data to create a Tb_checkin
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tb_checkin we want to update
     *   }
     * })
     */
    upsert<T extends tb_checkinUpsertArgs>(args: SelectSubset<T, tb_checkinUpsertArgs<ExtArgs>>): Prisma__tb_checkinClient<$Result.GetResult<Prisma.$tb_checkinPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Tb_checkins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_checkinCountArgs} args - Arguments to filter Tb_checkins to count.
     * @example
     * // Count the number of Tb_checkins
     * const count = await prisma.tb_checkin.count({
     *   where: {
     *     // ... the filter for the Tb_checkins we want to count
     *   }
     * })
    **/
    count<T extends tb_checkinCountArgs>(
      args?: Subset<T, tb_checkinCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Tb_checkinCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tb_checkin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Tb_checkinAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Tb_checkinAggregateArgs>(args: Subset<T, Tb_checkinAggregateArgs>): Prisma.PrismaPromise<GetTb_checkinAggregateType<T>>

    /**
     * Group by Tb_checkin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_checkinGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends tb_checkinGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: tb_checkinGroupByArgs['orderBy'] }
        : { orderBy?: tb_checkinGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, tb_checkinGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTb_checkinGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the tb_checkin model
   */
  readonly fields: tb_checkinFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for tb_checkin.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__tb_checkinClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the tb_checkin model
   */
  interface tb_checkinFieldRefs {
    readonly checkin_id: FieldRef<"tb_checkin", 'Int'>
    readonly checkin_date: FieldRef<"tb_checkin", 'DateTime'>
    readonly checkout_date: FieldRef<"tb_checkin", 'DateTime'>
    readonly personal_id: FieldRef<"tb_checkin", 'Int'>
    readonly order_id: FieldRef<"tb_checkin", 'Int'>
    readonly status: FieldRef<"tb_checkin", 'Int'>
    readonly doss_id: FieldRef<"tb_checkin", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * tb_checkin findUnique
   */
  export type tb_checkinFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_checkin
     */
    select?: tb_checkinSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_checkin
     */
    omit?: tb_checkinOmit<ExtArgs> | null
    /**
     * Filter, which tb_checkin to fetch.
     */
    where: tb_checkinWhereUniqueInput
  }

  /**
   * tb_checkin findUniqueOrThrow
   */
  export type tb_checkinFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_checkin
     */
    select?: tb_checkinSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_checkin
     */
    omit?: tb_checkinOmit<ExtArgs> | null
    /**
     * Filter, which tb_checkin to fetch.
     */
    where: tb_checkinWhereUniqueInput
  }

  /**
   * tb_checkin findFirst
   */
  export type tb_checkinFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_checkin
     */
    select?: tb_checkinSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_checkin
     */
    omit?: tb_checkinOmit<ExtArgs> | null
    /**
     * Filter, which tb_checkin to fetch.
     */
    where?: tb_checkinWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tb_checkins to fetch.
     */
    orderBy?: tb_checkinOrderByWithRelationInput | tb_checkinOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tb_checkins.
     */
    cursor?: tb_checkinWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tb_checkins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tb_checkins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tb_checkins.
     */
    distinct?: Tb_checkinScalarFieldEnum | Tb_checkinScalarFieldEnum[]
  }

  /**
   * tb_checkin findFirstOrThrow
   */
  export type tb_checkinFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_checkin
     */
    select?: tb_checkinSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_checkin
     */
    omit?: tb_checkinOmit<ExtArgs> | null
    /**
     * Filter, which tb_checkin to fetch.
     */
    where?: tb_checkinWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tb_checkins to fetch.
     */
    orderBy?: tb_checkinOrderByWithRelationInput | tb_checkinOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tb_checkins.
     */
    cursor?: tb_checkinWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tb_checkins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tb_checkins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tb_checkins.
     */
    distinct?: Tb_checkinScalarFieldEnum | Tb_checkinScalarFieldEnum[]
  }

  /**
   * tb_checkin findMany
   */
  export type tb_checkinFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_checkin
     */
    select?: tb_checkinSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_checkin
     */
    omit?: tb_checkinOmit<ExtArgs> | null
    /**
     * Filter, which tb_checkins to fetch.
     */
    where?: tb_checkinWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tb_checkins to fetch.
     */
    orderBy?: tb_checkinOrderByWithRelationInput | tb_checkinOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing tb_checkins.
     */
    cursor?: tb_checkinWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tb_checkins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tb_checkins.
     */
    skip?: number
    distinct?: Tb_checkinScalarFieldEnum | Tb_checkinScalarFieldEnum[]
  }

  /**
   * tb_checkin create
   */
  export type tb_checkinCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_checkin
     */
    select?: tb_checkinSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_checkin
     */
    omit?: tb_checkinOmit<ExtArgs> | null
    /**
     * The data needed to create a tb_checkin.
     */
    data: XOR<tb_checkinCreateInput, tb_checkinUncheckedCreateInput>
  }

  /**
   * tb_checkin createMany
   */
  export type tb_checkinCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many tb_checkins.
     */
    data: tb_checkinCreateManyInput | tb_checkinCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * tb_checkin update
   */
  export type tb_checkinUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_checkin
     */
    select?: tb_checkinSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_checkin
     */
    omit?: tb_checkinOmit<ExtArgs> | null
    /**
     * The data needed to update a tb_checkin.
     */
    data: XOR<tb_checkinUpdateInput, tb_checkinUncheckedUpdateInput>
    /**
     * Choose, which tb_checkin to update.
     */
    where: tb_checkinWhereUniqueInput
  }

  /**
   * tb_checkin updateMany
   */
  export type tb_checkinUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update tb_checkins.
     */
    data: XOR<tb_checkinUpdateManyMutationInput, tb_checkinUncheckedUpdateManyInput>
    /**
     * Filter which tb_checkins to update
     */
    where?: tb_checkinWhereInput
    /**
     * Limit how many tb_checkins to update.
     */
    limit?: number
  }

  /**
   * tb_checkin upsert
   */
  export type tb_checkinUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_checkin
     */
    select?: tb_checkinSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_checkin
     */
    omit?: tb_checkinOmit<ExtArgs> | null
    /**
     * The filter to search for the tb_checkin to update in case it exists.
     */
    where: tb_checkinWhereUniqueInput
    /**
     * In case the tb_checkin found by the `where` argument doesn't exist, create a new tb_checkin with this data.
     */
    create: XOR<tb_checkinCreateInput, tb_checkinUncheckedCreateInput>
    /**
     * In case the tb_checkin was found with the provided `where` argument, update it with this data.
     */
    update: XOR<tb_checkinUpdateInput, tb_checkinUncheckedUpdateInput>
  }

  /**
   * tb_checkin delete
   */
  export type tb_checkinDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_checkin
     */
    select?: tb_checkinSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_checkin
     */
    omit?: tb_checkinOmit<ExtArgs> | null
    /**
     * Filter which tb_checkin to delete.
     */
    where: tb_checkinWhereUniqueInput
  }

  /**
   * tb_checkin deleteMany
   */
  export type tb_checkinDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tb_checkins to delete
     */
    where?: tb_checkinWhereInput
    /**
     * Limit how many tb_checkins to delete.
     */
    limit?: number
  }

  /**
   * tb_checkin without action
   */
  export type tb_checkinDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_checkin
     */
    select?: tb_checkinSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_checkin
     */
    omit?: tb_checkinOmit<ExtArgs> | null
  }


  /**
   * Model tb_coi
   */

  export type AggregateTb_coi = {
    _count: Tb_coiCountAggregateOutputType | null
    _avg: Tb_coiAvgAggregateOutputType | null
    _sum: Tb_coiSumAggregateOutputType | null
    _min: Tb_coiMinAggregateOutputType | null
    _max: Tb_coiMaxAggregateOutputType | null
  }

  export type Tb_coiAvgAggregateOutputType = {
    coi_id: number | null
    from_officer: number | null
    to_coispec: number | null
    case_id: number | null
    coi_state: number | null
    request_count: number | null
    coi_status: number | null
  }

  export type Tb_coiSumAggregateOutputType = {
    coi_id: number | null
    from_officer: number | null
    to_coispec: number | null
    case_id: number | null
    coi_state: number | null
    request_count: number | null
    coi_status: number | null
  }

  export type Tb_coiMinAggregateOutputType = {
    coi_id: number | null
    from_officer: number | null
    to_coispec: number | null
    case_id: number | null
    request_date: Date | null
    request_deadline: Date | null
    description: string | null
    request_text: string | null
    coi_state: number | null
    request_count: number | null
    response_date: Date | null
    coi_status: number | null
  }

  export type Tb_coiMaxAggregateOutputType = {
    coi_id: number | null
    from_officer: number | null
    to_coispec: number | null
    case_id: number | null
    request_date: Date | null
    request_deadline: Date | null
    description: string | null
    request_text: string | null
    coi_state: number | null
    request_count: number | null
    response_date: Date | null
    coi_status: number | null
  }

  export type Tb_coiCountAggregateOutputType = {
    coi_id: number
    from_officer: number
    to_coispec: number
    case_id: number
    request_date: number
    request_deadline: number
    description: number
    request_text: number
    coi_state: number
    request_count: number
    response_date: number
    coi_status: number
    _all: number
  }


  export type Tb_coiAvgAggregateInputType = {
    coi_id?: true
    from_officer?: true
    to_coispec?: true
    case_id?: true
    coi_state?: true
    request_count?: true
    coi_status?: true
  }

  export type Tb_coiSumAggregateInputType = {
    coi_id?: true
    from_officer?: true
    to_coispec?: true
    case_id?: true
    coi_state?: true
    request_count?: true
    coi_status?: true
  }

  export type Tb_coiMinAggregateInputType = {
    coi_id?: true
    from_officer?: true
    to_coispec?: true
    case_id?: true
    request_date?: true
    request_deadline?: true
    description?: true
    request_text?: true
    coi_state?: true
    request_count?: true
    response_date?: true
    coi_status?: true
  }

  export type Tb_coiMaxAggregateInputType = {
    coi_id?: true
    from_officer?: true
    to_coispec?: true
    case_id?: true
    request_date?: true
    request_deadline?: true
    description?: true
    request_text?: true
    coi_state?: true
    request_count?: true
    response_date?: true
    coi_status?: true
  }

  export type Tb_coiCountAggregateInputType = {
    coi_id?: true
    from_officer?: true
    to_coispec?: true
    case_id?: true
    request_date?: true
    request_deadline?: true
    description?: true
    request_text?: true
    coi_state?: true
    request_count?: true
    response_date?: true
    coi_status?: true
    _all?: true
  }

  export type Tb_coiAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tb_coi to aggregate.
     */
    where?: tb_coiWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tb_cois to fetch.
     */
    orderBy?: tb_coiOrderByWithRelationInput | tb_coiOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: tb_coiWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tb_cois from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tb_cois.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned tb_cois
    **/
    _count?: true | Tb_coiCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Tb_coiAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Tb_coiSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Tb_coiMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Tb_coiMaxAggregateInputType
  }

  export type GetTb_coiAggregateType<T extends Tb_coiAggregateArgs> = {
        [P in keyof T & keyof AggregateTb_coi]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTb_coi[P]>
      : GetScalarType<T[P], AggregateTb_coi[P]>
  }




  export type tb_coiGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: tb_coiWhereInput
    orderBy?: tb_coiOrderByWithAggregationInput | tb_coiOrderByWithAggregationInput[]
    by: Tb_coiScalarFieldEnum[] | Tb_coiScalarFieldEnum
    having?: tb_coiScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Tb_coiCountAggregateInputType | true
    _avg?: Tb_coiAvgAggregateInputType
    _sum?: Tb_coiSumAggregateInputType
    _min?: Tb_coiMinAggregateInputType
    _max?: Tb_coiMaxAggregateInputType
  }

  export type Tb_coiGroupByOutputType = {
    coi_id: number
    from_officer: number
    to_coispec: number
    case_id: number
    request_date: Date
    request_deadline: Date
    description: string | null
    request_text: string
    coi_state: number
    request_count: number | null
    response_date: Date | null
    coi_status: number
    _count: Tb_coiCountAggregateOutputType | null
    _avg: Tb_coiAvgAggregateOutputType | null
    _sum: Tb_coiSumAggregateOutputType | null
    _min: Tb_coiMinAggregateOutputType | null
    _max: Tb_coiMaxAggregateOutputType | null
  }

  type GetTb_coiGroupByPayload<T extends tb_coiGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Tb_coiGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Tb_coiGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Tb_coiGroupByOutputType[P]>
            : GetScalarType<T[P], Tb_coiGroupByOutputType[P]>
        }
      >
    >


  export type tb_coiSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    coi_id?: boolean
    from_officer?: boolean
    to_coispec?: boolean
    case_id?: boolean
    request_date?: boolean
    request_deadline?: boolean
    description?: boolean
    request_text?: boolean
    coi_state?: boolean
    request_count?: boolean
    response_date?: boolean
    coi_status?: boolean
  }, ExtArgs["result"]["tb_coi"]>



  export type tb_coiSelectScalar = {
    coi_id?: boolean
    from_officer?: boolean
    to_coispec?: boolean
    case_id?: boolean
    request_date?: boolean
    request_deadline?: boolean
    description?: boolean
    request_text?: boolean
    coi_state?: boolean
    request_count?: boolean
    response_date?: boolean
    coi_status?: boolean
  }

  export type tb_coiOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"coi_id" | "from_officer" | "to_coispec" | "case_id" | "request_date" | "request_deadline" | "description" | "request_text" | "coi_state" | "request_count" | "response_date" | "coi_status", ExtArgs["result"]["tb_coi"]>

  export type $tb_coiPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "tb_coi"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      coi_id: number
      from_officer: number
      to_coispec: number
      case_id: number
      request_date: Date
      request_deadline: Date
      description: string | null
      request_text: string
      coi_state: number
      request_count: number | null
      response_date: Date | null
      coi_status: number
    }, ExtArgs["result"]["tb_coi"]>
    composites: {}
  }

  type tb_coiGetPayload<S extends boolean | null | undefined | tb_coiDefaultArgs> = $Result.GetResult<Prisma.$tb_coiPayload, S>

  type tb_coiCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<tb_coiFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Tb_coiCountAggregateInputType | true
    }

  export interface tb_coiDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['tb_coi'], meta: { name: 'tb_coi' } }
    /**
     * Find zero or one Tb_coi that matches the filter.
     * @param {tb_coiFindUniqueArgs} args - Arguments to find a Tb_coi
     * @example
     * // Get one Tb_coi
     * const tb_coi = await prisma.tb_coi.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends tb_coiFindUniqueArgs>(args: SelectSubset<T, tb_coiFindUniqueArgs<ExtArgs>>): Prisma__tb_coiClient<$Result.GetResult<Prisma.$tb_coiPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Tb_coi that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {tb_coiFindUniqueOrThrowArgs} args - Arguments to find a Tb_coi
     * @example
     * // Get one Tb_coi
     * const tb_coi = await prisma.tb_coi.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends tb_coiFindUniqueOrThrowArgs>(args: SelectSubset<T, tb_coiFindUniqueOrThrowArgs<ExtArgs>>): Prisma__tb_coiClient<$Result.GetResult<Prisma.$tb_coiPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tb_coi that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_coiFindFirstArgs} args - Arguments to find a Tb_coi
     * @example
     * // Get one Tb_coi
     * const tb_coi = await prisma.tb_coi.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends tb_coiFindFirstArgs>(args?: SelectSubset<T, tb_coiFindFirstArgs<ExtArgs>>): Prisma__tb_coiClient<$Result.GetResult<Prisma.$tb_coiPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tb_coi that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_coiFindFirstOrThrowArgs} args - Arguments to find a Tb_coi
     * @example
     * // Get one Tb_coi
     * const tb_coi = await prisma.tb_coi.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends tb_coiFindFirstOrThrowArgs>(args?: SelectSubset<T, tb_coiFindFirstOrThrowArgs<ExtArgs>>): Prisma__tb_coiClient<$Result.GetResult<Prisma.$tb_coiPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Tb_cois that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_coiFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tb_cois
     * const tb_cois = await prisma.tb_coi.findMany()
     * 
     * // Get first 10 Tb_cois
     * const tb_cois = await prisma.tb_coi.findMany({ take: 10 })
     * 
     * // Only select the `coi_id`
     * const tb_coiWithCoi_idOnly = await prisma.tb_coi.findMany({ select: { coi_id: true } })
     * 
     */
    findMany<T extends tb_coiFindManyArgs>(args?: SelectSubset<T, tb_coiFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tb_coiPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Tb_coi.
     * @param {tb_coiCreateArgs} args - Arguments to create a Tb_coi.
     * @example
     * // Create one Tb_coi
     * const Tb_coi = await prisma.tb_coi.create({
     *   data: {
     *     // ... data to create a Tb_coi
     *   }
     * })
     * 
     */
    create<T extends tb_coiCreateArgs>(args: SelectSubset<T, tb_coiCreateArgs<ExtArgs>>): Prisma__tb_coiClient<$Result.GetResult<Prisma.$tb_coiPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Tb_cois.
     * @param {tb_coiCreateManyArgs} args - Arguments to create many Tb_cois.
     * @example
     * // Create many Tb_cois
     * const tb_coi = await prisma.tb_coi.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends tb_coiCreateManyArgs>(args?: SelectSubset<T, tb_coiCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Tb_coi.
     * @param {tb_coiDeleteArgs} args - Arguments to delete one Tb_coi.
     * @example
     * // Delete one Tb_coi
     * const Tb_coi = await prisma.tb_coi.delete({
     *   where: {
     *     // ... filter to delete one Tb_coi
     *   }
     * })
     * 
     */
    delete<T extends tb_coiDeleteArgs>(args: SelectSubset<T, tb_coiDeleteArgs<ExtArgs>>): Prisma__tb_coiClient<$Result.GetResult<Prisma.$tb_coiPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Tb_coi.
     * @param {tb_coiUpdateArgs} args - Arguments to update one Tb_coi.
     * @example
     * // Update one Tb_coi
     * const tb_coi = await prisma.tb_coi.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends tb_coiUpdateArgs>(args: SelectSubset<T, tb_coiUpdateArgs<ExtArgs>>): Prisma__tb_coiClient<$Result.GetResult<Prisma.$tb_coiPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Tb_cois.
     * @param {tb_coiDeleteManyArgs} args - Arguments to filter Tb_cois to delete.
     * @example
     * // Delete a few Tb_cois
     * const { count } = await prisma.tb_coi.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends tb_coiDeleteManyArgs>(args?: SelectSubset<T, tb_coiDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tb_cois.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_coiUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tb_cois
     * const tb_coi = await prisma.tb_coi.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends tb_coiUpdateManyArgs>(args: SelectSubset<T, tb_coiUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Tb_coi.
     * @param {tb_coiUpsertArgs} args - Arguments to update or create a Tb_coi.
     * @example
     * // Update or create a Tb_coi
     * const tb_coi = await prisma.tb_coi.upsert({
     *   create: {
     *     // ... data to create a Tb_coi
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tb_coi we want to update
     *   }
     * })
     */
    upsert<T extends tb_coiUpsertArgs>(args: SelectSubset<T, tb_coiUpsertArgs<ExtArgs>>): Prisma__tb_coiClient<$Result.GetResult<Prisma.$tb_coiPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Tb_cois.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_coiCountArgs} args - Arguments to filter Tb_cois to count.
     * @example
     * // Count the number of Tb_cois
     * const count = await prisma.tb_coi.count({
     *   where: {
     *     // ... the filter for the Tb_cois we want to count
     *   }
     * })
    **/
    count<T extends tb_coiCountArgs>(
      args?: Subset<T, tb_coiCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Tb_coiCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tb_coi.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Tb_coiAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Tb_coiAggregateArgs>(args: Subset<T, Tb_coiAggregateArgs>): Prisma.PrismaPromise<GetTb_coiAggregateType<T>>

    /**
     * Group by Tb_coi.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_coiGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends tb_coiGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: tb_coiGroupByArgs['orderBy'] }
        : { orderBy?: tb_coiGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, tb_coiGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTb_coiGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the tb_coi model
   */
  readonly fields: tb_coiFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for tb_coi.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__tb_coiClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the tb_coi model
   */
  interface tb_coiFieldRefs {
    readonly coi_id: FieldRef<"tb_coi", 'Int'>
    readonly from_officer: FieldRef<"tb_coi", 'Int'>
    readonly to_coispec: FieldRef<"tb_coi", 'Int'>
    readonly case_id: FieldRef<"tb_coi", 'Int'>
    readonly request_date: FieldRef<"tb_coi", 'DateTime'>
    readonly request_deadline: FieldRef<"tb_coi", 'DateTime'>
    readonly description: FieldRef<"tb_coi", 'String'>
    readonly request_text: FieldRef<"tb_coi", 'String'>
    readonly coi_state: FieldRef<"tb_coi", 'Int'>
    readonly request_count: FieldRef<"tb_coi", 'Int'>
    readonly response_date: FieldRef<"tb_coi", 'DateTime'>
    readonly coi_status: FieldRef<"tb_coi", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * tb_coi findUnique
   */
  export type tb_coiFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_coi
     */
    select?: tb_coiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_coi
     */
    omit?: tb_coiOmit<ExtArgs> | null
    /**
     * Filter, which tb_coi to fetch.
     */
    where: tb_coiWhereUniqueInput
  }

  /**
   * tb_coi findUniqueOrThrow
   */
  export type tb_coiFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_coi
     */
    select?: tb_coiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_coi
     */
    omit?: tb_coiOmit<ExtArgs> | null
    /**
     * Filter, which tb_coi to fetch.
     */
    where: tb_coiWhereUniqueInput
  }

  /**
   * tb_coi findFirst
   */
  export type tb_coiFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_coi
     */
    select?: tb_coiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_coi
     */
    omit?: tb_coiOmit<ExtArgs> | null
    /**
     * Filter, which tb_coi to fetch.
     */
    where?: tb_coiWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tb_cois to fetch.
     */
    orderBy?: tb_coiOrderByWithRelationInput | tb_coiOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tb_cois.
     */
    cursor?: tb_coiWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tb_cois from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tb_cois.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tb_cois.
     */
    distinct?: Tb_coiScalarFieldEnum | Tb_coiScalarFieldEnum[]
  }

  /**
   * tb_coi findFirstOrThrow
   */
  export type tb_coiFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_coi
     */
    select?: tb_coiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_coi
     */
    omit?: tb_coiOmit<ExtArgs> | null
    /**
     * Filter, which tb_coi to fetch.
     */
    where?: tb_coiWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tb_cois to fetch.
     */
    orderBy?: tb_coiOrderByWithRelationInput | tb_coiOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tb_cois.
     */
    cursor?: tb_coiWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tb_cois from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tb_cois.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tb_cois.
     */
    distinct?: Tb_coiScalarFieldEnum | Tb_coiScalarFieldEnum[]
  }

  /**
   * tb_coi findMany
   */
  export type tb_coiFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_coi
     */
    select?: tb_coiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_coi
     */
    omit?: tb_coiOmit<ExtArgs> | null
    /**
     * Filter, which tb_cois to fetch.
     */
    where?: tb_coiWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tb_cois to fetch.
     */
    orderBy?: tb_coiOrderByWithRelationInput | tb_coiOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing tb_cois.
     */
    cursor?: tb_coiWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tb_cois from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tb_cois.
     */
    skip?: number
    distinct?: Tb_coiScalarFieldEnum | Tb_coiScalarFieldEnum[]
  }

  /**
   * tb_coi create
   */
  export type tb_coiCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_coi
     */
    select?: tb_coiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_coi
     */
    omit?: tb_coiOmit<ExtArgs> | null
    /**
     * The data needed to create a tb_coi.
     */
    data: XOR<tb_coiCreateInput, tb_coiUncheckedCreateInput>
  }

  /**
   * tb_coi createMany
   */
  export type tb_coiCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many tb_cois.
     */
    data: tb_coiCreateManyInput | tb_coiCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * tb_coi update
   */
  export type tb_coiUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_coi
     */
    select?: tb_coiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_coi
     */
    omit?: tb_coiOmit<ExtArgs> | null
    /**
     * The data needed to update a tb_coi.
     */
    data: XOR<tb_coiUpdateInput, tb_coiUncheckedUpdateInput>
    /**
     * Choose, which tb_coi to update.
     */
    where: tb_coiWhereUniqueInput
  }

  /**
   * tb_coi updateMany
   */
  export type tb_coiUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update tb_cois.
     */
    data: XOR<tb_coiUpdateManyMutationInput, tb_coiUncheckedUpdateManyInput>
    /**
     * Filter which tb_cois to update
     */
    where?: tb_coiWhereInput
    /**
     * Limit how many tb_cois to update.
     */
    limit?: number
  }

  /**
   * tb_coi upsert
   */
  export type tb_coiUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_coi
     */
    select?: tb_coiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_coi
     */
    omit?: tb_coiOmit<ExtArgs> | null
    /**
     * The filter to search for the tb_coi to update in case it exists.
     */
    where: tb_coiWhereUniqueInput
    /**
     * In case the tb_coi found by the `where` argument doesn't exist, create a new tb_coi with this data.
     */
    create: XOR<tb_coiCreateInput, tb_coiUncheckedCreateInput>
    /**
     * In case the tb_coi was found with the provided `where` argument, update it with this data.
     */
    update: XOR<tb_coiUpdateInput, tb_coiUncheckedUpdateInput>
  }

  /**
   * tb_coi delete
   */
  export type tb_coiDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_coi
     */
    select?: tb_coiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_coi
     */
    omit?: tb_coiOmit<ExtArgs> | null
    /**
     * Filter which tb_coi to delete.
     */
    where: tb_coiWhereUniqueInput
  }

  /**
   * tb_coi deleteMany
   */
  export type tb_coiDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tb_cois to delete
     */
    where?: tb_coiWhereInput
    /**
     * Limit how many tb_cois to delete.
     */
    limit?: number
  }

  /**
   * tb_coi without action
   */
  export type tb_coiDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_coi
     */
    select?: tb_coiSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_coi
     */
    omit?: tb_coiOmit<ExtArgs> | null
  }


  /**
   * Model tb_country
   */

  export type AggregateTb_country = {
    _count: Tb_countryCountAggregateOutputType | null
    _avg: Tb_countryAvgAggregateOutputType | null
    _sum: Tb_countrySumAggregateOutputType | null
    _min: Tb_countryMinAggregateOutputType | null
    _max: Tb_countryMaxAggregateOutputType | null
  }

  export type Tb_countryAvgAggregateOutputType = {
    country_id: number | null
  }

  export type Tb_countrySumAggregateOutputType = {
    country_id: number | null
  }

  export type Tb_countryMinAggregateOutputType = {
    country_id: number | null
    country_eng: string | null
    country_arm: string | null
  }

  export type Tb_countryMaxAggregateOutputType = {
    country_id: number | null
    country_eng: string | null
    country_arm: string | null
  }

  export type Tb_countryCountAggregateOutputType = {
    country_id: number
    country_eng: number
    country_arm: number
    _all: number
  }


  export type Tb_countryAvgAggregateInputType = {
    country_id?: true
  }

  export type Tb_countrySumAggregateInputType = {
    country_id?: true
  }

  export type Tb_countryMinAggregateInputType = {
    country_id?: true
    country_eng?: true
    country_arm?: true
  }

  export type Tb_countryMaxAggregateInputType = {
    country_id?: true
    country_eng?: true
    country_arm?: true
  }

  export type Tb_countryCountAggregateInputType = {
    country_id?: true
    country_eng?: true
    country_arm?: true
    _all?: true
  }

  export type Tb_countryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tb_country to aggregate.
     */
    where?: tb_countryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tb_countries to fetch.
     */
    orderBy?: tb_countryOrderByWithRelationInput | tb_countryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: tb_countryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tb_countries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tb_countries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned tb_countries
    **/
    _count?: true | Tb_countryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Tb_countryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Tb_countrySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Tb_countryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Tb_countryMaxAggregateInputType
  }

  export type GetTb_countryAggregateType<T extends Tb_countryAggregateArgs> = {
        [P in keyof T & keyof AggregateTb_country]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTb_country[P]>
      : GetScalarType<T[P], AggregateTb_country[P]>
  }




  export type tb_countryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: tb_countryWhereInput
    orderBy?: tb_countryOrderByWithAggregationInput | tb_countryOrderByWithAggregationInput[]
    by: Tb_countryScalarFieldEnum[] | Tb_countryScalarFieldEnum
    having?: tb_countryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Tb_countryCountAggregateInputType | true
    _avg?: Tb_countryAvgAggregateInputType
    _sum?: Tb_countrySumAggregateInputType
    _min?: Tb_countryMinAggregateInputType
    _max?: Tb_countryMaxAggregateInputType
  }

  export type Tb_countryGroupByOutputType = {
    country_id: number
    country_eng: string
    country_arm: string
    _count: Tb_countryCountAggregateOutputType | null
    _avg: Tb_countryAvgAggregateOutputType | null
    _sum: Tb_countrySumAggregateOutputType | null
    _min: Tb_countryMinAggregateOutputType | null
    _max: Tb_countryMaxAggregateOutputType | null
  }

  type GetTb_countryGroupByPayload<T extends tb_countryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Tb_countryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Tb_countryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Tb_countryGroupByOutputType[P]>
            : GetScalarType<T[P], Tb_countryGroupByOutputType[P]>
        }
      >
    >


  export type tb_countrySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    country_id?: boolean
    country_eng?: boolean
    country_arm?: boolean
  }, ExtArgs["result"]["tb_country"]>



  export type tb_countrySelectScalar = {
    country_id?: boolean
    country_eng?: boolean
    country_arm?: boolean
  }

  export type tb_countryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"country_id" | "country_eng" | "country_arm", ExtArgs["result"]["tb_country"]>

  export type $tb_countryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "tb_country"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      country_id: number
      country_eng: string
      country_arm: string
    }, ExtArgs["result"]["tb_country"]>
    composites: {}
  }

  type tb_countryGetPayload<S extends boolean | null | undefined | tb_countryDefaultArgs> = $Result.GetResult<Prisma.$tb_countryPayload, S>

  type tb_countryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<tb_countryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Tb_countryCountAggregateInputType | true
    }

  export interface tb_countryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['tb_country'], meta: { name: 'tb_country' } }
    /**
     * Find zero or one Tb_country that matches the filter.
     * @param {tb_countryFindUniqueArgs} args - Arguments to find a Tb_country
     * @example
     * // Get one Tb_country
     * const tb_country = await prisma.tb_country.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends tb_countryFindUniqueArgs>(args: SelectSubset<T, tb_countryFindUniqueArgs<ExtArgs>>): Prisma__tb_countryClient<$Result.GetResult<Prisma.$tb_countryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Tb_country that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {tb_countryFindUniqueOrThrowArgs} args - Arguments to find a Tb_country
     * @example
     * // Get one Tb_country
     * const tb_country = await prisma.tb_country.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends tb_countryFindUniqueOrThrowArgs>(args: SelectSubset<T, tb_countryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__tb_countryClient<$Result.GetResult<Prisma.$tb_countryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tb_country that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_countryFindFirstArgs} args - Arguments to find a Tb_country
     * @example
     * // Get one Tb_country
     * const tb_country = await prisma.tb_country.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends tb_countryFindFirstArgs>(args?: SelectSubset<T, tb_countryFindFirstArgs<ExtArgs>>): Prisma__tb_countryClient<$Result.GetResult<Prisma.$tb_countryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tb_country that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_countryFindFirstOrThrowArgs} args - Arguments to find a Tb_country
     * @example
     * // Get one Tb_country
     * const tb_country = await prisma.tb_country.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends tb_countryFindFirstOrThrowArgs>(args?: SelectSubset<T, tb_countryFindFirstOrThrowArgs<ExtArgs>>): Prisma__tb_countryClient<$Result.GetResult<Prisma.$tb_countryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Tb_countries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_countryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tb_countries
     * const tb_countries = await prisma.tb_country.findMany()
     * 
     * // Get first 10 Tb_countries
     * const tb_countries = await prisma.tb_country.findMany({ take: 10 })
     * 
     * // Only select the `country_id`
     * const tb_countryWithCountry_idOnly = await prisma.tb_country.findMany({ select: { country_id: true } })
     * 
     */
    findMany<T extends tb_countryFindManyArgs>(args?: SelectSubset<T, tb_countryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tb_countryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Tb_country.
     * @param {tb_countryCreateArgs} args - Arguments to create a Tb_country.
     * @example
     * // Create one Tb_country
     * const Tb_country = await prisma.tb_country.create({
     *   data: {
     *     // ... data to create a Tb_country
     *   }
     * })
     * 
     */
    create<T extends tb_countryCreateArgs>(args: SelectSubset<T, tb_countryCreateArgs<ExtArgs>>): Prisma__tb_countryClient<$Result.GetResult<Prisma.$tb_countryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Tb_countries.
     * @param {tb_countryCreateManyArgs} args - Arguments to create many Tb_countries.
     * @example
     * // Create many Tb_countries
     * const tb_country = await prisma.tb_country.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends tb_countryCreateManyArgs>(args?: SelectSubset<T, tb_countryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Tb_country.
     * @param {tb_countryDeleteArgs} args - Arguments to delete one Tb_country.
     * @example
     * // Delete one Tb_country
     * const Tb_country = await prisma.tb_country.delete({
     *   where: {
     *     // ... filter to delete one Tb_country
     *   }
     * })
     * 
     */
    delete<T extends tb_countryDeleteArgs>(args: SelectSubset<T, tb_countryDeleteArgs<ExtArgs>>): Prisma__tb_countryClient<$Result.GetResult<Prisma.$tb_countryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Tb_country.
     * @param {tb_countryUpdateArgs} args - Arguments to update one Tb_country.
     * @example
     * // Update one Tb_country
     * const tb_country = await prisma.tb_country.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends tb_countryUpdateArgs>(args: SelectSubset<T, tb_countryUpdateArgs<ExtArgs>>): Prisma__tb_countryClient<$Result.GetResult<Prisma.$tb_countryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Tb_countries.
     * @param {tb_countryDeleteManyArgs} args - Arguments to filter Tb_countries to delete.
     * @example
     * // Delete a few Tb_countries
     * const { count } = await prisma.tb_country.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends tb_countryDeleteManyArgs>(args?: SelectSubset<T, tb_countryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tb_countries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_countryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tb_countries
     * const tb_country = await prisma.tb_country.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends tb_countryUpdateManyArgs>(args: SelectSubset<T, tb_countryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Tb_country.
     * @param {tb_countryUpsertArgs} args - Arguments to update or create a Tb_country.
     * @example
     * // Update or create a Tb_country
     * const tb_country = await prisma.tb_country.upsert({
     *   create: {
     *     // ... data to create a Tb_country
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tb_country we want to update
     *   }
     * })
     */
    upsert<T extends tb_countryUpsertArgs>(args: SelectSubset<T, tb_countryUpsertArgs<ExtArgs>>): Prisma__tb_countryClient<$Result.GetResult<Prisma.$tb_countryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Tb_countries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_countryCountArgs} args - Arguments to filter Tb_countries to count.
     * @example
     * // Count the number of Tb_countries
     * const count = await prisma.tb_country.count({
     *   where: {
     *     // ... the filter for the Tb_countries we want to count
     *   }
     * })
    **/
    count<T extends tb_countryCountArgs>(
      args?: Subset<T, tb_countryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Tb_countryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tb_country.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Tb_countryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Tb_countryAggregateArgs>(args: Subset<T, Tb_countryAggregateArgs>): Prisma.PrismaPromise<GetTb_countryAggregateType<T>>

    /**
     * Group by Tb_country.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_countryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends tb_countryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: tb_countryGroupByArgs['orderBy'] }
        : { orderBy?: tb_countryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, tb_countryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTb_countryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the tb_country model
   */
  readonly fields: tb_countryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for tb_country.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__tb_countryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the tb_country model
   */
  interface tb_countryFieldRefs {
    readonly country_id: FieldRef<"tb_country", 'Int'>
    readonly country_eng: FieldRef<"tb_country", 'String'>
    readonly country_arm: FieldRef<"tb_country", 'String'>
  }
    

  // Custom InputTypes
  /**
   * tb_country findUnique
   */
  export type tb_countryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_country
     */
    select?: tb_countrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_country
     */
    omit?: tb_countryOmit<ExtArgs> | null
    /**
     * Filter, which tb_country to fetch.
     */
    where: tb_countryWhereUniqueInput
  }

  /**
   * tb_country findUniqueOrThrow
   */
  export type tb_countryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_country
     */
    select?: tb_countrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_country
     */
    omit?: tb_countryOmit<ExtArgs> | null
    /**
     * Filter, which tb_country to fetch.
     */
    where: tb_countryWhereUniqueInput
  }

  /**
   * tb_country findFirst
   */
  export type tb_countryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_country
     */
    select?: tb_countrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_country
     */
    omit?: tb_countryOmit<ExtArgs> | null
    /**
     * Filter, which tb_country to fetch.
     */
    where?: tb_countryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tb_countries to fetch.
     */
    orderBy?: tb_countryOrderByWithRelationInput | tb_countryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tb_countries.
     */
    cursor?: tb_countryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tb_countries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tb_countries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tb_countries.
     */
    distinct?: Tb_countryScalarFieldEnum | Tb_countryScalarFieldEnum[]
  }

  /**
   * tb_country findFirstOrThrow
   */
  export type tb_countryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_country
     */
    select?: tb_countrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_country
     */
    omit?: tb_countryOmit<ExtArgs> | null
    /**
     * Filter, which tb_country to fetch.
     */
    where?: tb_countryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tb_countries to fetch.
     */
    orderBy?: tb_countryOrderByWithRelationInput | tb_countryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tb_countries.
     */
    cursor?: tb_countryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tb_countries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tb_countries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tb_countries.
     */
    distinct?: Tb_countryScalarFieldEnum | Tb_countryScalarFieldEnum[]
  }

  /**
   * tb_country findMany
   */
  export type tb_countryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_country
     */
    select?: tb_countrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_country
     */
    omit?: tb_countryOmit<ExtArgs> | null
    /**
     * Filter, which tb_countries to fetch.
     */
    where?: tb_countryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tb_countries to fetch.
     */
    orderBy?: tb_countryOrderByWithRelationInput | tb_countryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing tb_countries.
     */
    cursor?: tb_countryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tb_countries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tb_countries.
     */
    skip?: number
    distinct?: Tb_countryScalarFieldEnum | Tb_countryScalarFieldEnum[]
  }

  /**
   * tb_country create
   */
  export type tb_countryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_country
     */
    select?: tb_countrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_country
     */
    omit?: tb_countryOmit<ExtArgs> | null
    /**
     * The data needed to create a tb_country.
     */
    data: XOR<tb_countryCreateInput, tb_countryUncheckedCreateInput>
  }

  /**
   * tb_country createMany
   */
  export type tb_countryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many tb_countries.
     */
    data: tb_countryCreateManyInput | tb_countryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * tb_country update
   */
  export type tb_countryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_country
     */
    select?: tb_countrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_country
     */
    omit?: tb_countryOmit<ExtArgs> | null
    /**
     * The data needed to update a tb_country.
     */
    data: XOR<tb_countryUpdateInput, tb_countryUncheckedUpdateInput>
    /**
     * Choose, which tb_country to update.
     */
    where: tb_countryWhereUniqueInput
  }

  /**
   * tb_country updateMany
   */
  export type tb_countryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update tb_countries.
     */
    data: XOR<tb_countryUpdateManyMutationInput, tb_countryUncheckedUpdateManyInput>
    /**
     * Filter which tb_countries to update
     */
    where?: tb_countryWhereInput
    /**
     * Limit how many tb_countries to update.
     */
    limit?: number
  }

  /**
   * tb_country upsert
   */
  export type tb_countryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_country
     */
    select?: tb_countrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_country
     */
    omit?: tb_countryOmit<ExtArgs> | null
    /**
     * The filter to search for the tb_country to update in case it exists.
     */
    where: tb_countryWhereUniqueInput
    /**
     * In case the tb_country found by the `where` argument doesn't exist, create a new tb_country with this data.
     */
    create: XOR<tb_countryCreateInput, tb_countryUncheckedCreateInput>
    /**
     * In case the tb_country was found with the provided `where` argument, update it with this data.
     */
    update: XOR<tb_countryUpdateInput, tb_countryUncheckedUpdateInput>
  }

  /**
   * tb_country delete
   */
  export type tb_countryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_country
     */
    select?: tb_countrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_country
     */
    omit?: tb_countryOmit<ExtArgs> | null
    /**
     * Filter which tb_country to delete.
     */
    where: tb_countryWhereUniqueInput
  }

  /**
   * tb_country deleteMany
   */
  export type tb_countryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tb_countries to delete
     */
    where?: tb_countryWhereInput
    /**
     * Limit how many tb_countries to delete.
     */
    limit?: number
  }

  /**
   * tb_country without action
   */
  export type tb_countryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_country
     */
    select?: tb_countrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_country
     */
    omit?: tb_countryOmit<ExtArgs> | null
  }


  /**
   * Model tb_cover_files
   */

  export type AggregateTb_cover_files = {
    _count: Tb_cover_filesCountAggregateOutputType | null
    _avg: Tb_cover_filesAvgAggregateOutputType | null
    _sum: Tb_cover_filesSumAggregateOutputType | null
    _min: Tb_cover_filesMinAggregateOutputType | null
    _max: Tb_cover_filesMaxAggregateOutputType | null
  }

  export type Tb_cover_filesAvgAggregateOutputType = {
    cover_file_id: number | null
    type: number | null
    cover_status: number | null
    case_id: number | null
    translation_id: number | null
    cover_actual: number | null
  }

  export type Tb_cover_filesSumAggregateOutputType = {
    cover_file_id: number | null
    type: number | null
    cover_status: number | null
    case_id: number | null
    translation_id: number | null
    cover_actual: number | null
  }

  export type Tb_cover_filesMinAggregateOutputType = {
    cover_file_id: number | null
    type: number | null
    file_name: string | null
    cover_status: number | null
    case_id: number | null
    translation_id: number | null
    cover_actual: number | null
  }

  export type Tb_cover_filesMaxAggregateOutputType = {
    cover_file_id: number | null
    type: number | null
    file_name: string | null
    cover_status: number | null
    case_id: number | null
    translation_id: number | null
    cover_actual: number | null
  }

  export type Tb_cover_filesCountAggregateOutputType = {
    cover_file_id: number
    type: number
    file_name: number
    cover_status: number
    case_id: number
    translation_id: number
    cover_actual: number
    _all: number
  }


  export type Tb_cover_filesAvgAggregateInputType = {
    cover_file_id?: true
    type?: true
    cover_status?: true
    case_id?: true
    translation_id?: true
    cover_actual?: true
  }

  export type Tb_cover_filesSumAggregateInputType = {
    cover_file_id?: true
    type?: true
    cover_status?: true
    case_id?: true
    translation_id?: true
    cover_actual?: true
  }

  export type Tb_cover_filesMinAggregateInputType = {
    cover_file_id?: true
    type?: true
    file_name?: true
    cover_status?: true
    case_id?: true
    translation_id?: true
    cover_actual?: true
  }

  export type Tb_cover_filesMaxAggregateInputType = {
    cover_file_id?: true
    type?: true
    file_name?: true
    cover_status?: true
    case_id?: true
    translation_id?: true
    cover_actual?: true
  }

  export type Tb_cover_filesCountAggregateInputType = {
    cover_file_id?: true
    type?: true
    file_name?: true
    cover_status?: true
    case_id?: true
    translation_id?: true
    cover_actual?: true
    _all?: true
  }

  export type Tb_cover_filesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tb_cover_files to aggregate.
     */
    where?: tb_cover_filesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tb_cover_files to fetch.
     */
    orderBy?: tb_cover_filesOrderByWithRelationInput | tb_cover_filesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: tb_cover_filesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tb_cover_files from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tb_cover_files.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned tb_cover_files
    **/
    _count?: true | Tb_cover_filesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Tb_cover_filesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Tb_cover_filesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Tb_cover_filesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Tb_cover_filesMaxAggregateInputType
  }

  export type GetTb_cover_filesAggregateType<T extends Tb_cover_filesAggregateArgs> = {
        [P in keyof T & keyof AggregateTb_cover_files]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTb_cover_files[P]>
      : GetScalarType<T[P], AggregateTb_cover_files[P]>
  }




  export type tb_cover_filesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: tb_cover_filesWhereInput
    orderBy?: tb_cover_filesOrderByWithAggregationInput | tb_cover_filesOrderByWithAggregationInput[]
    by: Tb_cover_filesScalarFieldEnum[] | Tb_cover_filesScalarFieldEnum
    having?: tb_cover_filesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Tb_cover_filesCountAggregateInputType | true
    _avg?: Tb_cover_filesAvgAggregateInputType
    _sum?: Tb_cover_filesSumAggregateInputType
    _min?: Tb_cover_filesMinAggregateInputType
    _max?: Tb_cover_filesMaxAggregateInputType
  }

  export type Tb_cover_filesGroupByOutputType = {
    cover_file_id: number
    type: number
    file_name: string
    cover_status: number
    case_id: number
    translation_id: number
    cover_actual: number | null
    _count: Tb_cover_filesCountAggregateOutputType | null
    _avg: Tb_cover_filesAvgAggregateOutputType | null
    _sum: Tb_cover_filesSumAggregateOutputType | null
    _min: Tb_cover_filesMinAggregateOutputType | null
    _max: Tb_cover_filesMaxAggregateOutputType | null
  }

  type GetTb_cover_filesGroupByPayload<T extends tb_cover_filesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Tb_cover_filesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Tb_cover_filesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Tb_cover_filesGroupByOutputType[P]>
            : GetScalarType<T[P], Tb_cover_filesGroupByOutputType[P]>
        }
      >
    >


  export type tb_cover_filesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    cover_file_id?: boolean
    type?: boolean
    file_name?: boolean
    cover_status?: boolean
    case_id?: boolean
    translation_id?: boolean
    cover_actual?: boolean
  }, ExtArgs["result"]["tb_cover_files"]>



  export type tb_cover_filesSelectScalar = {
    cover_file_id?: boolean
    type?: boolean
    file_name?: boolean
    cover_status?: boolean
    case_id?: boolean
    translation_id?: boolean
    cover_actual?: boolean
  }

  export type tb_cover_filesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"cover_file_id" | "type" | "file_name" | "cover_status" | "case_id" | "translation_id" | "cover_actual", ExtArgs["result"]["tb_cover_files"]>

  export type $tb_cover_filesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "tb_cover_files"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      cover_file_id: number
      type: number
      file_name: string
      cover_status: number
      case_id: number
      translation_id: number
      cover_actual: number | null
    }, ExtArgs["result"]["tb_cover_files"]>
    composites: {}
  }

  type tb_cover_filesGetPayload<S extends boolean | null | undefined | tb_cover_filesDefaultArgs> = $Result.GetResult<Prisma.$tb_cover_filesPayload, S>

  type tb_cover_filesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<tb_cover_filesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Tb_cover_filesCountAggregateInputType | true
    }

  export interface tb_cover_filesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['tb_cover_files'], meta: { name: 'tb_cover_files' } }
    /**
     * Find zero or one Tb_cover_files that matches the filter.
     * @param {tb_cover_filesFindUniqueArgs} args - Arguments to find a Tb_cover_files
     * @example
     * // Get one Tb_cover_files
     * const tb_cover_files = await prisma.tb_cover_files.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends tb_cover_filesFindUniqueArgs>(args: SelectSubset<T, tb_cover_filesFindUniqueArgs<ExtArgs>>): Prisma__tb_cover_filesClient<$Result.GetResult<Prisma.$tb_cover_filesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Tb_cover_files that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {tb_cover_filesFindUniqueOrThrowArgs} args - Arguments to find a Tb_cover_files
     * @example
     * // Get one Tb_cover_files
     * const tb_cover_files = await prisma.tb_cover_files.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends tb_cover_filesFindUniqueOrThrowArgs>(args: SelectSubset<T, tb_cover_filesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__tb_cover_filesClient<$Result.GetResult<Prisma.$tb_cover_filesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tb_cover_files that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_cover_filesFindFirstArgs} args - Arguments to find a Tb_cover_files
     * @example
     * // Get one Tb_cover_files
     * const tb_cover_files = await prisma.tb_cover_files.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends tb_cover_filesFindFirstArgs>(args?: SelectSubset<T, tb_cover_filesFindFirstArgs<ExtArgs>>): Prisma__tb_cover_filesClient<$Result.GetResult<Prisma.$tb_cover_filesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tb_cover_files that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_cover_filesFindFirstOrThrowArgs} args - Arguments to find a Tb_cover_files
     * @example
     * // Get one Tb_cover_files
     * const tb_cover_files = await prisma.tb_cover_files.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends tb_cover_filesFindFirstOrThrowArgs>(args?: SelectSubset<T, tb_cover_filesFindFirstOrThrowArgs<ExtArgs>>): Prisma__tb_cover_filesClient<$Result.GetResult<Prisma.$tb_cover_filesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Tb_cover_files that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_cover_filesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tb_cover_files
     * const tb_cover_files = await prisma.tb_cover_files.findMany()
     * 
     * // Get first 10 Tb_cover_files
     * const tb_cover_files = await prisma.tb_cover_files.findMany({ take: 10 })
     * 
     * // Only select the `cover_file_id`
     * const tb_cover_filesWithCover_file_idOnly = await prisma.tb_cover_files.findMany({ select: { cover_file_id: true } })
     * 
     */
    findMany<T extends tb_cover_filesFindManyArgs>(args?: SelectSubset<T, tb_cover_filesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tb_cover_filesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Tb_cover_files.
     * @param {tb_cover_filesCreateArgs} args - Arguments to create a Tb_cover_files.
     * @example
     * // Create one Tb_cover_files
     * const Tb_cover_files = await prisma.tb_cover_files.create({
     *   data: {
     *     // ... data to create a Tb_cover_files
     *   }
     * })
     * 
     */
    create<T extends tb_cover_filesCreateArgs>(args: SelectSubset<T, tb_cover_filesCreateArgs<ExtArgs>>): Prisma__tb_cover_filesClient<$Result.GetResult<Prisma.$tb_cover_filesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Tb_cover_files.
     * @param {tb_cover_filesCreateManyArgs} args - Arguments to create many Tb_cover_files.
     * @example
     * // Create many Tb_cover_files
     * const tb_cover_files = await prisma.tb_cover_files.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends tb_cover_filesCreateManyArgs>(args?: SelectSubset<T, tb_cover_filesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Tb_cover_files.
     * @param {tb_cover_filesDeleteArgs} args - Arguments to delete one Tb_cover_files.
     * @example
     * // Delete one Tb_cover_files
     * const Tb_cover_files = await prisma.tb_cover_files.delete({
     *   where: {
     *     // ... filter to delete one Tb_cover_files
     *   }
     * })
     * 
     */
    delete<T extends tb_cover_filesDeleteArgs>(args: SelectSubset<T, tb_cover_filesDeleteArgs<ExtArgs>>): Prisma__tb_cover_filesClient<$Result.GetResult<Prisma.$tb_cover_filesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Tb_cover_files.
     * @param {tb_cover_filesUpdateArgs} args - Arguments to update one Tb_cover_files.
     * @example
     * // Update one Tb_cover_files
     * const tb_cover_files = await prisma.tb_cover_files.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends tb_cover_filesUpdateArgs>(args: SelectSubset<T, tb_cover_filesUpdateArgs<ExtArgs>>): Prisma__tb_cover_filesClient<$Result.GetResult<Prisma.$tb_cover_filesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Tb_cover_files.
     * @param {tb_cover_filesDeleteManyArgs} args - Arguments to filter Tb_cover_files to delete.
     * @example
     * // Delete a few Tb_cover_files
     * const { count } = await prisma.tb_cover_files.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends tb_cover_filesDeleteManyArgs>(args?: SelectSubset<T, tb_cover_filesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tb_cover_files.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_cover_filesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tb_cover_files
     * const tb_cover_files = await prisma.tb_cover_files.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends tb_cover_filesUpdateManyArgs>(args: SelectSubset<T, tb_cover_filesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Tb_cover_files.
     * @param {tb_cover_filesUpsertArgs} args - Arguments to update or create a Tb_cover_files.
     * @example
     * // Update or create a Tb_cover_files
     * const tb_cover_files = await prisma.tb_cover_files.upsert({
     *   create: {
     *     // ... data to create a Tb_cover_files
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tb_cover_files we want to update
     *   }
     * })
     */
    upsert<T extends tb_cover_filesUpsertArgs>(args: SelectSubset<T, tb_cover_filesUpsertArgs<ExtArgs>>): Prisma__tb_cover_filesClient<$Result.GetResult<Prisma.$tb_cover_filesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Tb_cover_files.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_cover_filesCountArgs} args - Arguments to filter Tb_cover_files to count.
     * @example
     * // Count the number of Tb_cover_files
     * const count = await prisma.tb_cover_files.count({
     *   where: {
     *     // ... the filter for the Tb_cover_files we want to count
     *   }
     * })
    **/
    count<T extends tb_cover_filesCountArgs>(
      args?: Subset<T, tb_cover_filesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Tb_cover_filesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tb_cover_files.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Tb_cover_filesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Tb_cover_filesAggregateArgs>(args: Subset<T, Tb_cover_filesAggregateArgs>): Prisma.PrismaPromise<GetTb_cover_filesAggregateType<T>>

    /**
     * Group by Tb_cover_files.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_cover_filesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends tb_cover_filesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: tb_cover_filesGroupByArgs['orderBy'] }
        : { orderBy?: tb_cover_filesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, tb_cover_filesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTb_cover_filesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the tb_cover_files model
   */
  readonly fields: tb_cover_filesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for tb_cover_files.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__tb_cover_filesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the tb_cover_files model
   */
  interface tb_cover_filesFieldRefs {
    readonly cover_file_id: FieldRef<"tb_cover_files", 'Int'>
    readonly type: FieldRef<"tb_cover_files", 'Int'>
    readonly file_name: FieldRef<"tb_cover_files", 'String'>
    readonly cover_status: FieldRef<"tb_cover_files", 'Int'>
    readonly case_id: FieldRef<"tb_cover_files", 'Int'>
    readonly translation_id: FieldRef<"tb_cover_files", 'Int'>
    readonly cover_actual: FieldRef<"tb_cover_files", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * tb_cover_files findUnique
   */
  export type tb_cover_filesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_cover_files
     */
    select?: tb_cover_filesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_cover_files
     */
    omit?: tb_cover_filesOmit<ExtArgs> | null
    /**
     * Filter, which tb_cover_files to fetch.
     */
    where: tb_cover_filesWhereUniqueInput
  }

  /**
   * tb_cover_files findUniqueOrThrow
   */
  export type tb_cover_filesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_cover_files
     */
    select?: tb_cover_filesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_cover_files
     */
    omit?: tb_cover_filesOmit<ExtArgs> | null
    /**
     * Filter, which tb_cover_files to fetch.
     */
    where: tb_cover_filesWhereUniqueInput
  }

  /**
   * tb_cover_files findFirst
   */
  export type tb_cover_filesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_cover_files
     */
    select?: tb_cover_filesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_cover_files
     */
    omit?: tb_cover_filesOmit<ExtArgs> | null
    /**
     * Filter, which tb_cover_files to fetch.
     */
    where?: tb_cover_filesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tb_cover_files to fetch.
     */
    orderBy?: tb_cover_filesOrderByWithRelationInput | tb_cover_filesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tb_cover_files.
     */
    cursor?: tb_cover_filesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tb_cover_files from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tb_cover_files.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tb_cover_files.
     */
    distinct?: Tb_cover_filesScalarFieldEnum | Tb_cover_filesScalarFieldEnum[]
  }

  /**
   * tb_cover_files findFirstOrThrow
   */
  export type tb_cover_filesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_cover_files
     */
    select?: tb_cover_filesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_cover_files
     */
    omit?: tb_cover_filesOmit<ExtArgs> | null
    /**
     * Filter, which tb_cover_files to fetch.
     */
    where?: tb_cover_filesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tb_cover_files to fetch.
     */
    orderBy?: tb_cover_filesOrderByWithRelationInput | tb_cover_filesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tb_cover_files.
     */
    cursor?: tb_cover_filesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tb_cover_files from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tb_cover_files.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tb_cover_files.
     */
    distinct?: Tb_cover_filesScalarFieldEnum | Tb_cover_filesScalarFieldEnum[]
  }

  /**
   * tb_cover_files findMany
   */
  export type tb_cover_filesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_cover_files
     */
    select?: tb_cover_filesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_cover_files
     */
    omit?: tb_cover_filesOmit<ExtArgs> | null
    /**
     * Filter, which tb_cover_files to fetch.
     */
    where?: tb_cover_filesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tb_cover_files to fetch.
     */
    orderBy?: tb_cover_filesOrderByWithRelationInput | tb_cover_filesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing tb_cover_files.
     */
    cursor?: tb_cover_filesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tb_cover_files from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tb_cover_files.
     */
    skip?: number
    distinct?: Tb_cover_filesScalarFieldEnum | Tb_cover_filesScalarFieldEnum[]
  }

  /**
   * tb_cover_files create
   */
  export type tb_cover_filesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_cover_files
     */
    select?: tb_cover_filesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_cover_files
     */
    omit?: tb_cover_filesOmit<ExtArgs> | null
    /**
     * The data needed to create a tb_cover_files.
     */
    data: XOR<tb_cover_filesCreateInput, tb_cover_filesUncheckedCreateInput>
  }

  /**
   * tb_cover_files createMany
   */
  export type tb_cover_filesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many tb_cover_files.
     */
    data: tb_cover_filesCreateManyInput | tb_cover_filesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * tb_cover_files update
   */
  export type tb_cover_filesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_cover_files
     */
    select?: tb_cover_filesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_cover_files
     */
    omit?: tb_cover_filesOmit<ExtArgs> | null
    /**
     * The data needed to update a tb_cover_files.
     */
    data: XOR<tb_cover_filesUpdateInput, tb_cover_filesUncheckedUpdateInput>
    /**
     * Choose, which tb_cover_files to update.
     */
    where: tb_cover_filesWhereUniqueInput
  }

  /**
   * tb_cover_files updateMany
   */
  export type tb_cover_filesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update tb_cover_files.
     */
    data: XOR<tb_cover_filesUpdateManyMutationInput, tb_cover_filesUncheckedUpdateManyInput>
    /**
     * Filter which tb_cover_files to update
     */
    where?: tb_cover_filesWhereInput
    /**
     * Limit how many tb_cover_files to update.
     */
    limit?: number
  }

  /**
   * tb_cover_files upsert
   */
  export type tb_cover_filesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_cover_files
     */
    select?: tb_cover_filesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_cover_files
     */
    omit?: tb_cover_filesOmit<ExtArgs> | null
    /**
     * The filter to search for the tb_cover_files to update in case it exists.
     */
    where: tb_cover_filesWhereUniqueInput
    /**
     * In case the tb_cover_files found by the `where` argument doesn't exist, create a new tb_cover_files with this data.
     */
    create: XOR<tb_cover_filesCreateInput, tb_cover_filesUncheckedCreateInput>
    /**
     * In case the tb_cover_files was found with the provided `where` argument, update it with this data.
     */
    update: XOR<tb_cover_filesUpdateInput, tb_cover_filesUncheckedUpdateInput>
  }

  /**
   * tb_cover_files delete
   */
  export type tb_cover_filesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_cover_files
     */
    select?: tb_cover_filesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_cover_files
     */
    omit?: tb_cover_filesOmit<ExtArgs> | null
    /**
     * Filter which tb_cover_files to delete.
     */
    where: tb_cover_filesWhereUniqueInput
  }

  /**
   * tb_cover_files deleteMany
   */
  export type tb_cover_filesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tb_cover_files to delete
     */
    where?: tb_cover_filesWhereInput
    /**
     * Limit how many tb_cover_files to delete.
     */
    limit?: number
  }

  /**
   * tb_cover_files without action
   */
  export type tb_cover_filesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_cover_files
     */
    select?: tb_cover_filesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_cover_files
     */
    omit?: tb_cover_filesOmit<ExtArgs> | null
  }


  /**
   * Model tb_deadline
   */

  export type AggregateTb_deadline = {
    _count: Tb_deadlineCountAggregateOutputType | null
    _avg: Tb_deadlineAvgAggregateOutputType | null
    _sum: Tb_deadlineSumAggregateOutputType | null
    _min: Tb_deadlineMinAggregateOutputType | null
    _max: Tb_deadlineMaxAggregateOutputType | null
  }

  export type Tb_deadlineAvgAggregateOutputType = {
    id: number | null
    case_id: number | null
    deadline_type: number | null
    actual_dead: number | null
    process_type_id: number | null
  }

  export type Tb_deadlineSumAggregateOutputType = {
    id: number | null
    case_id: number | null
    deadline_type: number | null
    actual_dead: number | null
    process_type_id: number | null
  }

  export type Tb_deadlineMinAggregateOutputType = {
    id: number | null
    case_id: number | null
    deadline_type: number | null
    deadline: Date | null
    actual_dead: number | null
    process_type_id: number | null
  }

  export type Tb_deadlineMaxAggregateOutputType = {
    id: number | null
    case_id: number | null
    deadline_type: number | null
    deadline: Date | null
    actual_dead: number | null
    process_type_id: number | null
  }

  export type Tb_deadlineCountAggregateOutputType = {
    id: number
    case_id: number
    deadline_type: number
    deadline: number
    actual_dead: number
    process_type_id: number
    _all: number
  }


  export type Tb_deadlineAvgAggregateInputType = {
    id?: true
    case_id?: true
    deadline_type?: true
    actual_dead?: true
    process_type_id?: true
  }

  export type Tb_deadlineSumAggregateInputType = {
    id?: true
    case_id?: true
    deadline_type?: true
    actual_dead?: true
    process_type_id?: true
  }

  export type Tb_deadlineMinAggregateInputType = {
    id?: true
    case_id?: true
    deadline_type?: true
    deadline?: true
    actual_dead?: true
    process_type_id?: true
  }

  export type Tb_deadlineMaxAggregateInputType = {
    id?: true
    case_id?: true
    deadline_type?: true
    deadline?: true
    actual_dead?: true
    process_type_id?: true
  }

  export type Tb_deadlineCountAggregateInputType = {
    id?: true
    case_id?: true
    deadline_type?: true
    deadline?: true
    actual_dead?: true
    process_type_id?: true
    _all?: true
  }

  export type Tb_deadlineAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tb_deadline to aggregate.
     */
    where?: tb_deadlineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tb_deadlines to fetch.
     */
    orderBy?: tb_deadlineOrderByWithRelationInput | tb_deadlineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: tb_deadlineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tb_deadlines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tb_deadlines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned tb_deadlines
    **/
    _count?: true | Tb_deadlineCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Tb_deadlineAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Tb_deadlineSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Tb_deadlineMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Tb_deadlineMaxAggregateInputType
  }

  export type GetTb_deadlineAggregateType<T extends Tb_deadlineAggregateArgs> = {
        [P in keyof T & keyof AggregateTb_deadline]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTb_deadline[P]>
      : GetScalarType<T[P], AggregateTb_deadline[P]>
  }




  export type tb_deadlineGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: tb_deadlineWhereInput
    orderBy?: tb_deadlineOrderByWithAggregationInput | tb_deadlineOrderByWithAggregationInput[]
    by: Tb_deadlineScalarFieldEnum[] | Tb_deadlineScalarFieldEnum
    having?: tb_deadlineScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Tb_deadlineCountAggregateInputType | true
    _avg?: Tb_deadlineAvgAggregateInputType
    _sum?: Tb_deadlineSumAggregateInputType
    _min?: Tb_deadlineMinAggregateInputType
    _max?: Tb_deadlineMaxAggregateInputType
  }

  export type Tb_deadlineGroupByOutputType = {
    id: number
    case_id: number
    deadline_type: number
    deadline: Date
    actual_dead: number
    process_type_id: number
    _count: Tb_deadlineCountAggregateOutputType | null
    _avg: Tb_deadlineAvgAggregateOutputType | null
    _sum: Tb_deadlineSumAggregateOutputType | null
    _min: Tb_deadlineMinAggregateOutputType | null
    _max: Tb_deadlineMaxAggregateOutputType | null
  }

  type GetTb_deadlineGroupByPayload<T extends tb_deadlineGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Tb_deadlineGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Tb_deadlineGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Tb_deadlineGroupByOutputType[P]>
            : GetScalarType<T[P], Tb_deadlineGroupByOutputType[P]>
        }
      >
    >


  export type tb_deadlineSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    case_id?: boolean
    deadline_type?: boolean
    deadline?: boolean
    actual_dead?: boolean
    process_type_id?: boolean
  }, ExtArgs["result"]["tb_deadline"]>



  export type tb_deadlineSelectScalar = {
    id?: boolean
    case_id?: boolean
    deadline_type?: boolean
    deadline?: boolean
    actual_dead?: boolean
    process_type_id?: boolean
  }

  export type tb_deadlineOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "case_id" | "deadline_type" | "deadline" | "actual_dead" | "process_type_id", ExtArgs["result"]["tb_deadline"]>

  export type $tb_deadlinePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "tb_deadline"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      case_id: number
      deadline_type: number
      deadline: Date
      actual_dead: number
      process_type_id: number
    }, ExtArgs["result"]["tb_deadline"]>
    composites: {}
  }

  type tb_deadlineGetPayload<S extends boolean | null | undefined | tb_deadlineDefaultArgs> = $Result.GetResult<Prisma.$tb_deadlinePayload, S>

  type tb_deadlineCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<tb_deadlineFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Tb_deadlineCountAggregateInputType | true
    }

  export interface tb_deadlineDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['tb_deadline'], meta: { name: 'tb_deadline' } }
    /**
     * Find zero or one Tb_deadline that matches the filter.
     * @param {tb_deadlineFindUniqueArgs} args - Arguments to find a Tb_deadline
     * @example
     * // Get one Tb_deadline
     * const tb_deadline = await prisma.tb_deadline.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends tb_deadlineFindUniqueArgs>(args: SelectSubset<T, tb_deadlineFindUniqueArgs<ExtArgs>>): Prisma__tb_deadlineClient<$Result.GetResult<Prisma.$tb_deadlinePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Tb_deadline that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {tb_deadlineFindUniqueOrThrowArgs} args - Arguments to find a Tb_deadline
     * @example
     * // Get one Tb_deadline
     * const tb_deadline = await prisma.tb_deadline.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends tb_deadlineFindUniqueOrThrowArgs>(args: SelectSubset<T, tb_deadlineFindUniqueOrThrowArgs<ExtArgs>>): Prisma__tb_deadlineClient<$Result.GetResult<Prisma.$tb_deadlinePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tb_deadline that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_deadlineFindFirstArgs} args - Arguments to find a Tb_deadline
     * @example
     * // Get one Tb_deadline
     * const tb_deadline = await prisma.tb_deadline.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends tb_deadlineFindFirstArgs>(args?: SelectSubset<T, tb_deadlineFindFirstArgs<ExtArgs>>): Prisma__tb_deadlineClient<$Result.GetResult<Prisma.$tb_deadlinePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tb_deadline that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_deadlineFindFirstOrThrowArgs} args - Arguments to find a Tb_deadline
     * @example
     * // Get one Tb_deadline
     * const tb_deadline = await prisma.tb_deadline.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends tb_deadlineFindFirstOrThrowArgs>(args?: SelectSubset<T, tb_deadlineFindFirstOrThrowArgs<ExtArgs>>): Prisma__tb_deadlineClient<$Result.GetResult<Prisma.$tb_deadlinePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Tb_deadlines that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_deadlineFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tb_deadlines
     * const tb_deadlines = await prisma.tb_deadline.findMany()
     * 
     * // Get first 10 Tb_deadlines
     * const tb_deadlines = await prisma.tb_deadline.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tb_deadlineWithIdOnly = await prisma.tb_deadline.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends tb_deadlineFindManyArgs>(args?: SelectSubset<T, tb_deadlineFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tb_deadlinePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Tb_deadline.
     * @param {tb_deadlineCreateArgs} args - Arguments to create a Tb_deadline.
     * @example
     * // Create one Tb_deadline
     * const Tb_deadline = await prisma.tb_deadline.create({
     *   data: {
     *     // ... data to create a Tb_deadline
     *   }
     * })
     * 
     */
    create<T extends tb_deadlineCreateArgs>(args: SelectSubset<T, tb_deadlineCreateArgs<ExtArgs>>): Prisma__tb_deadlineClient<$Result.GetResult<Prisma.$tb_deadlinePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Tb_deadlines.
     * @param {tb_deadlineCreateManyArgs} args - Arguments to create many Tb_deadlines.
     * @example
     * // Create many Tb_deadlines
     * const tb_deadline = await prisma.tb_deadline.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends tb_deadlineCreateManyArgs>(args?: SelectSubset<T, tb_deadlineCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Tb_deadline.
     * @param {tb_deadlineDeleteArgs} args - Arguments to delete one Tb_deadline.
     * @example
     * // Delete one Tb_deadline
     * const Tb_deadline = await prisma.tb_deadline.delete({
     *   where: {
     *     // ... filter to delete one Tb_deadline
     *   }
     * })
     * 
     */
    delete<T extends tb_deadlineDeleteArgs>(args: SelectSubset<T, tb_deadlineDeleteArgs<ExtArgs>>): Prisma__tb_deadlineClient<$Result.GetResult<Prisma.$tb_deadlinePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Tb_deadline.
     * @param {tb_deadlineUpdateArgs} args - Arguments to update one Tb_deadline.
     * @example
     * // Update one Tb_deadline
     * const tb_deadline = await prisma.tb_deadline.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends tb_deadlineUpdateArgs>(args: SelectSubset<T, tb_deadlineUpdateArgs<ExtArgs>>): Prisma__tb_deadlineClient<$Result.GetResult<Prisma.$tb_deadlinePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Tb_deadlines.
     * @param {tb_deadlineDeleteManyArgs} args - Arguments to filter Tb_deadlines to delete.
     * @example
     * // Delete a few Tb_deadlines
     * const { count } = await prisma.tb_deadline.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends tb_deadlineDeleteManyArgs>(args?: SelectSubset<T, tb_deadlineDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tb_deadlines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_deadlineUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tb_deadlines
     * const tb_deadline = await prisma.tb_deadline.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends tb_deadlineUpdateManyArgs>(args: SelectSubset<T, tb_deadlineUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Tb_deadline.
     * @param {tb_deadlineUpsertArgs} args - Arguments to update or create a Tb_deadline.
     * @example
     * // Update or create a Tb_deadline
     * const tb_deadline = await prisma.tb_deadline.upsert({
     *   create: {
     *     // ... data to create a Tb_deadline
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tb_deadline we want to update
     *   }
     * })
     */
    upsert<T extends tb_deadlineUpsertArgs>(args: SelectSubset<T, tb_deadlineUpsertArgs<ExtArgs>>): Prisma__tb_deadlineClient<$Result.GetResult<Prisma.$tb_deadlinePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Tb_deadlines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_deadlineCountArgs} args - Arguments to filter Tb_deadlines to count.
     * @example
     * // Count the number of Tb_deadlines
     * const count = await prisma.tb_deadline.count({
     *   where: {
     *     // ... the filter for the Tb_deadlines we want to count
     *   }
     * })
    **/
    count<T extends tb_deadlineCountArgs>(
      args?: Subset<T, tb_deadlineCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Tb_deadlineCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tb_deadline.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Tb_deadlineAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Tb_deadlineAggregateArgs>(args: Subset<T, Tb_deadlineAggregateArgs>): Prisma.PrismaPromise<GetTb_deadlineAggregateType<T>>

    /**
     * Group by Tb_deadline.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_deadlineGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends tb_deadlineGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: tb_deadlineGroupByArgs['orderBy'] }
        : { orderBy?: tb_deadlineGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, tb_deadlineGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTb_deadlineGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the tb_deadline model
   */
  readonly fields: tb_deadlineFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for tb_deadline.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__tb_deadlineClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the tb_deadline model
   */
  interface tb_deadlineFieldRefs {
    readonly id: FieldRef<"tb_deadline", 'Int'>
    readonly case_id: FieldRef<"tb_deadline", 'Int'>
    readonly deadline_type: FieldRef<"tb_deadline", 'Int'>
    readonly deadline: FieldRef<"tb_deadline", 'DateTime'>
    readonly actual_dead: FieldRef<"tb_deadline", 'Int'>
    readonly process_type_id: FieldRef<"tb_deadline", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * tb_deadline findUnique
   */
  export type tb_deadlineFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_deadline
     */
    select?: tb_deadlineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_deadline
     */
    omit?: tb_deadlineOmit<ExtArgs> | null
    /**
     * Filter, which tb_deadline to fetch.
     */
    where: tb_deadlineWhereUniqueInput
  }

  /**
   * tb_deadline findUniqueOrThrow
   */
  export type tb_deadlineFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_deadline
     */
    select?: tb_deadlineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_deadline
     */
    omit?: tb_deadlineOmit<ExtArgs> | null
    /**
     * Filter, which tb_deadline to fetch.
     */
    where: tb_deadlineWhereUniqueInput
  }

  /**
   * tb_deadline findFirst
   */
  export type tb_deadlineFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_deadline
     */
    select?: tb_deadlineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_deadline
     */
    omit?: tb_deadlineOmit<ExtArgs> | null
    /**
     * Filter, which tb_deadline to fetch.
     */
    where?: tb_deadlineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tb_deadlines to fetch.
     */
    orderBy?: tb_deadlineOrderByWithRelationInput | tb_deadlineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tb_deadlines.
     */
    cursor?: tb_deadlineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tb_deadlines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tb_deadlines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tb_deadlines.
     */
    distinct?: Tb_deadlineScalarFieldEnum | Tb_deadlineScalarFieldEnum[]
  }

  /**
   * tb_deadline findFirstOrThrow
   */
  export type tb_deadlineFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_deadline
     */
    select?: tb_deadlineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_deadline
     */
    omit?: tb_deadlineOmit<ExtArgs> | null
    /**
     * Filter, which tb_deadline to fetch.
     */
    where?: tb_deadlineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tb_deadlines to fetch.
     */
    orderBy?: tb_deadlineOrderByWithRelationInput | tb_deadlineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tb_deadlines.
     */
    cursor?: tb_deadlineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tb_deadlines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tb_deadlines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tb_deadlines.
     */
    distinct?: Tb_deadlineScalarFieldEnum | Tb_deadlineScalarFieldEnum[]
  }

  /**
   * tb_deadline findMany
   */
  export type tb_deadlineFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_deadline
     */
    select?: tb_deadlineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_deadline
     */
    omit?: tb_deadlineOmit<ExtArgs> | null
    /**
     * Filter, which tb_deadlines to fetch.
     */
    where?: tb_deadlineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tb_deadlines to fetch.
     */
    orderBy?: tb_deadlineOrderByWithRelationInput | tb_deadlineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing tb_deadlines.
     */
    cursor?: tb_deadlineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tb_deadlines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tb_deadlines.
     */
    skip?: number
    distinct?: Tb_deadlineScalarFieldEnum | Tb_deadlineScalarFieldEnum[]
  }

  /**
   * tb_deadline create
   */
  export type tb_deadlineCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_deadline
     */
    select?: tb_deadlineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_deadline
     */
    omit?: tb_deadlineOmit<ExtArgs> | null
    /**
     * The data needed to create a tb_deadline.
     */
    data: XOR<tb_deadlineCreateInput, tb_deadlineUncheckedCreateInput>
  }

  /**
   * tb_deadline createMany
   */
  export type tb_deadlineCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many tb_deadlines.
     */
    data: tb_deadlineCreateManyInput | tb_deadlineCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * tb_deadline update
   */
  export type tb_deadlineUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_deadline
     */
    select?: tb_deadlineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_deadline
     */
    omit?: tb_deadlineOmit<ExtArgs> | null
    /**
     * The data needed to update a tb_deadline.
     */
    data: XOR<tb_deadlineUpdateInput, tb_deadlineUncheckedUpdateInput>
    /**
     * Choose, which tb_deadline to update.
     */
    where: tb_deadlineWhereUniqueInput
  }

  /**
   * tb_deadline updateMany
   */
  export type tb_deadlineUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update tb_deadlines.
     */
    data: XOR<tb_deadlineUpdateManyMutationInput, tb_deadlineUncheckedUpdateManyInput>
    /**
     * Filter which tb_deadlines to update
     */
    where?: tb_deadlineWhereInput
    /**
     * Limit how many tb_deadlines to update.
     */
    limit?: number
  }

  /**
   * tb_deadline upsert
   */
  export type tb_deadlineUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_deadline
     */
    select?: tb_deadlineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_deadline
     */
    omit?: tb_deadlineOmit<ExtArgs> | null
    /**
     * The filter to search for the tb_deadline to update in case it exists.
     */
    where: tb_deadlineWhereUniqueInput
    /**
     * In case the tb_deadline found by the `where` argument doesn't exist, create a new tb_deadline with this data.
     */
    create: XOR<tb_deadlineCreateInput, tb_deadlineUncheckedCreateInput>
    /**
     * In case the tb_deadline was found with the provided `where` argument, update it with this data.
     */
    update: XOR<tb_deadlineUpdateInput, tb_deadlineUncheckedUpdateInput>
  }

  /**
   * tb_deadline delete
   */
  export type tb_deadlineDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_deadline
     */
    select?: tb_deadlineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_deadline
     */
    omit?: tb_deadlineOmit<ExtArgs> | null
    /**
     * Filter which tb_deadline to delete.
     */
    where: tb_deadlineWhereUniqueInput
  }

  /**
   * tb_deadline deleteMany
   */
  export type tb_deadlineDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tb_deadlines to delete
     */
    where?: tb_deadlineWhereInput
    /**
     * Limit how many tb_deadlines to delete.
     */
    limit?: number
  }

  /**
   * tb_deadline without action
   */
  export type tb_deadlineDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_deadline
     */
    select?: tb_deadlineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_deadline
     */
    omit?: tb_deadlineOmit<ExtArgs> | null
  }


  /**
   * Model tb_deadline_types
   */

  export type AggregateTb_deadline_types = {
    _count: Tb_deadline_typesCountAggregateOutputType | null
    _avg: Tb_deadline_typesAvgAggregateOutputType | null
    _sum: Tb_deadline_typesSumAggregateOutputType | null
    _min: Tb_deadline_typesMinAggregateOutputType | null
    _max: Tb_deadline_typesMaxAggregateOutputType | null
  }

  export type Tb_deadline_typesAvgAggregateOutputType = {
    deadline_type_id: number | null
  }

  export type Tb_deadline_typesSumAggregateOutputType = {
    deadline_type_id: number | null
  }

  export type Tb_deadline_typesMinAggregateOutputType = {
    deadline_type_id: number | null
    deadline_type: string | null
  }

  export type Tb_deadline_typesMaxAggregateOutputType = {
    deadline_type_id: number | null
    deadline_type: string | null
  }

  export type Tb_deadline_typesCountAggregateOutputType = {
    deadline_type_id: number
    deadline_type: number
    _all: number
  }


  export type Tb_deadline_typesAvgAggregateInputType = {
    deadline_type_id?: true
  }

  export type Tb_deadline_typesSumAggregateInputType = {
    deadline_type_id?: true
  }

  export type Tb_deadline_typesMinAggregateInputType = {
    deadline_type_id?: true
    deadline_type?: true
  }

  export type Tb_deadline_typesMaxAggregateInputType = {
    deadline_type_id?: true
    deadline_type?: true
  }

  export type Tb_deadline_typesCountAggregateInputType = {
    deadline_type_id?: true
    deadline_type?: true
    _all?: true
  }

  export type Tb_deadline_typesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tb_deadline_types to aggregate.
     */
    where?: tb_deadline_typesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tb_deadline_types to fetch.
     */
    orderBy?: tb_deadline_typesOrderByWithRelationInput | tb_deadline_typesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: tb_deadline_typesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tb_deadline_types from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tb_deadline_types.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned tb_deadline_types
    **/
    _count?: true | Tb_deadline_typesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Tb_deadline_typesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Tb_deadline_typesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Tb_deadline_typesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Tb_deadline_typesMaxAggregateInputType
  }

  export type GetTb_deadline_typesAggregateType<T extends Tb_deadline_typesAggregateArgs> = {
        [P in keyof T & keyof AggregateTb_deadline_types]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTb_deadline_types[P]>
      : GetScalarType<T[P], AggregateTb_deadline_types[P]>
  }




  export type tb_deadline_typesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: tb_deadline_typesWhereInput
    orderBy?: tb_deadline_typesOrderByWithAggregationInput | tb_deadline_typesOrderByWithAggregationInput[]
    by: Tb_deadline_typesScalarFieldEnum[] | Tb_deadline_typesScalarFieldEnum
    having?: tb_deadline_typesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Tb_deadline_typesCountAggregateInputType | true
    _avg?: Tb_deadline_typesAvgAggregateInputType
    _sum?: Tb_deadline_typesSumAggregateInputType
    _min?: Tb_deadline_typesMinAggregateInputType
    _max?: Tb_deadline_typesMaxAggregateInputType
  }

  export type Tb_deadline_typesGroupByOutputType = {
    deadline_type_id: number
    deadline_type: string
    _count: Tb_deadline_typesCountAggregateOutputType | null
    _avg: Tb_deadline_typesAvgAggregateOutputType | null
    _sum: Tb_deadline_typesSumAggregateOutputType | null
    _min: Tb_deadline_typesMinAggregateOutputType | null
    _max: Tb_deadline_typesMaxAggregateOutputType | null
  }

  type GetTb_deadline_typesGroupByPayload<T extends tb_deadline_typesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Tb_deadline_typesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Tb_deadline_typesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Tb_deadline_typesGroupByOutputType[P]>
            : GetScalarType<T[P], Tb_deadline_typesGroupByOutputType[P]>
        }
      >
    >


  export type tb_deadline_typesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    deadline_type_id?: boolean
    deadline_type?: boolean
  }, ExtArgs["result"]["tb_deadline_types"]>



  export type tb_deadline_typesSelectScalar = {
    deadline_type_id?: boolean
    deadline_type?: boolean
  }

  export type tb_deadline_typesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"deadline_type_id" | "deadline_type", ExtArgs["result"]["tb_deadline_types"]>

  export type $tb_deadline_typesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "tb_deadline_types"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      deadline_type_id: number
      deadline_type: string
    }, ExtArgs["result"]["tb_deadline_types"]>
    composites: {}
  }

  type tb_deadline_typesGetPayload<S extends boolean | null | undefined | tb_deadline_typesDefaultArgs> = $Result.GetResult<Prisma.$tb_deadline_typesPayload, S>

  type tb_deadline_typesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<tb_deadline_typesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Tb_deadline_typesCountAggregateInputType | true
    }

  export interface tb_deadline_typesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['tb_deadline_types'], meta: { name: 'tb_deadline_types' } }
    /**
     * Find zero or one Tb_deadline_types that matches the filter.
     * @param {tb_deadline_typesFindUniqueArgs} args - Arguments to find a Tb_deadline_types
     * @example
     * // Get one Tb_deadline_types
     * const tb_deadline_types = await prisma.tb_deadline_types.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends tb_deadline_typesFindUniqueArgs>(args: SelectSubset<T, tb_deadline_typesFindUniqueArgs<ExtArgs>>): Prisma__tb_deadline_typesClient<$Result.GetResult<Prisma.$tb_deadline_typesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Tb_deadline_types that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {tb_deadline_typesFindUniqueOrThrowArgs} args - Arguments to find a Tb_deadline_types
     * @example
     * // Get one Tb_deadline_types
     * const tb_deadline_types = await prisma.tb_deadline_types.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends tb_deadline_typesFindUniqueOrThrowArgs>(args: SelectSubset<T, tb_deadline_typesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__tb_deadline_typesClient<$Result.GetResult<Prisma.$tb_deadline_typesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tb_deadline_types that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_deadline_typesFindFirstArgs} args - Arguments to find a Tb_deadline_types
     * @example
     * // Get one Tb_deadline_types
     * const tb_deadline_types = await prisma.tb_deadline_types.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends tb_deadline_typesFindFirstArgs>(args?: SelectSubset<T, tb_deadline_typesFindFirstArgs<ExtArgs>>): Prisma__tb_deadline_typesClient<$Result.GetResult<Prisma.$tb_deadline_typesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tb_deadline_types that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_deadline_typesFindFirstOrThrowArgs} args - Arguments to find a Tb_deadline_types
     * @example
     * // Get one Tb_deadline_types
     * const tb_deadline_types = await prisma.tb_deadline_types.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends tb_deadline_typesFindFirstOrThrowArgs>(args?: SelectSubset<T, tb_deadline_typesFindFirstOrThrowArgs<ExtArgs>>): Prisma__tb_deadline_typesClient<$Result.GetResult<Prisma.$tb_deadline_typesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Tb_deadline_types that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_deadline_typesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tb_deadline_types
     * const tb_deadline_types = await prisma.tb_deadline_types.findMany()
     * 
     * // Get first 10 Tb_deadline_types
     * const tb_deadline_types = await prisma.tb_deadline_types.findMany({ take: 10 })
     * 
     * // Only select the `deadline_type_id`
     * const tb_deadline_typesWithDeadline_type_idOnly = await prisma.tb_deadline_types.findMany({ select: { deadline_type_id: true } })
     * 
     */
    findMany<T extends tb_deadline_typesFindManyArgs>(args?: SelectSubset<T, tb_deadline_typesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tb_deadline_typesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Tb_deadline_types.
     * @param {tb_deadline_typesCreateArgs} args - Arguments to create a Tb_deadline_types.
     * @example
     * // Create one Tb_deadline_types
     * const Tb_deadline_types = await prisma.tb_deadline_types.create({
     *   data: {
     *     // ... data to create a Tb_deadline_types
     *   }
     * })
     * 
     */
    create<T extends tb_deadline_typesCreateArgs>(args: SelectSubset<T, tb_deadline_typesCreateArgs<ExtArgs>>): Prisma__tb_deadline_typesClient<$Result.GetResult<Prisma.$tb_deadline_typesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Tb_deadline_types.
     * @param {tb_deadline_typesCreateManyArgs} args - Arguments to create many Tb_deadline_types.
     * @example
     * // Create many Tb_deadline_types
     * const tb_deadline_types = await prisma.tb_deadline_types.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends tb_deadline_typesCreateManyArgs>(args?: SelectSubset<T, tb_deadline_typesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Tb_deadline_types.
     * @param {tb_deadline_typesDeleteArgs} args - Arguments to delete one Tb_deadline_types.
     * @example
     * // Delete one Tb_deadline_types
     * const Tb_deadline_types = await prisma.tb_deadline_types.delete({
     *   where: {
     *     // ... filter to delete one Tb_deadline_types
     *   }
     * })
     * 
     */
    delete<T extends tb_deadline_typesDeleteArgs>(args: SelectSubset<T, tb_deadline_typesDeleteArgs<ExtArgs>>): Prisma__tb_deadline_typesClient<$Result.GetResult<Prisma.$tb_deadline_typesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Tb_deadline_types.
     * @param {tb_deadline_typesUpdateArgs} args - Arguments to update one Tb_deadline_types.
     * @example
     * // Update one Tb_deadline_types
     * const tb_deadline_types = await prisma.tb_deadline_types.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends tb_deadline_typesUpdateArgs>(args: SelectSubset<T, tb_deadline_typesUpdateArgs<ExtArgs>>): Prisma__tb_deadline_typesClient<$Result.GetResult<Prisma.$tb_deadline_typesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Tb_deadline_types.
     * @param {tb_deadline_typesDeleteManyArgs} args - Arguments to filter Tb_deadline_types to delete.
     * @example
     * // Delete a few Tb_deadline_types
     * const { count } = await prisma.tb_deadline_types.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends tb_deadline_typesDeleteManyArgs>(args?: SelectSubset<T, tb_deadline_typesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tb_deadline_types.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_deadline_typesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tb_deadline_types
     * const tb_deadline_types = await prisma.tb_deadline_types.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends tb_deadline_typesUpdateManyArgs>(args: SelectSubset<T, tb_deadline_typesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Tb_deadline_types.
     * @param {tb_deadline_typesUpsertArgs} args - Arguments to update or create a Tb_deadline_types.
     * @example
     * // Update or create a Tb_deadline_types
     * const tb_deadline_types = await prisma.tb_deadline_types.upsert({
     *   create: {
     *     // ... data to create a Tb_deadline_types
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tb_deadline_types we want to update
     *   }
     * })
     */
    upsert<T extends tb_deadline_typesUpsertArgs>(args: SelectSubset<T, tb_deadline_typesUpsertArgs<ExtArgs>>): Prisma__tb_deadline_typesClient<$Result.GetResult<Prisma.$tb_deadline_typesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Tb_deadline_types.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_deadline_typesCountArgs} args - Arguments to filter Tb_deadline_types to count.
     * @example
     * // Count the number of Tb_deadline_types
     * const count = await prisma.tb_deadline_types.count({
     *   where: {
     *     // ... the filter for the Tb_deadline_types we want to count
     *   }
     * })
    **/
    count<T extends tb_deadline_typesCountArgs>(
      args?: Subset<T, tb_deadline_typesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Tb_deadline_typesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tb_deadline_types.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Tb_deadline_typesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Tb_deadline_typesAggregateArgs>(args: Subset<T, Tb_deadline_typesAggregateArgs>): Prisma.PrismaPromise<GetTb_deadline_typesAggregateType<T>>

    /**
     * Group by Tb_deadline_types.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_deadline_typesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends tb_deadline_typesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: tb_deadline_typesGroupByArgs['orderBy'] }
        : { orderBy?: tb_deadline_typesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, tb_deadline_typesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTb_deadline_typesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the tb_deadline_types model
   */
  readonly fields: tb_deadline_typesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for tb_deadline_types.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__tb_deadline_typesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the tb_deadline_types model
   */
  interface tb_deadline_typesFieldRefs {
    readonly deadline_type_id: FieldRef<"tb_deadline_types", 'Int'>
    readonly deadline_type: FieldRef<"tb_deadline_types", 'String'>
  }
    

  // Custom InputTypes
  /**
   * tb_deadline_types findUnique
   */
  export type tb_deadline_typesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_deadline_types
     */
    select?: tb_deadline_typesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_deadline_types
     */
    omit?: tb_deadline_typesOmit<ExtArgs> | null
    /**
     * Filter, which tb_deadline_types to fetch.
     */
    where: tb_deadline_typesWhereUniqueInput
  }

  /**
   * tb_deadline_types findUniqueOrThrow
   */
  export type tb_deadline_typesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_deadline_types
     */
    select?: tb_deadline_typesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_deadline_types
     */
    omit?: tb_deadline_typesOmit<ExtArgs> | null
    /**
     * Filter, which tb_deadline_types to fetch.
     */
    where: tb_deadline_typesWhereUniqueInput
  }

  /**
   * tb_deadline_types findFirst
   */
  export type tb_deadline_typesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_deadline_types
     */
    select?: tb_deadline_typesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_deadline_types
     */
    omit?: tb_deadline_typesOmit<ExtArgs> | null
    /**
     * Filter, which tb_deadline_types to fetch.
     */
    where?: tb_deadline_typesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tb_deadline_types to fetch.
     */
    orderBy?: tb_deadline_typesOrderByWithRelationInput | tb_deadline_typesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tb_deadline_types.
     */
    cursor?: tb_deadline_typesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tb_deadline_types from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tb_deadline_types.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tb_deadline_types.
     */
    distinct?: Tb_deadline_typesScalarFieldEnum | Tb_deadline_typesScalarFieldEnum[]
  }

  /**
   * tb_deadline_types findFirstOrThrow
   */
  export type tb_deadline_typesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_deadline_types
     */
    select?: tb_deadline_typesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_deadline_types
     */
    omit?: tb_deadline_typesOmit<ExtArgs> | null
    /**
     * Filter, which tb_deadline_types to fetch.
     */
    where?: tb_deadline_typesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tb_deadline_types to fetch.
     */
    orderBy?: tb_deadline_typesOrderByWithRelationInput | tb_deadline_typesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tb_deadline_types.
     */
    cursor?: tb_deadline_typesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tb_deadline_types from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tb_deadline_types.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tb_deadline_types.
     */
    distinct?: Tb_deadline_typesScalarFieldEnum | Tb_deadline_typesScalarFieldEnum[]
  }

  /**
   * tb_deadline_types findMany
   */
  export type tb_deadline_typesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_deadline_types
     */
    select?: tb_deadline_typesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_deadline_types
     */
    omit?: tb_deadline_typesOmit<ExtArgs> | null
    /**
     * Filter, which tb_deadline_types to fetch.
     */
    where?: tb_deadline_typesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tb_deadline_types to fetch.
     */
    orderBy?: tb_deadline_typesOrderByWithRelationInput | tb_deadline_typesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing tb_deadline_types.
     */
    cursor?: tb_deadline_typesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tb_deadline_types from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tb_deadline_types.
     */
    skip?: number
    distinct?: Tb_deadline_typesScalarFieldEnum | Tb_deadline_typesScalarFieldEnum[]
  }

  /**
   * tb_deadline_types create
   */
  export type tb_deadline_typesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_deadline_types
     */
    select?: tb_deadline_typesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_deadline_types
     */
    omit?: tb_deadline_typesOmit<ExtArgs> | null
    /**
     * The data needed to create a tb_deadline_types.
     */
    data: XOR<tb_deadline_typesCreateInput, tb_deadline_typesUncheckedCreateInput>
  }

  /**
   * tb_deadline_types createMany
   */
  export type tb_deadline_typesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many tb_deadline_types.
     */
    data: tb_deadline_typesCreateManyInput | tb_deadline_typesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * tb_deadline_types update
   */
  export type tb_deadline_typesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_deadline_types
     */
    select?: tb_deadline_typesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_deadline_types
     */
    omit?: tb_deadline_typesOmit<ExtArgs> | null
    /**
     * The data needed to update a tb_deadline_types.
     */
    data: XOR<tb_deadline_typesUpdateInput, tb_deadline_typesUncheckedUpdateInput>
    /**
     * Choose, which tb_deadline_types to update.
     */
    where: tb_deadline_typesWhereUniqueInput
  }

  /**
   * tb_deadline_types updateMany
   */
  export type tb_deadline_typesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update tb_deadline_types.
     */
    data: XOR<tb_deadline_typesUpdateManyMutationInput, tb_deadline_typesUncheckedUpdateManyInput>
    /**
     * Filter which tb_deadline_types to update
     */
    where?: tb_deadline_typesWhereInput
    /**
     * Limit how many tb_deadline_types to update.
     */
    limit?: number
  }

  /**
   * tb_deadline_types upsert
   */
  export type tb_deadline_typesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_deadline_types
     */
    select?: tb_deadline_typesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_deadline_types
     */
    omit?: tb_deadline_typesOmit<ExtArgs> | null
    /**
     * The filter to search for the tb_deadline_types to update in case it exists.
     */
    where: tb_deadline_typesWhereUniqueInput
    /**
     * In case the tb_deadline_types found by the `where` argument doesn't exist, create a new tb_deadline_types with this data.
     */
    create: XOR<tb_deadline_typesCreateInput, tb_deadline_typesUncheckedCreateInput>
    /**
     * In case the tb_deadline_types was found with the provided `where` argument, update it with this data.
     */
    update: XOR<tb_deadline_typesUpdateInput, tb_deadline_typesUncheckedUpdateInput>
  }

  /**
   * tb_deadline_types delete
   */
  export type tb_deadline_typesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_deadline_types
     */
    select?: tb_deadline_typesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_deadline_types
     */
    omit?: tb_deadline_typesOmit<ExtArgs> | null
    /**
     * Filter which tb_deadline_types to delete.
     */
    where: tb_deadline_typesWhereUniqueInput
  }

  /**
   * tb_deadline_types deleteMany
   */
  export type tb_deadline_typesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tb_deadline_types to delete
     */
    where?: tb_deadline_typesWhereInput
    /**
     * Limit how many tb_deadline_types to delete.
     */
    limit?: number
  }

  /**
   * tb_deadline_types without action
   */
  export type tb_deadline_typesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_deadline_types
     */
    select?: tb_deadline_typesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_deadline_types
     */
    omit?: tb_deadline_typesOmit<ExtArgs> | null
  }


  /**
   * Model tb_decision_status
   */

  export type AggregateTb_decision_status = {
    _count: Tb_decision_statusCountAggregateOutputType | null
    _avg: Tb_decision_statusAvgAggregateOutputType | null
    _sum: Tb_decision_statusSumAggregateOutputType | null
    _min: Tb_decision_statusMinAggregateOutputType | null
    _max: Tb_decision_statusMaxAggregateOutputType | null
  }

  export type Tb_decision_statusAvgAggregateOutputType = {
    decision_status_id: number | null
  }

  export type Tb_decision_statusSumAggregateOutputType = {
    decision_status_id: number | null
  }

  export type Tb_decision_statusMinAggregateOutputType = {
    decision_status_id: number | null
    decision_status: string | null
    decision_status_eng: string | null
  }

  export type Tb_decision_statusMaxAggregateOutputType = {
    decision_status_id: number | null
    decision_status: string | null
    decision_status_eng: string | null
  }

  export type Tb_decision_statusCountAggregateOutputType = {
    decision_status_id: number
    decision_status: number
    decision_status_eng: number
    _all: number
  }


  export type Tb_decision_statusAvgAggregateInputType = {
    decision_status_id?: true
  }

  export type Tb_decision_statusSumAggregateInputType = {
    decision_status_id?: true
  }

  export type Tb_decision_statusMinAggregateInputType = {
    decision_status_id?: true
    decision_status?: true
    decision_status_eng?: true
  }

  export type Tb_decision_statusMaxAggregateInputType = {
    decision_status_id?: true
    decision_status?: true
    decision_status_eng?: true
  }

  export type Tb_decision_statusCountAggregateInputType = {
    decision_status_id?: true
    decision_status?: true
    decision_status_eng?: true
    _all?: true
  }

  export type Tb_decision_statusAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tb_decision_status to aggregate.
     */
    where?: tb_decision_statusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tb_decision_statuses to fetch.
     */
    orderBy?: tb_decision_statusOrderByWithRelationInput | tb_decision_statusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: tb_decision_statusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tb_decision_statuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tb_decision_statuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned tb_decision_statuses
    **/
    _count?: true | Tb_decision_statusCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Tb_decision_statusAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Tb_decision_statusSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Tb_decision_statusMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Tb_decision_statusMaxAggregateInputType
  }

  export type GetTb_decision_statusAggregateType<T extends Tb_decision_statusAggregateArgs> = {
        [P in keyof T & keyof AggregateTb_decision_status]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTb_decision_status[P]>
      : GetScalarType<T[P], AggregateTb_decision_status[P]>
  }




  export type tb_decision_statusGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: tb_decision_statusWhereInput
    orderBy?: tb_decision_statusOrderByWithAggregationInput | tb_decision_statusOrderByWithAggregationInput[]
    by: Tb_decision_statusScalarFieldEnum[] | Tb_decision_statusScalarFieldEnum
    having?: tb_decision_statusScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Tb_decision_statusCountAggregateInputType | true
    _avg?: Tb_decision_statusAvgAggregateInputType
    _sum?: Tb_decision_statusSumAggregateInputType
    _min?: Tb_decision_statusMinAggregateInputType
    _max?: Tb_decision_statusMaxAggregateInputType
  }

  export type Tb_decision_statusGroupByOutputType = {
    decision_status_id: number
    decision_status: string
    decision_status_eng: string | null
    _count: Tb_decision_statusCountAggregateOutputType | null
    _avg: Tb_decision_statusAvgAggregateOutputType | null
    _sum: Tb_decision_statusSumAggregateOutputType | null
    _min: Tb_decision_statusMinAggregateOutputType | null
    _max: Tb_decision_statusMaxAggregateOutputType | null
  }

  type GetTb_decision_statusGroupByPayload<T extends tb_decision_statusGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Tb_decision_statusGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Tb_decision_statusGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Tb_decision_statusGroupByOutputType[P]>
            : GetScalarType<T[P], Tb_decision_statusGroupByOutputType[P]>
        }
      >
    >


  export type tb_decision_statusSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    decision_status_id?: boolean
    decision_status?: boolean
    decision_status_eng?: boolean
  }, ExtArgs["result"]["tb_decision_status"]>



  export type tb_decision_statusSelectScalar = {
    decision_status_id?: boolean
    decision_status?: boolean
    decision_status_eng?: boolean
  }

  export type tb_decision_statusOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"decision_status_id" | "decision_status" | "decision_status_eng", ExtArgs["result"]["tb_decision_status"]>

  export type $tb_decision_statusPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "tb_decision_status"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      decision_status_id: number
      decision_status: string
      decision_status_eng: string | null
    }, ExtArgs["result"]["tb_decision_status"]>
    composites: {}
  }

  type tb_decision_statusGetPayload<S extends boolean | null | undefined | tb_decision_statusDefaultArgs> = $Result.GetResult<Prisma.$tb_decision_statusPayload, S>

  type tb_decision_statusCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<tb_decision_statusFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Tb_decision_statusCountAggregateInputType | true
    }

  export interface tb_decision_statusDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['tb_decision_status'], meta: { name: 'tb_decision_status' } }
    /**
     * Find zero or one Tb_decision_status that matches the filter.
     * @param {tb_decision_statusFindUniqueArgs} args - Arguments to find a Tb_decision_status
     * @example
     * // Get one Tb_decision_status
     * const tb_decision_status = await prisma.tb_decision_status.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends tb_decision_statusFindUniqueArgs>(args: SelectSubset<T, tb_decision_statusFindUniqueArgs<ExtArgs>>): Prisma__tb_decision_statusClient<$Result.GetResult<Prisma.$tb_decision_statusPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Tb_decision_status that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {tb_decision_statusFindUniqueOrThrowArgs} args - Arguments to find a Tb_decision_status
     * @example
     * // Get one Tb_decision_status
     * const tb_decision_status = await prisma.tb_decision_status.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends tb_decision_statusFindUniqueOrThrowArgs>(args: SelectSubset<T, tb_decision_statusFindUniqueOrThrowArgs<ExtArgs>>): Prisma__tb_decision_statusClient<$Result.GetResult<Prisma.$tb_decision_statusPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tb_decision_status that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_decision_statusFindFirstArgs} args - Arguments to find a Tb_decision_status
     * @example
     * // Get one Tb_decision_status
     * const tb_decision_status = await prisma.tb_decision_status.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends tb_decision_statusFindFirstArgs>(args?: SelectSubset<T, tb_decision_statusFindFirstArgs<ExtArgs>>): Prisma__tb_decision_statusClient<$Result.GetResult<Prisma.$tb_decision_statusPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tb_decision_status that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_decision_statusFindFirstOrThrowArgs} args - Arguments to find a Tb_decision_status
     * @example
     * // Get one Tb_decision_status
     * const tb_decision_status = await prisma.tb_decision_status.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends tb_decision_statusFindFirstOrThrowArgs>(args?: SelectSubset<T, tb_decision_statusFindFirstOrThrowArgs<ExtArgs>>): Prisma__tb_decision_statusClient<$Result.GetResult<Prisma.$tb_decision_statusPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Tb_decision_statuses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_decision_statusFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tb_decision_statuses
     * const tb_decision_statuses = await prisma.tb_decision_status.findMany()
     * 
     * // Get first 10 Tb_decision_statuses
     * const tb_decision_statuses = await prisma.tb_decision_status.findMany({ take: 10 })
     * 
     * // Only select the `decision_status_id`
     * const tb_decision_statusWithDecision_status_idOnly = await prisma.tb_decision_status.findMany({ select: { decision_status_id: true } })
     * 
     */
    findMany<T extends tb_decision_statusFindManyArgs>(args?: SelectSubset<T, tb_decision_statusFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tb_decision_statusPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Tb_decision_status.
     * @param {tb_decision_statusCreateArgs} args - Arguments to create a Tb_decision_status.
     * @example
     * // Create one Tb_decision_status
     * const Tb_decision_status = await prisma.tb_decision_status.create({
     *   data: {
     *     // ... data to create a Tb_decision_status
     *   }
     * })
     * 
     */
    create<T extends tb_decision_statusCreateArgs>(args: SelectSubset<T, tb_decision_statusCreateArgs<ExtArgs>>): Prisma__tb_decision_statusClient<$Result.GetResult<Prisma.$tb_decision_statusPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Tb_decision_statuses.
     * @param {tb_decision_statusCreateManyArgs} args - Arguments to create many Tb_decision_statuses.
     * @example
     * // Create many Tb_decision_statuses
     * const tb_decision_status = await prisma.tb_decision_status.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends tb_decision_statusCreateManyArgs>(args?: SelectSubset<T, tb_decision_statusCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Tb_decision_status.
     * @param {tb_decision_statusDeleteArgs} args - Arguments to delete one Tb_decision_status.
     * @example
     * // Delete one Tb_decision_status
     * const Tb_decision_status = await prisma.tb_decision_status.delete({
     *   where: {
     *     // ... filter to delete one Tb_decision_status
     *   }
     * })
     * 
     */
    delete<T extends tb_decision_statusDeleteArgs>(args: SelectSubset<T, tb_decision_statusDeleteArgs<ExtArgs>>): Prisma__tb_decision_statusClient<$Result.GetResult<Prisma.$tb_decision_statusPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Tb_decision_status.
     * @param {tb_decision_statusUpdateArgs} args - Arguments to update one Tb_decision_status.
     * @example
     * // Update one Tb_decision_status
     * const tb_decision_status = await prisma.tb_decision_status.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends tb_decision_statusUpdateArgs>(args: SelectSubset<T, tb_decision_statusUpdateArgs<ExtArgs>>): Prisma__tb_decision_statusClient<$Result.GetResult<Prisma.$tb_decision_statusPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Tb_decision_statuses.
     * @param {tb_decision_statusDeleteManyArgs} args - Arguments to filter Tb_decision_statuses to delete.
     * @example
     * // Delete a few Tb_decision_statuses
     * const { count } = await prisma.tb_decision_status.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends tb_decision_statusDeleteManyArgs>(args?: SelectSubset<T, tb_decision_statusDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tb_decision_statuses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_decision_statusUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tb_decision_statuses
     * const tb_decision_status = await prisma.tb_decision_status.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends tb_decision_statusUpdateManyArgs>(args: SelectSubset<T, tb_decision_statusUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Tb_decision_status.
     * @param {tb_decision_statusUpsertArgs} args - Arguments to update or create a Tb_decision_status.
     * @example
     * // Update or create a Tb_decision_status
     * const tb_decision_status = await prisma.tb_decision_status.upsert({
     *   create: {
     *     // ... data to create a Tb_decision_status
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tb_decision_status we want to update
     *   }
     * })
     */
    upsert<T extends tb_decision_statusUpsertArgs>(args: SelectSubset<T, tb_decision_statusUpsertArgs<ExtArgs>>): Prisma__tb_decision_statusClient<$Result.GetResult<Prisma.$tb_decision_statusPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Tb_decision_statuses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_decision_statusCountArgs} args - Arguments to filter Tb_decision_statuses to count.
     * @example
     * // Count the number of Tb_decision_statuses
     * const count = await prisma.tb_decision_status.count({
     *   where: {
     *     // ... the filter for the Tb_decision_statuses we want to count
     *   }
     * })
    **/
    count<T extends tb_decision_statusCountArgs>(
      args?: Subset<T, tb_decision_statusCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Tb_decision_statusCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tb_decision_status.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Tb_decision_statusAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Tb_decision_statusAggregateArgs>(args: Subset<T, Tb_decision_statusAggregateArgs>): Prisma.PrismaPromise<GetTb_decision_statusAggregateType<T>>

    /**
     * Group by Tb_decision_status.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_decision_statusGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends tb_decision_statusGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: tb_decision_statusGroupByArgs['orderBy'] }
        : { orderBy?: tb_decision_statusGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, tb_decision_statusGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTb_decision_statusGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the tb_decision_status model
   */
  readonly fields: tb_decision_statusFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for tb_decision_status.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__tb_decision_statusClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the tb_decision_status model
   */
  interface tb_decision_statusFieldRefs {
    readonly decision_status_id: FieldRef<"tb_decision_status", 'Int'>
    readonly decision_status: FieldRef<"tb_decision_status", 'String'>
    readonly decision_status_eng: FieldRef<"tb_decision_status", 'String'>
  }
    

  // Custom InputTypes
  /**
   * tb_decision_status findUnique
   */
  export type tb_decision_statusFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_decision_status
     */
    select?: tb_decision_statusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_decision_status
     */
    omit?: tb_decision_statusOmit<ExtArgs> | null
    /**
     * Filter, which tb_decision_status to fetch.
     */
    where: tb_decision_statusWhereUniqueInput
  }

  /**
   * tb_decision_status findUniqueOrThrow
   */
  export type tb_decision_statusFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_decision_status
     */
    select?: tb_decision_statusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_decision_status
     */
    omit?: tb_decision_statusOmit<ExtArgs> | null
    /**
     * Filter, which tb_decision_status to fetch.
     */
    where: tb_decision_statusWhereUniqueInput
  }

  /**
   * tb_decision_status findFirst
   */
  export type tb_decision_statusFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_decision_status
     */
    select?: tb_decision_statusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_decision_status
     */
    omit?: tb_decision_statusOmit<ExtArgs> | null
    /**
     * Filter, which tb_decision_status to fetch.
     */
    where?: tb_decision_statusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tb_decision_statuses to fetch.
     */
    orderBy?: tb_decision_statusOrderByWithRelationInput | tb_decision_statusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tb_decision_statuses.
     */
    cursor?: tb_decision_statusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tb_decision_statuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tb_decision_statuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tb_decision_statuses.
     */
    distinct?: Tb_decision_statusScalarFieldEnum | Tb_decision_statusScalarFieldEnum[]
  }

  /**
   * tb_decision_status findFirstOrThrow
   */
  export type tb_decision_statusFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_decision_status
     */
    select?: tb_decision_statusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_decision_status
     */
    omit?: tb_decision_statusOmit<ExtArgs> | null
    /**
     * Filter, which tb_decision_status to fetch.
     */
    where?: tb_decision_statusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tb_decision_statuses to fetch.
     */
    orderBy?: tb_decision_statusOrderByWithRelationInput | tb_decision_statusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tb_decision_statuses.
     */
    cursor?: tb_decision_statusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tb_decision_statuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tb_decision_statuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tb_decision_statuses.
     */
    distinct?: Tb_decision_statusScalarFieldEnum | Tb_decision_statusScalarFieldEnum[]
  }

  /**
   * tb_decision_status findMany
   */
  export type tb_decision_statusFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_decision_status
     */
    select?: tb_decision_statusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_decision_status
     */
    omit?: tb_decision_statusOmit<ExtArgs> | null
    /**
     * Filter, which tb_decision_statuses to fetch.
     */
    where?: tb_decision_statusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tb_decision_statuses to fetch.
     */
    orderBy?: tb_decision_statusOrderByWithRelationInput | tb_decision_statusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing tb_decision_statuses.
     */
    cursor?: tb_decision_statusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tb_decision_statuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tb_decision_statuses.
     */
    skip?: number
    distinct?: Tb_decision_statusScalarFieldEnum | Tb_decision_statusScalarFieldEnum[]
  }

  /**
   * tb_decision_status create
   */
  export type tb_decision_statusCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_decision_status
     */
    select?: tb_decision_statusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_decision_status
     */
    omit?: tb_decision_statusOmit<ExtArgs> | null
    /**
     * The data needed to create a tb_decision_status.
     */
    data: XOR<tb_decision_statusCreateInput, tb_decision_statusUncheckedCreateInput>
  }

  /**
   * tb_decision_status createMany
   */
  export type tb_decision_statusCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many tb_decision_statuses.
     */
    data: tb_decision_statusCreateManyInput | tb_decision_statusCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * tb_decision_status update
   */
  export type tb_decision_statusUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_decision_status
     */
    select?: tb_decision_statusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_decision_status
     */
    omit?: tb_decision_statusOmit<ExtArgs> | null
    /**
     * The data needed to update a tb_decision_status.
     */
    data: XOR<tb_decision_statusUpdateInput, tb_decision_statusUncheckedUpdateInput>
    /**
     * Choose, which tb_decision_status to update.
     */
    where: tb_decision_statusWhereUniqueInput
  }

  /**
   * tb_decision_status updateMany
   */
  export type tb_decision_statusUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update tb_decision_statuses.
     */
    data: XOR<tb_decision_statusUpdateManyMutationInput, tb_decision_statusUncheckedUpdateManyInput>
    /**
     * Filter which tb_decision_statuses to update
     */
    where?: tb_decision_statusWhereInput
    /**
     * Limit how many tb_decision_statuses to update.
     */
    limit?: number
  }

  /**
   * tb_decision_status upsert
   */
  export type tb_decision_statusUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_decision_status
     */
    select?: tb_decision_statusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_decision_status
     */
    omit?: tb_decision_statusOmit<ExtArgs> | null
    /**
     * The filter to search for the tb_decision_status to update in case it exists.
     */
    where: tb_decision_statusWhereUniqueInput
    /**
     * In case the tb_decision_status found by the `where` argument doesn't exist, create a new tb_decision_status with this data.
     */
    create: XOR<tb_decision_statusCreateInput, tb_decision_statusUncheckedCreateInput>
    /**
     * In case the tb_decision_status was found with the provided `where` argument, update it with this data.
     */
    update: XOR<tb_decision_statusUpdateInput, tb_decision_statusUncheckedUpdateInput>
  }

  /**
   * tb_decision_status delete
   */
  export type tb_decision_statusDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_decision_status
     */
    select?: tb_decision_statusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_decision_status
     */
    omit?: tb_decision_statusOmit<ExtArgs> | null
    /**
     * Filter which tb_decision_status to delete.
     */
    where: tb_decision_statusWhereUniqueInput
  }

  /**
   * tb_decision_status deleteMany
   */
  export type tb_decision_statusDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tb_decision_statuses to delete
     */
    where?: tb_decision_statusWhereInput
    /**
     * Limit how many tb_decision_statuses to delete.
     */
    limit?: number
  }

  /**
   * tb_decision_status without action
   */
  export type tb_decision_statusDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_decision_status
     */
    select?: tb_decision_statusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_decision_status
     */
    omit?: tb_decision_statusOmit<ExtArgs> | null
  }


  /**
   * Model tb_decision_types
   */

  export type AggregateTb_decision_types = {
    _count: Tb_decision_typesCountAggregateOutputType | null
    _avg: Tb_decision_typesAvgAggregateOutputType | null
    _sum: Tb_decision_typesSumAggregateOutputType | null
    _min: Tb_decision_typesMinAggregateOutputType | null
    _max: Tb_decision_typesMaxAggregateOutputType | null
  }

  export type Tb_decision_typesAvgAggregateOutputType = {
    decision_type_id: number | null
  }

  export type Tb_decision_typesSumAggregateOutputType = {
    decision_type_id: number | null
  }

  export type Tb_decision_typesMinAggregateOutputType = {
    decision_type_id: number | null
    decision_type: string | null
    decision_type_eng: string | null
  }

  export type Tb_decision_typesMaxAggregateOutputType = {
    decision_type_id: number | null
    decision_type: string | null
    decision_type_eng: string | null
  }

  export type Tb_decision_typesCountAggregateOutputType = {
    decision_type_id: number
    decision_type: number
    decision_type_eng: number
    _all: number
  }


  export type Tb_decision_typesAvgAggregateInputType = {
    decision_type_id?: true
  }

  export type Tb_decision_typesSumAggregateInputType = {
    decision_type_id?: true
  }

  export type Tb_decision_typesMinAggregateInputType = {
    decision_type_id?: true
    decision_type?: true
    decision_type_eng?: true
  }

  export type Tb_decision_typesMaxAggregateInputType = {
    decision_type_id?: true
    decision_type?: true
    decision_type_eng?: true
  }

  export type Tb_decision_typesCountAggregateInputType = {
    decision_type_id?: true
    decision_type?: true
    decision_type_eng?: true
    _all?: true
  }

  export type Tb_decision_typesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tb_decision_types to aggregate.
     */
    where?: tb_decision_typesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tb_decision_types to fetch.
     */
    orderBy?: tb_decision_typesOrderByWithRelationInput | tb_decision_typesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: tb_decision_typesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tb_decision_types from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tb_decision_types.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned tb_decision_types
    **/
    _count?: true | Tb_decision_typesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Tb_decision_typesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Tb_decision_typesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Tb_decision_typesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Tb_decision_typesMaxAggregateInputType
  }

  export type GetTb_decision_typesAggregateType<T extends Tb_decision_typesAggregateArgs> = {
        [P in keyof T & keyof AggregateTb_decision_types]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTb_decision_types[P]>
      : GetScalarType<T[P], AggregateTb_decision_types[P]>
  }




  export type tb_decision_typesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: tb_decision_typesWhereInput
    orderBy?: tb_decision_typesOrderByWithAggregationInput | tb_decision_typesOrderByWithAggregationInput[]
    by: Tb_decision_typesScalarFieldEnum[] | Tb_decision_typesScalarFieldEnum
    having?: tb_decision_typesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Tb_decision_typesCountAggregateInputType | true
    _avg?: Tb_decision_typesAvgAggregateInputType
    _sum?: Tb_decision_typesSumAggregateInputType
    _min?: Tb_decision_typesMinAggregateInputType
    _max?: Tb_decision_typesMaxAggregateInputType
  }

  export type Tb_decision_typesGroupByOutputType = {
    decision_type_id: number
    decision_type: string
    decision_type_eng: string
    _count: Tb_decision_typesCountAggregateOutputType | null
    _avg: Tb_decision_typesAvgAggregateOutputType | null
    _sum: Tb_decision_typesSumAggregateOutputType | null
    _min: Tb_decision_typesMinAggregateOutputType | null
    _max: Tb_decision_typesMaxAggregateOutputType | null
  }

  type GetTb_decision_typesGroupByPayload<T extends tb_decision_typesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Tb_decision_typesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Tb_decision_typesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Tb_decision_typesGroupByOutputType[P]>
            : GetScalarType<T[P], Tb_decision_typesGroupByOutputType[P]>
        }
      >
    >


  export type tb_decision_typesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    decision_type_id?: boolean
    decision_type?: boolean
    decision_type_eng?: boolean
  }, ExtArgs["result"]["tb_decision_types"]>



  export type tb_decision_typesSelectScalar = {
    decision_type_id?: boolean
    decision_type?: boolean
    decision_type_eng?: boolean
  }

  export type tb_decision_typesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"decision_type_id" | "decision_type" | "decision_type_eng", ExtArgs["result"]["tb_decision_types"]>

  export type $tb_decision_typesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "tb_decision_types"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      decision_type_id: number
      decision_type: string
      decision_type_eng: string
    }, ExtArgs["result"]["tb_decision_types"]>
    composites: {}
  }

  type tb_decision_typesGetPayload<S extends boolean | null | undefined | tb_decision_typesDefaultArgs> = $Result.GetResult<Prisma.$tb_decision_typesPayload, S>

  type tb_decision_typesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<tb_decision_typesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Tb_decision_typesCountAggregateInputType | true
    }

  export interface tb_decision_typesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['tb_decision_types'], meta: { name: 'tb_decision_types' } }
    /**
     * Find zero or one Tb_decision_types that matches the filter.
     * @param {tb_decision_typesFindUniqueArgs} args - Arguments to find a Tb_decision_types
     * @example
     * // Get one Tb_decision_types
     * const tb_decision_types = await prisma.tb_decision_types.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends tb_decision_typesFindUniqueArgs>(args: SelectSubset<T, tb_decision_typesFindUniqueArgs<ExtArgs>>): Prisma__tb_decision_typesClient<$Result.GetResult<Prisma.$tb_decision_typesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Tb_decision_types that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {tb_decision_typesFindUniqueOrThrowArgs} args - Arguments to find a Tb_decision_types
     * @example
     * // Get one Tb_decision_types
     * const tb_decision_types = await prisma.tb_decision_types.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends tb_decision_typesFindUniqueOrThrowArgs>(args: SelectSubset<T, tb_decision_typesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__tb_decision_typesClient<$Result.GetResult<Prisma.$tb_decision_typesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tb_decision_types that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_decision_typesFindFirstArgs} args - Arguments to find a Tb_decision_types
     * @example
     * // Get one Tb_decision_types
     * const tb_decision_types = await prisma.tb_decision_types.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends tb_decision_typesFindFirstArgs>(args?: SelectSubset<T, tb_decision_typesFindFirstArgs<ExtArgs>>): Prisma__tb_decision_typesClient<$Result.GetResult<Prisma.$tb_decision_typesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tb_decision_types that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_decision_typesFindFirstOrThrowArgs} args - Arguments to find a Tb_decision_types
     * @example
     * // Get one Tb_decision_types
     * const tb_decision_types = await prisma.tb_decision_types.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends tb_decision_typesFindFirstOrThrowArgs>(args?: SelectSubset<T, tb_decision_typesFindFirstOrThrowArgs<ExtArgs>>): Prisma__tb_decision_typesClient<$Result.GetResult<Prisma.$tb_decision_typesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Tb_decision_types that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_decision_typesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tb_decision_types
     * const tb_decision_types = await prisma.tb_decision_types.findMany()
     * 
     * // Get first 10 Tb_decision_types
     * const tb_decision_types = await prisma.tb_decision_types.findMany({ take: 10 })
     * 
     * // Only select the `decision_type_id`
     * const tb_decision_typesWithDecision_type_idOnly = await prisma.tb_decision_types.findMany({ select: { decision_type_id: true } })
     * 
     */
    findMany<T extends tb_decision_typesFindManyArgs>(args?: SelectSubset<T, tb_decision_typesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tb_decision_typesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Tb_decision_types.
     * @param {tb_decision_typesCreateArgs} args - Arguments to create a Tb_decision_types.
     * @example
     * // Create one Tb_decision_types
     * const Tb_decision_types = await prisma.tb_decision_types.create({
     *   data: {
     *     // ... data to create a Tb_decision_types
     *   }
     * })
     * 
     */
    create<T extends tb_decision_typesCreateArgs>(args: SelectSubset<T, tb_decision_typesCreateArgs<ExtArgs>>): Prisma__tb_decision_typesClient<$Result.GetResult<Prisma.$tb_decision_typesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Tb_decision_types.
     * @param {tb_decision_typesCreateManyArgs} args - Arguments to create many Tb_decision_types.
     * @example
     * // Create many Tb_decision_types
     * const tb_decision_types = await prisma.tb_decision_types.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends tb_decision_typesCreateManyArgs>(args?: SelectSubset<T, tb_decision_typesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Tb_decision_types.
     * @param {tb_decision_typesDeleteArgs} args - Arguments to delete one Tb_decision_types.
     * @example
     * // Delete one Tb_decision_types
     * const Tb_decision_types = await prisma.tb_decision_types.delete({
     *   where: {
     *     // ... filter to delete one Tb_decision_types
     *   }
     * })
     * 
     */
    delete<T extends tb_decision_typesDeleteArgs>(args: SelectSubset<T, tb_decision_typesDeleteArgs<ExtArgs>>): Prisma__tb_decision_typesClient<$Result.GetResult<Prisma.$tb_decision_typesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Tb_decision_types.
     * @param {tb_decision_typesUpdateArgs} args - Arguments to update one Tb_decision_types.
     * @example
     * // Update one Tb_decision_types
     * const tb_decision_types = await prisma.tb_decision_types.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends tb_decision_typesUpdateArgs>(args: SelectSubset<T, tb_decision_typesUpdateArgs<ExtArgs>>): Prisma__tb_decision_typesClient<$Result.GetResult<Prisma.$tb_decision_typesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Tb_decision_types.
     * @param {tb_decision_typesDeleteManyArgs} args - Arguments to filter Tb_decision_types to delete.
     * @example
     * // Delete a few Tb_decision_types
     * const { count } = await prisma.tb_decision_types.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends tb_decision_typesDeleteManyArgs>(args?: SelectSubset<T, tb_decision_typesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tb_decision_types.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_decision_typesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tb_decision_types
     * const tb_decision_types = await prisma.tb_decision_types.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends tb_decision_typesUpdateManyArgs>(args: SelectSubset<T, tb_decision_typesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Tb_decision_types.
     * @param {tb_decision_typesUpsertArgs} args - Arguments to update or create a Tb_decision_types.
     * @example
     * // Update or create a Tb_decision_types
     * const tb_decision_types = await prisma.tb_decision_types.upsert({
     *   create: {
     *     // ... data to create a Tb_decision_types
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tb_decision_types we want to update
     *   }
     * })
     */
    upsert<T extends tb_decision_typesUpsertArgs>(args: SelectSubset<T, tb_decision_typesUpsertArgs<ExtArgs>>): Prisma__tb_decision_typesClient<$Result.GetResult<Prisma.$tb_decision_typesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Tb_decision_types.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_decision_typesCountArgs} args - Arguments to filter Tb_decision_types to count.
     * @example
     * // Count the number of Tb_decision_types
     * const count = await prisma.tb_decision_types.count({
     *   where: {
     *     // ... the filter for the Tb_decision_types we want to count
     *   }
     * })
    **/
    count<T extends tb_decision_typesCountArgs>(
      args?: Subset<T, tb_decision_typesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Tb_decision_typesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tb_decision_types.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Tb_decision_typesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Tb_decision_typesAggregateArgs>(args: Subset<T, Tb_decision_typesAggregateArgs>): Prisma.PrismaPromise<GetTb_decision_typesAggregateType<T>>

    /**
     * Group by Tb_decision_types.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_decision_typesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends tb_decision_typesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: tb_decision_typesGroupByArgs['orderBy'] }
        : { orderBy?: tb_decision_typesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, tb_decision_typesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTb_decision_typesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the tb_decision_types model
   */
  readonly fields: tb_decision_typesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for tb_decision_types.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__tb_decision_typesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the tb_decision_types model
   */
  interface tb_decision_typesFieldRefs {
    readonly decision_type_id: FieldRef<"tb_decision_types", 'Int'>
    readonly decision_type: FieldRef<"tb_decision_types", 'String'>
    readonly decision_type_eng: FieldRef<"tb_decision_types", 'String'>
  }
    

  // Custom InputTypes
  /**
   * tb_decision_types findUnique
   */
  export type tb_decision_typesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_decision_types
     */
    select?: tb_decision_typesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_decision_types
     */
    omit?: tb_decision_typesOmit<ExtArgs> | null
    /**
     * Filter, which tb_decision_types to fetch.
     */
    where: tb_decision_typesWhereUniqueInput
  }

  /**
   * tb_decision_types findUniqueOrThrow
   */
  export type tb_decision_typesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_decision_types
     */
    select?: tb_decision_typesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_decision_types
     */
    omit?: tb_decision_typesOmit<ExtArgs> | null
    /**
     * Filter, which tb_decision_types to fetch.
     */
    where: tb_decision_typesWhereUniqueInput
  }

  /**
   * tb_decision_types findFirst
   */
  export type tb_decision_typesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_decision_types
     */
    select?: tb_decision_typesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_decision_types
     */
    omit?: tb_decision_typesOmit<ExtArgs> | null
    /**
     * Filter, which tb_decision_types to fetch.
     */
    where?: tb_decision_typesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tb_decision_types to fetch.
     */
    orderBy?: tb_decision_typesOrderByWithRelationInput | tb_decision_typesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tb_decision_types.
     */
    cursor?: tb_decision_typesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tb_decision_types from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tb_decision_types.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tb_decision_types.
     */
    distinct?: Tb_decision_typesScalarFieldEnum | Tb_decision_typesScalarFieldEnum[]
  }

  /**
   * tb_decision_types findFirstOrThrow
   */
  export type tb_decision_typesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_decision_types
     */
    select?: tb_decision_typesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_decision_types
     */
    omit?: tb_decision_typesOmit<ExtArgs> | null
    /**
     * Filter, which tb_decision_types to fetch.
     */
    where?: tb_decision_typesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tb_decision_types to fetch.
     */
    orderBy?: tb_decision_typesOrderByWithRelationInput | tb_decision_typesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tb_decision_types.
     */
    cursor?: tb_decision_typesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tb_decision_types from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tb_decision_types.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tb_decision_types.
     */
    distinct?: Tb_decision_typesScalarFieldEnum | Tb_decision_typesScalarFieldEnum[]
  }

  /**
   * tb_decision_types findMany
   */
  export type tb_decision_typesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_decision_types
     */
    select?: tb_decision_typesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_decision_types
     */
    omit?: tb_decision_typesOmit<ExtArgs> | null
    /**
     * Filter, which tb_decision_types to fetch.
     */
    where?: tb_decision_typesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tb_decision_types to fetch.
     */
    orderBy?: tb_decision_typesOrderByWithRelationInput | tb_decision_typesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing tb_decision_types.
     */
    cursor?: tb_decision_typesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tb_decision_types from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tb_decision_types.
     */
    skip?: number
    distinct?: Tb_decision_typesScalarFieldEnum | Tb_decision_typesScalarFieldEnum[]
  }

  /**
   * tb_decision_types create
   */
  export type tb_decision_typesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_decision_types
     */
    select?: tb_decision_typesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_decision_types
     */
    omit?: tb_decision_typesOmit<ExtArgs> | null
    /**
     * The data needed to create a tb_decision_types.
     */
    data: XOR<tb_decision_typesCreateInput, tb_decision_typesUncheckedCreateInput>
  }

  /**
   * tb_decision_types createMany
   */
  export type tb_decision_typesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many tb_decision_types.
     */
    data: tb_decision_typesCreateManyInput | tb_decision_typesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * tb_decision_types update
   */
  export type tb_decision_typesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_decision_types
     */
    select?: tb_decision_typesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_decision_types
     */
    omit?: tb_decision_typesOmit<ExtArgs> | null
    /**
     * The data needed to update a tb_decision_types.
     */
    data: XOR<tb_decision_typesUpdateInput, tb_decision_typesUncheckedUpdateInput>
    /**
     * Choose, which tb_decision_types to update.
     */
    where: tb_decision_typesWhereUniqueInput
  }

  /**
   * tb_decision_types updateMany
   */
  export type tb_decision_typesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update tb_decision_types.
     */
    data: XOR<tb_decision_typesUpdateManyMutationInput, tb_decision_typesUncheckedUpdateManyInput>
    /**
     * Filter which tb_decision_types to update
     */
    where?: tb_decision_typesWhereInput
    /**
     * Limit how many tb_decision_types to update.
     */
    limit?: number
  }

  /**
   * tb_decision_types upsert
   */
  export type tb_decision_typesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_decision_types
     */
    select?: tb_decision_typesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_decision_types
     */
    omit?: tb_decision_typesOmit<ExtArgs> | null
    /**
     * The filter to search for the tb_decision_types to update in case it exists.
     */
    where: tb_decision_typesWhereUniqueInput
    /**
     * In case the tb_decision_types found by the `where` argument doesn't exist, create a new tb_decision_types with this data.
     */
    create: XOR<tb_decision_typesCreateInput, tb_decision_typesUncheckedCreateInput>
    /**
     * In case the tb_decision_types was found with the provided `where` argument, update it with this data.
     */
    update: XOR<tb_decision_typesUpdateInput, tb_decision_typesUncheckedUpdateInput>
  }

  /**
   * tb_decision_types delete
   */
  export type tb_decision_typesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_decision_types
     */
    select?: tb_decision_typesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_decision_types
     */
    omit?: tb_decision_typesOmit<ExtArgs> | null
    /**
     * Filter which tb_decision_types to delete.
     */
    where: tb_decision_typesWhereUniqueInput
  }

  /**
   * tb_decision_types deleteMany
   */
  export type tb_decision_typesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tb_decision_types to delete
     */
    where?: tb_decision_typesWhereInput
    /**
     * Limit how many tb_decision_types to delete.
     */
    limit?: number
  }

  /**
   * tb_decision_types without action
   */
  export type tb_decision_typesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_decision_types
     */
    select?: tb_decision_typesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_decision_types
     */
    omit?: tb_decision_typesOmit<ExtArgs> | null
  }


  /**
   * Model tb_decisions
   */

  export type AggregateTb_decisions = {
    _count: Tb_decisionsCountAggregateOutputType | null
    _avg: Tb_decisionsAvgAggregateOutputType | null
    _sum: Tb_decisionsSumAggregateOutputType | null
    _min: Tb_decisionsMinAggregateOutputType | null
    _max: Tb_decisionsMaxAggregateOutputType | null
  }

  export type Tb_decisionsAvgAggregateOutputType = {
    decision_id: number | null
    case_id: number | null
    decision_type: number | null
    decision_status: number | null
    actual: number | null
  }

  export type Tb_decisionsSumAggregateOutputType = {
    decision_id: number | null
    case_id: number | null
    decision_type: number | null
    decision_status: number | null
    actual: number | null
  }

  export type Tb_decisionsMinAggregateOutputType = {
    decision_id: number | null
    case_id: number | null
    decision_type: number | null
    decison_date: Date | null
    decision_status: number | null
    actual: number | null
    decision_out_num: string | null
  }

  export type Tb_decisionsMaxAggregateOutputType = {
    decision_id: number | null
    case_id: number | null
    decision_type: number | null
    decison_date: Date | null
    decision_status: number | null
    actual: number | null
    decision_out_num: string | null
  }

  export type Tb_decisionsCountAggregateOutputType = {
    decision_id: number
    case_id: number
    decision_type: number
    decison_date: number
    decision_status: number
    actual: number
    decision_out_num: number
    _all: number
  }


  export type Tb_decisionsAvgAggregateInputType = {
    decision_id?: true
    case_id?: true
    decision_type?: true
    decision_status?: true
    actual?: true
  }

  export type Tb_decisionsSumAggregateInputType = {
    decision_id?: true
    case_id?: true
    decision_type?: true
    decision_status?: true
    actual?: true
  }

  export type Tb_decisionsMinAggregateInputType = {
    decision_id?: true
    case_id?: true
    decision_type?: true
    decison_date?: true
    decision_status?: true
    actual?: true
    decision_out_num?: true
  }

  export type Tb_decisionsMaxAggregateInputType = {
    decision_id?: true
    case_id?: true
    decision_type?: true
    decison_date?: true
    decision_status?: true
    actual?: true
    decision_out_num?: true
  }

  export type Tb_decisionsCountAggregateInputType = {
    decision_id?: true
    case_id?: true
    decision_type?: true
    decison_date?: true
    decision_status?: true
    actual?: true
    decision_out_num?: true
    _all?: true
  }

  export type Tb_decisionsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tb_decisions to aggregate.
     */
    where?: tb_decisionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tb_decisions to fetch.
     */
    orderBy?: tb_decisionsOrderByWithRelationInput | tb_decisionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: tb_decisionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tb_decisions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tb_decisions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned tb_decisions
    **/
    _count?: true | Tb_decisionsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Tb_decisionsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Tb_decisionsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Tb_decisionsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Tb_decisionsMaxAggregateInputType
  }

  export type GetTb_decisionsAggregateType<T extends Tb_decisionsAggregateArgs> = {
        [P in keyof T & keyof AggregateTb_decisions]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTb_decisions[P]>
      : GetScalarType<T[P], AggregateTb_decisions[P]>
  }




  export type tb_decisionsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: tb_decisionsWhereInput
    orderBy?: tb_decisionsOrderByWithAggregationInput | tb_decisionsOrderByWithAggregationInput[]
    by: Tb_decisionsScalarFieldEnum[] | Tb_decisionsScalarFieldEnum
    having?: tb_decisionsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Tb_decisionsCountAggregateInputType | true
    _avg?: Tb_decisionsAvgAggregateInputType
    _sum?: Tb_decisionsSumAggregateInputType
    _min?: Tb_decisionsMinAggregateInputType
    _max?: Tb_decisionsMaxAggregateInputType
  }

  export type Tb_decisionsGroupByOutputType = {
    decision_id: number
    case_id: number
    decision_type: number
    decison_date: Date
    decision_status: number
    actual: number
    decision_out_num: string | null
    _count: Tb_decisionsCountAggregateOutputType | null
    _avg: Tb_decisionsAvgAggregateOutputType | null
    _sum: Tb_decisionsSumAggregateOutputType | null
    _min: Tb_decisionsMinAggregateOutputType | null
    _max: Tb_decisionsMaxAggregateOutputType | null
  }

  type GetTb_decisionsGroupByPayload<T extends tb_decisionsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Tb_decisionsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Tb_decisionsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Tb_decisionsGroupByOutputType[P]>
            : GetScalarType<T[P], Tb_decisionsGroupByOutputType[P]>
        }
      >
    >


  export type tb_decisionsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    decision_id?: boolean
    case_id?: boolean
    decision_type?: boolean
    decison_date?: boolean
    decision_status?: boolean
    actual?: boolean
    decision_out_num?: boolean
  }, ExtArgs["result"]["tb_decisions"]>



  export type tb_decisionsSelectScalar = {
    decision_id?: boolean
    case_id?: boolean
    decision_type?: boolean
    decison_date?: boolean
    decision_status?: boolean
    actual?: boolean
    decision_out_num?: boolean
  }

  export type tb_decisionsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"decision_id" | "case_id" | "decision_type" | "decison_date" | "decision_status" | "actual" | "decision_out_num", ExtArgs["result"]["tb_decisions"]>

  export type $tb_decisionsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "tb_decisions"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      decision_id: number
      case_id: number
      decision_type: number
      decison_date: Date
      decision_status: number
      actual: number
      decision_out_num: string | null
    }, ExtArgs["result"]["tb_decisions"]>
    composites: {}
  }

  type tb_decisionsGetPayload<S extends boolean | null | undefined | tb_decisionsDefaultArgs> = $Result.GetResult<Prisma.$tb_decisionsPayload, S>

  type tb_decisionsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<tb_decisionsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Tb_decisionsCountAggregateInputType | true
    }

  export interface tb_decisionsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['tb_decisions'], meta: { name: 'tb_decisions' } }
    /**
     * Find zero or one Tb_decisions that matches the filter.
     * @param {tb_decisionsFindUniqueArgs} args - Arguments to find a Tb_decisions
     * @example
     * // Get one Tb_decisions
     * const tb_decisions = await prisma.tb_decisions.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends tb_decisionsFindUniqueArgs>(args: SelectSubset<T, tb_decisionsFindUniqueArgs<ExtArgs>>): Prisma__tb_decisionsClient<$Result.GetResult<Prisma.$tb_decisionsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Tb_decisions that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {tb_decisionsFindUniqueOrThrowArgs} args - Arguments to find a Tb_decisions
     * @example
     * // Get one Tb_decisions
     * const tb_decisions = await prisma.tb_decisions.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends tb_decisionsFindUniqueOrThrowArgs>(args: SelectSubset<T, tb_decisionsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__tb_decisionsClient<$Result.GetResult<Prisma.$tb_decisionsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tb_decisions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_decisionsFindFirstArgs} args - Arguments to find a Tb_decisions
     * @example
     * // Get one Tb_decisions
     * const tb_decisions = await prisma.tb_decisions.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends tb_decisionsFindFirstArgs>(args?: SelectSubset<T, tb_decisionsFindFirstArgs<ExtArgs>>): Prisma__tb_decisionsClient<$Result.GetResult<Prisma.$tb_decisionsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tb_decisions that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_decisionsFindFirstOrThrowArgs} args - Arguments to find a Tb_decisions
     * @example
     * // Get one Tb_decisions
     * const tb_decisions = await prisma.tb_decisions.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends tb_decisionsFindFirstOrThrowArgs>(args?: SelectSubset<T, tb_decisionsFindFirstOrThrowArgs<ExtArgs>>): Prisma__tb_decisionsClient<$Result.GetResult<Prisma.$tb_decisionsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Tb_decisions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_decisionsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tb_decisions
     * const tb_decisions = await prisma.tb_decisions.findMany()
     * 
     * // Get first 10 Tb_decisions
     * const tb_decisions = await prisma.tb_decisions.findMany({ take: 10 })
     * 
     * // Only select the `decision_id`
     * const tb_decisionsWithDecision_idOnly = await prisma.tb_decisions.findMany({ select: { decision_id: true } })
     * 
     */
    findMany<T extends tb_decisionsFindManyArgs>(args?: SelectSubset<T, tb_decisionsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tb_decisionsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Tb_decisions.
     * @param {tb_decisionsCreateArgs} args - Arguments to create a Tb_decisions.
     * @example
     * // Create one Tb_decisions
     * const Tb_decisions = await prisma.tb_decisions.create({
     *   data: {
     *     // ... data to create a Tb_decisions
     *   }
     * })
     * 
     */
    create<T extends tb_decisionsCreateArgs>(args: SelectSubset<T, tb_decisionsCreateArgs<ExtArgs>>): Prisma__tb_decisionsClient<$Result.GetResult<Prisma.$tb_decisionsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Tb_decisions.
     * @param {tb_decisionsCreateManyArgs} args - Arguments to create many Tb_decisions.
     * @example
     * // Create many Tb_decisions
     * const tb_decisions = await prisma.tb_decisions.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends tb_decisionsCreateManyArgs>(args?: SelectSubset<T, tb_decisionsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Tb_decisions.
     * @param {tb_decisionsDeleteArgs} args - Arguments to delete one Tb_decisions.
     * @example
     * // Delete one Tb_decisions
     * const Tb_decisions = await prisma.tb_decisions.delete({
     *   where: {
     *     // ... filter to delete one Tb_decisions
     *   }
     * })
     * 
     */
    delete<T extends tb_decisionsDeleteArgs>(args: SelectSubset<T, tb_decisionsDeleteArgs<ExtArgs>>): Prisma__tb_decisionsClient<$Result.GetResult<Prisma.$tb_decisionsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Tb_decisions.
     * @param {tb_decisionsUpdateArgs} args - Arguments to update one Tb_decisions.
     * @example
     * // Update one Tb_decisions
     * const tb_decisions = await prisma.tb_decisions.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends tb_decisionsUpdateArgs>(args: SelectSubset<T, tb_decisionsUpdateArgs<ExtArgs>>): Prisma__tb_decisionsClient<$Result.GetResult<Prisma.$tb_decisionsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Tb_decisions.
     * @param {tb_decisionsDeleteManyArgs} args - Arguments to filter Tb_decisions to delete.
     * @example
     * // Delete a few Tb_decisions
     * const { count } = await prisma.tb_decisions.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends tb_decisionsDeleteManyArgs>(args?: SelectSubset<T, tb_decisionsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tb_decisions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_decisionsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tb_decisions
     * const tb_decisions = await prisma.tb_decisions.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends tb_decisionsUpdateManyArgs>(args: SelectSubset<T, tb_decisionsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Tb_decisions.
     * @param {tb_decisionsUpsertArgs} args - Arguments to update or create a Tb_decisions.
     * @example
     * // Update or create a Tb_decisions
     * const tb_decisions = await prisma.tb_decisions.upsert({
     *   create: {
     *     // ... data to create a Tb_decisions
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tb_decisions we want to update
     *   }
     * })
     */
    upsert<T extends tb_decisionsUpsertArgs>(args: SelectSubset<T, tb_decisionsUpsertArgs<ExtArgs>>): Prisma__tb_decisionsClient<$Result.GetResult<Prisma.$tb_decisionsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Tb_decisions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_decisionsCountArgs} args - Arguments to filter Tb_decisions to count.
     * @example
     * // Count the number of Tb_decisions
     * const count = await prisma.tb_decisions.count({
     *   where: {
     *     // ... the filter for the Tb_decisions we want to count
     *   }
     * })
    **/
    count<T extends tb_decisionsCountArgs>(
      args?: Subset<T, tb_decisionsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Tb_decisionsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tb_decisions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Tb_decisionsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Tb_decisionsAggregateArgs>(args: Subset<T, Tb_decisionsAggregateArgs>): Prisma.PrismaPromise<GetTb_decisionsAggregateType<T>>

    /**
     * Group by Tb_decisions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_decisionsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends tb_decisionsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: tb_decisionsGroupByArgs['orderBy'] }
        : { orderBy?: tb_decisionsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, tb_decisionsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTb_decisionsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the tb_decisions model
   */
  readonly fields: tb_decisionsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for tb_decisions.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__tb_decisionsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the tb_decisions model
   */
  interface tb_decisionsFieldRefs {
    readonly decision_id: FieldRef<"tb_decisions", 'Int'>
    readonly case_id: FieldRef<"tb_decisions", 'Int'>
    readonly decision_type: FieldRef<"tb_decisions", 'Int'>
    readonly decison_date: FieldRef<"tb_decisions", 'DateTime'>
    readonly decision_status: FieldRef<"tb_decisions", 'Int'>
    readonly actual: FieldRef<"tb_decisions", 'Int'>
    readonly decision_out_num: FieldRef<"tb_decisions", 'String'>
  }
    

  // Custom InputTypes
  /**
   * tb_decisions findUnique
   */
  export type tb_decisionsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_decisions
     */
    select?: tb_decisionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_decisions
     */
    omit?: tb_decisionsOmit<ExtArgs> | null
    /**
     * Filter, which tb_decisions to fetch.
     */
    where: tb_decisionsWhereUniqueInput
  }

  /**
   * tb_decisions findUniqueOrThrow
   */
  export type tb_decisionsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_decisions
     */
    select?: tb_decisionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_decisions
     */
    omit?: tb_decisionsOmit<ExtArgs> | null
    /**
     * Filter, which tb_decisions to fetch.
     */
    where: tb_decisionsWhereUniqueInput
  }

  /**
   * tb_decisions findFirst
   */
  export type tb_decisionsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_decisions
     */
    select?: tb_decisionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_decisions
     */
    omit?: tb_decisionsOmit<ExtArgs> | null
    /**
     * Filter, which tb_decisions to fetch.
     */
    where?: tb_decisionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tb_decisions to fetch.
     */
    orderBy?: tb_decisionsOrderByWithRelationInput | tb_decisionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tb_decisions.
     */
    cursor?: tb_decisionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tb_decisions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tb_decisions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tb_decisions.
     */
    distinct?: Tb_decisionsScalarFieldEnum | Tb_decisionsScalarFieldEnum[]
  }

  /**
   * tb_decisions findFirstOrThrow
   */
  export type tb_decisionsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_decisions
     */
    select?: tb_decisionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_decisions
     */
    omit?: tb_decisionsOmit<ExtArgs> | null
    /**
     * Filter, which tb_decisions to fetch.
     */
    where?: tb_decisionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tb_decisions to fetch.
     */
    orderBy?: tb_decisionsOrderByWithRelationInput | tb_decisionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tb_decisions.
     */
    cursor?: tb_decisionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tb_decisions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tb_decisions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tb_decisions.
     */
    distinct?: Tb_decisionsScalarFieldEnum | Tb_decisionsScalarFieldEnum[]
  }

  /**
   * tb_decisions findMany
   */
  export type tb_decisionsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_decisions
     */
    select?: tb_decisionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_decisions
     */
    omit?: tb_decisionsOmit<ExtArgs> | null
    /**
     * Filter, which tb_decisions to fetch.
     */
    where?: tb_decisionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tb_decisions to fetch.
     */
    orderBy?: tb_decisionsOrderByWithRelationInput | tb_decisionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing tb_decisions.
     */
    cursor?: tb_decisionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tb_decisions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tb_decisions.
     */
    skip?: number
    distinct?: Tb_decisionsScalarFieldEnum | Tb_decisionsScalarFieldEnum[]
  }

  /**
   * tb_decisions create
   */
  export type tb_decisionsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_decisions
     */
    select?: tb_decisionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_decisions
     */
    omit?: tb_decisionsOmit<ExtArgs> | null
    /**
     * The data needed to create a tb_decisions.
     */
    data: XOR<tb_decisionsCreateInput, tb_decisionsUncheckedCreateInput>
  }

  /**
   * tb_decisions createMany
   */
  export type tb_decisionsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many tb_decisions.
     */
    data: tb_decisionsCreateManyInput | tb_decisionsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * tb_decisions update
   */
  export type tb_decisionsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_decisions
     */
    select?: tb_decisionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_decisions
     */
    omit?: tb_decisionsOmit<ExtArgs> | null
    /**
     * The data needed to update a tb_decisions.
     */
    data: XOR<tb_decisionsUpdateInput, tb_decisionsUncheckedUpdateInput>
    /**
     * Choose, which tb_decisions to update.
     */
    where: tb_decisionsWhereUniqueInput
  }

  /**
   * tb_decisions updateMany
   */
  export type tb_decisionsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update tb_decisions.
     */
    data: XOR<tb_decisionsUpdateManyMutationInput, tb_decisionsUncheckedUpdateManyInput>
    /**
     * Filter which tb_decisions to update
     */
    where?: tb_decisionsWhereInput
    /**
     * Limit how many tb_decisions to update.
     */
    limit?: number
  }

  /**
   * tb_decisions upsert
   */
  export type tb_decisionsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_decisions
     */
    select?: tb_decisionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_decisions
     */
    omit?: tb_decisionsOmit<ExtArgs> | null
    /**
     * The filter to search for the tb_decisions to update in case it exists.
     */
    where: tb_decisionsWhereUniqueInput
    /**
     * In case the tb_decisions found by the `where` argument doesn't exist, create a new tb_decisions with this data.
     */
    create: XOR<tb_decisionsCreateInput, tb_decisionsUncheckedCreateInput>
    /**
     * In case the tb_decisions was found with the provided `where` argument, update it with this data.
     */
    update: XOR<tb_decisionsUpdateInput, tb_decisionsUncheckedUpdateInput>
  }

  /**
   * tb_decisions delete
   */
  export type tb_decisionsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_decisions
     */
    select?: tb_decisionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_decisions
     */
    omit?: tb_decisionsOmit<ExtArgs> | null
    /**
     * Filter which tb_decisions to delete.
     */
    where: tb_decisionsWhereUniqueInput
  }

  /**
   * tb_decisions deleteMany
   */
  export type tb_decisionsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tb_decisions to delete
     */
    where?: tb_decisionsWhereInput
    /**
     * Limit how many tb_decisions to delete.
     */
    limit?: number
  }

  /**
   * tb_decisions without action
   */
  export type tb_decisionsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_decisions
     */
    select?: tb_decisionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_decisions
     */
    omit?: tb_decisionsOmit<ExtArgs> | null
  }


  /**
   * Model tb_doss
   */

  export type AggregateTb_doss = {
    _count: Tb_dossCountAggregateOutputType | null
    _avg: Tb_dossAvgAggregateOutputType | null
    _sum: Tb_dossSumAggregateOutputType | null
    _min: Tb_dossMinAggregateOutputType | null
    _max: Tb_dossMaxAggregateOutputType | null
  }

  export type Tb_dossAvgAggregateOutputType = {
    doss_id: number | null
    room_num: number | null
    doss_status: number | null
    doss_sex: number | null
  }

  export type Tb_dossSumAggregateOutputType = {
    doss_id: number | null
    room_num: number | null
    doss_status: number | null
    doss_sex: number | null
  }

  export type Tb_dossMinAggregateOutputType = {
    doss_id: number | null
    room_num: number | null
    doss: string | null
    doss_status: number | null
    doss_type: string | null
    doss_sex: number | null
  }

  export type Tb_dossMaxAggregateOutputType = {
    doss_id: number | null
    room_num: number | null
    doss: string | null
    doss_status: number | null
    doss_type: string | null
    doss_sex: number | null
  }

  export type Tb_dossCountAggregateOutputType = {
    doss_id: number
    room_num: number
    doss: number
    doss_status: number
    doss_type: number
    doss_sex: number
    _all: number
  }


  export type Tb_dossAvgAggregateInputType = {
    doss_id?: true
    room_num?: true
    doss_status?: true
    doss_sex?: true
  }

  export type Tb_dossSumAggregateInputType = {
    doss_id?: true
    room_num?: true
    doss_status?: true
    doss_sex?: true
  }

  export type Tb_dossMinAggregateInputType = {
    doss_id?: true
    room_num?: true
    doss?: true
    doss_status?: true
    doss_type?: true
    doss_sex?: true
  }

  export type Tb_dossMaxAggregateInputType = {
    doss_id?: true
    room_num?: true
    doss?: true
    doss_status?: true
    doss_type?: true
    doss_sex?: true
  }

  export type Tb_dossCountAggregateInputType = {
    doss_id?: true
    room_num?: true
    doss?: true
    doss_status?: true
    doss_type?: true
    doss_sex?: true
    _all?: true
  }

  export type Tb_dossAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tb_doss to aggregate.
     */
    where?: tb_dossWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tb_dosses to fetch.
     */
    orderBy?: tb_dossOrderByWithRelationInput | tb_dossOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: tb_dossWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tb_dosses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tb_dosses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned tb_dosses
    **/
    _count?: true | Tb_dossCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Tb_dossAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Tb_dossSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Tb_dossMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Tb_dossMaxAggregateInputType
  }

  export type GetTb_dossAggregateType<T extends Tb_dossAggregateArgs> = {
        [P in keyof T & keyof AggregateTb_doss]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTb_doss[P]>
      : GetScalarType<T[P], AggregateTb_doss[P]>
  }




  export type tb_dossGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: tb_dossWhereInput
    orderBy?: tb_dossOrderByWithAggregationInput | tb_dossOrderByWithAggregationInput[]
    by: Tb_dossScalarFieldEnum[] | Tb_dossScalarFieldEnum
    having?: tb_dossScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Tb_dossCountAggregateInputType | true
    _avg?: Tb_dossAvgAggregateInputType
    _sum?: Tb_dossSumAggregateInputType
    _min?: Tb_dossMinAggregateInputType
    _max?: Tb_dossMaxAggregateInputType
  }

  export type Tb_dossGroupByOutputType = {
    doss_id: number
    room_num: number
    doss: string
    doss_status: number
    doss_type: string
    doss_sex: number
    _count: Tb_dossCountAggregateOutputType | null
    _avg: Tb_dossAvgAggregateOutputType | null
    _sum: Tb_dossSumAggregateOutputType | null
    _min: Tb_dossMinAggregateOutputType | null
    _max: Tb_dossMaxAggregateOutputType | null
  }

  type GetTb_dossGroupByPayload<T extends tb_dossGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Tb_dossGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Tb_dossGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Tb_dossGroupByOutputType[P]>
            : GetScalarType<T[P], Tb_dossGroupByOutputType[P]>
        }
      >
    >


  export type tb_dossSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    doss_id?: boolean
    room_num?: boolean
    doss?: boolean
    doss_status?: boolean
    doss_type?: boolean
    doss_sex?: boolean
  }, ExtArgs["result"]["tb_doss"]>



  export type tb_dossSelectScalar = {
    doss_id?: boolean
    room_num?: boolean
    doss?: boolean
    doss_status?: boolean
    doss_type?: boolean
    doss_sex?: boolean
  }

  export type tb_dossOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"doss_id" | "room_num" | "doss" | "doss_status" | "doss_type" | "doss_sex", ExtArgs["result"]["tb_doss"]>

  export type $tb_dossPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "tb_doss"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      doss_id: number
      room_num: number
      doss: string
      doss_status: number
      doss_type: string
      doss_sex: number
    }, ExtArgs["result"]["tb_doss"]>
    composites: {}
  }

  type tb_dossGetPayload<S extends boolean | null | undefined | tb_dossDefaultArgs> = $Result.GetResult<Prisma.$tb_dossPayload, S>

  type tb_dossCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<tb_dossFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Tb_dossCountAggregateInputType | true
    }

  export interface tb_dossDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['tb_doss'], meta: { name: 'tb_doss' } }
    /**
     * Find zero or one Tb_doss that matches the filter.
     * @param {tb_dossFindUniqueArgs} args - Arguments to find a Tb_doss
     * @example
     * // Get one Tb_doss
     * const tb_doss = await prisma.tb_doss.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends tb_dossFindUniqueArgs>(args: SelectSubset<T, tb_dossFindUniqueArgs<ExtArgs>>): Prisma__tb_dossClient<$Result.GetResult<Prisma.$tb_dossPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Tb_doss that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {tb_dossFindUniqueOrThrowArgs} args - Arguments to find a Tb_doss
     * @example
     * // Get one Tb_doss
     * const tb_doss = await prisma.tb_doss.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends tb_dossFindUniqueOrThrowArgs>(args: SelectSubset<T, tb_dossFindUniqueOrThrowArgs<ExtArgs>>): Prisma__tb_dossClient<$Result.GetResult<Prisma.$tb_dossPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tb_doss that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_dossFindFirstArgs} args - Arguments to find a Tb_doss
     * @example
     * // Get one Tb_doss
     * const tb_doss = await prisma.tb_doss.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends tb_dossFindFirstArgs>(args?: SelectSubset<T, tb_dossFindFirstArgs<ExtArgs>>): Prisma__tb_dossClient<$Result.GetResult<Prisma.$tb_dossPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tb_doss that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_dossFindFirstOrThrowArgs} args - Arguments to find a Tb_doss
     * @example
     * // Get one Tb_doss
     * const tb_doss = await prisma.tb_doss.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends tb_dossFindFirstOrThrowArgs>(args?: SelectSubset<T, tb_dossFindFirstOrThrowArgs<ExtArgs>>): Prisma__tb_dossClient<$Result.GetResult<Prisma.$tb_dossPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Tb_dosses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_dossFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tb_dosses
     * const tb_dosses = await prisma.tb_doss.findMany()
     * 
     * // Get first 10 Tb_dosses
     * const tb_dosses = await prisma.tb_doss.findMany({ take: 10 })
     * 
     * // Only select the `doss_id`
     * const tb_dossWithDoss_idOnly = await prisma.tb_doss.findMany({ select: { doss_id: true } })
     * 
     */
    findMany<T extends tb_dossFindManyArgs>(args?: SelectSubset<T, tb_dossFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tb_dossPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Tb_doss.
     * @param {tb_dossCreateArgs} args - Arguments to create a Tb_doss.
     * @example
     * // Create one Tb_doss
     * const Tb_doss = await prisma.tb_doss.create({
     *   data: {
     *     // ... data to create a Tb_doss
     *   }
     * })
     * 
     */
    create<T extends tb_dossCreateArgs>(args: SelectSubset<T, tb_dossCreateArgs<ExtArgs>>): Prisma__tb_dossClient<$Result.GetResult<Prisma.$tb_dossPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Tb_dosses.
     * @param {tb_dossCreateManyArgs} args - Arguments to create many Tb_dosses.
     * @example
     * // Create many Tb_dosses
     * const tb_doss = await prisma.tb_doss.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends tb_dossCreateManyArgs>(args?: SelectSubset<T, tb_dossCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Tb_doss.
     * @param {tb_dossDeleteArgs} args - Arguments to delete one Tb_doss.
     * @example
     * // Delete one Tb_doss
     * const Tb_doss = await prisma.tb_doss.delete({
     *   where: {
     *     // ... filter to delete one Tb_doss
     *   }
     * })
     * 
     */
    delete<T extends tb_dossDeleteArgs>(args: SelectSubset<T, tb_dossDeleteArgs<ExtArgs>>): Prisma__tb_dossClient<$Result.GetResult<Prisma.$tb_dossPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Tb_doss.
     * @param {tb_dossUpdateArgs} args - Arguments to update one Tb_doss.
     * @example
     * // Update one Tb_doss
     * const tb_doss = await prisma.tb_doss.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends tb_dossUpdateArgs>(args: SelectSubset<T, tb_dossUpdateArgs<ExtArgs>>): Prisma__tb_dossClient<$Result.GetResult<Prisma.$tb_dossPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Tb_dosses.
     * @param {tb_dossDeleteManyArgs} args - Arguments to filter Tb_dosses to delete.
     * @example
     * // Delete a few Tb_dosses
     * const { count } = await prisma.tb_doss.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends tb_dossDeleteManyArgs>(args?: SelectSubset<T, tb_dossDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tb_dosses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_dossUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tb_dosses
     * const tb_doss = await prisma.tb_doss.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends tb_dossUpdateManyArgs>(args: SelectSubset<T, tb_dossUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Tb_doss.
     * @param {tb_dossUpsertArgs} args - Arguments to update or create a Tb_doss.
     * @example
     * // Update or create a Tb_doss
     * const tb_doss = await prisma.tb_doss.upsert({
     *   create: {
     *     // ... data to create a Tb_doss
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tb_doss we want to update
     *   }
     * })
     */
    upsert<T extends tb_dossUpsertArgs>(args: SelectSubset<T, tb_dossUpsertArgs<ExtArgs>>): Prisma__tb_dossClient<$Result.GetResult<Prisma.$tb_dossPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Tb_dosses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_dossCountArgs} args - Arguments to filter Tb_dosses to count.
     * @example
     * // Count the number of Tb_dosses
     * const count = await prisma.tb_doss.count({
     *   where: {
     *     // ... the filter for the Tb_dosses we want to count
     *   }
     * })
    **/
    count<T extends tb_dossCountArgs>(
      args?: Subset<T, tb_dossCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Tb_dossCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tb_doss.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Tb_dossAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Tb_dossAggregateArgs>(args: Subset<T, Tb_dossAggregateArgs>): Prisma.PrismaPromise<GetTb_dossAggregateType<T>>

    /**
     * Group by Tb_doss.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_dossGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends tb_dossGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: tb_dossGroupByArgs['orderBy'] }
        : { orderBy?: tb_dossGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, tb_dossGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTb_dossGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the tb_doss model
   */
  readonly fields: tb_dossFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for tb_doss.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__tb_dossClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the tb_doss model
   */
  interface tb_dossFieldRefs {
    readonly doss_id: FieldRef<"tb_doss", 'Int'>
    readonly room_num: FieldRef<"tb_doss", 'Int'>
    readonly doss: FieldRef<"tb_doss", 'String'>
    readonly doss_status: FieldRef<"tb_doss", 'Int'>
    readonly doss_type: FieldRef<"tb_doss", 'String'>
    readonly doss_sex: FieldRef<"tb_doss", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * tb_doss findUnique
   */
  export type tb_dossFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_doss
     */
    select?: tb_dossSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_doss
     */
    omit?: tb_dossOmit<ExtArgs> | null
    /**
     * Filter, which tb_doss to fetch.
     */
    where: tb_dossWhereUniqueInput
  }

  /**
   * tb_doss findUniqueOrThrow
   */
  export type tb_dossFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_doss
     */
    select?: tb_dossSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_doss
     */
    omit?: tb_dossOmit<ExtArgs> | null
    /**
     * Filter, which tb_doss to fetch.
     */
    where: tb_dossWhereUniqueInput
  }

  /**
   * tb_doss findFirst
   */
  export type tb_dossFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_doss
     */
    select?: tb_dossSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_doss
     */
    omit?: tb_dossOmit<ExtArgs> | null
    /**
     * Filter, which tb_doss to fetch.
     */
    where?: tb_dossWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tb_dosses to fetch.
     */
    orderBy?: tb_dossOrderByWithRelationInput | tb_dossOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tb_dosses.
     */
    cursor?: tb_dossWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tb_dosses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tb_dosses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tb_dosses.
     */
    distinct?: Tb_dossScalarFieldEnum | Tb_dossScalarFieldEnum[]
  }

  /**
   * tb_doss findFirstOrThrow
   */
  export type tb_dossFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_doss
     */
    select?: tb_dossSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_doss
     */
    omit?: tb_dossOmit<ExtArgs> | null
    /**
     * Filter, which tb_doss to fetch.
     */
    where?: tb_dossWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tb_dosses to fetch.
     */
    orderBy?: tb_dossOrderByWithRelationInput | tb_dossOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tb_dosses.
     */
    cursor?: tb_dossWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tb_dosses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tb_dosses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tb_dosses.
     */
    distinct?: Tb_dossScalarFieldEnum | Tb_dossScalarFieldEnum[]
  }

  /**
   * tb_doss findMany
   */
  export type tb_dossFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_doss
     */
    select?: tb_dossSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_doss
     */
    omit?: tb_dossOmit<ExtArgs> | null
    /**
     * Filter, which tb_dosses to fetch.
     */
    where?: tb_dossWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tb_dosses to fetch.
     */
    orderBy?: tb_dossOrderByWithRelationInput | tb_dossOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing tb_dosses.
     */
    cursor?: tb_dossWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tb_dosses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tb_dosses.
     */
    skip?: number
    distinct?: Tb_dossScalarFieldEnum | Tb_dossScalarFieldEnum[]
  }

  /**
   * tb_doss create
   */
  export type tb_dossCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_doss
     */
    select?: tb_dossSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_doss
     */
    omit?: tb_dossOmit<ExtArgs> | null
    /**
     * The data needed to create a tb_doss.
     */
    data: XOR<tb_dossCreateInput, tb_dossUncheckedCreateInput>
  }

  /**
   * tb_doss createMany
   */
  export type tb_dossCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many tb_dosses.
     */
    data: tb_dossCreateManyInput | tb_dossCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * tb_doss update
   */
  export type tb_dossUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_doss
     */
    select?: tb_dossSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_doss
     */
    omit?: tb_dossOmit<ExtArgs> | null
    /**
     * The data needed to update a tb_doss.
     */
    data: XOR<tb_dossUpdateInput, tb_dossUncheckedUpdateInput>
    /**
     * Choose, which tb_doss to update.
     */
    where: tb_dossWhereUniqueInput
  }

  /**
   * tb_doss updateMany
   */
  export type tb_dossUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update tb_dosses.
     */
    data: XOR<tb_dossUpdateManyMutationInput, tb_dossUncheckedUpdateManyInput>
    /**
     * Filter which tb_dosses to update
     */
    where?: tb_dossWhereInput
    /**
     * Limit how many tb_dosses to update.
     */
    limit?: number
  }

  /**
   * tb_doss upsert
   */
  export type tb_dossUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_doss
     */
    select?: tb_dossSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_doss
     */
    omit?: tb_dossOmit<ExtArgs> | null
    /**
     * The filter to search for the tb_doss to update in case it exists.
     */
    where: tb_dossWhereUniqueInput
    /**
     * In case the tb_doss found by the `where` argument doesn't exist, create a new tb_doss with this data.
     */
    create: XOR<tb_dossCreateInput, tb_dossUncheckedCreateInput>
    /**
     * In case the tb_doss was found with the provided `where` argument, update it with this data.
     */
    update: XOR<tb_dossUpdateInput, tb_dossUncheckedUpdateInput>
  }

  /**
   * tb_doss delete
   */
  export type tb_dossDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_doss
     */
    select?: tb_dossSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_doss
     */
    omit?: tb_dossOmit<ExtArgs> | null
    /**
     * Filter which tb_doss to delete.
     */
    where: tb_dossWhereUniqueInput
  }

  /**
   * tb_doss deleteMany
   */
  export type tb_dossDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tb_dosses to delete
     */
    where?: tb_dossWhereInput
    /**
     * Limit how many tb_dosses to delete.
     */
    limit?: number
  }

  /**
   * tb_doss without action
   */
  export type tb_dossDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_doss
     */
    select?: tb_dossSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_doss
     */
    omit?: tb_dossOmit<ExtArgs> | null
  }


  /**
   * Model tb_draft
   */

  export type AggregateTb_draft = {
    _count: Tb_draftCountAggregateOutputType | null
    _avg: Tb_draftAvgAggregateOutputType | null
    _sum: Tb_draftSumAggregateOutputType | null
    _min: Tb_draftMinAggregateOutputType | null
    _max: Tb_draftMaxAggregateOutputType | null
  }

  export type Tb_draftAvgAggregateOutputType = {
    draft_id: number | null
    case_id: number | null
    autor: number | null
    receiver: number | null
    actual: number | null
  }

  export type Tb_draftSumAggregateOutputType = {
    draft_id: number | null
    case_id: number | null
    autor: number | null
    receiver: number | null
    actual: number | null
  }

  export type Tb_draftMinAggregateOutputType = {
    draft_id: number | null
    case_id: number | null
    autor: number | null
    uploaded: Date | null
    receiver: number | null
    actual: number | null
  }

  export type Tb_draftMaxAggregateOutputType = {
    draft_id: number | null
    case_id: number | null
    autor: number | null
    uploaded: Date | null
    receiver: number | null
    actual: number | null
  }

  export type Tb_draftCountAggregateOutputType = {
    draft_id: number
    case_id: number
    autor: number
    uploaded: number
    receiver: number
    actual: number
    _all: number
  }


  export type Tb_draftAvgAggregateInputType = {
    draft_id?: true
    case_id?: true
    autor?: true
    receiver?: true
    actual?: true
  }

  export type Tb_draftSumAggregateInputType = {
    draft_id?: true
    case_id?: true
    autor?: true
    receiver?: true
    actual?: true
  }

  export type Tb_draftMinAggregateInputType = {
    draft_id?: true
    case_id?: true
    autor?: true
    uploaded?: true
    receiver?: true
    actual?: true
  }

  export type Tb_draftMaxAggregateInputType = {
    draft_id?: true
    case_id?: true
    autor?: true
    uploaded?: true
    receiver?: true
    actual?: true
  }

  export type Tb_draftCountAggregateInputType = {
    draft_id?: true
    case_id?: true
    autor?: true
    uploaded?: true
    receiver?: true
    actual?: true
    _all?: true
  }

  export type Tb_draftAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tb_draft to aggregate.
     */
    where?: tb_draftWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tb_drafts to fetch.
     */
    orderBy?: tb_draftOrderByWithRelationInput | tb_draftOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: tb_draftWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tb_drafts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tb_drafts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned tb_drafts
    **/
    _count?: true | Tb_draftCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Tb_draftAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Tb_draftSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Tb_draftMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Tb_draftMaxAggregateInputType
  }

  export type GetTb_draftAggregateType<T extends Tb_draftAggregateArgs> = {
        [P in keyof T & keyof AggregateTb_draft]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTb_draft[P]>
      : GetScalarType<T[P], AggregateTb_draft[P]>
  }




  export type tb_draftGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: tb_draftWhereInput
    orderBy?: tb_draftOrderByWithAggregationInput | tb_draftOrderByWithAggregationInput[]
    by: Tb_draftScalarFieldEnum[] | Tb_draftScalarFieldEnum
    having?: tb_draftScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Tb_draftCountAggregateInputType | true
    _avg?: Tb_draftAvgAggregateInputType
    _sum?: Tb_draftSumAggregateInputType
    _min?: Tb_draftMinAggregateInputType
    _max?: Tb_draftMaxAggregateInputType
  }

  export type Tb_draftGroupByOutputType = {
    draft_id: number
    case_id: number
    autor: number
    uploaded: Date
    receiver: number
    actual: number
    _count: Tb_draftCountAggregateOutputType | null
    _avg: Tb_draftAvgAggregateOutputType | null
    _sum: Tb_draftSumAggregateOutputType | null
    _min: Tb_draftMinAggregateOutputType | null
    _max: Tb_draftMaxAggregateOutputType | null
  }

  type GetTb_draftGroupByPayload<T extends tb_draftGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Tb_draftGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Tb_draftGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Tb_draftGroupByOutputType[P]>
            : GetScalarType<T[P], Tb_draftGroupByOutputType[P]>
        }
      >
    >


  export type tb_draftSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    draft_id?: boolean
    case_id?: boolean
    autor?: boolean
    uploaded?: boolean
    receiver?: boolean
    actual?: boolean
  }, ExtArgs["result"]["tb_draft"]>



  export type tb_draftSelectScalar = {
    draft_id?: boolean
    case_id?: boolean
    autor?: boolean
    uploaded?: boolean
    receiver?: boolean
    actual?: boolean
  }

  export type tb_draftOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"draft_id" | "case_id" | "autor" | "uploaded" | "receiver" | "actual", ExtArgs["result"]["tb_draft"]>

  export type $tb_draftPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "tb_draft"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      draft_id: number
      case_id: number
      autor: number
      uploaded: Date
      receiver: number
      actual: number
    }, ExtArgs["result"]["tb_draft"]>
    composites: {}
  }

  type tb_draftGetPayload<S extends boolean | null | undefined | tb_draftDefaultArgs> = $Result.GetResult<Prisma.$tb_draftPayload, S>

  type tb_draftCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<tb_draftFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Tb_draftCountAggregateInputType | true
    }

  export interface tb_draftDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['tb_draft'], meta: { name: 'tb_draft' } }
    /**
     * Find zero or one Tb_draft that matches the filter.
     * @param {tb_draftFindUniqueArgs} args - Arguments to find a Tb_draft
     * @example
     * // Get one Tb_draft
     * const tb_draft = await prisma.tb_draft.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends tb_draftFindUniqueArgs>(args: SelectSubset<T, tb_draftFindUniqueArgs<ExtArgs>>): Prisma__tb_draftClient<$Result.GetResult<Prisma.$tb_draftPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Tb_draft that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {tb_draftFindUniqueOrThrowArgs} args - Arguments to find a Tb_draft
     * @example
     * // Get one Tb_draft
     * const tb_draft = await prisma.tb_draft.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends tb_draftFindUniqueOrThrowArgs>(args: SelectSubset<T, tb_draftFindUniqueOrThrowArgs<ExtArgs>>): Prisma__tb_draftClient<$Result.GetResult<Prisma.$tb_draftPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tb_draft that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_draftFindFirstArgs} args - Arguments to find a Tb_draft
     * @example
     * // Get one Tb_draft
     * const tb_draft = await prisma.tb_draft.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends tb_draftFindFirstArgs>(args?: SelectSubset<T, tb_draftFindFirstArgs<ExtArgs>>): Prisma__tb_draftClient<$Result.GetResult<Prisma.$tb_draftPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tb_draft that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_draftFindFirstOrThrowArgs} args - Arguments to find a Tb_draft
     * @example
     * // Get one Tb_draft
     * const tb_draft = await prisma.tb_draft.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends tb_draftFindFirstOrThrowArgs>(args?: SelectSubset<T, tb_draftFindFirstOrThrowArgs<ExtArgs>>): Prisma__tb_draftClient<$Result.GetResult<Prisma.$tb_draftPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Tb_drafts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_draftFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tb_drafts
     * const tb_drafts = await prisma.tb_draft.findMany()
     * 
     * // Get first 10 Tb_drafts
     * const tb_drafts = await prisma.tb_draft.findMany({ take: 10 })
     * 
     * // Only select the `draft_id`
     * const tb_draftWithDraft_idOnly = await prisma.tb_draft.findMany({ select: { draft_id: true } })
     * 
     */
    findMany<T extends tb_draftFindManyArgs>(args?: SelectSubset<T, tb_draftFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tb_draftPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Tb_draft.
     * @param {tb_draftCreateArgs} args - Arguments to create a Tb_draft.
     * @example
     * // Create one Tb_draft
     * const Tb_draft = await prisma.tb_draft.create({
     *   data: {
     *     // ... data to create a Tb_draft
     *   }
     * })
     * 
     */
    create<T extends tb_draftCreateArgs>(args: SelectSubset<T, tb_draftCreateArgs<ExtArgs>>): Prisma__tb_draftClient<$Result.GetResult<Prisma.$tb_draftPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Tb_drafts.
     * @param {tb_draftCreateManyArgs} args - Arguments to create many Tb_drafts.
     * @example
     * // Create many Tb_drafts
     * const tb_draft = await prisma.tb_draft.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends tb_draftCreateManyArgs>(args?: SelectSubset<T, tb_draftCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Tb_draft.
     * @param {tb_draftDeleteArgs} args - Arguments to delete one Tb_draft.
     * @example
     * // Delete one Tb_draft
     * const Tb_draft = await prisma.tb_draft.delete({
     *   where: {
     *     // ... filter to delete one Tb_draft
     *   }
     * })
     * 
     */
    delete<T extends tb_draftDeleteArgs>(args: SelectSubset<T, tb_draftDeleteArgs<ExtArgs>>): Prisma__tb_draftClient<$Result.GetResult<Prisma.$tb_draftPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Tb_draft.
     * @param {tb_draftUpdateArgs} args - Arguments to update one Tb_draft.
     * @example
     * // Update one Tb_draft
     * const tb_draft = await prisma.tb_draft.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends tb_draftUpdateArgs>(args: SelectSubset<T, tb_draftUpdateArgs<ExtArgs>>): Prisma__tb_draftClient<$Result.GetResult<Prisma.$tb_draftPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Tb_drafts.
     * @param {tb_draftDeleteManyArgs} args - Arguments to filter Tb_drafts to delete.
     * @example
     * // Delete a few Tb_drafts
     * const { count } = await prisma.tb_draft.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends tb_draftDeleteManyArgs>(args?: SelectSubset<T, tb_draftDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tb_drafts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_draftUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tb_drafts
     * const tb_draft = await prisma.tb_draft.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends tb_draftUpdateManyArgs>(args: SelectSubset<T, tb_draftUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Tb_draft.
     * @param {tb_draftUpsertArgs} args - Arguments to update or create a Tb_draft.
     * @example
     * // Update or create a Tb_draft
     * const tb_draft = await prisma.tb_draft.upsert({
     *   create: {
     *     // ... data to create a Tb_draft
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tb_draft we want to update
     *   }
     * })
     */
    upsert<T extends tb_draftUpsertArgs>(args: SelectSubset<T, tb_draftUpsertArgs<ExtArgs>>): Prisma__tb_draftClient<$Result.GetResult<Prisma.$tb_draftPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Tb_drafts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_draftCountArgs} args - Arguments to filter Tb_drafts to count.
     * @example
     * // Count the number of Tb_drafts
     * const count = await prisma.tb_draft.count({
     *   where: {
     *     // ... the filter for the Tb_drafts we want to count
     *   }
     * })
    **/
    count<T extends tb_draftCountArgs>(
      args?: Subset<T, tb_draftCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Tb_draftCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tb_draft.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Tb_draftAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Tb_draftAggregateArgs>(args: Subset<T, Tb_draftAggregateArgs>): Prisma.PrismaPromise<GetTb_draftAggregateType<T>>

    /**
     * Group by Tb_draft.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_draftGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends tb_draftGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: tb_draftGroupByArgs['orderBy'] }
        : { orderBy?: tb_draftGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, tb_draftGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTb_draftGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the tb_draft model
   */
  readonly fields: tb_draftFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for tb_draft.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__tb_draftClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the tb_draft model
   */
  interface tb_draftFieldRefs {
    readonly draft_id: FieldRef<"tb_draft", 'Int'>
    readonly case_id: FieldRef<"tb_draft", 'Int'>
    readonly autor: FieldRef<"tb_draft", 'Int'>
    readonly uploaded: FieldRef<"tb_draft", 'DateTime'>
    readonly receiver: FieldRef<"tb_draft", 'Int'>
    readonly actual: FieldRef<"tb_draft", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * tb_draft findUnique
   */
  export type tb_draftFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_draft
     */
    select?: tb_draftSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_draft
     */
    omit?: tb_draftOmit<ExtArgs> | null
    /**
     * Filter, which tb_draft to fetch.
     */
    where: tb_draftWhereUniqueInput
  }

  /**
   * tb_draft findUniqueOrThrow
   */
  export type tb_draftFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_draft
     */
    select?: tb_draftSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_draft
     */
    omit?: tb_draftOmit<ExtArgs> | null
    /**
     * Filter, which tb_draft to fetch.
     */
    where: tb_draftWhereUniqueInput
  }

  /**
   * tb_draft findFirst
   */
  export type tb_draftFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_draft
     */
    select?: tb_draftSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_draft
     */
    omit?: tb_draftOmit<ExtArgs> | null
    /**
     * Filter, which tb_draft to fetch.
     */
    where?: tb_draftWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tb_drafts to fetch.
     */
    orderBy?: tb_draftOrderByWithRelationInput | tb_draftOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tb_drafts.
     */
    cursor?: tb_draftWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tb_drafts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tb_drafts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tb_drafts.
     */
    distinct?: Tb_draftScalarFieldEnum | Tb_draftScalarFieldEnum[]
  }

  /**
   * tb_draft findFirstOrThrow
   */
  export type tb_draftFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_draft
     */
    select?: tb_draftSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_draft
     */
    omit?: tb_draftOmit<ExtArgs> | null
    /**
     * Filter, which tb_draft to fetch.
     */
    where?: tb_draftWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tb_drafts to fetch.
     */
    orderBy?: tb_draftOrderByWithRelationInput | tb_draftOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tb_drafts.
     */
    cursor?: tb_draftWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tb_drafts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tb_drafts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tb_drafts.
     */
    distinct?: Tb_draftScalarFieldEnum | Tb_draftScalarFieldEnum[]
  }

  /**
   * tb_draft findMany
   */
  export type tb_draftFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_draft
     */
    select?: tb_draftSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_draft
     */
    omit?: tb_draftOmit<ExtArgs> | null
    /**
     * Filter, which tb_drafts to fetch.
     */
    where?: tb_draftWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tb_drafts to fetch.
     */
    orderBy?: tb_draftOrderByWithRelationInput | tb_draftOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing tb_drafts.
     */
    cursor?: tb_draftWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tb_drafts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tb_drafts.
     */
    skip?: number
    distinct?: Tb_draftScalarFieldEnum | Tb_draftScalarFieldEnum[]
  }

  /**
   * tb_draft create
   */
  export type tb_draftCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_draft
     */
    select?: tb_draftSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_draft
     */
    omit?: tb_draftOmit<ExtArgs> | null
    /**
     * The data needed to create a tb_draft.
     */
    data: XOR<tb_draftCreateInput, tb_draftUncheckedCreateInput>
  }

  /**
   * tb_draft createMany
   */
  export type tb_draftCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many tb_drafts.
     */
    data: tb_draftCreateManyInput | tb_draftCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * tb_draft update
   */
  export type tb_draftUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_draft
     */
    select?: tb_draftSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_draft
     */
    omit?: tb_draftOmit<ExtArgs> | null
    /**
     * The data needed to update a tb_draft.
     */
    data: XOR<tb_draftUpdateInput, tb_draftUncheckedUpdateInput>
    /**
     * Choose, which tb_draft to update.
     */
    where: tb_draftWhereUniqueInput
  }

  /**
   * tb_draft updateMany
   */
  export type tb_draftUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update tb_drafts.
     */
    data: XOR<tb_draftUpdateManyMutationInput, tb_draftUncheckedUpdateManyInput>
    /**
     * Filter which tb_drafts to update
     */
    where?: tb_draftWhereInput
    /**
     * Limit how many tb_drafts to update.
     */
    limit?: number
  }

  /**
   * tb_draft upsert
   */
  export type tb_draftUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_draft
     */
    select?: tb_draftSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_draft
     */
    omit?: tb_draftOmit<ExtArgs> | null
    /**
     * The filter to search for the tb_draft to update in case it exists.
     */
    where: tb_draftWhereUniqueInput
    /**
     * In case the tb_draft found by the `where` argument doesn't exist, create a new tb_draft with this data.
     */
    create: XOR<tb_draftCreateInput, tb_draftUncheckedCreateInput>
    /**
     * In case the tb_draft was found with the provided `where` argument, update it with this data.
     */
    update: XOR<tb_draftUpdateInput, tb_draftUncheckedUpdateInput>
  }

  /**
   * tb_draft delete
   */
  export type tb_draftDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_draft
     */
    select?: tb_draftSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_draft
     */
    omit?: tb_draftOmit<ExtArgs> | null
    /**
     * Filter which tb_draft to delete.
     */
    where: tb_draftWhereUniqueInput
  }

  /**
   * tb_draft deleteMany
   */
  export type tb_draftDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tb_drafts to delete
     */
    where?: tb_draftWhereInput
    /**
     * Limit how many tb_drafts to delete.
     */
    limit?: number
  }

  /**
   * tb_draft without action
   */
  export type tb_draftDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_draft
     */
    select?: tb_draftSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_draft
     */
    omit?: tb_draftOmit<ExtArgs> | null
  }


  /**
   * Model tb_drooms
   */

  export type AggregateTb_drooms = {
    _count: Tb_droomsCountAggregateOutputType | null
    _avg: Tb_droomsAvgAggregateOutputType | null
    _sum: Tb_droomsSumAggregateOutputType | null
    _min: Tb_droomsMinAggregateOutputType | null
    _max: Tb_droomsMaxAggregateOutputType | null
  }

  export type Tb_droomsAvgAggregateOutputType = {
    room_id: number | null
    room_num: number | null
    floor: number | null
    capacity: number | null
    room_sex: number | null
  }

  export type Tb_droomsSumAggregateOutputType = {
    room_id: number | null
    room_num: number | null
    floor: number | null
    capacity: number | null
    room_sex: number | null
  }

  export type Tb_droomsMinAggregateOutputType = {
    room_id: number | null
    room_num: number | null
    floor: number | null
    type: string | null
    capacity: number | null
    room_sex: number | null
  }

  export type Tb_droomsMaxAggregateOutputType = {
    room_id: number | null
    room_num: number | null
    floor: number | null
    type: string | null
    capacity: number | null
    room_sex: number | null
  }

  export type Tb_droomsCountAggregateOutputType = {
    room_id: number
    room_num: number
    floor: number
    type: number
    capacity: number
    room_sex: number
    _all: number
  }


  export type Tb_droomsAvgAggregateInputType = {
    room_id?: true
    room_num?: true
    floor?: true
    capacity?: true
    room_sex?: true
  }

  export type Tb_droomsSumAggregateInputType = {
    room_id?: true
    room_num?: true
    floor?: true
    capacity?: true
    room_sex?: true
  }

  export type Tb_droomsMinAggregateInputType = {
    room_id?: true
    room_num?: true
    floor?: true
    type?: true
    capacity?: true
    room_sex?: true
  }

  export type Tb_droomsMaxAggregateInputType = {
    room_id?: true
    room_num?: true
    floor?: true
    type?: true
    capacity?: true
    room_sex?: true
  }

  export type Tb_droomsCountAggregateInputType = {
    room_id?: true
    room_num?: true
    floor?: true
    type?: true
    capacity?: true
    room_sex?: true
    _all?: true
  }

  export type Tb_droomsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tb_drooms to aggregate.
     */
    where?: tb_droomsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tb_drooms to fetch.
     */
    orderBy?: tb_droomsOrderByWithRelationInput | tb_droomsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: tb_droomsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tb_drooms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tb_drooms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned tb_drooms
    **/
    _count?: true | Tb_droomsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Tb_droomsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Tb_droomsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Tb_droomsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Tb_droomsMaxAggregateInputType
  }

  export type GetTb_droomsAggregateType<T extends Tb_droomsAggregateArgs> = {
        [P in keyof T & keyof AggregateTb_drooms]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTb_drooms[P]>
      : GetScalarType<T[P], AggregateTb_drooms[P]>
  }




  export type tb_droomsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: tb_droomsWhereInput
    orderBy?: tb_droomsOrderByWithAggregationInput | tb_droomsOrderByWithAggregationInput[]
    by: Tb_droomsScalarFieldEnum[] | Tb_droomsScalarFieldEnum
    having?: tb_droomsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Tb_droomsCountAggregateInputType | true
    _avg?: Tb_droomsAvgAggregateInputType
    _sum?: Tb_droomsSumAggregateInputType
    _min?: Tb_droomsMinAggregateInputType
    _max?: Tb_droomsMaxAggregateInputType
  }

  export type Tb_droomsGroupByOutputType = {
    room_id: number
    room_num: number | null
    floor: number | null
    type: string | null
    capacity: number | null
    room_sex: number
    _count: Tb_droomsCountAggregateOutputType | null
    _avg: Tb_droomsAvgAggregateOutputType | null
    _sum: Tb_droomsSumAggregateOutputType | null
    _min: Tb_droomsMinAggregateOutputType | null
    _max: Tb_droomsMaxAggregateOutputType | null
  }

  type GetTb_droomsGroupByPayload<T extends tb_droomsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Tb_droomsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Tb_droomsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Tb_droomsGroupByOutputType[P]>
            : GetScalarType<T[P], Tb_droomsGroupByOutputType[P]>
        }
      >
    >


  export type tb_droomsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    room_id?: boolean
    room_num?: boolean
    floor?: boolean
    type?: boolean
    capacity?: boolean
    room_sex?: boolean
  }, ExtArgs["result"]["tb_drooms"]>



  export type tb_droomsSelectScalar = {
    room_id?: boolean
    room_num?: boolean
    floor?: boolean
    type?: boolean
    capacity?: boolean
    room_sex?: boolean
  }

  export type tb_droomsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"room_id" | "room_num" | "floor" | "type" | "capacity" | "room_sex", ExtArgs["result"]["tb_drooms"]>

  export type $tb_droomsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "tb_drooms"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      room_id: number
      room_num: number | null
      floor: number | null
      type: string | null
      capacity: number | null
      room_sex: number
    }, ExtArgs["result"]["tb_drooms"]>
    composites: {}
  }

  type tb_droomsGetPayload<S extends boolean | null | undefined | tb_droomsDefaultArgs> = $Result.GetResult<Prisma.$tb_droomsPayload, S>

  type tb_droomsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<tb_droomsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Tb_droomsCountAggregateInputType | true
    }

  export interface tb_droomsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['tb_drooms'], meta: { name: 'tb_drooms' } }
    /**
     * Find zero or one Tb_drooms that matches the filter.
     * @param {tb_droomsFindUniqueArgs} args - Arguments to find a Tb_drooms
     * @example
     * // Get one Tb_drooms
     * const tb_drooms = await prisma.tb_drooms.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends tb_droomsFindUniqueArgs>(args: SelectSubset<T, tb_droomsFindUniqueArgs<ExtArgs>>): Prisma__tb_droomsClient<$Result.GetResult<Prisma.$tb_droomsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Tb_drooms that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {tb_droomsFindUniqueOrThrowArgs} args - Arguments to find a Tb_drooms
     * @example
     * // Get one Tb_drooms
     * const tb_drooms = await prisma.tb_drooms.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends tb_droomsFindUniqueOrThrowArgs>(args: SelectSubset<T, tb_droomsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__tb_droomsClient<$Result.GetResult<Prisma.$tb_droomsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tb_drooms that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_droomsFindFirstArgs} args - Arguments to find a Tb_drooms
     * @example
     * // Get one Tb_drooms
     * const tb_drooms = await prisma.tb_drooms.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends tb_droomsFindFirstArgs>(args?: SelectSubset<T, tb_droomsFindFirstArgs<ExtArgs>>): Prisma__tb_droomsClient<$Result.GetResult<Prisma.$tb_droomsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tb_drooms that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_droomsFindFirstOrThrowArgs} args - Arguments to find a Tb_drooms
     * @example
     * // Get one Tb_drooms
     * const tb_drooms = await prisma.tb_drooms.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends tb_droomsFindFirstOrThrowArgs>(args?: SelectSubset<T, tb_droomsFindFirstOrThrowArgs<ExtArgs>>): Prisma__tb_droomsClient<$Result.GetResult<Prisma.$tb_droomsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Tb_drooms that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_droomsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tb_drooms
     * const tb_drooms = await prisma.tb_drooms.findMany()
     * 
     * // Get first 10 Tb_drooms
     * const tb_drooms = await prisma.tb_drooms.findMany({ take: 10 })
     * 
     * // Only select the `room_id`
     * const tb_droomsWithRoom_idOnly = await prisma.tb_drooms.findMany({ select: { room_id: true } })
     * 
     */
    findMany<T extends tb_droomsFindManyArgs>(args?: SelectSubset<T, tb_droomsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tb_droomsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Tb_drooms.
     * @param {tb_droomsCreateArgs} args - Arguments to create a Tb_drooms.
     * @example
     * // Create one Tb_drooms
     * const Tb_drooms = await prisma.tb_drooms.create({
     *   data: {
     *     // ... data to create a Tb_drooms
     *   }
     * })
     * 
     */
    create<T extends tb_droomsCreateArgs>(args: SelectSubset<T, tb_droomsCreateArgs<ExtArgs>>): Prisma__tb_droomsClient<$Result.GetResult<Prisma.$tb_droomsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Tb_drooms.
     * @param {tb_droomsCreateManyArgs} args - Arguments to create many Tb_drooms.
     * @example
     * // Create many Tb_drooms
     * const tb_drooms = await prisma.tb_drooms.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends tb_droomsCreateManyArgs>(args?: SelectSubset<T, tb_droomsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Tb_drooms.
     * @param {tb_droomsDeleteArgs} args - Arguments to delete one Tb_drooms.
     * @example
     * // Delete one Tb_drooms
     * const Tb_drooms = await prisma.tb_drooms.delete({
     *   where: {
     *     // ... filter to delete one Tb_drooms
     *   }
     * })
     * 
     */
    delete<T extends tb_droomsDeleteArgs>(args: SelectSubset<T, tb_droomsDeleteArgs<ExtArgs>>): Prisma__tb_droomsClient<$Result.GetResult<Prisma.$tb_droomsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Tb_drooms.
     * @param {tb_droomsUpdateArgs} args - Arguments to update one Tb_drooms.
     * @example
     * // Update one Tb_drooms
     * const tb_drooms = await prisma.tb_drooms.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends tb_droomsUpdateArgs>(args: SelectSubset<T, tb_droomsUpdateArgs<ExtArgs>>): Prisma__tb_droomsClient<$Result.GetResult<Prisma.$tb_droomsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Tb_drooms.
     * @param {tb_droomsDeleteManyArgs} args - Arguments to filter Tb_drooms to delete.
     * @example
     * // Delete a few Tb_drooms
     * const { count } = await prisma.tb_drooms.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends tb_droomsDeleteManyArgs>(args?: SelectSubset<T, tb_droomsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tb_drooms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_droomsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tb_drooms
     * const tb_drooms = await prisma.tb_drooms.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends tb_droomsUpdateManyArgs>(args: SelectSubset<T, tb_droomsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Tb_drooms.
     * @param {tb_droomsUpsertArgs} args - Arguments to update or create a Tb_drooms.
     * @example
     * // Update or create a Tb_drooms
     * const tb_drooms = await prisma.tb_drooms.upsert({
     *   create: {
     *     // ... data to create a Tb_drooms
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tb_drooms we want to update
     *   }
     * })
     */
    upsert<T extends tb_droomsUpsertArgs>(args: SelectSubset<T, tb_droomsUpsertArgs<ExtArgs>>): Prisma__tb_droomsClient<$Result.GetResult<Prisma.$tb_droomsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Tb_drooms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_droomsCountArgs} args - Arguments to filter Tb_drooms to count.
     * @example
     * // Count the number of Tb_drooms
     * const count = await prisma.tb_drooms.count({
     *   where: {
     *     // ... the filter for the Tb_drooms we want to count
     *   }
     * })
    **/
    count<T extends tb_droomsCountArgs>(
      args?: Subset<T, tb_droomsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Tb_droomsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tb_drooms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Tb_droomsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Tb_droomsAggregateArgs>(args: Subset<T, Tb_droomsAggregateArgs>): Prisma.PrismaPromise<GetTb_droomsAggregateType<T>>

    /**
     * Group by Tb_drooms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_droomsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends tb_droomsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: tb_droomsGroupByArgs['orderBy'] }
        : { orderBy?: tb_droomsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, tb_droomsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTb_droomsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the tb_drooms model
   */
  readonly fields: tb_droomsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for tb_drooms.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__tb_droomsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the tb_drooms model
   */
  interface tb_droomsFieldRefs {
    readonly room_id: FieldRef<"tb_drooms", 'Int'>
    readonly room_num: FieldRef<"tb_drooms", 'Int'>
    readonly floor: FieldRef<"tb_drooms", 'Int'>
    readonly type: FieldRef<"tb_drooms", 'String'>
    readonly capacity: FieldRef<"tb_drooms", 'Int'>
    readonly room_sex: FieldRef<"tb_drooms", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * tb_drooms findUnique
   */
  export type tb_droomsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_drooms
     */
    select?: tb_droomsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_drooms
     */
    omit?: tb_droomsOmit<ExtArgs> | null
    /**
     * Filter, which tb_drooms to fetch.
     */
    where: tb_droomsWhereUniqueInput
  }

  /**
   * tb_drooms findUniqueOrThrow
   */
  export type tb_droomsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_drooms
     */
    select?: tb_droomsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_drooms
     */
    omit?: tb_droomsOmit<ExtArgs> | null
    /**
     * Filter, which tb_drooms to fetch.
     */
    where: tb_droomsWhereUniqueInput
  }

  /**
   * tb_drooms findFirst
   */
  export type tb_droomsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_drooms
     */
    select?: tb_droomsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_drooms
     */
    omit?: tb_droomsOmit<ExtArgs> | null
    /**
     * Filter, which tb_drooms to fetch.
     */
    where?: tb_droomsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tb_drooms to fetch.
     */
    orderBy?: tb_droomsOrderByWithRelationInput | tb_droomsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tb_drooms.
     */
    cursor?: tb_droomsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tb_drooms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tb_drooms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tb_drooms.
     */
    distinct?: Tb_droomsScalarFieldEnum | Tb_droomsScalarFieldEnum[]
  }

  /**
   * tb_drooms findFirstOrThrow
   */
  export type tb_droomsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_drooms
     */
    select?: tb_droomsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_drooms
     */
    omit?: tb_droomsOmit<ExtArgs> | null
    /**
     * Filter, which tb_drooms to fetch.
     */
    where?: tb_droomsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tb_drooms to fetch.
     */
    orderBy?: tb_droomsOrderByWithRelationInput | tb_droomsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tb_drooms.
     */
    cursor?: tb_droomsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tb_drooms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tb_drooms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tb_drooms.
     */
    distinct?: Tb_droomsScalarFieldEnum | Tb_droomsScalarFieldEnum[]
  }

  /**
   * tb_drooms findMany
   */
  export type tb_droomsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_drooms
     */
    select?: tb_droomsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_drooms
     */
    omit?: tb_droomsOmit<ExtArgs> | null
    /**
     * Filter, which tb_drooms to fetch.
     */
    where?: tb_droomsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tb_drooms to fetch.
     */
    orderBy?: tb_droomsOrderByWithRelationInput | tb_droomsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing tb_drooms.
     */
    cursor?: tb_droomsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tb_drooms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tb_drooms.
     */
    skip?: number
    distinct?: Tb_droomsScalarFieldEnum | Tb_droomsScalarFieldEnum[]
  }

  /**
   * tb_drooms create
   */
  export type tb_droomsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_drooms
     */
    select?: tb_droomsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_drooms
     */
    omit?: tb_droomsOmit<ExtArgs> | null
    /**
     * The data needed to create a tb_drooms.
     */
    data?: XOR<tb_droomsCreateInput, tb_droomsUncheckedCreateInput>
  }

  /**
   * tb_drooms createMany
   */
  export type tb_droomsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many tb_drooms.
     */
    data: tb_droomsCreateManyInput | tb_droomsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * tb_drooms update
   */
  export type tb_droomsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_drooms
     */
    select?: tb_droomsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_drooms
     */
    omit?: tb_droomsOmit<ExtArgs> | null
    /**
     * The data needed to update a tb_drooms.
     */
    data: XOR<tb_droomsUpdateInput, tb_droomsUncheckedUpdateInput>
    /**
     * Choose, which tb_drooms to update.
     */
    where: tb_droomsWhereUniqueInput
  }

  /**
   * tb_drooms updateMany
   */
  export type tb_droomsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update tb_drooms.
     */
    data: XOR<tb_droomsUpdateManyMutationInput, tb_droomsUncheckedUpdateManyInput>
    /**
     * Filter which tb_drooms to update
     */
    where?: tb_droomsWhereInput
    /**
     * Limit how many tb_drooms to update.
     */
    limit?: number
  }

  /**
   * tb_drooms upsert
   */
  export type tb_droomsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_drooms
     */
    select?: tb_droomsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_drooms
     */
    omit?: tb_droomsOmit<ExtArgs> | null
    /**
     * The filter to search for the tb_drooms to update in case it exists.
     */
    where: tb_droomsWhereUniqueInput
    /**
     * In case the tb_drooms found by the `where` argument doesn't exist, create a new tb_drooms with this data.
     */
    create: XOR<tb_droomsCreateInput, tb_droomsUncheckedCreateInput>
    /**
     * In case the tb_drooms was found with the provided `where` argument, update it with this data.
     */
    update: XOR<tb_droomsUpdateInput, tb_droomsUncheckedUpdateInput>
  }

  /**
   * tb_drooms delete
   */
  export type tb_droomsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_drooms
     */
    select?: tb_droomsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_drooms
     */
    omit?: tb_droomsOmit<ExtArgs> | null
    /**
     * Filter which tb_drooms to delete.
     */
    where: tb_droomsWhereUniqueInput
  }

  /**
   * tb_drooms deleteMany
   */
  export type tb_droomsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tb_drooms to delete
     */
    where?: tb_droomsWhereInput
    /**
     * Limit how many tb_drooms to delete.
     */
    limit?: number
  }

  /**
   * tb_drooms without action
   */
  export type tb_droomsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_drooms
     */
    select?: tb_droomsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_drooms
     */
    omit?: tb_droomsOmit<ExtArgs> | null
  }


  /**
   * Model tb_edu_lvl
   */

  export type AggregateTb_edu_lvl = {
    _count: Tb_edu_lvlCountAggregateOutputType | null
    _avg: Tb_edu_lvlAvgAggregateOutputType | null
    _sum: Tb_edu_lvlSumAggregateOutputType | null
    _min: Tb_edu_lvlMinAggregateOutputType | null
    _max: Tb_edu_lvlMaxAggregateOutputType | null
  }

  export type Tb_edu_lvlAvgAggregateOutputType = {
    lvl_id: number | null
  }

  export type Tb_edu_lvlSumAggregateOutputType = {
    lvl_id: number | null
  }

  export type Tb_edu_lvlMinAggregateOutputType = {
    lvl_id: number | null
    edu_lvl: string | null
  }

  export type Tb_edu_lvlMaxAggregateOutputType = {
    lvl_id: number | null
    edu_lvl: string | null
  }

  export type Tb_edu_lvlCountAggregateOutputType = {
    lvl_id: number
    edu_lvl: number
    _all: number
  }


  export type Tb_edu_lvlAvgAggregateInputType = {
    lvl_id?: true
  }

  export type Tb_edu_lvlSumAggregateInputType = {
    lvl_id?: true
  }

  export type Tb_edu_lvlMinAggregateInputType = {
    lvl_id?: true
    edu_lvl?: true
  }

  export type Tb_edu_lvlMaxAggregateInputType = {
    lvl_id?: true
    edu_lvl?: true
  }

  export type Tb_edu_lvlCountAggregateInputType = {
    lvl_id?: true
    edu_lvl?: true
    _all?: true
  }

  export type Tb_edu_lvlAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tb_edu_lvl to aggregate.
     */
    where?: tb_edu_lvlWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tb_edu_lvls to fetch.
     */
    orderBy?: tb_edu_lvlOrderByWithRelationInput | tb_edu_lvlOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: tb_edu_lvlWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tb_edu_lvls from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tb_edu_lvls.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned tb_edu_lvls
    **/
    _count?: true | Tb_edu_lvlCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Tb_edu_lvlAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Tb_edu_lvlSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Tb_edu_lvlMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Tb_edu_lvlMaxAggregateInputType
  }

  export type GetTb_edu_lvlAggregateType<T extends Tb_edu_lvlAggregateArgs> = {
        [P in keyof T & keyof AggregateTb_edu_lvl]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTb_edu_lvl[P]>
      : GetScalarType<T[P], AggregateTb_edu_lvl[P]>
  }




  export type tb_edu_lvlGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: tb_edu_lvlWhereInput
    orderBy?: tb_edu_lvlOrderByWithAggregationInput | tb_edu_lvlOrderByWithAggregationInput[]
    by: Tb_edu_lvlScalarFieldEnum[] | Tb_edu_lvlScalarFieldEnum
    having?: tb_edu_lvlScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Tb_edu_lvlCountAggregateInputType | true
    _avg?: Tb_edu_lvlAvgAggregateInputType
    _sum?: Tb_edu_lvlSumAggregateInputType
    _min?: Tb_edu_lvlMinAggregateInputType
    _max?: Tb_edu_lvlMaxAggregateInputType
  }

  export type Tb_edu_lvlGroupByOutputType = {
    lvl_id: number
    edu_lvl: string
    _count: Tb_edu_lvlCountAggregateOutputType | null
    _avg: Tb_edu_lvlAvgAggregateOutputType | null
    _sum: Tb_edu_lvlSumAggregateOutputType | null
    _min: Tb_edu_lvlMinAggregateOutputType | null
    _max: Tb_edu_lvlMaxAggregateOutputType | null
  }

  type GetTb_edu_lvlGroupByPayload<T extends tb_edu_lvlGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Tb_edu_lvlGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Tb_edu_lvlGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Tb_edu_lvlGroupByOutputType[P]>
            : GetScalarType<T[P], Tb_edu_lvlGroupByOutputType[P]>
        }
      >
    >


  export type tb_edu_lvlSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    lvl_id?: boolean
    edu_lvl?: boolean
  }, ExtArgs["result"]["tb_edu_lvl"]>



  export type tb_edu_lvlSelectScalar = {
    lvl_id?: boolean
    edu_lvl?: boolean
  }

  export type tb_edu_lvlOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"lvl_id" | "edu_lvl", ExtArgs["result"]["tb_edu_lvl"]>

  export type $tb_edu_lvlPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "tb_edu_lvl"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      lvl_id: number
      edu_lvl: string
    }, ExtArgs["result"]["tb_edu_lvl"]>
    composites: {}
  }

  type tb_edu_lvlGetPayload<S extends boolean | null | undefined | tb_edu_lvlDefaultArgs> = $Result.GetResult<Prisma.$tb_edu_lvlPayload, S>

  type tb_edu_lvlCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<tb_edu_lvlFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Tb_edu_lvlCountAggregateInputType | true
    }

  export interface tb_edu_lvlDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['tb_edu_lvl'], meta: { name: 'tb_edu_lvl' } }
    /**
     * Find zero or one Tb_edu_lvl that matches the filter.
     * @param {tb_edu_lvlFindUniqueArgs} args - Arguments to find a Tb_edu_lvl
     * @example
     * // Get one Tb_edu_lvl
     * const tb_edu_lvl = await prisma.tb_edu_lvl.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends tb_edu_lvlFindUniqueArgs>(args: SelectSubset<T, tb_edu_lvlFindUniqueArgs<ExtArgs>>): Prisma__tb_edu_lvlClient<$Result.GetResult<Prisma.$tb_edu_lvlPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Tb_edu_lvl that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {tb_edu_lvlFindUniqueOrThrowArgs} args - Arguments to find a Tb_edu_lvl
     * @example
     * // Get one Tb_edu_lvl
     * const tb_edu_lvl = await prisma.tb_edu_lvl.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends tb_edu_lvlFindUniqueOrThrowArgs>(args: SelectSubset<T, tb_edu_lvlFindUniqueOrThrowArgs<ExtArgs>>): Prisma__tb_edu_lvlClient<$Result.GetResult<Prisma.$tb_edu_lvlPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tb_edu_lvl that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_edu_lvlFindFirstArgs} args - Arguments to find a Tb_edu_lvl
     * @example
     * // Get one Tb_edu_lvl
     * const tb_edu_lvl = await prisma.tb_edu_lvl.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends tb_edu_lvlFindFirstArgs>(args?: SelectSubset<T, tb_edu_lvlFindFirstArgs<ExtArgs>>): Prisma__tb_edu_lvlClient<$Result.GetResult<Prisma.$tb_edu_lvlPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tb_edu_lvl that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_edu_lvlFindFirstOrThrowArgs} args - Arguments to find a Tb_edu_lvl
     * @example
     * // Get one Tb_edu_lvl
     * const tb_edu_lvl = await prisma.tb_edu_lvl.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends tb_edu_lvlFindFirstOrThrowArgs>(args?: SelectSubset<T, tb_edu_lvlFindFirstOrThrowArgs<ExtArgs>>): Prisma__tb_edu_lvlClient<$Result.GetResult<Prisma.$tb_edu_lvlPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Tb_edu_lvls that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_edu_lvlFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tb_edu_lvls
     * const tb_edu_lvls = await prisma.tb_edu_lvl.findMany()
     * 
     * // Get first 10 Tb_edu_lvls
     * const tb_edu_lvls = await prisma.tb_edu_lvl.findMany({ take: 10 })
     * 
     * // Only select the `lvl_id`
     * const tb_edu_lvlWithLvl_idOnly = await prisma.tb_edu_lvl.findMany({ select: { lvl_id: true } })
     * 
     */
    findMany<T extends tb_edu_lvlFindManyArgs>(args?: SelectSubset<T, tb_edu_lvlFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tb_edu_lvlPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Tb_edu_lvl.
     * @param {tb_edu_lvlCreateArgs} args - Arguments to create a Tb_edu_lvl.
     * @example
     * // Create one Tb_edu_lvl
     * const Tb_edu_lvl = await prisma.tb_edu_lvl.create({
     *   data: {
     *     // ... data to create a Tb_edu_lvl
     *   }
     * })
     * 
     */
    create<T extends tb_edu_lvlCreateArgs>(args: SelectSubset<T, tb_edu_lvlCreateArgs<ExtArgs>>): Prisma__tb_edu_lvlClient<$Result.GetResult<Prisma.$tb_edu_lvlPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Tb_edu_lvls.
     * @param {tb_edu_lvlCreateManyArgs} args - Arguments to create many Tb_edu_lvls.
     * @example
     * // Create many Tb_edu_lvls
     * const tb_edu_lvl = await prisma.tb_edu_lvl.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends tb_edu_lvlCreateManyArgs>(args?: SelectSubset<T, tb_edu_lvlCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Tb_edu_lvl.
     * @param {tb_edu_lvlDeleteArgs} args - Arguments to delete one Tb_edu_lvl.
     * @example
     * // Delete one Tb_edu_lvl
     * const Tb_edu_lvl = await prisma.tb_edu_lvl.delete({
     *   where: {
     *     // ... filter to delete one Tb_edu_lvl
     *   }
     * })
     * 
     */
    delete<T extends tb_edu_lvlDeleteArgs>(args: SelectSubset<T, tb_edu_lvlDeleteArgs<ExtArgs>>): Prisma__tb_edu_lvlClient<$Result.GetResult<Prisma.$tb_edu_lvlPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Tb_edu_lvl.
     * @param {tb_edu_lvlUpdateArgs} args - Arguments to update one Tb_edu_lvl.
     * @example
     * // Update one Tb_edu_lvl
     * const tb_edu_lvl = await prisma.tb_edu_lvl.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends tb_edu_lvlUpdateArgs>(args: SelectSubset<T, tb_edu_lvlUpdateArgs<ExtArgs>>): Prisma__tb_edu_lvlClient<$Result.GetResult<Prisma.$tb_edu_lvlPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Tb_edu_lvls.
     * @param {tb_edu_lvlDeleteManyArgs} args - Arguments to filter Tb_edu_lvls to delete.
     * @example
     * // Delete a few Tb_edu_lvls
     * const { count } = await prisma.tb_edu_lvl.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends tb_edu_lvlDeleteManyArgs>(args?: SelectSubset<T, tb_edu_lvlDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tb_edu_lvls.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_edu_lvlUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tb_edu_lvls
     * const tb_edu_lvl = await prisma.tb_edu_lvl.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends tb_edu_lvlUpdateManyArgs>(args: SelectSubset<T, tb_edu_lvlUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Tb_edu_lvl.
     * @param {tb_edu_lvlUpsertArgs} args - Arguments to update or create a Tb_edu_lvl.
     * @example
     * // Update or create a Tb_edu_lvl
     * const tb_edu_lvl = await prisma.tb_edu_lvl.upsert({
     *   create: {
     *     // ... data to create a Tb_edu_lvl
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tb_edu_lvl we want to update
     *   }
     * })
     */
    upsert<T extends tb_edu_lvlUpsertArgs>(args: SelectSubset<T, tb_edu_lvlUpsertArgs<ExtArgs>>): Prisma__tb_edu_lvlClient<$Result.GetResult<Prisma.$tb_edu_lvlPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Tb_edu_lvls.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_edu_lvlCountArgs} args - Arguments to filter Tb_edu_lvls to count.
     * @example
     * // Count the number of Tb_edu_lvls
     * const count = await prisma.tb_edu_lvl.count({
     *   where: {
     *     // ... the filter for the Tb_edu_lvls we want to count
     *   }
     * })
    **/
    count<T extends tb_edu_lvlCountArgs>(
      args?: Subset<T, tb_edu_lvlCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Tb_edu_lvlCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tb_edu_lvl.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Tb_edu_lvlAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Tb_edu_lvlAggregateArgs>(args: Subset<T, Tb_edu_lvlAggregateArgs>): Prisma.PrismaPromise<GetTb_edu_lvlAggregateType<T>>

    /**
     * Group by Tb_edu_lvl.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_edu_lvlGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends tb_edu_lvlGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: tb_edu_lvlGroupByArgs['orderBy'] }
        : { orderBy?: tb_edu_lvlGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, tb_edu_lvlGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTb_edu_lvlGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the tb_edu_lvl model
   */
  readonly fields: tb_edu_lvlFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for tb_edu_lvl.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__tb_edu_lvlClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the tb_edu_lvl model
   */
  interface tb_edu_lvlFieldRefs {
    readonly lvl_id: FieldRef<"tb_edu_lvl", 'Int'>
    readonly edu_lvl: FieldRef<"tb_edu_lvl", 'String'>
  }
    

  // Custom InputTypes
  /**
   * tb_edu_lvl findUnique
   */
  export type tb_edu_lvlFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_edu_lvl
     */
    select?: tb_edu_lvlSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_edu_lvl
     */
    omit?: tb_edu_lvlOmit<ExtArgs> | null
    /**
     * Filter, which tb_edu_lvl to fetch.
     */
    where: tb_edu_lvlWhereUniqueInput
  }

  /**
   * tb_edu_lvl findUniqueOrThrow
   */
  export type tb_edu_lvlFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_edu_lvl
     */
    select?: tb_edu_lvlSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_edu_lvl
     */
    omit?: tb_edu_lvlOmit<ExtArgs> | null
    /**
     * Filter, which tb_edu_lvl to fetch.
     */
    where: tb_edu_lvlWhereUniqueInput
  }

  /**
   * tb_edu_lvl findFirst
   */
  export type tb_edu_lvlFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_edu_lvl
     */
    select?: tb_edu_lvlSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_edu_lvl
     */
    omit?: tb_edu_lvlOmit<ExtArgs> | null
    /**
     * Filter, which tb_edu_lvl to fetch.
     */
    where?: tb_edu_lvlWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tb_edu_lvls to fetch.
     */
    orderBy?: tb_edu_lvlOrderByWithRelationInput | tb_edu_lvlOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tb_edu_lvls.
     */
    cursor?: tb_edu_lvlWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tb_edu_lvls from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tb_edu_lvls.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tb_edu_lvls.
     */
    distinct?: Tb_edu_lvlScalarFieldEnum | Tb_edu_lvlScalarFieldEnum[]
  }

  /**
   * tb_edu_lvl findFirstOrThrow
   */
  export type tb_edu_lvlFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_edu_lvl
     */
    select?: tb_edu_lvlSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_edu_lvl
     */
    omit?: tb_edu_lvlOmit<ExtArgs> | null
    /**
     * Filter, which tb_edu_lvl to fetch.
     */
    where?: tb_edu_lvlWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tb_edu_lvls to fetch.
     */
    orderBy?: tb_edu_lvlOrderByWithRelationInput | tb_edu_lvlOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tb_edu_lvls.
     */
    cursor?: tb_edu_lvlWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tb_edu_lvls from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tb_edu_lvls.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tb_edu_lvls.
     */
    distinct?: Tb_edu_lvlScalarFieldEnum | Tb_edu_lvlScalarFieldEnum[]
  }

  /**
   * tb_edu_lvl findMany
   */
  export type tb_edu_lvlFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_edu_lvl
     */
    select?: tb_edu_lvlSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_edu_lvl
     */
    omit?: tb_edu_lvlOmit<ExtArgs> | null
    /**
     * Filter, which tb_edu_lvls to fetch.
     */
    where?: tb_edu_lvlWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tb_edu_lvls to fetch.
     */
    orderBy?: tb_edu_lvlOrderByWithRelationInput | tb_edu_lvlOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing tb_edu_lvls.
     */
    cursor?: tb_edu_lvlWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tb_edu_lvls from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tb_edu_lvls.
     */
    skip?: number
    distinct?: Tb_edu_lvlScalarFieldEnum | Tb_edu_lvlScalarFieldEnum[]
  }

  /**
   * tb_edu_lvl create
   */
  export type tb_edu_lvlCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_edu_lvl
     */
    select?: tb_edu_lvlSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_edu_lvl
     */
    omit?: tb_edu_lvlOmit<ExtArgs> | null
    /**
     * The data needed to create a tb_edu_lvl.
     */
    data: XOR<tb_edu_lvlCreateInput, tb_edu_lvlUncheckedCreateInput>
  }

  /**
   * tb_edu_lvl createMany
   */
  export type tb_edu_lvlCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many tb_edu_lvls.
     */
    data: tb_edu_lvlCreateManyInput | tb_edu_lvlCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * tb_edu_lvl update
   */
  export type tb_edu_lvlUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_edu_lvl
     */
    select?: tb_edu_lvlSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_edu_lvl
     */
    omit?: tb_edu_lvlOmit<ExtArgs> | null
    /**
     * The data needed to update a tb_edu_lvl.
     */
    data: XOR<tb_edu_lvlUpdateInput, tb_edu_lvlUncheckedUpdateInput>
    /**
     * Choose, which tb_edu_lvl to update.
     */
    where: tb_edu_lvlWhereUniqueInput
  }

  /**
   * tb_edu_lvl updateMany
   */
  export type tb_edu_lvlUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update tb_edu_lvls.
     */
    data: XOR<tb_edu_lvlUpdateManyMutationInput, tb_edu_lvlUncheckedUpdateManyInput>
    /**
     * Filter which tb_edu_lvls to update
     */
    where?: tb_edu_lvlWhereInput
    /**
     * Limit how many tb_edu_lvls to update.
     */
    limit?: number
  }

  /**
   * tb_edu_lvl upsert
   */
  export type tb_edu_lvlUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_edu_lvl
     */
    select?: tb_edu_lvlSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_edu_lvl
     */
    omit?: tb_edu_lvlOmit<ExtArgs> | null
    /**
     * The filter to search for the tb_edu_lvl to update in case it exists.
     */
    where: tb_edu_lvlWhereUniqueInput
    /**
     * In case the tb_edu_lvl found by the `where` argument doesn't exist, create a new tb_edu_lvl with this data.
     */
    create: XOR<tb_edu_lvlCreateInput, tb_edu_lvlUncheckedCreateInput>
    /**
     * In case the tb_edu_lvl was found with the provided `where` argument, update it with this data.
     */
    update: XOR<tb_edu_lvlUpdateInput, tb_edu_lvlUncheckedUpdateInput>
  }

  /**
   * tb_edu_lvl delete
   */
  export type tb_edu_lvlDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_edu_lvl
     */
    select?: tb_edu_lvlSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_edu_lvl
     */
    omit?: tb_edu_lvlOmit<ExtArgs> | null
    /**
     * Filter which tb_edu_lvl to delete.
     */
    where: tb_edu_lvlWhereUniqueInput
  }

  /**
   * tb_edu_lvl deleteMany
   */
  export type tb_edu_lvlDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tb_edu_lvls to delete
     */
    where?: tb_edu_lvlWhereInput
    /**
     * Limit how many tb_edu_lvls to delete.
     */
    limit?: number
  }

  /**
   * tb_edu_lvl without action
   */
  export type tb_edu_lvlDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_edu_lvl
     */
    select?: tb_edu_lvlSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_edu_lvl
     */
    omit?: tb_edu_lvlOmit<ExtArgs> | null
  }


  /**
   * Model tb_education
   */

  export type AggregateTb_education = {
    _count: Tb_educationCountAggregateOutputType | null
    _avg: Tb_educationAvgAggregateOutputType | null
    _sum: Tb_educationSumAggregateOutputType | null
    _min: Tb_educationMinAggregateOutputType | null
    _max: Tb_educationMaxAggregateOutputType | null
  }

  export type Tb_educationAvgAggregateOutputType = {
    edu_id: number | null
    edu_lvl: number | null
    personal_id: number | null
  }

  export type Tb_educationSumAggregateOutputType = {
    edu_id: number | null
    edu_lvl: number | null
    personal_id: number | null
  }

  export type Tb_educationMinAggregateOutputType = {
    edu_id: number | null
    specialization: string | null
    institution: string | null
    edu_lvl: number | null
    start_year: string | null
    end_year: string | null
    personal_id: number | null
  }

  export type Tb_educationMaxAggregateOutputType = {
    edu_id: number | null
    specialization: string | null
    institution: string | null
    edu_lvl: number | null
    start_year: string | null
    end_year: string | null
    personal_id: number | null
  }

  export type Tb_educationCountAggregateOutputType = {
    edu_id: number
    specialization: number
    institution: number
    edu_lvl: number
    start_year: number
    end_year: number
    personal_id: number
    _all: number
  }


  export type Tb_educationAvgAggregateInputType = {
    edu_id?: true
    edu_lvl?: true
    personal_id?: true
  }

  export type Tb_educationSumAggregateInputType = {
    edu_id?: true
    edu_lvl?: true
    personal_id?: true
  }

  export type Tb_educationMinAggregateInputType = {
    edu_id?: true
    specialization?: true
    institution?: true
    edu_lvl?: true
    start_year?: true
    end_year?: true
    personal_id?: true
  }

  export type Tb_educationMaxAggregateInputType = {
    edu_id?: true
    specialization?: true
    institution?: true
    edu_lvl?: true
    start_year?: true
    end_year?: true
    personal_id?: true
  }

  export type Tb_educationCountAggregateInputType = {
    edu_id?: true
    specialization?: true
    institution?: true
    edu_lvl?: true
    start_year?: true
    end_year?: true
    personal_id?: true
    _all?: true
  }

  export type Tb_educationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tb_education to aggregate.
     */
    where?: tb_educationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tb_educations to fetch.
     */
    orderBy?: tb_educationOrderByWithRelationInput | tb_educationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: tb_educationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tb_educations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tb_educations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned tb_educations
    **/
    _count?: true | Tb_educationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Tb_educationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Tb_educationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Tb_educationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Tb_educationMaxAggregateInputType
  }

  export type GetTb_educationAggregateType<T extends Tb_educationAggregateArgs> = {
        [P in keyof T & keyof AggregateTb_education]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTb_education[P]>
      : GetScalarType<T[P], AggregateTb_education[P]>
  }




  export type tb_educationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: tb_educationWhereInput
    orderBy?: tb_educationOrderByWithAggregationInput | tb_educationOrderByWithAggregationInput[]
    by: Tb_educationScalarFieldEnum[] | Tb_educationScalarFieldEnum
    having?: tb_educationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Tb_educationCountAggregateInputType | true
    _avg?: Tb_educationAvgAggregateInputType
    _sum?: Tb_educationSumAggregateInputType
    _min?: Tb_educationMinAggregateInputType
    _max?: Tb_educationMaxAggregateInputType
  }

  export type Tb_educationGroupByOutputType = {
    edu_id: number
    specialization: string | null
    institution: string | null
    edu_lvl: number
    start_year: string | null
    end_year: string | null
    personal_id: number
    _count: Tb_educationCountAggregateOutputType | null
    _avg: Tb_educationAvgAggregateOutputType | null
    _sum: Tb_educationSumAggregateOutputType | null
    _min: Tb_educationMinAggregateOutputType | null
    _max: Tb_educationMaxAggregateOutputType | null
  }

  type GetTb_educationGroupByPayload<T extends tb_educationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Tb_educationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Tb_educationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Tb_educationGroupByOutputType[P]>
            : GetScalarType<T[P], Tb_educationGroupByOutputType[P]>
        }
      >
    >


  export type tb_educationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    edu_id?: boolean
    specialization?: boolean
    institution?: boolean
    edu_lvl?: boolean
    start_year?: boolean
    end_year?: boolean
    personal_id?: boolean
  }, ExtArgs["result"]["tb_education"]>



  export type tb_educationSelectScalar = {
    edu_id?: boolean
    specialization?: boolean
    institution?: boolean
    edu_lvl?: boolean
    start_year?: boolean
    end_year?: boolean
    personal_id?: boolean
  }

  export type tb_educationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"edu_id" | "specialization" | "institution" | "edu_lvl" | "start_year" | "end_year" | "personal_id", ExtArgs["result"]["tb_education"]>

  export type $tb_educationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "tb_education"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      edu_id: number
      specialization: string | null
      institution: string | null
      edu_lvl: number
      start_year: string | null
      end_year: string | null
      personal_id: number
    }, ExtArgs["result"]["tb_education"]>
    composites: {}
  }

  type tb_educationGetPayload<S extends boolean | null | undefined | tb_educationDefaultArgs> = $Result.GetResult<Prisma.$tb_educationPayload, S>

  type tb_educationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<tb_educationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Tb_educationCountAggregateInputType | true
    }

  export interface tb_educationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['tb_education'], meta: { name: 'tb_education' } }
    /**
     * Find zero or one Tb_education that matches the filter.
     * @param {tb_educationFindUniqueArgs} args - Arguments to find a Tb_education
     * @example
     * // Get one Tb_education
     * const tb_education = await prisma.tb_education.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends tb_educationFindUniqueArgs>(args: SelectSubset<T, tb_educationFindUniqueArgs<ExtArgs>>): Prisma__tb_educationClient<$Result.GetResult<Prisma.$tb_educationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Tb_education that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {tb_educationFindUniqueOrThrowArgs} args - Arguments to find a Tb_education
     * @example
     * // Get one Tb_education
     * const tb_education = await prisma.tb_education.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends tb_educationFindUniqueOrThrowArgs>(args: SelectSubset<T, tb_educationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__tb_educationClient<$Result.GetResult<Prisma.$tb_educationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tb_education that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_educationFindFirstArgs} args - Arguments to find a Tb_education
     * @example
     * // Get one Tb_education
     * const tb_education = await prisma.tb_education.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends tb_educationFindFirstArgs>(args?: SelectSubset<T, tb_educationFindFirstArgs<ExtArgs>>): Prisma__tb_educationClient<$Result.GetResult<Prisma.$tb_educationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tb_education that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_educationFindFirstOrThrowArgs} args - Arguments to find a Tb_education
     * @example
     * // Get one Tb_education
     * const tb_education = await prisma.tb_education.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends tb_educationFindFirstOrThrowArgs>(args?: SelectSubset<T, tb_educationFindFirstOrThrowArgs<ExtArgs>>): Prisma__tb_educationClient<$Result.GetResult<Prisma.$tb_educationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Tb_educations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_educationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tb_educations
     * const tb_educations = await prisma.tb_education.findMany()
     * 
     * // Get first 10 Tb_educations
     * const tb_educations = await prisma.tb_education.findMany({ take: 10 })
     * 
     * // Only select the `edu_id`
     * const tb_educationWithEdu_idOnly = await prisma.tb_education.findMany({ select: { edu_id: true } })
     * 
     */
    findMany<T extends tb_educationFindManyArgs>(args?: SelectSubset<T, tb_educationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tb_educationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Tb_education.
     * @param {tb_educationCreateArgs} args - Arguments to create a Tb_education.
     * @example
     * // Create one Tb_education
     * const Tb_education = await prisma.tb_education.create({
     *   data: {
     *     // ... data to create a Tb_education
     *   }
     * })
     * 
     */
    create<T extends tb_educationCreateArgs>(args: SelectSubset<T, tb_educationCreateArgs<ExtArgs>>): Prisma__tb_educationClient<$Result.GetResult<Prisma.$tb_educationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Tb_educations.
     * @param {tb_educationCreateManyArgs} args - Arguments to create many Tb_educations.
     * @example
     * // Create many Tb_educations
     * const tb_education = await prisma.tb_education.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends tb_educationCreateManyArgs>(args?: SelectSubset<T, tb_educationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Tb_education.
     * @param {tb_educationDeleteArgs} args - Arguments to delete one Tb_education.
     * @example
     * // Delete one Tb_education
     * const Tb_education = await prisma.tb_education.delete({
     *   where: {
     *     // ... filter to delete one Tb_education
     *   }
     * })
     * 
     */
    delete<T extends tb_educationDeleteArgs>(args: SelectSubset<T, tb_educationDeleteArgs<ExtArgs>>): Prisma__tb_educationClient<$Result.GetResult<Prisma.$tb_educationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Tb_education.
     * @param {tb_educationUpdateArgs} args - Arguments to update one Tb_education.
     * @example
     * // Update one Tb_education
     * const tb_education = await prisma.tb_education.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends tb_educationUpdateArgs>(args: SelectSubset<T, tb_educationUpdateArgs<ExtArgs>>): Prisma__tb_educationClient<$Result.GetResult<Prisma.$tb_educationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Tb_educations.
     * @param {tb_educationDeleteManyArgs} args - Arguments to filter Tb_educations to delete.
     * @example
     * // Delete a few Tb_educations
     * const { count } = await prisma.tb_education.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends tb_educationDeleteManyArgs>(args?: SelectSubset<T, tb_educationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tb_educations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_educationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tb_educations
     * const tb_education = await prisma.tb_education.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends tb_educationUpdateManyArgs>(args: SelectSubset<T, tb_educationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Tb_education.
     * @param {tb_educationUpsertArgs} args - Arguments to update or create a Tb_education.
     * @example
     * // Update or create a Tb_education
     * const tb_education = await prisma.tb_education.upsert({
     *   create: {
     *     // ... data to create a Tb_education
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tb_education we want to update
     *   }
     * })
     */
    upsert<T extends tb_educationUpsertArgs>(args: SelectSubset<T, tb_educationUpsertArgs<ExtArgs>>): Prisma__tb_educationClient<$Result.GetResult<Prisma.$tb_educationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Tb_educations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_educationCountArgs} args - Arguments to filter Tb_educations to count.
     * @example
     * // Count the number of Tb_educations
     * const count = await prisma.tb_education.count({
     *   where: {
     *     // ... the filter for the Tb_educations we want to count
     *   }
     * })
    **/
    count<T extends tb_educationCountArgs>(
      args?: Subset<T, tb_educationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Tb_educationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tb_education.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Tb_educationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Tb_educationAggregateArgs>(args: Subset<T, Tb_educationAggregateArgs>): Prisma.PrismaPromise<GetTb_educationAggregateType<T>>

    /**
     * Group by Tb_education.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_educationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends tb_educationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: tb_educationGroupByArgs['orderBy'] }
        : { orderBy?: tb_educationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, tb_educationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTb_educationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the tb_education model
   */
  readonly fields: tb_educationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for tb_education.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__tb_educationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the tb_education model
   */
  interface tb_educationFieldRefs {
    readonly edu_id: FieldRef<"tb_education", 'Int'>
    readonly specialization: FieldRef<"tb_education", 'String'>
    readonly institution: FieldRef<"tb_education", 'String'>
    readonly edu_lvl: FieldRef<"tb_education", 'Int'>
    readonly start_year: FieldRef<"tb_education", 'String'>
    readonly end_year: FieldRef<"tb_education", 'String'>
    readonly personal_id: FieldRef<"tb_education", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * tb_education findUnique
   */
  export type tb_educationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_education
     */
    select?: tb_educationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_education
     */
    omit?: tb_educationOmit<ExtArgs> | null
    /**
     * Filter, which tb_education to fetch.
     */
    where: tb_educationWhereUniqueInput
  }

  /**
   * tb_education findUniqueOrThrow
   */
  export type tb_educationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_education
     */
    select?: tb_educationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_education
     */
    omit?: tb_educationOmit<ExtArgs> | null
    /**
     * Filter, which tb_education to fetch.
     */
    where: tb_educationWhereUniqueInput
  }

  /**
   * tb_education findFirst
   */
  export type tb_educationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_education
     */
    select?: tb_educationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_education
     */
    omit?: tb_educationOmit<ExtArgs> | null
    /**
     * Filter, which tb_education to fetch.
     */
    where?: tb_educationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tb_educations to fetch.
     */
    orderBy?: tb_educationOrderByWithRelationInput | tb_educationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tb_educations.
     */
    cursor?: tb_educationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tb_educations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tb_educations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tb_educations.
     */
    distinct?: Tb_educationScalarFieldEnum | Tb_educationScalarFieldEnum[]
  }

  /**
   * tb_education findFirstOrThrow
   */
  export type tb_educationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_education
     */
    select?: tb_educationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_education
     */
    omit?: tb_educationOmit<ExtArgs> | null
    /**
     * Filter, which tb_education to fetch.
     */
    where?: tb_educationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tb_educations to fetch.
     */
    orderBy?: tb_educationOrderByWithRelationInput | tb_educationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tb_educations.
     */
    cursor?: tb_educationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tb_educations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tb_educations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tb_educations.
     */
    distinct?: Tb_educationScalarFieldEnum | Tb_educationScalarFieldEnum[]
  }

  /**
   * tb_education findMany
   */
  export type tb_educationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_education
     */
    select?: tb_educationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_education
     */
    omit?: tb_educationOmit<ExtArgs> | null
    /**
     * Filter, which tb_educations to fetch.
     */
    where?: tb_educationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tb_educations to fetch.
     */
    orderBy?: tb_educationOrderByWithRelationInput | tb_educationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing tb_educations.
     */
    cursor?: tb_educationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tb_educations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tb_educations.
     */
    skip?: number
    distinct?: Tb_educationScalarFieldEnum | Tb_educationScalarFieldEnum[]
  }

  /**
   * tb_education create
   */
  export type tb_educationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_education
     */
    select?: tb_educationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_education
     */
    omit?: tb_educationOmit<ExtArgs> | null
    /**
     * The data needed to create a tb_education.
     */
    data: XOR<tb_educationCreateInput, tb_educationUncheckedCreateInput>
  }

  /**
   * tb_education createMany
   */
  export type tb_educationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many tb_educations.
     */
    data: tb_educationCreateManyInput | tb_educationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * tb_education update
   */
  export type tb_educationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_education
     */
    select?: tb_educationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_education
     */
    omit?: tb_educationOmit<ExtArgs> | null
    /**
     * The data needed to update a tb_education.
     */
    data: XOR<tb_educationUpdateInput, tb_educationUncheckedUpdateInput>
    /**
     * Choose, which tb_education to update.
     */
    where: tb_educationWhereUniqueInput
  }

  /**
   * tb_education updateMany
   */
  export type tb_educationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update tb_educations.
     */
    data: XOR<tb_educationUpdateManyMutationInput, tb_educationUncheckedUpdateManyInput>
    /**
     * Filter which tb_educations to update
     */
    where?: tb_educationWhereInput
    /**
     * Limit how many tb_educations to update.
     */
    limit?: number
  }

  /**
   * tb_education upsert
   */
  export type tb_educationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_education
     */
    select?: tb_educationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_education
     */
    omit?: tb_educationOmit<ExtArgs> | null
    /**
     * The filter to search for the tb_education to update in case it exists.
     */
    where: tb_educationWhereUniqueInput
    /**
     * In case the tb_education found by the `where` argument doesn't exist, create a new tb_education with this data.
     */
    create: XOR<tb_educationCreateInput, tb_educationUncheckedCreateInput>
    /**
     * In case the tb_education was found with the provided `where` argument, update it with this data.
     */
    update: XOR<tb_educationUpdateInput, tb_educationUncheckedUpdateInput>
  }

  /**
   * tb_education delete
   */
  export type tb_educationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_education
     */
    select?: tb_educationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_education
     */
    omit?: tb_educationOmit<ExtArgs> | null
    /**
     * Filter which tb_education to delete.
     */
    where: tb_educationWhereUniqueInput
  }

  /**
   * tb_education deleteMany
   */
  export type tb_educationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tb_educations to delete
     */
    where?: tb_educationWhereInput
    /**
     * Limit how many tb_educations to delete.
     */
    limit?: number
  }

  /**
   * tb_education without action
   */
  export type tb_educationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_education
     */
    select?: tb_educationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_education
     */
    omit?: tb_educationOmit<ExtArgs> | null
  }


  /**
   * Model tb_employment
   */

  export type AggregateTb_employment = {
    _count: Tb_employmentCountAggregateOutputType | null
    _avg: Tb_employmentAvgAggregateOutputType | null
    _sum: Tb_employmentSumAggregateOutputType | null
    _min: Tb_employmentMinAggregateOutputType | null
    _max: Tb_employmentMaxAggregateOutputType | null
  }

  export type Tb_employmentAvgAggregateOutputType = {
    employment_id: number | null
    personal_id: number | null
  }

  export type Tb_employmentSumAggregateOutputType = {
    employment_id: number | null
    personal_id: number | null
  }

  export type Tb_employmentMinAggregateOutputType = {
    employment_id: number | null
    start_date: string | null
    end_date: string | null
    occupation: string | null
    organization: string | null
    personal_id: number | null
  }

  export type Tb_employmentMaxAggregateOutputType = {
    employment_id: number | null
    start_date: string | null
    end_date: string | null
    occupation: string | null
    organization: string | null
    personal_id: number | null
  }

  export type Tb_employmentCountAggregateOutputType = {
    employment_id: number
    start_date: number
    end_date: number
    occupation: number
    organization: number
    personal_id: number
    _all: number
  }


  export type Tb_employmentAvgAggregateInputType = {
    employment_id?: true
    personal_id?: true
  }

  export type Tb_employmentSumAggregateInputType = {
    employment_id?: true
    personal_id?: true
  }

  export type Tb_employmentMinAggregateInputType = {
    employment_id?: true
    start_date?: true
    end_date?: true
    occupation?: true
    organization?: true
    personal_id?: true
  }

  export type Tb_employmentMaxAggregateInputType = {
    employment_id?: true
    start_date?: true
    end_date?: true
    occupation?: true
    organization?: true
    personal_id?: true
  }

  export type Tb_employmentCountAggregateInputType = {
    employment_id?: true
    start_date?: true
    end_date?: true
    occupation?: true
    organization?: true
    personal_id?: true
    _all?: true
  }

  export type Tb_employmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tb_employment to aggregate.
     */
    where?: tb_employmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tb_employments to fetch.
     */
    orderBy?: tb_employmentOrderByWithRelationInput | tb_employmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: tb_employmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tb_employments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tb_employments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned tb_employments
    **/
    _count?: true | Tb_employmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Tb_employmentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Tb_employmentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Tb_employmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Tb_employmentMaxAggregateInputType
  }

  export type GetTb_employmentAggregateType<T extends Tb_employmentAggregateArgs> = {
        [P in keyof T & keyof AggregateTb_employment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTb_employment[P]>
      : GetScalarType<T[P], AggregateTb_employment[P]>
  }




  export type tb_employmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: tb_employmentWhereInput
    orderBy?: tb_employmentOrderByWithAggregationInput | tb_employmentOrderByWithAggregationInput[]
    by: Tb_employmentScalarFieldEnum[] | Tb_employmentScalarFieldEnum
    having?: tb_employmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Tb_employmentCountAggregateInputType | true
    _avg?: Tb_employmentAvgAggregateInputType
    _sum?: Tb_employmentSumAggregateInputType
    _min?: Tb_employmentMinAggregateInputType
    _max?: Tb_employmentMaxAggregateInputType
  }

  export type Tb_employmentGroupByOutputType = {
    employment_id: number
    start_date: string | null
    end_date: string | null
    occupation: string | null
    organization: string | null
    personal_id: number
    _count: Tb_employmentCountAggregateOutputType | null
    _avg: Tb_employmentAvgAggregateOutputType | null
    _sum: Tb_employmentSumAggregateOutputType | null
    _min: Tb_employmentMinAggregateOutputType | null
    _max: Tb_employmentMaxAggregateOutputType | null
  }

  type GetTb_employmentGroupByPayload<T extends tb_employmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Tb_employmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Tb_employmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Tb_employmentGroupByOutputType[P]>
            : GetScalarType<T[P], Tb_employmentGroupByOutputType[P]>
        }
      >
    >


  export type tb_employmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    employment_id?: boolean
    start_date?: boolean
    end_date?: boolean
    occupation?: boolean
    organization?: boolean
    personal_id?: boolean
  }, ExtArgs["result"]["tb_employment"]>



  export type tb_employmentSelectScalar = {
    employment_id?: boolean
    start_date?: boolean
    end_date?: boolean
    occupation?: boolean
    organization?: boolean
    personal_id?: boolean
  }

  export type tb_employmentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"employment_id" | "start_date" | "end_date" | "occupation" | "organization" | "personal_id", ExtArgs["result"]["tb_employment"]>

  export type $tb_employmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "tb_employment"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      employment_id: number
      start_date: string | null
      end_date: string | null
      occupation: string | null
      organization: string | null
      personal_id: number
    }, ExtArgs["result"]["tb_employment"]>
    composites: {}
  }

  type tb_employmentGetPayload<S extends boolean | null | undefined | tb_employmentDefaultArgs> = $Result.GetResult<Prisma.$tb_employmentPayload, S>

  type tb_employmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<tb_employmentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Tb_employmentCountAggregateInputType | true
    }

  export interface tb_employmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['tb_employment'], meta: { name: 'tb_employment' } }
    /**
     * Find zero or one Tb_employment that matches the filter.
     * @param {tb_employmentFindUniqueArgs} args - Arguments to find a Tb_employment
     * @example
     * // Get one Tb_employment
     * const tb_employment = await prisma.tb_employment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends tb_employmentFindUniqueArgs>(args: SelectSubset<T, tb_employmentFindUniqueArgs<ExtArgs>>): Prisma__tb_employmentClient<$Result.GetResult<Prisma.$tb_employmentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Tb_employment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {tb_employmentFindUniqueOrThrowArgs} args - Arguments to find a Tb_employment
     * @example
     * // Get one Tb_employment
     * const tb_employment = await prisma.tb_employment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends tb_employmentFindUniqueOrThrowArgs>(args: SelectSubset<T, tb_employmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__tb_employmentClient<$Result.GetResult<Prisma.$tb_employmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tb_employment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_employmentFindFirstArgs} args - Arguments to find a Tb_employment
     * @example
     * // Get one Tb_employment
     * const tb_employment = await prisma.tb_employment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends tb_employmentFindFirstArgs>(args?: SelectSubset<T, tb_employmentFindFirstArgs<ExtArgs>>): Prisma__tb_employmentClient<$Result.GetResult<Prisma.$tb_employmentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tb_employment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_employmentFindFirstOrThrowArgs} args - Arguments to find a Tb_employment
     * @example
     * // Get one Tb_employment
     * const tb_employment = await prisma.tb_employment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends tb_employmentFindFirstOrThrowArgs>(args?: SelectSubset<T, tb_employmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__tb_employmentClient<$Result.GetResult<Prisma.$tb_employmentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Tb_employments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_employmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tb_employments
     * const tb_employments = await prisma.tb_employment.findMany()
     * 
     * // Get first 10 Tb_employments
     * const tb_employments = await prisma.tb_employment.findMany({ take: 10 })
     * 
     * // Only select the `employment_id`
     * const tb_employmentWithEmployment_idOnly = await prisma.tb_employment.findMany({ select: { employment_id: true } })
     * 
     */
    findMany<T extends tb_employmentFindManyArgs>(args?: SelectSubset<T, tb_employmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tb_employmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Tb_employment.
     * @param {tb_employmentCreateArgs} args - Arguments to create a Tb_employment.
     * @example
     * // Create one Tb_employment
     * const Tb_employment = await prisma.tb_employment.create({
     *   data: {
     *     // ... data to create a Tb_employment
     *   }
     * })
     * 
     */
    create<T extends tb_employmentCreateArgs>(args: SelectSubset<T, tb_employmentCreateArgs<ExtArgs>>): Prisma__tb_employmentClient<$Result.GetResult<Prisma.$tb_employmentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Tb_employments.
     * @param {tb_employmentCreateManyArgs} args - Arguments to create many Tb_employments.
     * @example
     * // Create many Tb_employments
     * const tb_employment = await prisma.tb_employment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends tb_employmentCreateManyArgs>(args?: SelectSubset<T, tb_employmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Tb_employment.
     * @param {tb_employmentDeleteArgs} args - Arguments to delete one Tb_employment.
     * @example
     * // Delete one Tb_employment
     * const Tb_employment = await prisma.tb_employment.delete({
     *   where: {
     *     // ... filter to delete one Tb_employment
     *   }
     * })
     * 
     */
    delete<T extends tb_employmentDeleteArgs>(args: SelectSubset<T, tb_employmentDeleteArgs<ExtArgs>>): Prisma__tb_employmentClient<$Result.GetResult<Prisma.$tb_employmentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Tb_employment.
     * @param {tb_employmentUpdateArgs} args - Arguments to update one Tb_employment.
     * @example
     * // Update one Tb_employment
     * const tb_employment = await prisma.tb_employment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends tb_employmentUpdateArgs>(args: SelectSubset<T, tb_employmentUpdateArgs<ExtArgs>>): Prisma__tb_employmentClient<$Result.GetResult<Prisma.$tb_employmentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Tb_employments.
     * @param {tb_employmentDeleteManyArgs} args - Arguments to filter Tb_employments to delete.
     * @example
     * // Delete a few Tb_employments
     * const { count } = await prisma.tb_employment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends tb_employmentDeleteManyArgs>(args?: SelectSubset<T, tb_employmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tb_employments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_employmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tb_employments
     * const tb_employment = await prisma.tb_employment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends tb_employmentUpdateManyArgs>(args: SelectSubset<T, tb_employmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Tb_employment.
     * @param {tb_employmentUpsertArgs} args - Arguments to update or create a Tb_employment.
     * @example
     * // Update or create a Tb_employment
     * const tb_employment = await prisma.tb_employment.upsert({
     *   create: {
     *     // ... data to create a Tb_employment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tb_employment we want to update
     *   }
     * })
     */
    upsert<T extends tb_employmentUpsertArgs>(args: SelectSubset<T, tb_employmentUpsertArgs<ExtArgs>>): Prisma__tb_employmentClient<$Result.GetResult<Prisma.$tb_employmentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Tb_employments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_employmentCountArgs} args - Arguments to filter Tb_employments to count.
     * @example
     * // Count the number of Tb_employments
     * const count = await prisma.tb_employment.count({
     *   where: {
     *     // ... the filter for the Tb_employments we want to count
     *   }
     * })
    **/
    count<T extends tb_employmentCountArgs>(
      args?: Subset<T, tb_employmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Tb_employmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tb_employment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Tb_employmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Tb_employmentAggregateArgs>(args: Subset<T, Tb_employmentAggregateArgs>): Prisma.PrismaPromise<GetTb_employmentAggregateType<T>>

    /**
     * Group by Tb_employment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_employmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends tb_employmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: tb_employmentGroupByArgs['orderBy'] }
        : { orderBy?: tb_employmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, tb_employmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTb_employmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the tb_employment model
   */
  readonly fields: tb_employmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for tb_employment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__tb_employmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the tb_employment model
   */
  interface tb_employmentFieldRefs {
    readonly employment_id: FieldRef<"tb_employment", 'Int'>
    readonly start_date: FieldRef<"tb_employment", 'String'>
    readonly end_date: FieldRef<"tb_employment", 'String'>
    readonly occupation: FieldRef<"tb_employment", 'String'>
    readonly organization: FieldRef<"tb_employment", 'String'>
    readonly personal_id: FieldRef<"tb_employment", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * tb_employment findUnique
   */
  export type tb_employmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_employment
     */
    select?: tb_employmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_employment
     */
    omit?: tb_employmentOmit<ExtArgs> | null
    /**
     * Filter, which tb_employment to fetch.
     */
    where: tb_employmentWhereUniqueInput
  }

  /**
   * tb_employment findUniqueOrThrow
   */
  export type tb_employmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_employment
     */
    select?: tb_employmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_employment
     */
    omit?: tb_employmentOmit<ExtArgs> | null
    /**
     * Filter, which tb_employment to fetch.
     */
    where: tb_employmentWhereUniqueInput
  }

  /**
   * tb_employment findFirst
   */
  export type tb_employmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_employment
     */
    select?: tb_employmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_employment
     */
    omit?: tb_employmentOmit<ExtArgs> | null
    /**
     * Filter, which tb_employment to fetch.
     */
    where?: tb_employmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tb_employments to fetch.
     */
    orderBy?: tb_employmentOrderByWithRelationInput | tb_employmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tb_employments.
     */
    cursor?: tb_employmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tb_employments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tb_employments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tb_employments.
     */
    distinct?: Tb_employmentScalarFieldEnum | Tb_employmentScalarFieldEnum[]
  }

  /**
   * tb_employment findFirstOrThrow
   */
  export type tb_employmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_employment
     */
    select?: tb_employmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_employment
     */
    omit?: tb_employmentOmit<ExtArgs> | null
    /**
     * Filter, which tb_employment to fetch.
     */
    where?: tb_employmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tb_employments to fetch.
     */
    orderBy?: tb_employmentOrderByWithRelationInput | tb_employmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tb_employments.
     */
    cursor?: tb_employmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tb_employments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tb_employments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tb_employments.
     */
    distinct?: Tb_employmentScalarFieldEnum | Tb_employmentScalarFieldEnum[]
  }

  /**
   * tb_employment findMany
   */
  export type tb_employmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_employment
     */
    select?: tb_employmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_employment
     */
    omit?: tb_employmentOmit<ExtArgs> | null
    /**
     * Filter, which tb_employments to fetch.
     */
    where?: tb_employmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tb_employments to fetch.
     */
    orderBy?: tb_employmentOrderByWithRelationInput | tb_employmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing tb_employments.
     */
    cursor?: tb_employmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tb_employments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tb_employments.
     */
    skip?: number
    distinct?: Tb_employmentScalarFieldEnum | Tb_employmentScalarFieldEnum[]
  }

  /**
   * tb_employment create
   */
  export type tb_employmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_employment
     */
    select?: tb_employmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_employment
     */
    omit?: tb_employmentOmit<ExtArgs> | null
    /**
     * The data needed to create a tb_employment.
     */
    data: XOR<tb_employmentCreateInput, tb_employmentUncheckedCreateInput>
  }

  /**
   * tb_employment createMany
   */
  export type tb_employmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many tb_employments.
     */
    data: tb_employmentCreateManyInput | tb_employmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * tb_employment update
   */
  export type tb_employmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_employment
     */
    select?: tb_employmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_employment
     */
    omit?: tb_employmentOmit<ExtArgs> | null
    /**
     * The data needed to update a tb_employment.
     */
    data: XOR<tb_employmentUpdateInput, tb_employmentUncheckedUpdateInput>
    /**
     * Choose, which tb_employment to update.
     */
    where: tb_employmentWhereUniqueInput
  }

  /**
   * tb_employment updateMany
   */
  export type tb_employmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update tb_employments.
     */
    data: XOR<tb_employmentUpdateManyMutationInput, tb_employmentUncheckedUpdateManyInput>
    /**
     * Filter which tb_employments to update
     */
    where?: tb_employmentWhereInput
    /**
     * Limit how many tb_employments to update.
     */
    limit?: number
  }

  /**
   * tb_employment upsert
   */
  export type tb_employmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_employment
     */
    select?: tb_employmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_employment
     */
    omit?: tb_employmentOmit<ExtArgs> | null
    /**
     * The filter to search for the tb_employment to update in case it exists.
     */
    where: tb_employmentWhereUniqueInput
    /**
     * In case the tb_employment found by the `where` argument doesn't exist, create a new tb_employment with this data.
     */
    create: XOR<tb_employmentCreateInput, tb_employmentUncheckedCreateInput>
    /**
     * In case the tb_employment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<tb_employmentUpdateInput, tb_employmentUncheckedUpdateInput>
  }

  /**
   * tb_employment delete
   */
  export type tb_employmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_employment
     */
    select?: tb_employmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_employment
     */
    omit?: tb_employmentOmit<ExtArgs> | null
    /**
     * Filter which tb_employment to delete.
     */
    where: tb_employmentWhereUniqueInput
  }

  /**
   * tb_employment deleteMany
   */
  export type tb_employmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tb_employments to delete
     */
    where?: tb_employmentWhereInput
    /**
     * Limit how many tb_employments to delete.
     */
    limit?: number
  }

  /**
   * tb_employment without action
   */
  export type tb_employmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_employment
     */
    select?: tb_employmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_employment
     */
    omit?: tb_employmentOmit<ExtArgs> | null
  }


  /**
   * Model tb_etnics
   */

  export type AggregateTb_etnics = {
    _count: Tb_etnicsCountAggregateOutputType | null
    _avg: Tb_etnicsAvgAggregateOutputType | null
    _sum: Tb_etnicsSumAggregateOutputType | null
    _min: Tb_etnicsMinAggregateOutputType | null
    _max: Tb_etnicsMaxAggregateOutputType | null
  }

  export type Tb_etnicsAvgAggregateOutputType = {
    etnic_id: number | null
  }

  export type Tb_etnicsSumAggregateOutputType = {
    etnic_id: number | null
  }

  export type Tb_etnicsMinAggregateOutputType = {
    etnic_id: number | null
    etnic_arm: string | null
    etnic_eng: string | null
  }

  export type Tb_etnicsMaxAggregateOutputType = {
    etnic_id: number | null
    etnic_arm: string | null
    etnic_eng: string | null
  }

  export type Tb_etnicsCountAggregateOutputType = {
    etnic_id: number
    etnic_arm: number
    etnic_eng: number
    _all: number
  }


  export type Tb_etnicsAvgAggregateInputType = {
    etnic_id?: true
  }

  export type Tb_etnicsSumAggregateInputType = {
    etnic_id?: true
  }

  export type Tb_etnicsMinAggregateInputType = {
    etnic_id?: true
    etnic_arm?: true
    etnic_eng?: true
  }

  export type Tb_etnicsMaxAggregateInputType = {
    etnic_id?: true
    etnic_arm?: true
    etnic_eng?: true
  }

  export type Tb_etnicsCountAggregateInputType = {
    etnic_id?: true
    etnic_arm?: true
    etnic_eng?: true
    _all?: true
  }

  export type Tb_etnicsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tb_etnics to aggregate.
     */
    where?: tb_etnicsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tb_etnics to fetch.
     */
    orderBy?: tb_etnicsOrderByWithRelationInput | tb_etnicsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: tb_etnicsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tb_etnics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tb_etnics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned tb_etnics
    **/
    _count?: true | Tb_etnicsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Tb_etnicsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Tb_etnicsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Tb_etnicsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Tb_etnicsMaxAggregateInputType
  }

  export type GetTb_etnicsAggregateType<T extends Tb_etnicsAggregateArgs> = {
        [P in keyof T & keyof AggregateTb_etnics]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTb_etnics[P]>
      : GetScalarType<T[P], AggregateTb_etnics[P]>
  }




  export type tb_etnicsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: tb_etnicsWhereInput
    orderBy?: tb_etnicsOrderByWithAggregationInput | tb_etnicsOrderByWithAggregationInput[]
    by: Tb_etnicsScalarFieldEnum[] | Tb_etnicsScalarFieldEnum
    having?: tb_etnicsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Tb_etnicsCountAggregateInputType | true
    _avg?: Tb_etnicsAvgAggregateInputType
    _sum?: Tb_etnicsSumAggregateInputType
    _min?: Tb_etnicsMinAggregateInputType
    _max?: Tb_etnicsMaxAggregateInputType
  }

  export type Tb_etnicsGroupByOutputType = {
    etnic_id: number
    etnic_arm: string
    etnic_eng: string
    _count: Tb_etnicsCountAggregateOutputType | null
    _avg: Tb_etnicsAvgAggregateOutputType | null
    _sum: Tb_etnicsSumAggregateOutputType | null
    _min: Tb_etnicsMinAggregateOutputType | null
    _max: Tb_etnicsMaxAggregateOutputType | null
  }

  type GetTb_etnicsGroupByPayload<T extends tb_etnicsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Tb_etnicsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Tb_etnicsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Tb_etnicsGroupByOutputType[P]>
            : GetScalarType<T[P], Tb_etnicsGroupByOutputType[P]>
        }
      >
    >


  export type tb_etnicsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    etnic_id?: boolean
    etnic_arm?: boolean
    etnic_eng?: boolean
  }, ExtArgs["result"]["tb_etnics"]>



  export type tb_etnicsSelectScalar = {
    etnic_id?: boolean
    etnic_arm?: boolean
    etnic_eng?: boolean
  }

  export type tb_etnicsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"etnic_id" | "etnic_arm" | "etnic_eng", ExtArgs["result"]["tb_etnics"]>

  export type $tb_etnicsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "tb_etnics"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      etnic_id: number
      etnic_arm: string
      etnic_eng: string
    }, ExtArgs["result"]["tb_etnics"]>
    composites: {}
  }

  type tb_etnicsGetPayload<S extends boolean | null | undefined | tb_etnicsDefaultArgs> = $Result.GetResult<Prisma.$tb_etnicsPayload, S>

  type tb_etnicsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<tb_etnicsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Tb_etnicsCountAggregateInputType | true
    }

  export interface tb_etnicsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['tb_etnics'], meta: { name: 'tb_etnics' } }
    /**
     * Find zero or one Tb_etnics that matches the filter.
     * @param {tb_etnicsFindUniqueArgs} args - Arguments to find a Tb_etnics
     * @example
     * // Get one Tb_etnics
     * const tb_etnics = await prisma.tb_etnics.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends tb_etnicsFindUniqueArgs>(args: SelectSubset<T, tb_etnicsFindUniqueArgs<ExtArgs>>): Prisma__tb_etnicsClient<$Result.GetResult<Prisma.$tb_etnicsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Tb_etnics that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {tb_etnicsFindUniqueOrThrowArgs} args - Arguments to find a Tb_etnics
     * @example
     * // Get one Tb_etnics
     * const tb_etnics = await prisma.tb_etnics.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends tb_etnicsFindUniqueOrThrowArgs>(args: SelectSubset<T, tb_etnicsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__tb_etnicsClient<$Result.GetResult<Prisma.$tb_etnicsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tb_etnics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_etnicsFindFirstArgs} args - Arguments to find a Tb_etnics
     * @example
     * // Get one Tb_etnics
     * const tb_etnics = await prisma.tb_etnics.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends tb_etnicsFindFirstArgs>(args?: SelectSubset<T, tb_etnicsFindFirstArgs<ExtArgs>>): Prisma__tb_etnicsClient<$Result.GetResult<Prisma.$tb_etnicsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tb_etnics that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_etnicsFindFirstOrThrowArgs} args - Arguments to find a Tb_etnics
     * @example
     * // Get one Tb_etnics
     * const tb_etnics = await prisma.tb_etnics.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends tb_etnicsFindFirstOrThrowArgs>(args?: SelectSubset<T, tb_etnicsFindFirstOrThrowArgs<ExtArgs>>): Prisma__tb_etnicsClient<$Result.GetResult<Prisma.$tb_etnicsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Tb_etnics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_etnicsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tb_etnics
     * const tb_etnics = await prisma.tb_etnics.findMany()
     * 
     * // Get first 10 Tb_etnics
     * const tb_etnics = await prisma.tb_etnics.findMany({ take: 10 })
     * 
     * // Only select the `etnic_id`
     * const tb_etnicsWithEtnic_idOnly = await prisma.tb_etnics.findMany({ select: { etnic_id: true } })
     * 
     */
    findMany<T extends tb_etnicsFindManyArgs>(args?: SelectSubset<T, tb_etnicsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tb_etnicsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Tb_etnics.
     * @param {tb_etnicsCreateArgs} args - Arguments to create a Tb_etnics.
     * @example
     * // Create one Tb_etnics
     * const Tb_etnics = await prisma.tb_etnics.create({
     *   data: {
     *     // ... data to create a Tb_etnics
     *   }
     * })
     * 
     */
    create<T extends tb_etnicsCreateArgs>(args: SelectSubset<T, tb_etnicsCreateArgs<ExtArgs>>): Prisma__tb_etnicsClient<$Result.GetResult<Prisma.$tb_etnicsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Tb_etnics.
     * @param {tb_etnicsCreateManyArgs} args - Arguments to create many Tb_etnics.
     * @example
     * // Create many Tb_etnics
     * const tb_etnics = await prisma.tb_etnics.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends tb_etnicsCreateManyArgs>(args?: SelectSubset<T, tb_etnicsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Tb_etnics.
     * @param {tb_etnicsDeleteArgs} args - Arguments to delete one Tb_etnics.
     * @example
     * // Delete one Tb_etnics
     * const Tb_etnics = await prisma.tb_etnics.delete({
     *   where: {
     *     // ... filter to delete one Tb_etnics
     *   }
     * })
     * 
     */
    delete<T extends tb_etnicsDeleteArgs>(args: SelectSubset<T, tb_etnicsDeleteArgs<ExtArgs>>): Prisma__tb_etnicsClient<$Result.GetResult<Prisma.$tb_etnicsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Tb_etnics.
     * @param {tb_etnicsUpdateArgs} args - Arguments to update one Tb_etnics.
     * @example
     * // Update one Tb_etnics
     * const tb_etnics = await prisma.tb_etnics.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends tb_etnicsUpdateArgs>(args: SelectSubset<T, tb_etnicsUpdateArgs<ExtArgs>>): Prisma__tb_etnicsClient<$Result.GetResult<Prisma.$tb_etnicsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Tb_etnics.
     * @param {tb_etnicsDeleteManyArgs} args - Arguments to filter Tb_etnics to delete.
     * @example
     * // Delete a few Tb_etnics
     * const { count } = await prisma.tb_etnics.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends tb_etnicsDeleteManyArgs>(args?: SelectSubset<T, tb_etnicsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tb_etnics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_etnicsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tb_etnics
     * const tb_etnics = await prisma.tb_etnics.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends tb_etnicsUpdateManyArgs>(args: SelectSubset<T, tb_etnicsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Tb_etnics.
     * @param {tb_etnicsUpsertArgs} args - Arguments to update or create a Tb_etnics.
     * @example
     * // Update or create a Tb_etnics
     * const tb_etnics = await prisma.tb_etnics.upsert({
     *   create: {
     *     // ... data to create a Tb_etnics
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tb_etnics we want to update
     *   }
     * })
     */
    upsert<T extends tb_etnicsUpsertArgs>(args: SelectSubset<T, tb_etnicsUpsertArgs<ExtArgs>>): Prisma__tb_etnicsClient<$Result.GetResult<Prisma.$tb_etnicsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Tb_etnics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_etnicsCountArgs} args - Arguments to filter Tb_etnics to count.
     * @example
     * // Count the number of Tb_etnics
     * const count = await prisma.tb_etnics.count({
     *   where: {
     *     // ... the filter for the Tb_etnics we want to count
     *   }
     * })
    **/
    count<T extends tb_etnicsCountArgs>(
      args?: Subset<T, tb_etnicsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Tb_etnicsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tb_etnics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Tb_etnicsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Tb_etnicsAggregateArgs>(args: Subset<T, Tb_etnicsAggregateArgs>): Prisma.PrismaPromise<GetTb_etnicsAggregateType<T>>

    /**
     * Group by Tb_etnics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_etnicsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends tb_etnicsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: tb_etnicsGroupByArgs['orderBy'] }
        : { orderBy?: tb_etnicsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, tb_etnicsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTb_etnicsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the tb_etnics model
   */
  readonly fields: tb_etnicsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for tb_etnics.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__tb_etnicsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the tb_etnics model
   */
  interface tb_etnicsFieldRefs {
    readonly etnic_id: FieldRef<"tb_etnics", 'Int'>
    readonly etnic_arm: FieldRef<"tb_etnics", 'String'>
    readonly etnic_eng: FieldRef<"tb_etnics", 'String'>
  }
    

  // Custom InputTypes
  /**
   * tb_etnics findUnique
   */
  export type tb_etnicsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_etnics
     */
    select?: tb_etnicsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_etnics
     */
    omit?: tb_etnicsOmit<ExtArgs> | null
    /**
     * Filter, which tb_etnics to fetch.
     */
    where: tb_etnicsWhereUniqueInput
  }

  /**
   * tb_etnics findUniqueOrThrow
   */
  export type tb_etnicsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_etnics
     */
    select?: tb_etnicsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_etnics
     */
    omit?: tb_etnicsOmit<ExtArgs> | null
    /**
     * Filter, which tb_etnics to fetch.
     */
    where: tb_etnicsWhereUniqueInput
  }

  /**
   * tb_etnics findFirst
   */
  export type tb_etnicsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_etnics
     */
    select?: tb_etnicsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_etnics
     */
    omit?: tb_etnicsOmit<ExtArgs> | null
    /**
     * Filter, which tb_etnics to fetch.
     */
    where?: tb_etnicsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tb_etnics to fetch.
     */
    orderBy?: tb_etnicsOrderByWithRelationInput | tb_etnicsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tb_etnics.
     */
    cursor?: tb_etnicsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tb_etnics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tb_etnics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tb_etnics.
     */
    distinct?: Tb_etnicsScalarFieldEnum | Tb_etnicsScalarFieldEnum[]
  }

  /**
   * tb_etnics findFirstOrThrow
   */
  export type tb_etnicsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_etnics
     */
    select?: tb_etnicsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_etnics
     */
    omit?: tb_etnicsOmit<ExtArgs> | null
    /**
     * Filter, which tb_etnics to fetch.
     */
    where?: tb_etnicsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tb_etnics to fetch.
     */
    orderBy?: tb_etnicsOrderByWithRelationInput | tb_etnicsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tb_etnics.
     */
    cursor?: tb_etnicsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tb_etnics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tb_etnics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tb_etnics.
     */
    distinct?: Tb_etnicsScalarFieldEnum | Tb_etnicsScalarFieldEnum[]
  }

  /**
   * tb_etnics findMany
   */
  export type tb_etnicsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_etnics
     */
    select?: tb_etnicsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_etnics
     */
    omit?: tb_etnicsOmit<ExtArgs> | null
    /**
     * Filter, which tb_etnics to fetch.
     */
    where?: tb_etnicsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tb_etnics to fetch.
     */
    orderBy?: tb_etnicsOrderByWithRelationInput | tb_etnicsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing tb_etnics.
     */
    cursor?: tb_etnicsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tb_etnics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tb_etnics.
     */
    skip?: number
    distinct?: Tb_etnicsScalarFieldEnum | Tb_etnicsScalarFieldEnum[]
  }

  /**
   * tb_etnics create
   */
  export type tb_etnicsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_etnics
     */
    select?: tb_etnicsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_etnics
     */
    omit?: tb_etnicsOmit<ExtArgs> | null
    /**
     * The data needed to create a tb_etnics.
     */
    data: XOR<tb_etnicsCreateInput, tb_etnicsUncheckedCreateInput>
  }

  /**
   * tb_etnics createMany
   */
  export type tb_etnicsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many tb_etnics.
     */
    data: tb_etnicsCreateManyInput | tb_etnicsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * tb_etnics update
   */
  export type tb_etnicsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_etnics
     */
    select?: tb_etnicsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_etnics
     */
    omit?: tb_etnicsOmit<ExtArgs> | null
    /**
     * The data needed to update a tb_etnics.
     */
    data: XOR<tb_etnicsUpdateInput, tb_etnicsUncheckedUpdateInput>
    /**
     * Choose, which tb_etnics to update.
     */
    where: tb_etnicsWhereUniqueInput
  }

  /**
   * tb_etnics updateMany
   */
  export type tb_etnicsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update tb_etnics.
     */
    data: XOR<tb_etnicsUpdateManyMutationInput, tb_etnicsUncheckedUpdateManyInput>
    /**
     * Filter which tb_etnics to update
     */
    where?: tb_etnicsWhereInput
    /**
     * Limit how many tb_etnics to update.
     */
    limit?: number
  }

  /**
   * tb_etnics upsert
   */
  export type tb_etnicsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_etnics
     */
    select?: tb_etnicsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_etnics
     */
    omit?: tb_etnicsOmit<ExtArgs> | null
    /**
     * The filter to search for the tb_etnics to update in case it exists.
     */
    where: tb_etnicsWhereUniqueInput
    /**
     * In case the tb_etnics found by the `where` argument doesn't exist, create a new tb_etnics with this data.
     */
    create: XOR<tb_etnicsCreateInput, tb_etnicsUncheckedCreateInput>
    /**
     * In case the tb_etnics was found with the provided `where` argument, update it with this data.
     */
    update: XOR<tb_etnicsUpdateInput, tb_etnicsUncheckedUpdateInput>
  }

  /**
   * tb_etnics delete
   */
  export type tb_etnicsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_etnics
     */
    select?: tb_etnicsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_etnics
     */
    omit?: tb_etnicsOmit<ExtArgs> | null
    /**
     * Filter which tb_etnics to delete.
     */
    where: tb_etnicsWhereUniqueInput
  }

  /**
   * tb_etnics deleteMany
   */
  export type tb_etnicsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tb_etnics to delete
     */
    where?: tb_etnicsWhereInput
    /**
     * Limit how many tb_etnics to delete.
     */
    limit?: number
  }

  /**
   * tb_etnics without action
   */
  export type tb_etnicsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_etnics
     */
    select?: tb_etnicsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_etnics
     */
    omit?: tb_etnicsOmit<ExtArgs> | null
  }


  /**
   * Model tb_file_type
   */

  export type AggregateTb_file_type = {
    _count: Tb_file_typeCountAggregateOutputType | null
    _avg: Tb_file_typeAvgAggregateOutputType | null
    _sum: Tb_file_typeSumAggregateOutputType | null
    _min: Tb_file_typeMinAggregateOutputType | null
    _max: Tb_file_typeMaxAggregateOutputType | null
  }

  export type Tb_file_typeAvgAggregateOutputType = {
    file_type_id: number | null
    file_filter: number | null
  }

  export type Tb_file_typeSumAggregateOutputType = {
    file_type_id: number | null
    file_filter: number | null
  }

  export type Tb_file_typeMinAggregateOutputType = {
    file_type_id: number | null
    file_type: string | null
    file_filter: number | null
  }

  export type Tb_file_typeMaxAggregateOutputType = {
    file_type_id: number | null
    file_type: string | null
    file_filter: number | null
  }

  export type Tb_file_typeCountAggregateOutputType = {
    file_type_id: number
    file_type: number
    file_filter: number
    _all: number
  }


  export type Tb_file_typeAvgAggregateInputType = {
    file_type_id?: true
    file_filter?: true
  }

  export type Tb_file_typeSumAggregateInputType = {
    file_type_id?: true
    file_filter?: true
  }

  export type Tb_file_typeMinAggregateInputType = {
    file_type_id?: true
    file_type?: true
    file_filter?: true
  }

  export type Tb_file_typeMaxAggregateInputType = {
    file_type_id?: true
    file_type?: true
    file_filter?: true
  }

  export type Tb_file_typeCountAggregateInputType = {
    file_type_id?: true
    file_type?: true
    file_filter?: true
    _all?: true
  }

  export type Tb_file_typeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tb_file_type to aggregate.
     */
    where?: tb_file_typeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tb_file_types to fetch.
     */
    orderBy?: tb_file_typeOrderByWithRelationInput | tb_file_typeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: tb_file_typeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tb_file_types from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tb_file_types.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned tb_file_types
    **/
    _count?: true | Tb_file_typeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Tb_file_typeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Tb_file_typeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Tb_file_typeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Tb_file_typeMaxAggregateInputType
  }

  export type GetTb_file_typeAggregateType<T extends Tb_file_typeAggregateArgs> = {
        [P in keyof T & keyof AggregateTb_file_type]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTb_file_type[P]>
      : GetScalarType<T[P], AggregateTb_file_type[P]>
  }




  export type tb_file_typeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: tb_file_typeWhereInput
    orderBy?: tb_file_typeOrderByWithAggregationInput | tb_file_typeOrderByWithAggregationInput[]
    by: Tb_file_typeScalarFieldEnum[] | Tb_file_typeScalarFieldEnum
    having?: tb_file_typeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Tb_file_typeCountAggregateInputType | true
    _avg?: Tb_file_typeAvgAggregateInputType
    _sum?: Tb_file_typeSumAggregateInputType
    _min?: Tb_file_typeMinAggregateInputType
    _max?: Tb_file_typeMaxAggregateInputType
  }

  export type Tb_file_typeGroupByOutputType = {
    file_type_id: number
    file_type: string
    file_filter: number
    _count: Tb_file_typeCountAggregateOutputType | null
    _avg: Tb_file_typeAvgAggregateOutputType | null
    _sum: Tb_file_typeSumAggregateOutputType | null
    _min: Tb_file_typeMinAggregateOutputType | null
    _max: Tb_file_typeMaxAggregateOutputType | null
  }

  type GetTb_file_typeGroupByPayload<T extends tb_file_typeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Tb_file_typeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Tb_file_typeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Tb_file_typeGroupByOutputType[P]>
            : GetScalarType<T[P], Tb_file_typeGroupByOutputType[P]>
        }
      >
    >


  export type tb_file_typeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    file_type_id?: boolean
    file_type?: boolean
    file_filter?: boolean
  }, ExtArgs["result"]["tb_file_type"]>



  export type tb_file_typeSelectScalar = {
    file_type_id?: boolean
    file_type?: boolean
    file_filter?: boolean
  }

  export type tb_file_typeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"file_type_id" | "file_type" | "file_filter", ExtArgs["result"]["tb_file_type"]>

  export type $tb_file_typePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "tb_file_type"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      file_type_id: number
      file_type: string
      file_filter: number
    }, ExtArgs["result"]["tb_file_type"]>
    composites: {}
  }

  type tb_file_typeGetPayload<S extends boolean | null | undefined | tb_file_typeDefaultArgs> = $Result.GetResult<Prisma.$tb_file_typePayload, S>

  type tb_file_typeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<tb_file_typeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Tb_file_typeCountAggregateInputType | true
    }

  export interface tb_file_typeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['tb_file_type'], meta: { name: 'tb_file_type' } }
    /**
     * Find zero or one Tb_file_type that matches the filter.
     * @param {tb_file_typeFindUniqueArgs} args - Arguments to find a Tb_file_type
     * @example
     * // Get one Tb_file_type
     * const tb_file_type = await prisma.tb_file_type.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends tb_file_typeFindUniqueArgs>(args: SelectSubset<T, tb_file_typeFindUniqueArgs<ExtArgs>>): Prisma__tb_file_typeClient<$Result.GetResult<Prisma.$tb_file_typePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Tb_file_type that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {tb_file_typeFindUniqueOrThrowArgs} args - Arguments to find a Tb_file_type
     * @example
     * // Get one Tb_file_type
     * const tb_file_type = await prisma.tb_file_type.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends tb_file_typeFindUniqueOrThrowArgs>(args: SelectSubset<T, tb_file_typeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__tb_file_typeClient<$Result.GetResult<Prisma.$tb_file_typePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tb_file_type that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_file_typeFindFirstArgs} args - Arguments to find a Tb_file_type
     * @example
     * // Get one Tb_file_type
     * const tb_file_type = await prisma.tb_file_type.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends tb_file_typeFindFirstArgs>(args?: SelectSubset<T, tb_file_typeFindFirstArgs<ExtArgs>>): Prisma__tb_file_typeClient<$Result.GetResult<Prisma.$tb_file_typePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tb_file_type that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_file_typeFindFirstOrThrowArgs} args - Arguments to find a Tb_file_type
     * @example
     * // Get one Tb_file_type
     * const tb_file_type = await prisma.tb_file_type.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends tb_file_typeFindFirstOrThrowArgs>(args?: SelectSubset<T, tb_file_typeFindFirstOrThrowArgs<ExtArgs>>): Prisma__tb_file_typeClient<$Result.GetResult<Prisma.$tb_file_typePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Tb_file_types that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_file_typeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tb_file_types
     * const tb_file_types = await prisma.tb_file_type.findMany()
     * 
     * // Get first 10 Tb_file_types
     * const tb_file_types = await prisma.tb_file_type.findMany({ take: 10 })
     * 
     * // Only select the `file_type_id`
     * const tb_file_typeWithFile_type_idOnly = await prisma.tb_file_type.findMany({ select: { file_type_id: true } })
     * 
     */
    findMany<T extends tb_file_typeFindManyArgs>(args?: SelectSubset<T, tb_file_typeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tb_file_typePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Tb_file_type.
     * @param {tb_file_typeCreateArgs} args - Arguments to create a Tb_file_type.
     * @example
     * // Create one Tb_file_type
     * const Tb_file_type = await prisma.tb_file_type.create({
     *   data: {
     *     // ... data to create a Tb_file_type
     *   }
     * })
     * 
     */
    create<T extends tb_file_typeCreateArgs>(args: SelectSubset<T, tb_file_typeCreateArgs<ExtArgs>>): Prisma__tb_file_typeClient<$Result.GetResult<Prisma.$tb_file_typePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Tb_file_types.
     * @param {tb_file_typeCreateManyArgs} args - Arguments to create many Tb_file_types.
     * @example
     * // Create many Tb_file_types
     * const tb_file_type = await prisma.tb_file_type.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends tb_file_typeCreateManyArgs>(args?: SelectSubset<T, tb_file_typeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Tb_file_type.
     * @param {tb_file_typeDeleteArgs} args - Arguments to delete one Tb_file_type.
     * @example
     * // Delete one Tb_file_type
     * const Tb_file_type = await prisma.tb_file_type.delete({
     *   where: {
     *     // ... filter to delete one Tb_file_type
     *   }
     * })
     * 
     */
    delete<T extends tb_file_typeDeleteArgs>(args: SelectSubset<T, tb_file_typeDeleteArgs<ExtArgs>>): Prisma__tb_file_typeClient<$Result.GetResult<Prisma.$tb_file_typePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Tb_file_type.
     * @param {tb_file_typeUpdateArgs} args - Arguments to update one Tb_file_type.
     * @example
     * // Update one Tb_file_type
     * const tb_file_type = await prisma.tb_file_type.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends tb_file_typeUpdateArgs>(args: SelectSubset<T, tb_file_typeUpdateArgs<ExtArgs>>): Prisma__tb_file_typeClient<$Result.GetResult<Prisma.$tb_file_typePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Tb_file_types.
     * @param {tb_file_typeDeleteManyArgs} args - Arguments to filter Tb_file_types to delete.
     * @example
     * // Delete a few Tb_file_types
     * const { count } = await prisma.tb_file_type.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends tb_file_typeDeleteManyArgs>(args?: SelectSubset<T, tb_file_typeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tb_file_types.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_file_typeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tb_file_types
     * const tb_file_type = await prisma.tb_file_type.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends tb_file_typeUpdateManyArgs>(args: SelectSubset<T, tb_file_typeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Tb_file_type.
     * @param {tb_file_typeUpsertArgs} args - Arguments to update or create a Tb_file_type.
     * @example
     * // Update or create a Tb_file_type
     * const tb_file_type = await prisma.tb_file_type.upsert({
     *   create: {
     *     // ... data to create a Tb_file_type
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tb_file_type we want to update
     *   }
     * })
     */
    upsert<T extends tb_file_typeUpsertArgs>(args: SelectSubset<T, tb_file_typeUpsertArgs<ExtArgs>>): Prisma__tb_file_typeClient<$Result.GetResult<Prisma.$tb_file_typePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Tb_file_types.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_file_typeCountArgs} args - Arguments to filter Tb_file_types to count.
     * @example
     * // Count the number of Tb_file_types
     * const count = await prisma.tb_file_type.count({
     *   where: {
     *     // ... the filter for the Tb_file_types we want to count
     *   }
     * })
    **/
    count<T extends tb_file_typeCountArgs>(
      args?: Subset<T, tb_file_typeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Tb_file_typeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tb_file_type.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Tb_file_typeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Tb_file_typeAggregateArgs>(args: Subset<T, Tb_file_typeAggregateArgs>): Prisma.PrismaPromise<GetTb_file_typeAggregateType<T>>

    /**
     * Group by Tb_file_type.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_file_typeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends tb_file_typeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: tb_file_typeGroupByArgs['orderBy'] }
        : { orderBy?: tb_file_typeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, tb_file_typeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTb_file_typeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the tb_file_type model
   */
  readonly fields: tb_file_typeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for tb_file_type.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__tb_file_typeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the tb_file_type model
   */
  interface tb_file_typeFieldRefs {
    readonly file_type_id: FieldRef<"tb_file_type", 'Int'>
    readonly file_type: FieldRef<"tb_file_type", 'String'>
    readonly file_filter: FieldRef<"tb_file_type", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * tb_file_type findUnique
   */
  export type tb_file_typeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_file_type
     */
    select?: tb_file_typeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_file_type
     */
    omit?: tb_file_typeOmit<ExtArgs> | null
    /**
     * Filter, which tb_file_type to fetch.
     */
    where: tb_file_typeWhereUniqueInput
  }

  /**
   * tb_file_type findUniqueOrThrow
   */
  export type tb_file_typeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_file_type
     */
    select?: tb_file_typeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_file_type
     */
    omit?: tb_file_typeOmit<ExtArgs> | null
    /**
     * Filter, which tb_file_type to fetch.
     */
    where: tb_file_typeWhereUniqueInput
  }

  /**
   * tb_file_type findFirst
   */
  export type tb_file_typeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_file_type
     */
    select?: tb_file_typeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_file_type
     */
    omit?: tb_file_typeOmit<ExtArgs> | null
    /**
     * Filter, which tb_file_type to fetch.
     */
    where?: tb_file_typeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tb_file_types to fetch.
     */
    orderBy?: tb_file_typeOrderByWithRelationInput | tb_file_typeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tb_file_types.
     */
    cursor?: tb_file_typeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tb_file_types from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tb_file_types.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tb_file_types.
     */
    distinct?: Tb_file_typeScalarFieldEnum | Tb_file_typeScalarFieldEnum[]
  }

  /**
   * tb_file_type findFirstOrThrow
   */
  export type tb_file_typeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_file_type
     */
    select?: tb_file_typeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_file_type
     */
    omit?: tb_file_typeOmit<ExtArgs> | null
    /**
     * Filter, which tb_file_type to fetch.
     */
    where?: tb_file_typeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tb_file_types to fetch.
     */
    orderBy?: tb_file_typeOrderByWithRelationInput | tb_file_typeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tb_file_types.
     */
    cursor?: tb_file_typeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tb_file_types from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tb_file_types.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tb_file_types.
     */
    distinct?: Tb_file_typeScalarFieldEnum | Tb_file_typeScalarFieldEnum[]
  }

  /**
   * tb_file_type findMany
   */
  export type tb_file_typeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_file_type
     */
    select?: tb_file_typeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_file_type
     */
    omit?: tb_file_typeOmit<ExtArgs> | null
    /**
     * Filter, which tb_file_types to fetch.
     */
    where?: tb_file_typeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tb_file_types to fetch.
     */
    orderBy?: tb_file_typeOrderByWithRelationInput | tb_file_typeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing tb_file_types.
     */
    cursor?: tb_file_typeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tb_file_types from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tb_file_types.
     */
    skip?: number
    distinct?: Tb_file_typeScalarFieldEnum | Tb_file_typeScalarFieldEnum[]
  }

  /**
   * tb_file_type create
   */
  export type tb_file_typeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_file_type
     */
    select?: tb_file_typeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_file_type
     */
    omit?: tb_file_typeOmit<ExtArgs> | null
    /**
     * The data needed to create a tb_file_type.
     */
    data: XOR<tb_file_typeCreateInput, tb_file_typeUncheckedCreateInput>
  }

  /**
   * tb_file_type createMany
   */
  export type tb_file_typeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many tb_file_types.
     */
    data: tb_file_typeCreateManyInput | tb_file_typeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * tb_file_type update
   */
  export type tb_file_typeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_file_type
     */
    select?: tb_file_typeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_file_type
     */
    omit?: tb_file_typeOmit<ExtArgs> | null
    /**
     * The data needed to update a tb_file_type.
     */
    data: XOR<tb_file_typeUpdateInput, tb_file_typeUncheckedUpdateInput>
    /**
     * Choose, which tb_file_type to update.
     */
    where: tb_file_typeWhereUniqueInput
  }

  /**
   * tb_file_type updateMany
   */
  export type tb_file_typeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update tb_file_types.
     */
    data: XOR<tb_file_typeUpdateManyMutationInput, tb_file_typeUncheckedUpdateManyInput>
    /**
     * Filter which tb_file_types to update
     */
    where?: tb_file_typeWhereInput
    /**
     * Limit how many tb_file_types to update.
     */
    limit?: number
  }

  /**
   * tb_file_type upsert
   */
  export type tb_file_typeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_file_type
     */
    select?: tb_file_typeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_file_type
     */
    omit?: tb_file_typeOmit<ExtArgs> | null
    /**
     * The filter to search for the tb_file_type to update in case it exists.
     */
    where: tb_file_typeWhereUniqueInput
    /**
     * In case the tb_file_type found by the `where` argument doesn't exist, create a new tb_file_type with this data.
     */
    create: XOR<tb_file_typeCreateInput, tb_file_typeUncheckedCreateInput>
    /**
     * In case the tb_file_type was found with the provided `where` argument, update it with this data.
     */
    update: XOR<tb_file_typeUpdateInput, tb_file_typeUncheckedUpdateInput>
  }

  /**
   * tb_file_type delete
   */
  export type tb_file_typeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_file_type
     */
    select?: tb_file_typeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_file_type
     */
    omit?: tb_file_typeOmit<ExtArgs> | null
    /**
     * Filter which tb_file_type to delete.
     */
    where: tb_file_typeWhereUniqueInput
  }

  /**
   * tb_file_type deleteMany
   */
  export type tb_file_typeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tb_file_types to delete
     */
    where?: tb_file_typeWhereInput
    /**
     * Limit how many tb_file_types to delete.
     */
    limit?: number
  }

  /**
   * tb_file_type without action
   */
  export type tb_file_typeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_file_type
     */
    select?: tb_file_typeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_file_type
     */
    omit?: tb_file_typeOmit<ExtArgs> | null
  }


  /**
   * Model tb_handed
   */

  export type AggregateTb_handed = {
    _count: Tb_handedCountAggregateOutputType | null
    _avg: Tb_handedAvgAggregateOutputType | null
    _sum: Tb_handedSumAggregateOutputType | null
    _min: Tb_handedMinAggregateOutputType | null
    _max: Tb_handedMaxAggregateOutputType | null
  }

  export type Tb_handedAvgAggregateOutputType = {
    handed_id: number | null
    case_id: number | null
    decision_id: number | null
    hended_by: number | null
  }

  export type Tb_handedSumAggregateOutputType = {
    handed_id: number | null
    case_id: number | null
    decision_id: number | null
    hended_by: number | null
  }

  export type Tb_handedMinAggregateOutputType = {
    handed_id: number | null
    case_id: number | null
    decision_id: number | null
    created: Date | null
    hended_by: number | null
    signed_page: string | null
  }

  export type Tb_handedMaxAggregateOutputType = {
    handed_id: number | null
    case_id: number | null
    decision_id: number | null
    created: Date | null
    hended_by: number | null
    signed_page: string | null
  }

  export type Tb_handedCountAggregateOutputType = {
    handed_id: number
    case_id: number
    decision_id: number
    created: number
    hended_by: number
    signed_page: number
    _all: number
  }


  export type Tb_handedAvgAggregateInputType = {
    handed_id?: true
    case_id?: true
    decision_id?: true
    hended_by?: true
  }

  export type Tb_handedSumAggregateInputType = {
    handed_id?: true
    case_id?: true
    decision_id?: true
    hended_by?: true
  }

  export type Tb_handedMinAggregateInputType = {
    handed_id?: true
    case_id?: true
    decision_id?: true
    created?: true
    hended_by?: true
    signed_page?: true
  }

  export type Tb_handedMaxAggregateInputType = {
    handed_id?: true
    case_id?: true
    decision_id?: true
    created?: true
    hended_by?: true
    signed_page?: true
  }

  export type Tb_handedCountAggregateInputType = {
    handed_id?: true
    case_id?: true
    decision_id?: true
    created?: true
    hended_by?: true
    signed_page?: true
    _all?: true
  }

  export type Tb_handedAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tb_handed to aggregate.
     */
    where?: tb_handedWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tb_handeds to fetch.
     */
    orderBy?: tb_handedOrderByWithRelationInput | tb_handedOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: tb_handedWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tb_handeds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tb_handeds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned tb_handeds
    **/
    _count?: true | Tb_handedCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Tb_handedAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Tb_handedSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Tb_handedMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Tb_handedMaxAggregateInputType
  }

  export type GetTb_handedAggregateType<T extends Tb_handedAggregateArgs> = {
        [P in keyof T & keyof AggregateTb_handed]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTb_handed[P]>
      : GetScalarType<T[P], AggregateTb_handed[P]>
  }




  export type tb_handedGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: tb_handedWhereInput
    orderBy?: tb_handedOrderByWithAggregationInput | tb_handedOrderByWithAggregationInput[]
    by: Tb_handedScalarFieldEnum[] | Tb_handedScalarFieldEnum
    having?: tb_handedScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Tb_handedCountAggregateInputType | true
    _avg?: Tb_handedAvgAggregateInputType
    _sum?: Tb_handedSumAggregateInputType
    _min?: Tb_handedMinAggregateInputType
    _max?: Tb_handedMaxAggregateInputType
  }

  export type Tb_handedGroupByOutputType = {
    handed_id: number
    case_id: number
    decision_id: number
    created: Date
    hended_by: number
    signed_page: string | null
    _count: Tb_handedCountAggregateOutputType | null
    _avg: Tb_handedAvgAggregateOutputType | null
    _sum: Tb_handedSumAggregateOutputType | null
    _min: Tb_handedMinAggregateOutputType | null
    _max: Tb_handedMaxAggregateOutputType | null
  }

  type GetTb_handedGroupByPayload<T extends tb_handedGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Tb_handedGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Tb_handedGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Tb_handedGroupByOutputType[P]>
            : GetScalarType<T[P], Tb_handedGroupByOutputType[P]>
        }
      >
    >


  export type tb_handedSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    handed_id?: boolean
    case_id?: boolean
    decision_id?: boolean
    created?: boolean
    hended_by?: boolean
    signed_page?: boolean
  }, ExtArgs["result"]["tb_handed"]>



  export type tb_handedSelectScalar = {
    handed_id?: boolean
    case_id?: boolean
    decision_id?: boolean
    created?: boolean
    hended_by?: boolean
    signed_page?: boolean
  }

  export type tb_handedOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"handed_id" | "case_id" | "decision_id" | "created" | "hended_by" | "signed_page", ExtArgs["result"]["tb_handed"]>

  export type $tb_handedPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "tb_handed"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      handed_id: number
      case_id: number
      decision_id: number
      created: Date
      hended_by: number
      signed_page: string | null
    }, ExtArgs["result"]["tb_handed"]>
    composites: {}
  }

  type tb_handedGetPayload<S extends boolean | null | undefined | tb_handedDefaultArgs> = $Result.GetResult<Prisma.$tb_handedPayload, S>

  type tb_handedCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<tb_handedFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Tb_handedCountAggregateInputType | true
    }

  export interface tb_handedDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['tb_handed'], meta: { name: 'tb_handed' } }
    /**
     * Find zero or one Tb_handed that matches the filter.
     * @param {tb_handedFindUniqueArgs} args - Arguments to find a Tb_handed
     * @example
     * // Get one Tb_handed
     * const tb_handed = await prisma.tb_handed.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends tb_handedFindUniqueArgs>(args: SelectSubset<T, tb_handedFindUniqueArgs<ExtArgs>>): Prisma__tb_handedClient<$Result.GetResult<Prisma.$tb_handedPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Tb_handed that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {tb_handedFindUniqueOrThrowArgs} args - Arguments to find a Tb_handed
     * @example
     * // Get one Tb_handed
     * const tb_handed = await prisma.tb_handed.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends tb_handedFindUniqueOrThrowArgs>(args: SelectSubset<T, tb_handedFindUniqueOrThrowArgs<ExtArgs>>): Prisma__tb_handedClient<$Result.GetResult<Prisma.$tb_handedPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tb_handed that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_handedFindFirstArgs} args - Arguments to find a Tb_handed
     * @example
     * // Get one Tb_handed
     * const tb_handed = await prisma.tb_handed.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends tb_handedFindFirstArgs>(args?: SelectSubset<T, tb_handedFindFirstArgs<ExtArgs>>): Prisma__tb_handedClient<$Result.GetResult<Prisma.$tb_handedPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tb_handed that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_handedFindFirstOrThrowArgs} args - Arguments to find a Tb_handed
     * @example
     * // Get one Tb_handed
     * const tb_handed = await prisma.tb_handed.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends tb_handedFindFirstOrThrowArgs>(args?: SelectSubset<T, tb_handedFindFirstOrThrowArgs<ExtArgs>>): Prisma__tb_handedClient<$Result.GetResult<Prisma.$tb_handedPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Tb_handeds that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_handedFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tb_handeds
     * const tb_handeds = await prisma.tb_handed.findMany()
     * 
     * // Get first 10 Tb_handeds
     * const tb_handeds = await prisma.tb_handed.findMany({ take: 10 })
     * 
     * // Only select the `handed_id`
     * const tb_handedWithHanded_idOnly = await prisma.tb_handed.findMany({ select: { handed_id: true } })
     * 
     */
    findMany<T extends tb_handedFindManyArgs>(args?: SelectSubset<T, tb_handedFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tb_handedPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Tb_handed.
     * @param {tb_handedCreateArgs} args - Arguments to create a Tb_handed.
     * @example
     * // Create one Tb_handed
     * const Tb_handed = await prisma.tb_handed.create({
     *   data: {
     *     // ... data to create a Tb_handed
     *   }
     * })
     * 
     */
    create<T extends tb_handedCreateArgs>(args: SelectSubset<T, tb_handedCreateArgs<ExtArgs>>): Prisma__tb_handedClient<$Result.GetResult<Prisma.$tb_handedPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Tb_handeds.
     * @param {tb_handedCreateManyArgs} args - Arguments to create many Tb_handeds.
     * @example
     * // Create many Tb_handeds
     * const tb_handed = await prisma.tb_handed.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends tb_handedCreateManyArgs>(args?: SelectSubset<T, tb_handedCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Tb_handed.
     * @param {tb_handedDeleteArgs} args - Arguments to delete one Tb_handed.
     * @example
     * // Delete one Tb_handed
     * const Tb_handed = await prisma.tb_handed.delete({
     *   where: {
     *     // ... filter to delete one Tb_handed
     *   }
     * })
     * 
     */
    delete<T extends tb_handedDeleteArgs>(args: SelectSubset<T, tb_handedDeleteArgs<ExtArgs>>): Prisma__tb_handedClient<$Result.GetResult<Prisma.$tb_handedPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Tb_handed.
     * @param {tb_handedUpdateArgs} args - Arguments to update one Tb_handed.
     * @example
     * // Update one Tb_handed
     * const tb_handed = await prisma.tb_handed.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends tb_handedUpdateArgs>(args: SelectSubset<T, tb_handedUpdateArgs<ExtArgs>>): Prisma__tb_handedClient<$Result.GetResult<Prisma.$tb_handedPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Tb_handeds.
     * @param {tb_handedDeleteManyArgs} args - Arguments to filter Tb_handeds to delete.
     * @example
     * // Delete a few Tb_handeds
     * const { count } = await prisma.tb_handed.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends tb_handedDeleteManyArgs>(args?: SelectSubset<T, tb_handedDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tb_handeds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_handedUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tb_handeds
     * const tb_handed = await prisma.tb_handed.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends tb_handedUpdateManyArgs>(args: SelectSubset<T, tb_handedUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Tb_handed.
     * @param {tb_handedUpsertArgs} args - Arguments to update or create a Tb_handed.
     * @example
     * // Update or create a Tb_handed
     * const tb_handed = await prisma.tb_handed.upsert({
     *   create: {
     *     // ... data to create a Tb_handed
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tb_handed we want to update
     *   }
     * })
     */
    upsert<T extends tb_handedUpsertArgs>(args: SelectSubset<T, tb_handedUpsertArgs<ExtArgs>>): Prisma__tb_handedClient<$Result.GetResult<Prisma.$tb_handedPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Tb_handeds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_handedCountArgs} args - Arguments to filter Tb_handeds to count.
     * @example
     * // Count the number of Tb_handeds
     * const count = await prisma.tb_handed.count({
     *   where: {
     *     // ... the filter for the Tb_handeds we want to count
     *   }
     * })
    **/
    count<T extends tb_handedCountArgs>(
      args?: Subset<T, tb_handedCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Tb_handedCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tb_handed.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Tb_handedAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Tb_handedAggregateArgs>(args: Subset<T, Tb_handedAggregateArgs>): Prisma.PrismaPromise<GetTb_handedAggregateType<T>>

    /**
     * Group by Tb_handed.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_handedGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends tb_handedGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: tb_handedGroupByArgs['orderBy'] }
        : { orderBy?: tb_handedGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, tb_handedGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTb_handedGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the tb_handed model
   */
  readonly fields: tb_handedFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for tb_handed.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__tb_handedClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the tb_handed model
   */
  interface tb_handedFieldRefs {
    readonly handed_id: FieldRef<"tb_handed", 'Int'>
    readonly case_id: FieldRef<"tb_handed", 'Int'>
    readonly decision_id: FieldRef<"tb_handed", 'Int'>
    readonly created: FieldRef<"tb_handed", 'DateTime'>
    readonly hended_by: FieldRef<"tb_handed", 'Int'>
    readonly signed_page: FieldRef<"tb_handed", 'String'>
  }
    

  // Custom InputTypes
  /**
   * tb_handed findUnique
   */
  export type tb_handedFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_handed
     */
    select?: tb_handedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_handed
     */
    omit?: tb_handedOmit<ExtArgs> | null
    /**
     * Filter, which tb_handed to fetch.
     */
    where: tb_handedWhereUniqueInput
  }

  /**
   * tb_handed findUniqueOrThrow
   */
  export type tb_handedFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_handed
     */
    select?: tb_handedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_handed
     */
    omit?: tb_handedOmit<ExtArgs> | null
    /**
     * Filter, which tb_handed to fetch.
     */
    where: tb_handedWhereUniqueInput
  }

  /**
   * tb_handed findFirst
   */
  export type tb_handedFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_handed
     */
    select?: tb_handedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_handed
     */
    omit?: tb_handedOmit<ExtArgs> | null
    /**
     * Filter, which tb_handed to fetch.
     */
    where?: tb_handedWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tb_handeds to fetch.
     */
    orderBy?: tb_handedOrderByWithRelationInput | tb_handedOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tb_handeds.
     */
    cursor?: tb_handedWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tb_handeds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tb_handeds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tb_handeds.
     */
    distinct?: Tb_handedScalarFieldEnum | Tb_handedScalarFieldEnum[]
  }

  /**
   * tb_handed findFirstOrThrow
   */
  export type tb_handedFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_handed
     */
    select?: tb_handedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_handed
     */
    omit?: tb_handedOmit<ExtArgs> | null
    /**
     * Filter, which tb_handed to fetch.
     */
    where?: tb_handedWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tb_handeds to fetch.
     */
    orderBy?: tb_handedOrderByWithRelationInput | tb_handedOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tb_handeds.
     */
    cursor?: tb_handedWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tb_handeds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tb_handeds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tb_handeds.
     */
    distinct?: Tb_handedScalarFieldEnum | Tb_handedScalarFieldEnum[]
  }

  /**
   * tb_handed findMany
   */
  export type tb_handedFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_handed
     */
    select?: tb_handedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_handed
     */
    omit?: tb_handedOmit<ExtArgs> | null
    /**
     * Filter, which tb_handeds to fetch.
     */
    where?: tb_handedWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tb_handeds to fetch.
     */
    orderBy?: tb_handedOrderByWithRelationInput | tb_handedOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing tb_handeds.
     */
    cursor?: tb_handedWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tb_handeds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tb_handeds.
     */
    skip?: number
    distinct?: Tb_handedScalarFieldEnum | Tb_handedScalarFieldEnum[]
  }

  /**
   * tb_handed create
   */
  export type tb_handedCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_handed
     */
    select?: tb_handedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_handed
     */
    omit?: tb_handedOmit<ExtArgs> | null
    /**
     * The data needed to create a tb_handed.
     */
    data: XOR<tb_handedCreateInput, tb_handedUncheckedCreateInput>
  }

  /**
   * tb_handed createMany
   */
  export type tb_handedCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many tb_handeds.
     */
    data: tb_handedCreateManyInput | tb_handedCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * tb_handed update
   */
  export type tb_handedUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_handed
     */
    select?: tb_handedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_handed
     */
    omit?: tb_handedOmit<ExtArgs> | null
    /**
     * The data needed to update a tb_handed.
     */
    data: XOR<tb_handedUpdateInput, tb_handedUncheckedUpdateInput>
    /**
     * Choose, which tb_handed to update.
     */
    where: tb_handedWhereUniqueInput
  }

  /**
   * tb_handed updateMany
   */
  export type tb_handedUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update tb_handeds.
     */
    data: XOR<tb_handedUpdateManyMutationInput, tb_handedUncheckedUpdateManyInput>
    /**
     * Filter which tb_handeds to update
     */
    where?: tb_handedWhereInput
    /**
     * Limit how many tb_handeds to update.
     */
    limit?: number
  }

  /**
   * tb_handed upsert
   */
  export type tb_handedUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_handed
     */
    select?: tb_handedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_handed
     */
    omit?: tb_handedOmit<ExtArgs> | null
    /**
     * The filter to search for the tb_handed to update in case it exists.
     */
    where: tb_handedWhereUniqueInput
    /**
     * In case the tb_handed found by the `where` argument doesn't exist, create a new tb_handed with this data.
     */
    create: XOR<tb_handedCreateInput, tb_handedUncheckedCreateInput>
    /**
     * In case the tb_handed was found with the provided `where` argument, update it with this data.
     */
    update: XOR<tb_handedUpdateInput, tb_handedUncheckedUpdateInput>
  }

  /**
   * tb_handed delete
   */
  export type tb_handedDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_handed
     */
    select?: tb_handedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_handed
     */
    omit?: tb_handedOmit<ExtArgs> | null
    /**
     * Filter which tb_handed to delete.
     */
    where: tb_handedWhereUniqueInput
  }

  /**
   * tb_handed deleteMany
   */
  export type tb_handedDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tb_handeds to delete
     */
    where?: tb_handedWhereInput
    /**
     * Limit how many tb_handeds to delete.
     */
    limit?: number
  }

  /**
   * tb_handed without action
   */
  export type tb_handedDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_handed
     */
    select?: tb_handedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_handed
     */
    omit?: tb_handedOmit<ExtArgs> | null
  }


  /**
   * Model tb_inter
   */

  export type AggregateTb_inter = {
    _count: Tb_interCountAggregateOutputType | null
    _avg: Tb_interAvgAggregateOutputType | null
    _sum: Tb_interSumAggregateOutputType | null
    _min: Tb_interMinAggregateOutputType | null
    _max: Tb_interMaxAggregateOutputType | null
  }

  export type Tb_interAvgAggregateOutputType = {
    inter_id: number | null
    case_id: number | null
    author_id: number | null
    inter_status: number | null
    inter_reciever: number | null
    inter_type: number | null
    send_type: number | null
  }

  export type Tb_interSumAggregateOutputType = {
    inter_id: number | null
    case_id: number | null
    author_id: number | null
    inter_status: number | null
    inter_reciever: number | null
    inter_type: number | null
    send_type: number | null
  }

  export type Tb_interMinAggregateOutputType = {
    inter_id: number | null
    case_id: number | null
    author_id: number | null
    inter_status: number | null
    inter_reciever: number | null
    inter_type: number | null
    send_type: number | null
    out_num: string | null
  }

  export type Tb_interMaxAggregateOutputType = {
    inter_id: number | null
    case_id: number | null
    author_id: number | null
    inter_status: number | null
    inter_reciever: number | null
    inter_type: number | null
    send_type: number | null
    out_num: string | null
  }

  export type Tb_interCountAggregateOutputType = {
    inter_id: number
    case_id: number
    author_id: number
    inter_status: number
    inter_reciever: number
    inter_type: number
    send_type: number
    out_num: number
    _all: number
  }


  export type Tb_interAvgAggregateInputType = {
    inter_id?: true
    case_id?: true
    author_id?: true
    inter_status?: true
    inter_reciever?: true
    inter_type?: true
    send_type?: true
  }

  export type Tb_interSumAggregateInputType = {
    inter_id?: true
    case_id?: true
    author_id?: true
    inter_status?: true
    inter_reciever?: true
    inter_type?: true
    send_type?: true
  }

  export type Tb_interMinAggregateInputType = {
    inter_id?: true
    case_id?: true
    author_id?: true
    inter_status?: true
    inter_reciever?: true
    inter_type?: true
    send_type?: true
    out_num?: true
  }

  export type Tb_interMaxAggregateInputType = {
    inter_id?: true
    case_id?: true
    author_id?: true
    inter_status?: true
    inter_reciever?: true
    inter_type?: true
    send_type?: true
    out_num?: true
  }

  export type Tb_interCountAggregateInputType = {
    inter_id?: true
    case_id?: true
    author_id?: true
    inter_status?: true
    inter_reciever?: true
    inter_type?: true
    send_type?: true
    out_num?: true
    _all?: true
  }

  export type Tb_interAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tb_inter to aggregate.
     */
    where?: tb_interWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tb_inters to fetch.
     */
    orderBy?: tb_interOrderByWithRelationInput | tb_interOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: tb_interWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tb_inters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tb_inters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned tb_inters
    **/
    _count?: true | Tb_interCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Tb_interAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Tb_interSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Tb_interMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Tb_interMaxAggregateInputType
  }

  export type GetTb_interAggregateType<T extends Tb_interAggregateArgs> = {
        [P in keyof T & keyof AggregateTb_inter]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTb_inter[P]>
      : GetScalarType<T[P], AggregateTb_inter[P]>
  }




  export type tb_interGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: tb_interWhereInput
    orderBy?: tb_interOrderByWithAggregationInput | tb_interOrderByWithAggregationInput[]
    by: Tb_interScalarFieldEnum[] | Tb_interScalarFieldEnum
    having?: tb_interScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Tb_interCountAggregateInputType | true
    _avg?: Tb_interAvgAggregateInputType
    _sum?: Tb_interSumAggregateInputType
    _min?: Tb_interMinAggregateInputType
    _max?: Tb_interMaxAggregateInputType
  }

  export type Tb_interGroupByOutputType = {
    inter_id: number
    case_id: number
    author_id: number
    inter_status: number
    inter_reciever: number
    inter_type: number
    send_type: number
    out_num: string | null
    _count: Tb_interCountAggregateOutputType | null
    _avg: Tb_interAvgAggregateOutputType | null
    _sum: Tb_interSumAggregateOutputType | null
    _min: Tb_interMinAggregateOutputType | null
    _max: Tb_interMaxAggregateOutputType | null
  }

  type GetTb_interGroupByPayload<T extends tb_interGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Tb_interGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Tb_interGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Tb_interGroupByOutputType[P]>
            : GetScalarType<T[P], Tb_interGroupByOutputType[P]>
        }
      >
    >


  export type tb_interSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    inter_id?: boolean
    case_id?: boolean
    author_id?: boolean
    inter_status?: boolean
    inter_reciever?: boolean
    inter_type?: boolean
    send_type?: boolean
    out_num?: boolean
  }, ExtArgs["result"]["tb_inter"]>



  export type tb_interSelectScalar = {
    inter_id?: boolean
    case_id?: boolean
    author_id?: boolean
    inter_status?: boolean
    inter_reciever?: boolean
    inter_type?: boolean
    send_type?: boolean
    out_num?: boolean
  }

  export type tb_interOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"inter_id" | "case_id" | "author_id" | "inter_status" | "inter_reciever" | "inter_type" | "send_type" | "out_num", ExtArgs["result"]["tb_inter"]>

  export type $tb_interPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "tb_inter"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      inter_id: number
      case_id: number
      author_id: number
      inter_status: number
      inter_reciever: number
      inter_type: number
      send_type: number
      out_num: string | null
    }, ExtArgs["result"]["tb_inter"]>
    composites: {}
  }

  type tb_interGetPayload<S extends boolean | null | undefined | tb_interDefaultArgs> = $Result.GetResult<Prisma.$tb_interPayload, S>

  type tb_interCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<tb_interFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Tb_interCountAggregateInputType | true
    }

  export interface tb_interDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['tb_inter'], meta: { name: 'tb_inter' } }
    /**
     * Find zero or one Tb_inter that matches the filter.
     * @param {tb_interFindUniqueArgs} args - Arguments to find a Tb_inter
     * @example
     * // Get one Tb_inter
     * const tb_inter = await prisma.tb_inter.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends tb_interFindUniqueArgs>(args: SelectSubset<T, tb_interFindUniqueArgs<ExtArgs>>): Prisma__tb_interClient<$Result.GetResult<Prisma.$tb_interPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Tb_inter that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {tb_interFindUniqueOrThrowArgs} args - Arguments to find a Tb_inter
     * @example
     * // Get one Tb_inter
     * const tb_inter = await prisma.tb_inter.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends tb_interFindUniqueOrThrowArgs>(args: SelectSubset<T, tb_interFindUniqueOrThrowArgs<ExtArgs>>): Prisma__tb_interClient<$Result.GetResult<Prisma.$tb_interPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tb_inter that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_interFindFirstArgs} args - Arguments to find a Tb_inter
     * @example
     * // Get one Tb_inter
     * const tb_inter = await prisma.tb_inter.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends tb_interFindFirstArgs>(args?: SelectSubset<T, tb_interFindFirstArgs<ExtArgs>>): Prisma__tb_interClient<$Result.GetResult<Prisma.$tb_interPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tb_inter that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_interFindFirstOrThrowArgs} args - Arguments to find a Tb_inter
     * @example
     * // Get one Tb_inter
     * const tb_inter = await prisma.tb_inter.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends tb_interFindFirstOrThrowArgs>(args?: SelectSubset<T, tb_interFindFirstOrThrowArgs<ExtArgs>>): Prisma__tb_interClient<$Result.GetResult<Prisma.$tb_interPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Tb_inters that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_interFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tb_inters
     * const tb_inters = await prisma.tb_inter.findMany()
     * 
     * // Get first 10 Tb_inters
     * const tb_inters = await prisma.tb_inter.findMany({ take: 10 })
     * 
     * // Only select the `inter_id`
     * const tb_interWithInter_idOnly = await prisma.tb_inter.findMany({ select: { inter_id: true } })
     * 
     */
    findMany<T extends tb_interFindManyArgs>(args?: SelectSubset<T, tb_interFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tb_interPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Tb_inter.
     * @param {tb_interCreateArgs} args - Arguments to create a Tb_inter.
     * @example
     * // Create one Tb_inter
     * const Tb_inter = await prisma.tb_inter.create({
     *   data: {
     *     // ... data to create a Tb_inter
     *   }
     * })
     * 
     */
    create<T extends tb_interCreateArgs>(args: SelectSubset<T, tb_interCreateArgs<ExtArgs>>): Prisma__tb_interClient<$Result.GetResult<Prisma.$tb_interPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Tb_inters.
     * @param {tb_interCreateManyArgs} args - Arguments to create many Tb_inters.
     * @example
     * // Create many Tb_inters
     * const tb_inter = await prisma.tb_inter.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends tb_interCreateManyArgs>(args?: SelectSubset<T, tb_interCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Tb_inter.
     * @param {tb_interDeleteArgs} args - Arguments to delete one Tb_inter.
     * @example
     * // Delete one Tb_inter
     * const Tb_inter = await prisma.tb_inter.delete({
     *   where: {
     *     // ... filter to delete one Tb_inter
     *   }
     * })
     * 
     */
    delete<T extends tb_interDeleteArgs>(args: SelectSubset<T, tb_interDeleteArgs<ExtArgs>>): Prisma__tb_interClient<$Result.GetResult<Prisma.$tb_interPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Tb_inter.
     * @param {tb_interUpdateArgs} args - Arguments to update one Tb_inter.
     * @example
     * // Update one Tb_inter
     * const tb_inter = await prisma.tb_inter.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends tb_interUpdateArgs>(args: SelectSubset<T, tb_interUpdateArgs<ExtArgs>>): Prisma__tb_interClient<$Result.GetResult<Prisma.$tb_interPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Tb_inters.
     * @param {tb_interDeleteManyArgs} args - Arguments to filter Tb_inters to delete.
     * @example
     * // Delete a few Tb_inters
     * const { count } = await prisma.tb_inter.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends tb_interDeleteManyArgs>(args?: SelectSubset<T, tb_interDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tb_inters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_interUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tb_inters
     * const tb_inter = await prisma.tb_inter.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends tb_interUpdateManyArgs>(args: SelectSubset<T, tb_interUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Tb_inter.
     * @param {tb_interUpsertArgs} args - Arguments to update or create a Tb_inter.
     * @example
     * // Update or create a Tb_inter
     * const tb_inter = await prisma.tb_inter.upsert({
     *   create: {
     *     // ... data to create a Tb_inter
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tb_inter we want to update
     *   }
     * })
     */
    upsert<T extends tb_interUpsertArgs>(args: SelectSubset<T, tb_interUpsertArgs<ExtArgs>>): Prisma__tb_interClient<$Result.GetResult<Prisma.$tb_interPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Tb_inters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_interCountArgs} args - Arguments to filter Tb_inters to count.
     * @example
     * // Count the number of Tb_inters
     * const count = await prisma.tb_inter.count({
     *   where: {
     *     // ... the filter for the Tb_inters we want to count
     *   }
     * })
    **/
    count<T extends tb_interCountArgs>(
      args?: Subset<T, tb_interCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Tb_interCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tb_inter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Tb_interAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Tb_interAggregateArgs>(args: Subset<T, Tb_interAggregateArgs>): Prisma.PrismaPromise<GetTb_interAggregateType<T>>

    /**
     * Group by Tb_inter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_interGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends tb_interGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: tb_interGroupByArgs['orderBy'] }
        : { orderBy?: tb_interGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, tb_interGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTb_interGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the tb_inter model
   */
  readonly fields: tb_interFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for tb_inter.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__tb_interClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the tb_inter model
   */
  interface tb_interFieldRefs {
    readonly inter_id: FieldRef<"tb_inter", 'Int'>
    readonly case_id: FieldRef<"tb_inter", 'Int'>
    readonly author_id: FieldRef<"tb_inter", 'Int'>
    readonly inter_status: FieldRef<"tb_inter", 'Int'>
    readonly inter_reciever: FieldRef<"tb_inter", 'Int'>
    readonly inter_type: FieldRef<"tb_inter", 'Int'>
    readonly send_type: FieldRef<"tb_inter", 'Int'>
    readonly out_num: FieldRef<"tb_inter", 'String'>
  }
    

  // Custom InputTypes
  /**
   * tb_inter findUnique
   */
  export type tb_interFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_inter
     */
    select?: tb_interSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_inter
     */
    omit?: tb_interOmit<ExtArgs> | null
    /**
     * Filter, which tb_inter to fetch.
     */
    where: tb_interWhereUniqueInput
  }

  /**
   * tb_inter findUniqueOrThrow
   */
  export type tb_interFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_inter
     */
    select?: tb_interSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_inter
     */
    omit?: tb_interOmit<ExtArgs> | null
    /**
     * Filter, which tb_inter to fetch.
     */
    where: tb_interWhereUniqueInput
  }

  /**
   * tb_inter findFirst
   */
  export type tb_interFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_inter
     */
    select?: tb_interSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_inter
     */
    omit?: tb_interOmit<ExtArgs> | null
    /**
     * Filter, which tb_inter to fetch.
     */
    where?: tb_interWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tb_inters to fetch.
     */
    orderBy?: tb_interOrderByWithRelationInput | tb_interOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tb_inters.
     */
    cursor?: tb_interWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tb_inters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tb_inters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tb_inters.
     */
    distinct?: Tb_interScalarFieldEnum | Tb_interScalarFieldEnum[]
  }

  /**
   * tb_inter findFirstOrThrow
   */
  export type tb_interFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_inter
     */
    select?: tb_interSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_inter
     */
    omit?: tb_interOmit<ExtArgs> | null
    /**
     * Filter, which tb_inter to fetch.
     */
    where?: tb_interWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tb_inters to fetch.
     */
    orderBy?: tb_interOrderByWithRelationInput | tb_interOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tb_inters.
     */
    cursor?: tb_interWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tb_inters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tb_inters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tb_inters.
     */
    distinct?: Tb_interScalarFieldEnum | Tb_interScalarFieldEnum[]
  }

  /**
   * tb_inter findMany
   */
  export type tb_interFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_inter
     */
    select?: tb_interSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_inter
     */
    omit?: tb_interOmit<ExtArgs> | null
    /**
     * Filter, which tb_inters to fetch.
     */
    where?: tb_interWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tb_inters to fetch.
     */
    orderBy?: tb_interOrderByWithRelationInput | tb_interOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing tb_inters.
     */
    cursor?: tb_interWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tb_inters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tb_inters.
     */
    skip?: number
    distinct?: Tb_interScalarFieldEnum | Tb_interScalarFieldEnum[]
  }

  /**
   * tb_inter create
   */
  export type tb_interCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_inter
     */
    select?: tb_interSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_inter
     */
    omit?: tb_interOmit<ExtArgs> | null
    /**
     * The data needed to create a tb_inter.
     */
    data: XOR<tb_interCreateInput, tb_interUncheckedCreateInput>
  }

  /**
   * tb_inter createMany
   */
  export type tb_interCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many tb_inters.
     */
    data: tb_interCreateManyInput | tb_interCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * tb_inter update
   */
  export type tb_interUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_inter
     */
    select?: tb_interSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_inter
     */
    omit?: tb_interOmit<ExtArgs> | null
    /**
     * The data needed to update a tb_inter.
     */
    data: XOR<tb_interUpdateInput, tb_interUncheckedUpdateInput>
    /**
     * Choose, which tb_inter to update.
     */
    where: tb_interWhereUniqueInput
  }

  /**
   * tb_inter updateMany
   */
  export type tb_interUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update tb_inters.
     */
    data: XOR<tb_interUpdateManyMutationInput, tb_interUncheckedUpdateManyInput>
    /**
     * Filter which tb_inters to update
     */
    where?: tb_interWhereInput
    /**
     * Limit how many tb_inters to update.
     */
    limit?: number
  }

  /**
   * tb_inter upsert
   */
  export type tb_interUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_inter
     */
    select?: tb_interSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_inter
     */
    omit?: tb_interOmit<ExtArgs> | null
    /**
     * The filter to search for the tb_inter to update in case it exists.
     */
    where: tb_interWhereUniqueInput
    /**
     * In case the tb_inter found by the `where` argument doesn't exist, create a new tb_inter with this data.
     */
    create: XOR<tb_interCreateInput, tb_interUncheckedCreateInput>
    /**
     * In case the tb_inter was found with the provided `where` argument, update it with this data.
     */
    update: XOR<tb_interUpdateInput, tb_interUncheckedUpdateInput>
  }

  /**
   * tb_inter delete
   */
  export type tb_interDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_inter
     */
    select?: tb_interSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_inter
     */
    omit?: tb_interOmit<ExtArgs> | null
    /**
     * Filter which tb_inter to delete.
     */
    where: tb_interWhereUniqueInput
  }

  /**
   * tb_inter deleteMany
   */
  export type tb_interDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tb_inters to delete
     */
    where?: tb_interWhereInput
    /**
     * Limit how many tb_inters to delete.
     */
    limit?: number
  }

  /**
   * tb_inter without action
   */
  export type tb_interDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_inter
     */
    select?: tb_interSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_inter
     */
    omit?: tb_interOmit<ExtArgs> | null
  }


  /**
   * Model tb_inter_notified
   */

  export type AggregateTb_inter_notified = {
    _count: Tb_inter_notifiedCountAggregateOutputType | null
    _avg: Tb_inter_notifiedAvgAggregateOutputType | null
    _sum: Tb_inter_notifiedSumAggregateOutputType | null
    _min: Tb_inter_notifiedMinAggregateOutputType | null
    _max: Tb_inter_notifiedMaxAggregateOutputType | null
  }

  export type Tb_inter_notifiedAvgAggregateOutputType = {
    inter_notified_id: number | null
    inter_id: number | null
  }

  export type Tb_inter_notifiedSumAggregateOutputType = {
    inter_notified_id: number | null
    inter_id: number | null
  }

  export type Tb_inter_notifiedMinAggregateOutputType = {
    inter_notified_id: number | null
    notified_date: Date | null
    actioned: Date | null
    file_name: string | null
    inter_id: number | null
    notification_status: $Enums.tb_inter_notified_notification_status | null
  }

  export type Tb_inter_notifiedMaxAggregateOutputType = {
    inter_notified_id: number | null
    notified_date: Date | null
    actioned: Date | null
    file_name: string | null
    inter_id: number | null
    notification_status: $Enums.tb_inter_notified_notification_status | null
  }

  export type Tb_inter_notifiedCountAggregateOutputType = {
    inter_notified_id: number
    notified_date: number
    actioned: number
    file_name: number
    inter_id: number
    notification_status: number
    _all: number
  }


  export type Tb_inter_notifiedAvgAggregateInputType = {
    inter_notified_id?: true
    inter_id?: true
  }

  export type Tb_inter_notifiedSumAggregateInputType = {
    inter_notified_id?: true
    inter_id?: true
  }

  export type Tb_inter_notifiedMinAggregateInputType = {
    inter_notified_id?: true
    notified_date?: true
    actioned?: true
    file_name?: true
    inter_id?: true
    notification_status?: true
  }

  export type Tb_inter_notifiedMaxAggregateInputType = {
    inter_notified_id?: true
    notified_date?: true
    actioned?: true
    file_name?: true
    inter_id?: true
    notification_status?: true
  }

  export type Tb_inter_notifiedCountAggregateInputType = {
    inter_notified_id?: true
    notified_date?: true
    actioned?: true
    file_name?: true
    inter_id?: true
    notification_status?: true
    _all?: true
  }

  export type Tb_inter_notifiedAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tb_inter_notified to aggregate.
     */
    where?: tb_inter_notifiedWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tb_inter_notifieds to fetch.
     */
    orderBy?: tb_inter_notifiedOrderByWithRelationInput | tb_inter_notifiedOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: tb_inter_notifiedWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tb_inter_notifieds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tb_inter_notifieds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned tb_inter_notifieds
    **/
    _count?: true | Tb_inter_notifiedCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Tb_inter_notifiedAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Tb_inter_notifiedSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Tb_inter_notifiedMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Tb_inter_notifiedMaxAggregateInputType
  }

  export type GetTb_inter_notifiedAggregateType<T extends Tb_inter_notifiedAggregateArgs> = {
        [P in keyof T & keyof AggregateTb_inter_notified]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTb_inter_notified[P]>
      : GetScalarType<T[P], AggregateTb_inter_notified[P]>
  }




  export type tb_inter_notifiedGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: tb_inter_notifiedWhereInput
    orderBy?: tb_inter_notifiedOrderByWithAggregationInput | tb_inter_notifiedOrderByWithAggregationInput[]
    by: Tb_inter_notifiedScalarFieldEnum[] | Tb_inter_notifiedScalarFieldEnum
    having?: tb_inter_notifiedScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Tb_inter_notifiedCountAggregateInputType | true
    _avg?: Tb_inter_notifiedAvgAggregateInputType
    _sum?: Tb_inter_notifiedSumAggregateInputType
    _min?: Tb_inter_notifiedMinAggregateInputType
    _max?: Tb_inter_notifiedMaxAggregateInputType
  }

  export type Tb_inter_notifiedGroupByOutputType = {
    inter_notified_id: number
    notified_date: Date | null
    actioned: Date
    file_name: string | null
    inter_id: number
    notification_status: $Enums.tb_inter_notified_notification_status | null
    _count: Tb_inter_notifiedCountAggregateOutputType | null
    _avg: Tb_inter_notifiedAvgAggregateOutputType | null
    _sum: Tb_inter_notifiedSumAggregateOutputType | null
    _min: Tb_inter_notifiedMinAggregateOutputType | null
    _max: Tb_inter_notifiedMaxAggregateOutputType | null
  }

  type GetTb_inter_notifiedGroupByPayload<T extends tb_inter_notifiedGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Tb_inter_notifiedGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Tb_inter_notifiedGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Tb_inter_notifiedGroupByOutputType[P]>
            : GetScalarType<T[P], Tb_inter_notifiedGroupByOutputType[P]>
        }
      >
    >


  export type tb_inter_notifiedSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    inter_notified_id?: boolean
    notified_date?: boolean
    actioned?: boolean
    file_name?: boolean
    inter_id?: boolean
    notification_status?: boolean
  }, ExtArgs["result"]["tb_inter_notified"]>



  export type tb_inter_notifiedSelectScalar = {
    inter_notified_id?: boolean
    notified_date?: boolean
    actioned?: boolean
    file_name?: boolean
    inter_id?: boolean
    notification_status?: boolean
  }

  export type tb_inter_notifiedOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"inter_notified_id" | "notified_date" | "actioned" | "file_name" | "inter_id" | "notification_status", ExtArgs["result"]["tb_inter_notified"]>

  export type $tb_inter_notifiedPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "tb_inter_notified"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      inter_notified_id: number
      notified_date: Date | null
      actioned: Date
      file_name: string | null
      inter_id: number
      notification_status: $Enums.tb_inter_notified_notification_status | null
    }, ExtArgs["result"]["tb_inter_notified"]>
    composites: {}
  }

  type tb_inter_notifiedGetPayload<S extends boolean | null | undefined | tb_inter_notifiedDefaultArgs> = $Result.GetResult<Prisma.$tb_inter_notifiedPayload, S>

  type tb_inter_notifiedCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<tb_inter_notifiedFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Tb_inter_notifiedCountAggregateInputType | true
    }

  export interface tb_inter_notifiedDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['tb_inter_notified'], meta: { name: 'tb_inter_notified' } }
    /**
     * Find zero or one Tb_inter_notified that matches the filter.
     * @param {tb_inter_notifiedFindUniqueArgs} args - Arguments to find a Tb_inter_notified
     * @example
     * // Get one Tb_inter_notified
     * const tb_inter_notified = await prisma.tb_inter_notified.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends tb_inter_notifiedFindUniqueArgs>(args: SelectSubset<T, tb_inter_notifiedFindUniqueArgs<ExtArgs>>): Prisma__tb_inter_notifiedClient<$Result.GetResult<Prisma.$tb_inter_notifiedPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Tb_inter_notified that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {tb_inter_notifiedFindUniqueOrThrowArgs} args - Arguments to find a Tb_inter_notified
     * @example
     * // Get one Tb_inter_notified
     * const tb_inter_notified = await prisma.tb_inter_notified.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends tb_inter_notifiedFindUniqueOrThrowArgs>(args: SelectSubset<T, tb_inter_notifiedFindUniqueOrThrowArgs<ExtArgs>>): Prisma__tb_inter_notifiedClient<$Result.GetResult<Prisma.$tb_inter_notifiedPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tb_inter_notified that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_inter_notifiedFindFirstArgs} args - Arguments to find a Tb_inter_notified
     * @example
     * // Get one Tb_inter_notified
     * const tb_inter_notified = await prisma.tb_inter_notified.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends tb_inter_notifiedFindFirstArgs>(args?: SelectSubset<T, tb_inter_notifiedFindFirstArgs<ExtArgs>>): Prisma__tb_inter_notifiedClient<$Result.GetResult<Prisma.$tb_inter_notifiedPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tb_inter_notified that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_inter_notifiedFindFirstOrThrowArgs} args - Arguments to find a Tb_inter_notified
     * @example
     * // Get one Tb_inter_notified
     * const tb_inter_notified = await prisma.tb_inter_notified.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends tb_inter_notifiedFindFirstOrThrowArgs>(args?: SelectSubset<T, tb_inter_notifiedFindFirstOrThrowArgs<ExtArgs>>): Prisma__tb_inter_notifiedClient<$Result.GetResult<Prisma.$tb_inter_notifiedPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Tb_inter_notifieds that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_inter_notifiedFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tb_inter_notifieds
     * const tb_inter_notifieds = await prisma.tb_inter_notified.findMany()
     * 
     * // Get first 10 Tb_inter_notifieds
     * const tb_inter_notifieds = await prisma.tb_inter_notified.findMany({ take: 10 })
     * 
     * // Only select the `inter_notified_id`
     * const tb_inter_notifiedWithInter_notified_idOnly = await prisma.tb_inter_notified.findMany({ select: { inter_notified_id: true } })
     * 
     */
    findMany<T extends tb_inter_notifiedFindManyArgs>(args?: SelectSubset<T, tb_inter_notifiedFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tb_inter_notifiedPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Tb_inter_notified.
     * @param {tb_inter_notifiedCreateArgs} args - Arguments to create a Tb_inter_notified.
     * @example
     * // Create one Tb_inter_notified
     * const Tb_inter_notified = await prisma.tb_inter_notified.create({
     *   data: {
     *     // ... data to create a Tb_inter_notified
     *   }
     * })
     * 
     */
    create<T extends tb_inter_notifiedCreateArgs>(args: SelectSubset<T, tb_inter_notifiedCreateArgs<ExtArgs>>): Prisma__tb_inter_notifiedClient<$Result.GetResult<Prisma.$tb_inter_notifiedPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Tb_inter_notifieds.
     * @param {tb_inter_notifiedCreateManyArgs} args - Arguments to create many Tb_inter_notifieds.
     * @example
     * // Create many Tb_inter_notifieds
     * const tb_inter_notified = await prisma.tb_inter_notified.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends tb_inter_notifiedCreateManyArgs>(args?: SelectSubset<T, tb_inter_notifiedCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Tb_inter_notified.
     * @param {tb_inter_notifiedDeleteArgs} args - Arguments to delete one Tb_inter_notified.
     * @example
     * // Delete one Tb_inter_notified
     * const Tb_inter_notified = await prisma.tb_inter_notified.delete({
     *   where: {
     *     // ... filter to delete one Tb_inter_notified
     *   }
     * })
     * 
     */
    delete<T extends tb_inter_notifiedDeleteArgs>(args: SelectSubset<T, tb_inter_notifiedDeleteArgs<ExtArgs>>): Prisma__tb_inter_notifiedClient<$Result.GetResult<Prisma.$tb_inter_notifiedPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Tb_inter_notified.
     * @param {tb_inter_notifiedUpdateArgs} args - Arguments to update one Tb_inter_notified.
     * @example
     * // Update one Tb_inter_notified
     * const tb_inter_notified = await prisma.tb_inter_notified.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends tb_inter_notifiedUpdateArgs>(args: SelectSubset<T, tb_inter_notifiedUpdateArgs<ExtArgs>>): Prisma__tb_inter_notifiedClient<$Result.GetResult<Prisma.$tb_inter_notifiedPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Tb_inter_notifieds.
     * @param {tb_inter_notifiedDeleteManyArgs} args - Arguments to filter Tb_inter_notifieds to delete.
     * @example
     * // Delete a few Tb_inter_notifieds
     * const { count } = await prisma.tb_inter_notified.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends tb_inter_notifiedDeleteManyArgs>(args?: SelectSubset<T, tb_inter_notifiedDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tb_inter_notifieds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_inter_notifiedUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tb_inter_notifieds
     * const tb_inter_notified = await prisma.tb_inter_notified.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends tb_inter_notifiedUpdateManyArgs>(args: SelectSubset<T, tb_inter_notifiedUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Tb_inter_notified.
     * @param {tb_inter_notifiedUpsertArgs} args - Arguments to update or create a Tb_inter_notified.
     * @example
     * // Update or create a Tb_inter_notified
     * const tb_inter_notified = await prisma.tb_inter_notified.upsert({
     *   create: {
     *     // ... data to create a Tb_inter_notified
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tb_inter_notified we want to update
     *   }
     * })
     */
    upsert<T extends tb_inter_notifiedUpsertArgs>(args: SelectSubset<T, tb_inter_notifiedUpsertArgs<ExtArgs>>): Prisma__tb_inter_notifiedClient<$Result.GetResult<Prisma.$tb_inter_notifiedPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Tb_inter_notifieds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_inter_notifiedCountArgs} args - Arguments to filter Tb_inter_notifieds to count.
     * @example
     * // Count the number of Tb_inter_notifieds
     * const count = await prisma.tb_inter_notified.count({
     *   where: {
     *     // ... the filter for the Tb_inter_notifieds we want to count
     *   }
     * })
    **/
    count<T extends tb_inter_notifiedCountArgs>(
      args?: Subset<T, tb_inter_notifiedCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Tb_inter_notifiedCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tb_inter_notified.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Tb_inter_notifiedAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Tb_inter_notifiedAggregateArgs>(args: Subset<T, Tb_inter_notifiedAggregateArgs>): Prisma.PrismaPromise<GetTb_inter_notifiedAggregateType<T>>

    /**
     * Group by Tb_inter_notified.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_inter_notifiedGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends tb_inter_notifiedGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: tb_inter_notifiedGroupByArgs['orderBy'] }
        : { orderBy?: tb_inter_notifiedGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, tb_inter_notifiedGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTb_inter_notifiedGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the tb_inter_notified model
   */
  readonly fields: tb_inter_notifiedFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for tb_inter_notified.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__tb_inter_notifiedClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the tb_inter_notified model
   */
  interface tb_inter_notifiedFieldRefs {
    readonly inter_notified_id: FieldRef<"tb_inter_notified", 'Int'>
    readonly notified_date: FieldRef<"tb_inter_notified", 'DateTime'>
    readonly actioned: FieldRef<"tb_inter_notified", 'DateTime'>
    readonly file_name: FieldRef<"tb_inter_notified", 'String'>
    readonly inter_id: FieldRef<"tb_inter_notified", 'Int'>
    readonly notification_status: FieldRef<"tb_inter_notified", 'tb_inter_notified_notification_status'>
  }
    

  // Custom InputTypes
  /**
   * tb_inter_notified findUnique
   */
  export type tb_inter_notifiedFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_inter_notified
     */
    select?: tb_inter_notifiedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_inter_notified
     */
    omit?: tb_inter_notifiedOmit<ExtArgs> | null
    /**
     * Filter, which tb_inter_notified to fetch.
     */
    where: tb_inter_notifiedWhereUniqueInput
  }

  /**
   * tb_inter_notified findUniqueOrThrow
   */
  export type tb_inter_notifiedFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_inter_notified
     */
    select?: tb_inter_notifiedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_inter_notified
     */
    omit?: tb_inter_notifiedOmit<ExtArgs> | null
    /**
     * Filter, which tb_inter_notified to fetch.
     */
    where: tb_inter_notifiedWhereUniqueInput
  }

  /**
   * tb_inter_notified findFirst
   */
  export type tb_inter_notifiedFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_inter_notified
     */
    select?: tb_inter_notifiedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_inter_notified
     */
    omit?: tb_inter_notifiedOmit<ExtArgs> | null
    /**
     * Filter, which tb_inter_notified to fetch.
     */
    where?: tb_inter_notifiedWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tb_inter_notifieds to fetch.
     */
    orderBy?: tb_inter_notifiedOrderByWithRelationInput | tb_inter_notifiedOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tb_inter_notifieds.
     */
    cursor?: tb_inter_notifiedWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tb_inter_notifieds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tb_inter_notifieds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tb_inter_notifieds.
     */
    distinct?: Tb_inter_notifiedScalarFieldEnum | Tb_inter_notifiedScalarFieldEnum[]
  }

  /**
   * tb_inter_notified findFirstOrThrow
   */
  export type tb_inter_notifiedFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_inter_notified
     */
    select?: tb_inter_notifiedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_inter_notified
     */
    omit?: tb_inter_notifiedOmit<ExtArgs> | null
    /**
     * Filter, which tb_inter_notified to fetch.
     */
    where?: tb_inter_notifiedWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tb_inter_notifieds to fetch.
     */
    orderBy?: tb_inter_notifiedOrderByWithRelationInput | tb_inter_notifiedOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tb_inter_notifieds.
     */
    cursor?: tb_inter_notifiedWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tb_inter_notifieds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tb_inter_notifieds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tb_inter_notifieds.
     */
    distinct?: Tb_inter_notifiedScalarFieldEnum | Tb_inter_notifiedScalarFieldEnum[]
  }

  /**
   * tb_inter_notified findMany
   */
  export type tb_inter_notifiedFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_inter_notified
     */
    select?: tb_inter_notifiedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_inter_notified
     */
    omit?: tb_inter_notifiedOmit<ExtArgs> | null
    /**
     * Filter, which tb_inter_notifieds to fetch.
     */
    where?: tb_inter_notifiedWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tb_inter_notifieds to fetch.
     */
    orderBy?: tb_inter_notifiedOrderByWithRelationInput | tb_inter_notifiedOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing tb_inter_notifieds.
     */
    cursor?: tb_inter_notifiedWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tb_inter_notifieds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tb_inter_notifieds.
     */
    skip?: number
    distinct?: Tb_inter_notifiedScalarFieldEnum | Tb_inter_notifiedScalarFieldEnum[]
  }

  /**
   * tb_inter_notified create
   */
  export type tb_inter_notifiedCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_inter_notified
     */
    select?: tb_inter_notifiedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_inter_notified
     */
    omit?: tb_inter_notifiedOmit<ExtArgs> | null
    /**
     * The data needed to create a tb_inter_notified.
     */
    data: XOR<tb_inter_notifiedCreateInput, tb_inter_notifiedUncheckedCreateInput>
  }

  /**
   * tb_inter_notified createMany
   */
  export type tb_inter_notifiedCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many tb_inter_notifieds.
     */
    data: tb_inter_notifiedCreateManyInput | tb_inter_notifiedCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * tb_inter_notified update
   */
  export type tb_inter_notifiedUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_inter_notified
     */
    select?: tb_inter_notifiedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_inter_notified
     */
    omit?: tb_inter_notifiedOmit<ExtArgs> | null
    /**
     * The data needed to update a tb_inter_notified.
     */
    data: XOR<tb_inter_notifiedUpdateInput, tb_inter_notifiedUncheckedUpdateInput>
    /**
     * Choose, which tb_inter_notified to update.
     */
    where: tb_inter_notifiedWhereUniqueInput
  }

  /**
   * tb_inter_notified updateMany
   */
  export type tb_inter_notifiedUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update tb_inter_notifieds.
     */
    data: XOR<tb_inter_notifiedUpdateManyMutationInput, tb_inter_notifiedUncheckedUpdateManyInput>
    /**
     * Filter which tb_inter_notifieds to update
     */
    where?: tb_inter_notifiedWhereInput
    /**
     * Limit how many tb_inter_notifieds to update.
     */
    limit?: number
  }

  /**
   * tb_inter_notified upsert
   */
  export type tb_inter_notifiedUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_inter_notified
     */
    select?: tb_inter_notifiedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_inter_notified
     */
    omit?: tb_inter_notifiedOmit<ExtArgs> | null
    /**
     * The filter to search for the tb_inter_notified to update in case it exists.
     */
    where: tb_inter_notifiedWhereUniqueInput
    /**
     * In case the tb_inter_notified found by the `where` argument doesn't exist, create a new tb_inter_notified with this data.
     */
    create: XOR<tb_inter_notifiedCreateInput, tb_inter_notifiedUncheckedCreateInput>
    /**
     * In case the tb_inter_notified was found with the provided `where` argument, update it with this data.
     */
    update: XOR<tb_inter_notifiedUpdateInput, tb_inter_notifiedUncheckedUpdateInput>
  }

  /**
   * tb_inter_notified delete
   */
  export type tb_inter_notifiedDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_inter_notified
     */
    select?: tb_inter_notifiedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_inter_notified
     */
    omit?: tb_inter_notifiedOmit<ExtArgs> | null
    /**
     * Filter which tb_inter_notified to delete.
     */
    where: tb_inter_notifiedWhereUniqueInput
  }

  /**
   * tb_inter_notified deleteMany
   */
  export type tb_inter_notifiedDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tb_inter_notifieds to delete
     */
    where?: tb_inter_notifiedWhereInput
    /**
     * Limit how many tb_inter_notifieds to delete.
     */
    limit?: number
  }

  /**
   * tb_inter_notified without action
   */
  export type tb_inter_notifiedDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_inter_notified
     */
    select?: tb_inter_notifiedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_inter_notified
     */
    omit?: tb_inter_notifiedOmit<ExtArgs> | null
  }


  /**
   * Model tb_inter_recivers
   */

  export type AggregateTb_inter_recivers = {
    _count: Tb_inter_reciversCountAggregateOutputType | null
    _avg: Tb_inter_reciversAvgAggregateOutputType | null
    _sum: Tb_inter_reciversSumAggregateOutputType | null
    _min: Tb_inter_reciversMinAggregateOutputType | null
    _max: Tb_inter_reciversMaxAggregateOutputType | null
  }

  export type Tb_inter_reciversAvgAggregateOutputType = {
    inter_reciever_id: number | null
  }

  export type Tb_inter_reciversSumAggregateOutputType = {
    inter_reciever_id: number | null
  }

  export type Tb_inter_reciversMinAggregateOutputType = {
    inter_reciever_id: number | null
    inter_reciever_text: string | null
  }

  export type Tb_inter_reciversMaxAggregateOutputType = {
    inter_reciever_id: number | null
    inter_reciever_text: string | null
  }

  export type Tb_inter_reciversCountAggregateOutputType = {
    inter_reciever_id: number
    inter_reciever_text: number
    _all: number
  }


  export type Tb_inter_reciversAvgAggregateInputType = {
    inter_reciever_id?: true
  }

  export type Tb_inter_reciversSumAggregateInputType = {
    inter_reciever_id?: true
  }

  export type Tb_inter_reciversMinAggregateInputType = {
    inter_reciever_id?: true
    inter_reciever_text?: true
  }

  export type Tb_inter_reciversMaxAggregateInputType = {
    inter_reciever_id?: true
    inter_reciever_text?: true
  }

  export type Tb_inter_reciversCountAggregateInputType = {
    inter_reciever_id?: true
    inter_reciever_text?: true
    _all?: true
  }

  export type Tb_inter_reciversAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tb_inter_recivers to aggregate.
     */
    where?: tb_inter_reciversWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tb_inter_recivers to fetch.
     */
    orderBy?: tb_inter_reciversOrderByWithRelationInput | tb_inter_reciversOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: tb_inter_reciversWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tb_inter_recivers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tb_inter_recivers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned tb_inter_recivers
    **/
    _count?: true | Tb_inter_reciversCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Tb_inter_reciversAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Tb_inter_reciversSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Tb_inter_reciversMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Tb_inter_reciversMaxAggregateInputType
  }

  export type GetTb_inter_reciversAggregateType<T extends Tb_inter_reciversAggregateArgs> = {
        [P in keyof T & keyof AggregateTb_inter_recivers]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTb_inter_recivers[P]>
      : GetScalarType<T[P], AggregateTb_inter_recivers[P]>
  }




  export type tb_inter_reciversGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: tb_inter_reciversWhereInput
    orderBy?: tb_inter_reciversOrderByWithAggregationInput | tb_inter_reciversOrderByWithAggregationInput[]
    by: Tb_inter_reciversScalarFieldEnum[] | Tb_inter_reciversScalarFieldEnum
    having?: tb_inter_reciversScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Tb_inter_reciversCountAggregateInputType | true
    _avg?: Tb_inter_reciversAvgAggregateInputType
    _sum?: Tb_inter_reciversSumAggregateInputType
    _min?: Tb_inter_reciversMinAggregateInputType
    _max?: Tb_inter_reciversMaxAggregateInputType
  }

  export type Tb_inter_reciversGroupByOutputType = {
    inter_reciever_id: number
    inter_reciever_text: string
    _count: Tb_inter_reciversCountAggregateOutputType | null
    _avg: Tb_inter_reciversAvgAggregateOutputType | null
    _sum: Tb_inter_reciversSumAggregateOutputType | null
    _min: Tb_inter_reciversMinAggregateOutputType | null
    _max: Tb_inter_reciversMaxAggregateOutputType | null
  }

  type GetTb_inter_reciversGroupByPayload<T extends tb_inter_reciversGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Tb_inter_reciversGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Tb_inter_reciversGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Tb_inter_reciversGroupByOutputType[P]>
            : GetScalarType<T[P], Tb_inter_reciversGroupByOutputType[P]>
        }
      >
    >


  export type tb_inter_reciversSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    inter_reciever_id?: boolean
    inter_reciever_text?: boolean
  }, ExtArgs["result"]["tb_inter_recivers"]>



  export type tb_inter_reciversSelectScalar = {
    inter_reciever_id?: boolean
    inter_reciever_text?: boolean
  }

  export type tb_inter_reciversOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"inter_reciever_id" | "inter_reciever_text", ExtArgs["result"]["tb_inter_recivers"]>

  export type $tb_inter_reciversPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "tb_inter_recivers"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      inter_reciever_id: number
      inter_reciever_text: string
    }, ExtArgs["result"]["tb_inter_recivers"]>
    composites: {}
  }

  type tb_inter_reciversGetPayload<S extends boolean | null | undefined | tb_inter_reciversDefaultArgs> = $Result.GetResult<Prisma.$tb_inter_reciversPayload, S>

  type tb_inter_reciversCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<tb_inter_reciversFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Tb_inter_reciversCountAggregateInputType | true
    }

  export interface tb_inter_reciversDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['tb_inter_recivers'], meta: { name: 'tb_inter_recivers' } }
    /**
     * Find zero or one Tb_inter_recivers that matches the filter.
     * @param {tb_inter_reciversFindUniqueArgs} args - Arguments to find a Tb_inter_recivers
     * @example
     * // Get one Tb_inter_recivers
     * const tb_inter_recivers = await prisma.tb_inter_recivers.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends tb_inter_reciversFindUniqueArgs>(args: SelectSubset<T, tb_inter_reciversFindUniqueArgs<ExtArgs>>): Prisma__tb_inter_reciversClient<$Result.GetResult<Prisma.$tb_inter_reciversPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Tb_inter_recivers that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {tb_inter_reciversFindUniqueOrThrowArgs} args - Arguments to find a Tb_inter_recivers
     * @example
     * // Get one Tb_inter_recivers
     * const tb_inter_recivers = await prisma.tb_inter_recivers.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends tb_inter_reciversFindUniqueOrThrowArgs>(args: SelectSubset<T, tb_inter_reciversFindUniqueOrThrowArgs<ExtArgs>>): Prisma__tb_inter_reciversClient<$Result.GetResult<Prisma.$tb_inter_reciversPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tb_inter_recivers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_inter_reciversFindFirstArgs} args - Arguments to find a Tb_inter_recivers
     * @example
     * // Get one Tb_inter_recivers
     * const tb_inter_recivers = await prisma.tb_inter_recivers.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends tb_inter_reciversFindFirstArgs>(args?: SelectSubset<T, tb_inter_reciversFindFirstArgs<ExtArgs>>): Prisma__tb_inter_reciversClient<$Result.GetResult<Prisma.$tb_inter_reciversPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tb_inter_recivers that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_inter_reciversFindFirstOrThrowArgs} args - Arguments to find a Tb_inter_recivers
     * @example
     * // Get one Tb_inter_recivers
     * const tb_inter_recivers = await prisma.tb_inter_recivers.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends tb_inter_reciversFindFirstOrThrowArgs>(args?: SelectSubset<T, tb_inter_reciversFindFirstOrThrowArgs<ExtArgs>>): Prisma__tb_inter_reciversClient<$Result.GetResult<Prisma.$tb_inter_reciversPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Tb_inter_recivers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_inter_reciversFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tb_inter_recivers
     * const tb_inter_recivers = await prisma.tb_inter_recivers.findMany()
     * 
     * // Get first 10 Tb_inter_recivers
     * const tb_inter_recivers = await prisma.tb_inter_recivers.findMany({ take: 10 })
     * 
     * // Only select the `inter_reciever_id`
     * const tb_inter_reciversWithInter_reciever_idOnly = await prisma.tb_inter_recivers.findMany({ select: { inter_reciever_id: true } })
     * 
     */
    findMany<T extends tb_inter_reciversFindManyArgs>(args?: SelectSubset<T, tb_inter_reciversFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tb_inter_reciversPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Tb_inter_recivers.
     * @param {tb_inter_reciversCreateArgs} args - Arguments to create a Tb_inter_recivers.
     * @example
     * // Create one Tb_inter_recivers
     * const Tb_inter_recivers = await prisma.tb_inter_recivers.create({
     *   data: {
     *     // ... data to create a Tb_inter_recivers
     *   }
     * })
     * 
     */
    create<T extends tb_inter_reciversCreateArgs>(args: SelectSubset<T, tb_inter_reciversCreateArgs<ExtArgs>>): Prisma__tb_inter_reciversClient<$Result.GetResult<Prisma.$tb_inter_reciversPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Tb_inter_recivers.
     * @param {tb_inter_reciversCreateManyArgs} args - Arguments to create many Tb_inter_recivers.
     * @example
     * // Create many Tb_inter_recivers
     * const tb_inter_recivers = await prisma.tb_inter_recivers.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends tb_inter_reciversCreateManyArgs>(args?: SelectSubset<T, tb_inter_reciversCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Tb_inter_recivers.
     * @param {tb_inter_reciversDeleteArgs} args - Arguments to delete one Tb_inter_recivers.
     * @example
     * // Delete one Tb_inter_recivers
     * const Tb_inter_recivers = await prisma.tb_inter_recivers.delete({
     *   where: {
     *     // ... filter to delete one Tb_inter_recivers
     *   }
     * })
     * 
     */
    delete<T extends tb_inter_reciversDeleteArgs>(args: SelectSubset<T, tb_inter_reciversDeleteArgs<ExtArgs>>): Prisma__tb_inter_reciversClient<$Result.GetResult<Prisma.$tb_inter_reciversPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Tb_inter_recivers.
     * @param {tb_inter_reciversUpdateArgs} args - Arguments to update one Tb_inter_recivers.
     * @example
     * // Update one Tb_inter_recivers
     * const tb_inter_recivers = await prisma.tb_inter_recivers.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends tb_inter_reciversUpdateArgs>(args: SelectSubset<T, tb_inter_reciversUpdateArgs<ExtArgs>>): Prisma__tb_inter_reciversClient<$Result.GetResult<Prisma.$tb_inter_reciversPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Tb_inter_recivers.
     * @param {tb_inter_reciversDeleteManyArgs} args - Arguments to filter Tb_inter_recivers to delete.
     * @example
     * // Delete a few Tb_inter_recivers
     * const { count } = await prisma.tb_inter_recivers.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends tb_inter_reciversDeleteManyArgs>(args?: SelectSubset<T, tb_inter_reciversDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tb_inter_recivers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_inter_reciversUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tb_inter_recivers
     * const tb_inter_recivers = await prisma.tb_inter_recivers.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends tb_inter_reciversUpdateManyArgs>(args: SelectSubset<T, tb_inter_reciversUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Tb_inter_recivers.
     * @param {tb_inter_reciversUpsertArgs} args - Arguments to update or create a Tb_inter_recivers.
     * @example
     * // Update or create a Tb_inter_recivers
     * const tb_inter_recivers = await prisma.tb_inter_recivers.upsert({
     *   create: {
     *     // ... data to create a Tb_inter_recivers
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tb_inter_recivers we want to update
     *   }
     * })
     */
    upsert<T extends tb_inter_reciversUpsertArgs>(args: SelectSubset<T, tb_inter_reciversUpsertArgs<ExtArgs>>): Prisma__tb_inter_reciversClient<$Result.GetResult<Prisma.$tb_inter_reciversPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Tb_inter_recivers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_inter_reciversCountArgs} args - Arguments to filter Tb_inter_recivers to count.
     * @example
     * // Count the number of Tb_inter_recivers
     * const count = await prisma.tb_inter_recivers.count({
     *   where: {
     *     // ... the filter for the Tb_inter_recivers we want to count
     *   }
     * })
    **/
    count<T extends tb_inter_reciversCountArgs>(
      args?: Subset<T, tb_inter_reciversCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Tb_inter_reciversCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tb_inter_recivers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Tb_inter_reciversAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Tb_inter_reciversAggregateArgs>(args: Subset<T, Tb_inter_reciversAggregateArgs>): Prisma.PrismaPromise<GetTb_inter_reciversAggregateType<T>>

    /**
     * Group by Tb_inter_recivers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_inter_reciversGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends tb_inter_reciversGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: tb_inter_reciversGroupByArgs['orderBy'] }
        : { orderBy?: tb_inter_reciversGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, tb_inter_reciversGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTb_inter_reciversGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the tb_inter_recivers model
   */
  readonly fields: tb_inter_reciversFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for tb_inter_recivers.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__tb_inter_reciversClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the tb_inter_recivers model
   */
  interface tb_inter_reciversFieldRefs {
    readonly inter_reciever_id: FieldRef<"tb_inter_recivers", 'Int'>
    readonly inter_reciever_text: FieldRef<"tb_inter_recivers", 'String'>
  }
    

  // Custom InputTypes
  /**
   * tb_inter_recivers findUnique
   */
  export type tb_inter_reciversFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_inter_recivers
     */
    select?: tb_inter_reciversSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_inter_recivers
     */
    omit?: tb_inter_reciversOmit<ExtArgs> | null
    /**
     * Filter, which tb_inter_recivers to fetch.
     */
    where: tb_inter_reciversWhereUniqueInput
  }

  /**
   * tb_inter_recivers findUniqueOrThrow
   */
  export type tb_inter_reciversFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_inter_recivers
     */
    select?: tb_inter_reciversSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_inter_recivers
     */
    omit?: tb_inter_reciversOmit<ExtArgs> | null
    /**
     * Filter, which tb_inter_recivers to fetch.
     */
    where: tb_inter_reciversWhereUniqueInput
  }

  /**
   * tb_inter_recivers findFirst
   */
  export type tb_inter_reciversFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_inter_recivers
     */
    select?: tb_inter_reciversSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_inter_recivers
     */
    omit?: tb_inter_reciversOmit<ExtArgs> | null
    /**
     * Filter, which tb_inter_recivers to fetch.
     */
    where?: tb_inter_reciversWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tb_inter_recivers to fetch.
     */
    orderBy?: tb_inter_reciversOrderByWithRelationInput | tb_inter_reciversOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tb_inter_recivers.
     */
    cursor?: tb_inter_reciversWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tb_inter_recivers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tb_inter_recivers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tb_inter_recivers.
     */
    distinct?: Tb_inter_reciversScalarFieldEnum | Tb_inter_reciversScalarFieldEnum[]
  }

  /**
   * tb_inter_recivers findFirstOrThrow
   */
  export type tb_inter_reciversFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_inter_recivers
     */
    select?: tb_inter_reciversSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_inter_recivers
     */
    omit?: tb_inter_reciversOmit<ExtArgs> | null
    /**
     * Filter, which tb_inter_recivers to fetch.
     */
    where?: tb_inter_reciversWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tb_inter_recivers to fetch.
     */
    orderBy?: tb_inter_reciversOrderByWithRelationInput | tb_inter_reciversOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tb_inter_recivers.
     */
    cursor?: tb_inter_reciversWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tb_inter_recivers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tb_inter_recivers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tb_inter_recivers.
     */
    distinct?: Tb_inter_reciversScalarFieldEnum | Tb_inter_reciversScalarFieldEnum[]
  }

  /**
   * tb_inter_recivers findMany
   */
  export type tb_inter_reciversFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_inter_recivers
     */
    select?: tb_inter_reciversSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_inter_recivers
     */
    omit?: tb_inter_reciversOmit<ExtArgs> | null
    /**
     * Filter, which tb_inter_recivers to fetch.
     */
    where?: tb_inter_reciversWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tb_inter_recivers to fetch.
     */
    orderBy?: tb_inter_reciversOrderByWithRelationInput | tb_inter_reciversOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing tb_inter_recivers.
     */
    cursor?: tb_inter_reciversWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tb_inter_recivers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tb_inter_recivers.
     */
    skip?: number
    distinct?: Tb_inter_reciversScalarFieldEnum | Tb_inter_reciversScalarFieldEnum[]
  }

  /**
   * tb_inter_recivers create
   */
  export type tb_inter_reciversCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_inter_recivers
     */
    select?: tb_inter_reciversSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_inter_recivers
     */
    omit?: tb_inter_reciversOmit<ExtArgs> | null
    /**
     * The data needed to create a tb_inter_recivers.
     */
    data: XOR<tb_inter_reciversCreateInput, tb_inter_reciversUncheckedCreateInput>
  }

  /**
   * tb_inter_recivers createMany
   */
  export type tb_inter_reciversCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many tb_inter_recivers.
     */
    data: tb_inter_reciversCreateManyInput | tb_inter_reciversCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * tb_inter_recivers update
   */
  export type tb_inter_reciversUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_inter_recivers
     */
    select?: tb_inter_reciversSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_inter_recivers
     */
    omit?: tb_inter_reciversOmit<ExtArgs> | null
    /**
     * The data needed to update a tb_inter_recivers.
     */
    data: XOR<tb_inter_reciversUpdateInput, tb_inter_reciversUncheckedUpdateInput>
    /**
     * Choose, which tb_inter_recivers to update.
     */
    where: tb_inter_reciversWhereUniqueInput
  }

  /**
   * tb_inter_recivers updateMany
   */
  export type tb_inter_reciversUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update tb_inter_recivers.
     */
    data: XOR<tb_inter_reciversUpdateManyMutationInput, tb_inter_reciversUncheckedUpdateManyInput>
    /**
     * Filter which tb_inter_recivers to update
     */
    where?: tb_inter_reciversWhereInput
    /**
     * Limit how many tb_inter_recivers to update.
     */
    limit?: number
  }

  /**
   * tb_inter_recivers upsert
   */
  export type tb_inter_reciversUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_inter_recivers
     */
    select?: tb_inter_reciversSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_inter_recivers
     */
    omit?: tb_inter_reciversOmit<ExtArgs> | null
    /**
     * The filter to search for the tb_inter_recivers to update in case it exists.
     */
    where: tb_inter_reciversWhereUniqueInput
    /**
     * In case the tb_inter_recivers found by the `where` argument doesn't exist, create a new tb_inter_recivers with this data.
     */
    create: XOR<tb_inter_reciversCreateInput, tb_inter_reciversUncheckedCreateInput>
    /**
     * In case the tb_inter_recivers was found with the provided `where` argument, update it with this data.
     */
    update: XOR<tb_inter_reciversUpdateInput, tb_inter_reciversUncheckedUpdateInput>
  }

  /**
   * tb_inter_recivers delete
   */
  export type tb_inter_reciversDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_inter_recivers
     */
    select?: tb_inter_reciversSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_inter_recivers
     */
    omit?: tb_inter_reciversOmit<ExtArgs> | null
    /**
     * Filter which tb_inter_recivers to delete.
     */
    where: tb_inter_reciversWhereUniqueInput
  }

  /**
   * tb_inter_recivers deleteMany
   */
  export type tb_inter_reciversDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tb_inter_recivers to delete
     */
    where?: tb_inter_reciversWhereInput
    /**
     * Limit how many tb_inter_recivers to delete.
     */
    limit?: number
  }

  /**
   * tb_inter_recivers without action
   */
  export type tb_inter_reciversDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_inter_recivers
     */
    select?: tb_inter_reciversSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_inter_recivers
     */
    omit?: tb_inter_reciversOmit<ExtArgs> | null
  }


  /**
   * Model tb_inter_send_type
   */

  export type AggregateTb_inter_send_type = {
    _count: Tb_inter_send_typeCountAggregateOutputType | null
    _avg: Tb_inter_send_typeAvgAggregateOutputType | null
    _sum: Tb_inter_send_typeSumAggregateOutputType | null
    _min: Tb_inter_send_typeMinAggregateOutputType | null
    _max: Tb_inter_send_typeMaxAggregateOutputType | null
  }

  export type Tb_inter_send_typeAvgAggregateOutputType = {
    inter_send_type_id: number | null
  }

  export type Tb_inter_send_typeSumAggregateOutputType = {
    inter_send_type_id: number | null
  }

  export type Tb_inter_send_typeMinAggregateOutputType = {
    inter_send_type_id: number | null
    inter_send_type: string | null
  }

  export type Tb_inter_send_typeMaxAggregateOutputType = {
    inter_send_type_id: number | null
    inter_send_type: string | null
  }

  export type Tb_inter_send_typeCountAggregateOutputType = {
    inter_send_type_id: number
    inter_send_type: number
    _all: number
  }


  export type Tb_inter_send_typeAvgAggregateInputType = {
    inter_send_type_id?: true
  }

  export type Tb_inter_send_typeSumAggregateInputType = {
    inter_send_type_id?: true
  }

  export type Tb_inter_send_typeMinAggregateInputType = {
    inter_send_type_id?: true
    inter_send_type?: true
  }

  export type Tb_inter_send_typeMaxAggregateInputType = {
    inter_send_type_id?: true
    inter_send_type?: true
  }

  export type Tb_inter_send_typeCountAggregateInputType = {
    inter_send_type_id?: true
    inter_send_type?: true
    _all?: true
  }

  export type Tb_inter_send_typeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tb_inter_send_type to aggregate.
     */
    where?: tb_inter_send_typeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tb_inter_send_types to fetch.
     */
    orderBy?: tb_inter_send_typeOrderByWithRelationInput | tb_inter_send_typeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: tb_inter_send_typeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tb_inter_send_types from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tb_inter_send_types.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned tb_inter_send_types
    **/
    _count?: true | Tb_inter_send_typeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Tb_inter_send_typeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Tb_inter_send_typeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Tb_inter_send_typeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Tb_inter_send_typeMaxAggregateInputType
  }

  export type GetTb_inter_send_typeAggregateType<T extends Tb_inter_send_typeAggregateArgs> = {
        [P in keyof T & keyof AggregateTb_inter_send_type]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTb_inter_send_type[P]>
      : GetScalarType<T[P], AggregateTb_inter_send_type[P]>
  }




  export type tb_inter_send_typeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: tb_inter_send_typeWhereInput
    orderBy?: tb_inter_send_typeOrderByWithAggregationInput | tb_inter_send_typeOrderByWithAggregationInput[]
    by: Tb_inter_send_typeScalarFieldEnum[] | Tb_inter_send_typeScalarFieldEnum
    having?: tb_inter_send_typeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Tb_inter_send_typeCountAggregateInputType | true
    _avg?: Tb_inter_send_typeAvgAggregateInputType
    _sum?: Tb_inter_send_typeSumAggregateInputType
    _min?: Tb_inter_send_typeMinAggregateInputType
    _max?: Tb_inter_send_typeMaxAggregateInputType
  }

  export type Tb_inter_send_typeGroupByOutputType = {
    inter_send_type_id: number
    inter_send_type: string
    _count: Tb_inter_send_typeCountAggregateOutputType | null
    _avg: Tb_inter_send_typeAvgAggregateOutputType | null
    _sum: Tb_inter_send_typeSumAggregateOutputType | null
    _min: Tb_inter_send_typeMinAggregateOutputType | null
    _max: Tb_inter_send_typeMaxAggregateOutputType | null
  }

  type GetTb_inter_send_typeGroupByPayload<T extends tb_inter_send_typeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Tb_inter_send_typeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Tb_inter_send_typeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Tb_inter_send_typeGroupByOutputType[P]>
            : GetScalarType<T[P], Tb_inter_send_typeGroupByOutputType[P]>
        }
      >
    >


  export type tb_inter_send_typeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    inter_send_type_id?: boolean
    inter_send_type?: boolean
  }, ExtArgs["result"]["tb_inter_send_type"]>



  export type tb_inter_send_typeSelectScalar = {
    inter_send_type_id?: boolean
    inter_send_type?: boolean
  }

  export type tb_inter_send_typeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"inter_send_type_id" | "inter_send_type", ExtArgs["result"]["tb_inter_send_type"]>

  export type $tb_inter_send_typePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "tb_inter_send_type"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      inter_send_type_id: number
      inter_send_type: string
    }, ExtArgs["result"]["tb_inter_send_type"]>
    composites: {}
  }

  type tb_inter_send_typeGetPayload<S extends boolean | null | undefined | tb_inter_send_typeDefaultArgs> = $Result.GetResult<Prisma.$tb_inter_send_typePayload, S>

  type tb_inter_send_typeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<tb_inter_send_typeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Tb_inter_send_typeCountAggregateInputType | true
    }

  export interface tb_inter_send_typeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['tb_inter_send_type'], meta: { name: 'tb_inter_send_type' } }
    /**
     * Find zero or one Tb_inter_send_type that matches the filter.
     * @param {tb_inter_send_typeFindUniqueArgs} args - Arguments to find a Tb_inter_send_type
     * @example
     * // Get one Tb_inter_send_type
     * const tb_inter_send_type = await prisma.tb_inter_send_type.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends tb_inter_send_typeFindUniqueArgs>(args: SelectSubset<T, tb_inter_send_typeFindUniqueArgs<ExtArgs>>): Prisma__tb_inter_send_typeClient<$Result.GetResult<Prisma.$tb_inter_send_typePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Tb_inter_send_type that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {tb_inter_send_typeFindUniqueOrThrowArgs} args - Arguments to find a Tb_inter_send_type
     * @example
     * // Get one Tb_inter_send_type
     * const tb_inter_send_type = await prisma.tb_inter_send_type.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends tb_inter_send_typeFindUniqueOrThrowArgs>(args: SelectSubset<T, tb_inter_send_typeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__tb_inter_send_typeClient<$Result.GetResult<Prisma.$tb_inter_send_typePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tb_inter_send_type that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_inter_send_typeFindFirstArgs} args - Arguments to find a Tb_inter_send_type
     * @example
     * // Get one Tb_inter_send_type
     * const tb_inter_send_type = await prisma.tb_inter_send_type.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends tb_inter_send_typeFindFirstArgs>(args?: SelectSubset<T, tb_inter_send_typeFindFirstArgs<ExtArgs>>): Prisma__tb_inter_send_typeClient<$Result.GetResult<Prisma.$tb_inter_send_typePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tb_inter_send_type that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_inter_send_typeFindFirstOrThrowArgs} args - Arguments to find a Tb_inter_send_type
     * @example
     * // Get one Tb_inter_send_type
     * const tb_inter_send_type = await prisma.tb_inter_send_type.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends tb_inter_send_typeFindFirstOrThrowArgs>(args?: SelectSubset<T, tb_inter_send_typeFindFirstOrThrowArgs<ExtArgs>>): Prisma__tb_inter_send_typeClient<$Result.GetResult<Prisma.$tb_inter_send_typePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Tb_inter_send_types that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_inter_send_typeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tb_inter_send_types
     * const tb_inter_send_types = await prisma.tb_inter_send_type.findMany()
     * 
     * // Get first 10 Tb_inter_send_types
     * const tb_inter_send_types = await prisma.tb_inter_send_type.findMany({ take: 10 })
     * 
     * // Only select the `inter_send_type_id`
     * const tb_inter_send_typeWithInter_send_type_idOnly = await prisma.tb_inter_send_type.findMany({ select: { inter_send_type_id: true } })
     * 
     */
    findMany<T extends tb_inter_send_typeFindManyArgs>(args?: SelectSubset<T, tb_inter_send_typeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tb_inter_send_typePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Tb_inter_send_type.
     * @param {tb_inter_send_typeCreateArgs} args - Arguments to create a Tb_inter_send_type.
     * @example
     * // Create one Tb_inter_send_type
     * const Tb_inter_send_type = await prisma.tb_inter_send_type.create({
     *   data: {
     *     // ... data to create a Tb_inter_send_type
     *   }
     * })
     * 
     */
    create<T extends tb_inter_send_typeCreateArgs>(args: SelectSubset<T, tb_inter_send_typeCreateArgs<ExtArgs>>): Prisma__tb_inter_send_typeClient<$Result.GetResult<Prisma.$tb_inter_send_typePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Tb_inter_send_types.
     * @param {tb_inter_send_typeCreateManyArgs} args - Arguments to create many Tb_inter_send_types.
     * @example
     * // Create many Tb_inter_send_types
     * const tb_inter_send_type = await prisma.tb_inter_send_type.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends tb_inter_send_typeCreateManyArgs>(args?: SelectSubset<T, tb_inter_send_typeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Tb_inter_send_type.
     * @param {tb_inter_send_typeDeleteArgs} args - Arguments to delete one Tb_inter_send_type.
     * @example
     * // Delete one Tb_inter_send_type
     * const Tb_inter_send_type = await prisma.tb_inter_send_type.delete({
     *   where: {
     *     // ... filter to delete one Tb_inter_send_type
     *   }
     * })
     * 
     */
    delete<T extends tb_inter_send_typeDeleteArgs>(args: SelectSubset<T, tb_inter_send_typeDeleteArgs<ExtArgs>>): Prisma__tb_inter_send_typeClient<$Result.GetResult<Prisma.$tb_inter_send_typePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Tb_inter_send_type.
     * @param {tb_inter_send_typeUpdateArgs} args - Arguments to update one Tb_inter_send_type.
     * @example
     * // Update one Tb_inter_send_type
     * const tb_inter_send_type = await prisma.tb_inter_send_type.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends tb_inter_send_typeUpdateArgs>(args: SelectSubset<T, tb_inter_send_typeUpdateArgs<ExtArgs>>): Prisma__tb_inter_send_typeClient<$Result.GetResult<Prisma.$tb_inter_send_typePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Tb_inter_send_types.
     * @param {tb_inter_send_typeDeleteManyArgs} args - Arguments to filter Tb_inter_send_types to delete.
     * @example
     * // Delete a few Tb_inter_send_types
     * const { count } = await prisma.tb_inter_send_type.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends tb_inter_send_typeDeleteManyArgs>(args?: SelectSubset<T, tb_inter_send_typeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tb_inter_send_types.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_inter_send_typeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tb_inter_send_types
     * const tb_inter_send_type = await prisma.tb_inter_send_type.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends tb_inter_send_typeUpdateManyArgs>(args: SelectSubset<T, tb_inter_send_typeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Tb_inter_send_type.
     * @param {tb_inter_send_typeUpsertArgs} args - Arguments to update or create a Tb_inter_send_type.
     * @example
     * // Update or create a Tb_inter_send_type
     * const tb_inter_send_type = await prisma.tb_inter_send_type.upsert({
     *   create: {
     *     // ... data to create a Tb_inter_send_type
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tb_inter_send_type we want to update
     *   }
     * })
     */
    upsert<T extends tb_inter_send_typeUpsertArgs>(args: SelectSubset<T, tb_inter_send_typeUpsertArgs<ExtArgs>>): Prisma__tb_inter_send_typeClient<$Result.GetResult<Prisma.$tb_inter_send_typePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Tb_inter_send_types.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_inter_send_typeCountArgs} args - Arguments to filter Tb_inter_send_types to count.
     * @example
     * // Count the number of Tb_inter_send_types
     * const count = await prisma.tb_inter_send_type.count({
     *   where: {
     *     // ... the filter for the Tb_inter_send_types we want to count
     *   }
     * })
    **/
    count<T extends tb_inter_send_typeCountArgs>(
      args?: Subset<T, tb_inter_send_typeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Tb_inter_send_typeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tb_inter_send_type.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Tb_inter_send_typeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Tb_inter_send_typeAggregateArgs>(args: Subset<T, Tb_inter_send_typeAggregateArgs>): Prisma.PrismaPromise<GetTb_inter_send_typeAggregateType<T>>

    /**
     * Group by Tb_inter_send_type.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_inter_send_typeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends tb_inter_send_typeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: tb_inter_send_typeGroupByArgs['orderBy'] }
        : { orderBy?: tb_inter_send_typeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, tb_inter_send_typeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTb_inter_send_typeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the tb_inter_send_type model
   */
  readonly fields: tb_inter_send_typeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for tb_inter_send_type.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__tb_inter_send_typeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the tb_inter_send_type model
   */
  interface tb_inter_send_typeFieldRefs {
    readonly inter_send_type_id: FieldRef<"tb_inter_send_type", 'Int'>
    readonly inter_send_type: FieldRef<"tb_inter_send_type", 'String'>
  }
    

  // Custom InputTypes
  /**
   * tb_inter_send_type findUnique
   */
  export type tb_inter_send_typeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_inter_send_type
     */
    select?: tb_inter_send_typeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_inter_send_type
     */
    omit?: tb_inter_send_typeOmit<ExtArgs> | null
    /**
     * Filter, which tb_inter_send_type to fetch.
     */
    where: tb_inter_send_typeWhereUniqueInput
  }

  /**
   * tb_inter_send_type findUniqueOrThrow
   */
  export type tb_inter_send_typeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_inter_send_type
     */
    select?: tb_inter_send_typeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_inter_send_type
     */
    omit?: tb_inter_send_typeOmit<ExtArgs> | null
    /**
     * Filter, which tb_inter_send_type to fetch.
     */
    where: tb_inter_send_typeWhereUniqueInput
  }

  /**
   * tb_inter_send_type findFirst
   */
  export type tb_inter_send_typeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_inter_send_type
     */
    select?: tb_inter_send_typeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_inter_send_type
     */
    omit?: tb_inter_send_typeOmit<ExtArgs> | null
    /**
     * Filter, which tb_inter_send_type to fetch.
     */
    where?: tb_inter_send_typeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tb_inter_send_types to fetch.
     */
    orderBy?: tb_inter_send_typeOrderByWithRelationInput | tb_inter_send_typeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tb_inter_send_types.
     */
    cursor?: tb_inter_send_typeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tb_inter_send_types from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tb_inter_send_types.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tb_inter_send_types.
     */
    distinct?: Tb_inter_send_typeScalarFieldEnum | Tb_inter_send_typeScalarFieldEnum[]
  }

  /**
   * tb_inter_send_type findFirstOrThrow
   */
  export type tb_inter_send_typeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_inter_send_type
     */
    select?: tb_inter_send_typeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_inter_send_type
     */
    omit?: tb_inter_send_typeOmit<ExtArgs> | null
    /**
     * Filter, which tb_inter_send_type to fetch.
     */
    where?: tb_inter_send_typeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tb_inter_send_types to fetch.
     */
    orderBy?: tb_inter_send_typeOrderByWithRelationInput | tb_inter_send_typeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tb_inter_send_types.
     */
    cursor?: tb_inter_send_typeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tb_inter_send_types from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tb_inter_send_types.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tb_inter_send_types.
     */
    distinct?: Tb_inter_send_typeScalarFieldEnum | Tb_inter_send_typeScalarFieldEnum[]
  }

  /**
   * tb_inter_send_type findMany
   */
  export type tb_inter_send_typeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_inter_send_type
     */
    select?: tb_inter_send_typeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_inter_send_type
     */
    omit?: tb_inter_send_typeOmit<ExtArgs> | null
    /**
     * Filter, which tb_inter_send_types to fetch.
     */
    where?: tb_inter_send_typeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tb_inter_send_types to fetch.
     */
    orderBy?: tb_inter_send_typeOrderByWithRelationInput | tb_inter_send_typeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing tb_inter_send_types.
     */
    cursor?: tb_inter_send_typeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tb_inter_send_types from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tb_inter_send_types.
     */
    skip?: number
    distinct?: Tb_inter_send_typeScalarFieldEnum | Tb_inter_send_typeScalarFieldEnum[]
  }

  /**
   * tb_inter_send_type create
   */
  export type tb_inter_send_typeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_inter_send_type
     */
    select?: tb_inter_send_typeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_inter_send_type
     */
    omit?: tb_inter_send_typeOmit<ExtArgs> | null
    /**
     * The data needed to create a tb_inter_send_type.
     */
    data: XOR<tb_inter_send_typeCreateInput, tb_inter_send_typeUncheckedCreateInput>
  }

  /**
   * tb_inter_send_type createMany
   */
  export type tb_inter_send_typeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many tb_inter_send_types.
     */
    data: tb_inter_send_typeCreateManyInput | tb_inter_send_typeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * tb_inter_send_type update
   */
  export type tb_inter_send_typeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_inter_send_type
     */
    select?: tb_inter_send_typeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_inter_send_type
     */
    omit?: tb_inter_send_typeOmit<ExtArgs> | null
    /**
     * The data needed to update a tb_inter_send_type.
     */
    data: XOR<tb_inter_send_typeUpdateInput, tb_inter_send_typeUncheckedUpdateInput>
    /**
     * Choose, which tb_inter_send_type to update.
     */
    where: tb_inter_send_typeWhereUniqueInput
  }

  /**
   * tb_inter_send_type updateMany
   */
  export type tb_inter_send_typeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update tb_inter_send_types.
     */
    data: XOR<tb_inter_send_typeUpdateManyMutationInput, tb_inter_send_typeUncheckedUpdateManyInput>
    /**
     * Filter which tb_inter_send_types to update
     */
    where?: tb_inter_send_typeWhereInput
    /**
     * Limit how many tb_inter_send_types to update.
     */
    limit?: number
  }

  /**
   * tb_inter_send_type upsert
   */
  export type tb_inter_send_typeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_inter_send_type
     */
    select?: tb_inter_send_typeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_inter_send_type
     */
    omit?: tb_inter_send_typeOmit<ExtArgs> | null
    /**
     * The filter to search for the tb_inter_send_type to update in case it exists.
     */
    where: tb_inter_send_typeWhereUniqueInput
    /**
     * In case the tb_inter_send_type found by the `where` argument doesn't exist, create a new tb_inter_send_type with this data.
     */
    create: XOR<tb_inter_send_typeCreateInput, tb_inter_send_typeUncheckedCreateInput>
    /**
     * In case the tb_inter_send_type was found with the provided `where` argument, update it with this data.
     */
    update: XOR<tb_inter_send_typeUpdateInput, tb_inter_send_typeUncheckedUpdateInput>
  }

  /**
   * tb_inter_send_type delete
   */
  export type tb_inter_send_typeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_inter_send_type
     */
    select?: tb_inter_send_typeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_inter_send_type
     */
    omit?: tb_inter_send_typeOmit<ExtArgs> | null
    /**
     * Filter which tb_inter_send_type to delete.
     */
    where: tb_inter_send_typeWhereUniqueInput
  }

  /**
   * tb_inter_send_type deleteMany
   */
  export type tb_inter_send_typeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tb_inter_send_types to delete
     */
    where?: tb_inter_send_typeWhereInput
    /**
     * Limit how many tb_inter_send_types to delete.
     */
    limit?: number
  }

  /**
   * tb_inter_send_type without action
   */
  export type tb_inter_send_typeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_inter_send_type
     */
    select?: tb_inter_send_typeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_inter_send_type
     */
    omit?: tb_inter_send_typeOmit<ExtArgs> | null
  }


  /**
   * Model tb_inter_status_types
   */

  export type AggregateTb_inter_status_types = {
    _count: Tb_inter_status_typesCountAggregateOutputType | null
    _avg: Tb_inter_status_typesAvgAggregateOutputType | null
    _sum: Tb_inter_status_typesSumAggregateOutputType | null
    _min: Tb_inter_status_typesMinAggregateOutputType | null
    _max: Tb_inter_status_typesMaxAggregateOutputType | null
  }

  export type Tb_inter_status_typesAvgAggregateOutputType = {
    id: number | null
  }

  export type Tb_inter_status_typesSumAggregateOutputType = {
    id: number | null
  }

  export type Tb_inter_status_typesMinAggregateOutputType = {
    id: number | null
    inter_status_type: string | null
  }

  export type Tb_inter_status_typesMaxAggregateOutputType = {
    id: number | null
    inter_status_type: string | null
  }

  export type Tb_inter_status_typesCountAggregateOutputType = {
    id: number
    inter_status_type: number
    _all: number
  }


  export type Tb_inter_status_typesAvgAggregateInputType = {
    id?: true
  }

  export type Tb_inter_status_typesSumAggregateInputType = {
    id?: true
  }

  export type Tb_inter_status_typesMinAggregateInputType = {
    id?: true
    inter_status_type?: true
  }

  export type Tb_inter_status_typesMaxAggregateInputType = {
    id?: true
    inter_status_type?: true
  }

  export type Tb_inter_status_typesCountAggregateInputType = {
    id?: true
    inter_status_type?: true
    _all?: true
  }

  export type Tb_inter_status_typesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tb_inter_status_types to aggregate.
     */
    where?: tb_inter_status_typesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tb_inter_status_types to fetch.
     */
    orderBy?: tb_inter_status_typesOrderByWithRelationInput | tb_inter_status_typesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: tb_inter_status_typesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tb_inter_status_types from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tb_inter_status_types.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned tb_inter_status_types
    **/
    _count?: true | Tb_inter_status_typesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Tb_inter_status_typesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Tb_inter_status_typesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Tb_inter_status_typesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Tb_inter_status_typesMaxAggregateInputType
  }

  export type GetTb_inter_status_typesAggregateType<T extends Tb_inter_status_typesAggregateArgs> = {
        [P in keyof T & keyof AggregateTb_inter_status_types]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTb_inter_status_types[P]>
      : GetScalarType<T[P], AggregateTb_inter_status_types[P]>
  }




  export type tb_inter_status_typesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: tb_inter_status_typesWhereInput
    orderBy?: tb_inter_status_typesOrderByWithAggregationInput | tb_inter_status_typesOrderByWithAggregationInput[]
    by: Tb_inter_status_typesScalarFieldEnum[] | Tb_inter_status_typesScalarFieldEnum
    having?: tb_inter_status_typesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Tb_inter_status_typesCountAggregateInputType | true
    _avg?: Tb_inter_status_typesAvgAggregateInputType
    _sum?: Tb_inter_status_typesSumAggregateInputType
    _min?: Tb_inter_status_typesMinAggregateInputType
    _max?: Tb_inter_status_typesMaxAggregateInputType
  }

  export type Tb_inter_status_typesGroupByOutputType = {
    id: number
    inter_status_type: string
    _count: Tb_inter_status_typesCountAggregateOutputType | null
    _avg: Tb_inter_status_typesAvgAggregateOutputType | null
    _sum: Tb_inter_status_typesSumAggregateOutputType | null
    _min: Tb_inter_status_typesMinAggregateOutputType | null
    _max: Tb_inter_status_typesMaxAggregateOutputType | null
  }

  type GetTb_inter_status_typesGroupByPayload<T extends tb_inter_status_typesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Tb_inter_status_typesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Tb_inter_status_typesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Tb_inter_status_typesGroupByOutputType[P]>
            : GetScalarType<T[P], Tb_inter_status_typesGroupByOutputType[P]>
        }
      >
    >


  export type tb_inter_status_typesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    inter_status_type?: boolean
  }, ExtArgs["result"]["tb_inter_status_types"]>



  export type tb_inter_status_typesSelectScalar = {
    id?: boolean
    inter_status_type?: boolean
  }

  export type tb_inter_status_typesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "inter_status_type", ExtArgs["result"]["tb_inter_status_types"]>

  export type $tb_inter_status_typesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "tb_inter_status_types"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      inter_status_type: string
    }, ExtArgs["result"]["tb_inter_status_types"]>
    composites: {}
  }

  type tb_inter_status_typesGetPayload<S extends boolean | null | undefined | tb_inter_status_typesDefaultArgs> = $Result.GetResult<Prisma.$tb_inter_status_typesPayload, S>

  type tb_inter_status_typesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<tb_inter_status_typesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Tb_inter_status_typesCountAggregateInputType | true
    }

  export interface tb_inter_status_typesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['tb_inter_status_types'], meta: { name: 'tb_inter_status_types' } }
    /**
     * Find zero or one Tb_inter_status_types that matches the filter.
     * @param {tb_inter_status_typesFindUniqueArgs} args - Arguments to find a Tb_inter_status_types
     * @example
     * // Get one Tb_inter_status_types
     * const tb_inter_status_types = await prisma.tb_inter_status_types.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends tb_inter_status_typesFindUniqueArgs>(args: SelectSubset<T, tb_inter_status_typesFindUniqueArgs<ExtArgs>>): Prisma__tb_inter_status_typesClient<$Result.GetResult<Prisma.$tb_inter_status_typesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Tb_inter_status_types that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {tb_inter_status_typesFindUniqueOrThrowArgs} args - Arguments to find a Tb_inter_status_types
     * @example
     * // Get one Tb_inter_status_types
     * const tb_inter_status_types = await prisma.tb_inter_status_types.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends tb_inter_status_typesFindUniqueOrThrowArgs>(args: SelectSubset<T, tb_inter_status_typesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__tb_inter_status_typesClient<$Result.GetResult<Prisma.$tb_inter_status_typesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tb_inter_status_types that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_inter_status_typesFindFirstArgs} args - Arguments to find a Tb_inter_status_types
     * @example
     * // Get one Tb_inter_status_types
     * const tb_inter_status_types = await prisma.tb_inter_status_types.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends tb_inter_status_typesFindFirstArgs>(args?: SelectSubset<T, tb_inter_status_typesFindFirstArgs<ExtArgs>>): Prisma__tb_inter_status_typesClient<$Result.GetResult<Prisma.$tb_inter_status_typesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tb_inter_status_types that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_inter_status_typesFindFirstOrThrowArgs} args - Arguments to find a Tb_inter_status_types
     * @example
     * // Get one Tb_inter_status_types
     * const tb_inter_status_types = await prisma.tb_inter_status_types.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends tb_inter_status_typesFindFirstOrThrowArgs>(args?: SelectSubset<T, tb_inter_status_typesFindFirstOrThrowArgs<ExtArgs>>): Prisma__tb_inter_status_typesClient<$Result.GetResult<Prisma.$tb_inter_status_typesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Tb_inter_status_types that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_inter_status_typesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tb_inter_status_types
     * const tb_inter_status_types = await prisma.tb_inter_status_types.findMany()
     * 
     * // Get first 10 Tb_inter_status_types
     * const tb_inter_status_types = await prisma.tb_inter_status_types.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tb_inter_status_typesWithIdOnly = await prisma.tb_inter_status_types.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends tb_inter_status_typesFindManyArgs>(args?: SelectSubset<T, tb_inter_status_typesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tb_inter_status_typesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Tb_inter_status_types.
     * @param {tb_inter_status_typesCreateArgs} args - Arguments to create a Tb_inter_status_types.
     * @example
     * // Create one Tb_inter_status_types
     * const Tb_inter_status_types = await prisma.tb_inter_status_types.create({
     *   data: {
     *     // ... data to create a Tb_inter_status_types
     *   }
     * })
     * 
     */
    create<T extends tb_inter_status_typesCreateArgs>(args: SelectSubset<T, tb_inter_status_typesCreateArgs<ExtArgs>>): Prisma__tb_inter_status_typesClient<$Result.GetResult<Prisma.$tb_inter_status_typesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Tb_inter_status_types.
     * @param {tb_inter_status_typesCreateManyArgs} args - Arguments to create many Tb_inter_status_types.
     * @example
     * // Create many Tb_inter_status_types
     * const tb_inter_status_types = await prisma.tb_inter_status_types.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends tb_inter_status_typesCreateManyArgs>(args?: SelectSubset<T, tb_inter_status_typesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Tb_inter_status_types.
     * @param {tb_inter_status_typesDeleteArgs} args - Arguments to delete one Tb_inter_status_types.
     * @example
     * // Delete one Tb_inter_status_types
     * const Tb_inter_status_types = await prisma.tb_inter_status_types.delete({
     *   where: {
     *     // ... filter to delete one Tb_inter_status_types
     *   }
     * })
     * 
     */
    delete<T extends tb_inter_status_typesDeleteArgs>(args: SelectSubset<T, tb_inter_status_typesDeleteArgs<ExtArgs>>): Prisma__tb_inter_status_typesClient<$Result.GetResult<Prisma.$tb_inter_status_typesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Tb_inter_status_types.
     * @param {tb_inter_status_typesUpdateArgs} args - Arguments to update one Tb_inter_status_types.
     * @example
     * // Update one Tb_inter_status_types
     * const tb_inter_status_types = await prisma.tb_inter_status_types.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends tb_inter_status_typesUpdateArgs>(args: SelectSubset<T, tb_inter_status_typesUpdateArgs<ExtArgs>>): Prisma__tb_inter_status_typesClient<$Result.GetResult<Prisma.$tb_inter_status_typesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Tb_inter_status_types.
     * @param {tb_inter_status_typesDeleteManyArgs} args - Arguments to filter Tb_inter_status_types to delete.
     * @example
     * // Delete a few Tb_inter_status_types
     * const { count } = await prisma.tb_inter_status_types.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends tb_inter_status_typesDeleteManyArgs>(args?: SelectSubset<T, tb_inter_status_typesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tb_inter_status_types.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_inter_status_typesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tb_inter_status_types
     * const tb_inter_status_types = await prisma.tb_inter_status_types.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends tb_inter_status_typesUpdateManyArgs>(args: SelectSubset<T, tb_inter_status_typesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Tb_inter_status_types.
     * @param {tb_inter_status_typesUpsertArgs} args - Arguments to update or create a Tb_inter_status_types.
     * @example
     * // Update or create a Tb_inter_status_types
     * const tb_inter_status_types = await prisma.tb_inter_status_types.upsert({
     *   create: {
     *     // ... data to create a Tb_inter_status_types
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tb_inter_status_types we want to update
     *   }
     * })
     */
    upsert<T extends tb_inter_status_typesUpsertArgs>(args: SelectSubset<T, tb_inter_status_typesUpsertArgs<ExtArgs>>): Prisma__tb_inter_status_typesClient<$Result.GetResult<Prisma.$tb_inter_status_typesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Tb_inter_status_types.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_inter_status_typesCountArgs} args - Arguments to filter Tb_inter_status_types to count.
     * @example
     * // Count the number of Tb_inter_status_types
     * const count = await prisma.tb_inter_status_types.count({
     *   where: {
     *     // ... the filter for the Tb_inter_status_types we want to count
     *   }
     * })
    **/
    count<T extends tb_inter_status_typesCountArgs>(
      args?: Subset<T, tb_inter_status_typesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Tb_inter_status_typesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tb_inter_status_types.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Tb_inter_status_typesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Tb_inter_status_typesAggregateArgs>(args: Subset<T, Tb_inter_status_typesAggregateArgs>): Prisma.PrismaPromise<GetTb_inter_status_typesAggregateType<T>>

    /**
     * Group by Tb_inter_status_types.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_inter_status_typesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends tb_inter_status_typesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: tb_inter_status_typesGroupByArgs['orderBy'] }
        : { orderBy?: tb_inter_status_typesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, tb_inter_status_typesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTb_inter_status_typesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the tb_inter_status_types model
   */
  readonly fields: tb_inter_status_typesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for tb_inter_status_types.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__tb_inter_status_typesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the tb_inter_status_types model
   */
  interface tb_inter_status_typesFieldRefs {
    readonly id: FieldRef<"tb_inter_status_types", 'Int'>
    readonly inter_status_type: FieldRef<"tb_inter_status_types", 'String'>
  }
    

  // Custom InputTypes
  /**
   * tb_inter_status_types findUnique
   */
  export type tb_inter_status_typesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_inter_status_types
     */
    select?: tb_inter_status_typesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_inter_status_types
     */
    omit?: tb_inter_status_typesOmit<ExtArgs> | null
    /**
     * Filter, which tb_inter_status_types to fetch.
     */
    where: tb_inter_status_typesWhereUniqueInput
  }

  /**
   * tb_inter_status_types findUniqueOrThrow
   */
  export type tb_inter_status_typesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_inter_status_types
     */
    select?: tb_inter_status_typesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_inter_status_types
     */
    omit?: tb_inter_status_typesOmit<ExtArgs> | null
    /**
     * Filter, which tb_inter_status_types to fetch.
     */
    where: tb_inter_status_typesWhereUniqueInput
  }

  /**
   * tb_inter_status_types findFirst
   */
  export type tb_inter_status_typesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_inter_status_types
     */
    select?: tb_inter_status_typesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_inter_status_types
     */
    omit?: tb_inter_status_typesOmit<ExtArgs> | null
    /**
     * Filter, which tb_inter_status_types to fetch.
     */
    where?: tb_inter_status_typesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tb_inter_status_types to fetch.
     */
    orderBy?: tb_inter_status_typesOrderByWithRelationInput | tb_inter_status_typesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tb_inter_status_types.
     */
    cursor?: tb_inter_status_typesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tb_inter_status_types from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tb_inter_status_types.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tb_inter_status_types.
     */
    distinct?: Tb_inter_status_typesScalarFieldEnum | Tb_inter_status_typesScalarFieldEnum[]
  }

  /**
   * tb_inter_status_types findFirstOrThrow
   */
  export type tb_inter_status_typesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_inter_status_types
     */
    select?: tb_inter_status_typesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_inter_status_types
     */
    omit?: tb_inter_status_typesOmit<ExtArgs> | null
    /**
     * Filter, which tb_inter_status_types to fetch.
     */
    where?: tb_inter_status_typesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tb_inter_status_types to fetch.
     */
    orderBy?: tb_inter_status_typesOrderByWithRelationInput | tb_inter_status_typesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tb_inter_status_types.
     */
    cursor?: tb_inter_status_typesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tb_inter_status_types from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tb_inter_status_types.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tb_inter_status_types.
     */
    distinct?: Tb_inter_status_typesScalarFieldEnum | Tb_inter_status_typesScalarFieldEnum[]
  }

  /**
   * tb_inter_status_types findMany
   */
  export type tb_inter_status_typesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_inter_status_types
     */
    select?: tb_inter_status_typesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_inter_status_types
     */
    omit?: tb_inter_status_typesOmit<ExtArgs> | null
    /**
     * Filter, which tb_inter_status_types to fetch.
     */
    where?: tb_inter_status_typesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tb_inter_status_types to fetch.
     */
    orderBy?: tb_inter_status_typesOrderByWithRelationInput | tb_inter_status_typesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing tb_inter_status_types.
     */
    cursor?: tb_inter_status_typesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tb_inter_status_types from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tb_inter_status_types.
     */
    skip?: number
    distinct?: Tb_inter_status_typesScalarFieldEnum | Tb_inter_status_typesScalarFieldEnum[]
  }

  /**
   * tb_inter_status_types create
   */
  export type tb_inter_status_typesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_inter_status_types
     */
    select?: tb_inter_status_typesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_inter_status_types
     */
    omit?: tb_inter_status_typesOmit<ExtArgs> | null
    /**
     * The data needed to create a tb_inter_status_types.
     */
    data: XOR<tb_inter_status_typesCreateInput, tb_inter_status_typesUncheckedCreateInput>
  }

  /**
   * tb_inter_status_types createMany
   */
  export type tb_inter_status_typesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many tb_inter_status_types.
     */
    data: tb_inter_status_typesCreateManyInput | tb_inter_status_typesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * tb_inter_status_types update
   */
  export type tb_inter_status_typesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_inter_status_types
     */
    select?: tb_inter_status_typesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_inter_status_types
     */
    omit?: tb_inter_status_typesOmit<ExtArgs> | null
    /**
     * The data needed to update a tb_inter_status_types.
     */
    data: XOR<tb_inter_status_typesUpdateInput, tb_inter_status_typesUncheckedUpdateInput>
    /**
     * Choose, which tb_inter_status_types to update.
     */
    where: tb_inter_status_typesWhereUniqueInput
  }

  /**
   * tb_inter_status_types updateMany
   */
  export type tb_inter_status_typesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update tb_inter_status_types.
     */
    data: XOR<tb_inter_status_typesUpdateManyMutationInput, tb_inter_status_typesUncheckedUpdateManyInput>
    /**
     * Filter which tb_inter_status_types to update
     */
    where?: tb_inter_status_typesWhereInput
    /**
     * Limit how many tb_inter_status_types to update.
     */
    limit?: number
  }

  /**
   * tb_inter_status_types upsert
   */
  export type tb_inter_status_typesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_inter_status_types
     */
    select?: tb_inter_status_typesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_inter_status_types
     */
    omit?: tb_inter_status_typesOmit<ExtArgs> | null
    /**
     * The filter to search for the tb_inter_status_types to update in case it exists.
     */
    where: tb_inter_status_typesWhereUniqueInput
    /**
     * In case the tb_inter_status_types found by the `where` argument doesn't exist, create a new tb_inter_status_types with this data.
     */
    create: XOR<tb_inter_status_typesCreateInput, tb_inter_status_typesUncheckedCreateInput>
    /**
     * In case the tb_inter_status_types was found with the provided `where` argument, update it with this data.
     */
    update: XOR<tb_inter_status_typesUpdateInput, tb_inter_status_typesUncheckedUpdateInput>
  }

  /**
   * tb_inter_status_types delete
   */
  export type tb_inter_status_typesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_inter_status_types
     */
    select?: tb_inter_status_typesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_inter_status_types
     */
    omit?: tb_inter_status_typesOmit<ExtArgs> | null
    /**
     * Filter which tb_inter_status_types to delete.
     */
    where: tb_inter_status_typesWhereUniqueInput
  }

  /**
   * tb_inter_status_types deleteMany
   */
  export type tb_inter_status_typesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tb_inter_status_types to delete
     */
    where?: tb_inter_status_typesWhereInput
    /**
     * Limit how many tb_inter_status_types to delete.
     */
    limit?: number
  }

  /**
   * tb_inter_status_types without action
   */
  export type tb_inter_status_typesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_inter_status_types
     */
    select?: tb_inter_status_typesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_inter_status_types
     */
    omit?: tb_inter_status_typesOmit<ExtArgs> | null
  }


  /**
   * Model tb_inter_type
   */

  export type AggregateTb_inter_type = {
    _count: Tb_inter_typeCountAggregateOutputType | null
    _avg: Tb_inter_typeAvgAggregateOutputType | null
    _sum: Tb_inter_typeSumAggregateOutputType | null
    _min: Tb_inter_typeMinAggregateOutputType | null
    _max: Tb_inter_typeMaxAggregateOutputType | null
  }

  export type Tb_inter_typeAvgAggregateOutputType = {
    inter_type_id: number | null
  }

  export type Tb_inter_typeSumAggregateOutputType = {
    inter_type_id: number | null
  }

  export type Tb_inter_typeMinAggregateOutputType = {
    inter_type_id: number | null
    inter_type: string | null
  }

  export type Tb_inter_typeMaxAggregateOutputType = {
    inter_type_id: number | null
    inter_type: string | null
  }

  export type Tb_inter_typeCountAggregateOutputType = {
    inter_type_id: number
    inter_type: number
    _all: number
  }


  export type Tb_inter_typeAvgAggregateInputType = {
    inter_type_id?: true
  }

  export type Tb_inter_typeSumAggregateInputType = {
    inter_type_id?: true
  }

  export type Tb_inter_typeMinAggregateInputType = {
    inter_type_id?: true
    inter_type?: true
  }

  export type Tb_inter_typeMaxAggregateInputType = {
    inter_type_id?: true
    inter_type?: true
  }

  export type Tb_inter_typeCountAggregateInputType = {
    inter_type_id?: true
    inter_type?: true
    _all?: true
  }

  export type Tb_inter_typeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tb_inter_type to aggregate.
     */
    where?: tb_inter_typeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tb_inter_types to fetch.
     */
    orderBy?: tb_inter_typeOrderByWithRelationInput | tb_inter_typeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: tb_inter_typeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tb_inter_types from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tb_inter_types.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned tb_inter_types
    **/
    _count?: true | Tb_inter_typeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Tb_inter_typeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Tb_inter_typeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Tb_inter_typeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Tb_inter_typeMaxAggregateInputType
  }

  export type GetTb_inter_typeAggregateType<T extends Tb_inter_typeAggregateArgs> = {
        [P in keyof T & keyof AggregateTb_inter_type]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTb_inter_type[P]>
      : GetScalarType<T[P], AggregateTb_inter_type[P]>
  }




  export type tb_inter_typeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: tb_inter_typeWhereInput
    orderBy?: tb_inter_typeOrderByWithAggregationInput | tb_inter_typeOrderByWithAggregationInput[]
    by: Tb_inter_typeScalarFieldEnum[] | Tb_inter_typeScalarFieldEnum
    having?: tb_inter_typeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Tb_inter_typeCountAggregateInputType | true
    _avg?: Tb_inter_typeAvgAggregateInputType
    _sum?: Tb_inter_typeSumAggregateInputType
    _min?: Tb_inter_typeMinAggregateInputType
    _max?: Tb_inter_typeMaxAggregateInputType
  }

  export type Tb_inter_typeGroupByOutputType = {
    inter_type_id: number
    inter_type: string
    _count: Tb_inter_typeCountAggregateOutputType | null
    _avg: Tb_inter_typeAvgAggregateOutputType | null
    _sum: Tb_inter_typeSumAggregateOutputType | null
    _min: Tb_inter_typeMinAggregateOutputType | null
    _max: Tb_inter_typeMaxAggregateOutputType | null
  }

  type GetTb_inter_typeGroupByPayload<T extends tb_inter_typeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Tb_inter_typeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Tb_inter_typeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Tb_inter_typeGroupByOutputType[P]>
            : GetScalarType<T[P], Tb_inter_typeGroupByOutputType[P]>
        }
      >
    >


  export type tb_inter_typeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    inter_type_id?: boolean
    inter_type?: boolean
  }, ExtArgs["result"]["tb_inter_type"]>



  export type tb_inter_typeSelectScalar = {
    inter_type_id?: boolean
    inter_type?: boolean
  }

  export type tb_inter_typeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"inter_type_id" | "inter_type", ExtArgs["result"]["tb_inter_type"]>

  export type $tb_inter_typePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "tb_inter_type"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      inter_type_id: number
      inter_type: string
    }, ExtArgs["result"]["tb_inter_type"]>
    composites: {}
  }

  type tb_inter_typeGetPayload<S extends boolean | null | undefined | tb_inter_typeDefaultArgs> = $Result.GetResult<Prisma.$tb_inter_typePayload, S>

  type tb_inter_typeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<tb_inter_typeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Tb_inter_typeCountAggregateInputType | true
    }

  export interface tb_inter_typeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['tb_inter_type'], meta: { name: 'tb_inter_type' } }
    /**
     * Find zero or one Tb_inter_type that matches the filter.
     * @param {tb_inter_typeFindUniqueArgs} args - Arguments to find a Tb_inter_type
     * @example
     * // Get one Tb_inter_type
     * const tb_inter_type = await prisma.tb_inter_type.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends tb_inter_typeFindUniqueArgs>(args: SelectSubset<T, tb_inter_typeFindUniqueArgs<ExtArgs>>): Prisma__tb_inter_typeClient<$Result.GetResult<Prisma.$tb_inter_typePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Tb_inter_type that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {tb_inter_typeFindUniqueOrThrowArgs} args - Arguments to find a Tb_inter_type
     * @example
     * // Get one Tb_inter_type
     * const tb_inter_type = await prisma.tb_inter_type.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends tb_inter_typeFindUniqueOrThrowArgs>(args: SelectSubset<T, tb_inter_typeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__tb_inter_typeClient<$Result.GetResult<Prisma.$tb_inter_typePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tb_inter_type that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_inter_typeFindFirstArgs} args - Arguments to find a Tb_inter_type
     * @example
     * // Get one Tb_inter_type
     * const tb_inter_type = await prisma.tb_inter_type.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends tb_inter_typeFindFirstArgs>(args?: SelectSubset<T, tb_inter_typeFindFirstArgs<ExtArgs>>): Prisma__tb_inter_typeClient<$Result.GetResult<Prisma.$tb_inter_typePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tb_inter_type that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_inter_typeFindFirstOrThrowArgs} args - Arguments to find a Tb_inter_type
     * @example
     * // Get one Tb_inter_type
     * const tb_inter_type = await prisma.tb_inter_type.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends tb_inter_typeFindFirstOrThrowArgs>(args?: SelectSubset<T, tb_inter_typeFindFirstOrThrowArgs<ExtArgs>>): Prisma__tb_inter_typeClient<$Result.GetResult<Prisma.$tb_inter_typePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Tb_inter_types that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_inter_typeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tb_inter_types
     * const tb_inter_types = await prisma.tb_inter_type.findMany()
     * 
     * // Get first 10 Tb_inter_types
     * const tb_inter_types = await prisma.tb_inter_type.findMany({ take: 10 })
     * 
     * // Only select the `inter_type_id`
     * const tb_inter_typeWithInter_type_idOnly = await prisma.tb_inter_type.findMany({ select: { inter_type_id: true } })
     * 
     */
    findMany<T extends tb_inter_typeFindManyArgs>(args?: SelectSubset<T, tb_inter_typeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tb_inter_typePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Tb_inter_type.
     * @param {tb_inter_typeCreateArgs} args - Arguments to create a Tb_inter_type.
     * @example
     * // Create one Tb_inter_type
     * const Tb_inter_type = await prisma.tb_inter_type.create({
     *   data: {
     *     // ... data to create a Tb_inter_type
     *   }
     * })
     * 
     */
    create<T extends tb_inter_typeCreateArgs>(args: SelectSubset<T, tb_inter_typeCreateArgs<ExtArgs>>): Prisma__tb_inter_typeClient<$Result.GetResult<Prisma.$tb_inter_typePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Tb_inter_types.
     * @param {tb_inter_typeCreateManyArgs} args - Arguments to create many Tb_inter_types.
     * @example
     * // Create many Tb_inter_types
     * const tb_inter_type = await prisma.tb_inter_type.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends tb_inter_typeCreateManyArgs>(args?: SelectSubset<T, tb_inter_typeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Tb_inter_type.
     * @param {tb_inter_typeDeleteArgs} args - Arguments to delete one Tb_inter_type.
     * @example
     * // Delete one Tb_inter_type
     * const Tb_inter_type = await prisma.tb_inter_type.delete({
     *   where: {
     *     // ... filter to delete one Tb_inter_type
     *   }
     * })
     * 
     */
    delete<T extends tb_inter_typeDeleteArgs>(args: SelectSubset<T, tb_inter_typeDeleteArgs<ExtArgs>>): Prisma__tb_inter_typeClient<$Result.GetResult<Prisma.$tb_inter_typePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Tb_inter_type.
     * @param {tb_inter_typeUpdateArgs} args - Arguments to update one Tb_inter_type.
     * @example
     * // Update one Tb_inter_type
     * const tb_inter_type = await prisma.tb_inter_type.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends tb_inter_typeUpdateArgs>(args: SelectSubset<T, tb_inter_typeUpdateArgs<ExtArgs>>): Prisma__tb_inter_typeClient<$Result.GetResult<Prisma.$tb_inter_typePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Tb_inter_types.
     * @param {tb_inter_typeDeleteManyArgs} args - Arguments to filter Tb_inter_types to delete.
     * @example
     * // Delete a few Tb_inter_types
     * const { count } = await prisma.tb_inter_type.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends tb_inter_typeDeleteManyArgs>(args?: SelectSubset<T, tb_inter_typeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tb_inter_types.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_inter_typeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tb_inter_types
     * const tb_inter_type = await prisma.tb_inter_type.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends tb_inter_typeUpdateManyArgs>(args: SelectSubset<T, tb_inter_typeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Tb_inter_type.
     * @param {tb_inter_typeUpsertArgs} args - Arguments to update or create a Tb_inter_type.
     * @example
     * // Update or create a Tb_inter_type
     * const tb_inter_type = await prisma.tb_inter_type.upsert({
     *   create: {
     *     // ... data to create a Tb_inter_type
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tb_inter_type we want to update
     *   }
     * })
     */
    upsert<T extends tb_inter_typeUpsertArgs>(args: SelectSubset<T, tb_inter_typeUpsertArgs<ExtArgs>>): Prisma__tb_inter_typeClient<$Result.GetResult<Prisma.$tb_inter_typePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Tb_inter_types.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_inter_typeCountArgs} args - Arguments to filter Tb_inter_types to count.
     * @example
     * // Count the number of Tb_inter_types
     * const count = await prisma.tb_inter_type.count({
     *   where: {
     *     // ... the filter for the Tb_inter_types we want to count
     *   }
     * })
    **/
    count<T extends tb_inter_typeCountArgs>(
      args?: Subset<T, tb_inter_typeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Tb_inter_typeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tb_inter_type.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Tb_inter_typeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Tb_inter_typeAggregateArgs>(args: Subset<T, Tb_inter_typeAggregateArgs>): Prisma.PrismaPromise<GetTb_inter_typeAggregateType<T>>

    /**
     * Group by Tb_inter_type.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_inter_typeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends tb_inter_typeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: tb_inter_typeGroupByArgs['orderBy'] }
        : { orderBy?: tb_inter_typeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, tb_inter_typeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTb_inter_typeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the tb_inter_type model
   */
  readonly fields: tb_inter_typeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for tb_inter_type.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__tb_inter_typeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the tb_inter_type model
   */
  interface tb_inter_typeFieldRefs {
    readonly inter_type_id: FieldRef<"tb_inter_type", 'Int'>
    readonly inter_type: FieldRef<"tb_inter_type", 'String'>
  }
    

  // Custom InputTypes
  /**
   * tb_inter_type findUnique
   */
  export type tb_inter_typeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_inter_type
     */
    select?: tb_inter_typeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_inter_type
     */
    omit?: tb_inter_typeOmit<ExtArgs> | null
    /**
     * Filter, which tb_inter_type to fetch.
     */
    where: tb_inter_typeWhereUniqueInput
  }

  /**
   * tb_inter_type findUniqueOrThrow
   */
  export type tb_inter_typeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_inter_type
     */
    select?: tb_inter_typeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_inter_type
     */
    omit?: tb_inter_typeOmit<ExtArgs> | null
    /**
     * Filter, which tb_inter_type to fetch.
     */
    where: tb_inter_typeWhereUniqueInput
  }

  /**
   * tb_inter_type findFirst
   */
  export type tb_inter_typeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_inter_type
     */
    select?: tb_inter_typeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_inter_type
     */
    omit?: tb_inter_typeOmit<ExtArgs> | null
    /**
     * Filter, which tb_inter_type to fetch.
     */
    where?: tb_inter_typeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tb_inter_types to fetch.
     */
    orderBy?: tb_inter_typeOrderByWithRelationInput | tb_inter_typeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tb_inter_types.
     */
    cursor?: tb_inter_typeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tb_inter_types from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tb_inter_types.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tb_inter_types.
     */
    distinct?: Tb_inter_typeScalarFieldEnum | Tb_inter_typeScalarFieldEnum[]
  }

  /**
   * tb_inter_type findFirstOrThrow
   */
  export type tb_inter_typeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_inter_type
     */
    select?: tb_inter_typeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_inter_type
     */
    omit?: tb_inter_typeOmit<ExtArgs> | null
    /**
     * Filter, which tb_inter_type to fetch.
     */
    where?: tb_inter_typeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tb_inter_types to fetch.
     */
    orderBy?: tb_inter_typeOrderByWithRelationInput | tb_inter_typeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tb_inter_types.
     */
    cursor?: tb_inter_typeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tb_inter_types from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tb_inter_types.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tb_inter_types.
     */
    distinct?: Tb_inter_typeScalarFieldEnum | Tb_inter_typeScalarFieldEnum[]
  }

  /**
   * tb_inter_type findMany
   */
  export type tb_inter_typeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_inter_type
     */
    select?: tb_inter_typeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_inter_type
     */
    omit?: tb_inter_typeOmit<ExtArgs> | null
    /**
     * Filter, which tb_inter_types to fetch.
     */
    where?: tb_inter_typeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tb_inter_types to fetch.
     */
    orderBy?: tb_inter_typeOrderByWithRelationInput | tb_inter_typeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing tb_inter_types.
     */
    cursor?: tb_inter_typeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tb_inter_types from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tb_inter_types.
     */
    skip?: number
    distinct?: Tb_inter_typeScalarFieldEnum | Tb_inter_typeScalarFieldEnum[]
  }

  /**
   * tb_inter_type create
   */
  export type tb_inter_typeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_inter_type
     */
    select?: tb_inter_typeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_inter_type
     */
    omit?: tb_inter_typeOmit<ExtArgs> | null
    /**
     * The data needed to create a tb_inter_type.
     */
    data: XOR<tb_inter_typeCreateInput, tb_inter_typeUncheckedCreateInput>
  }

  /**
   * tb_inter_type createMany
   */
  export type tb_inter_typeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many tb_inter_types.
     */
    data: tb_inter_typeCreateManyInput | tb_inter_typeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * tb_inter_type update
   */
  export type tb_inter_typeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_inter_type
     */
    select?: tb_inter_typeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_inter_type
     */
    omit?: tb_inter_typeOmit<ExtArgs> | null
    /**
     * The data needed to update a tb_inter_type.
     */
    data: XOR<tb_inter_typeUpdateInput, tb_inter_typeUncheckedUpdateInput>
    /**
     * Choose, which tb_inter_type to update.
     */
    where: tb_inter_typeWhereUniqueInput
  }

  /**
   * tb_inter_type updateMany
   */
  export type tb_inter_typeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update tb_inter_types.
     */
    data: XOR<tb_inter_typeUpdateManyMutationInput, tb_inter_typeUncheckedUpdateManyInput>
    /**
     * Filter which tb_inter_types to update
     */
    where?: tb_inter_typeWhereInput
    /**
     * Limit how many tb_inter_types to update.
     */
    limit?: number
  }

  /**
   * tb_inter_type upsert
   */
  export type tb_inter_typeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_inter_type
     */
    select?: tb_inter_typeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_inter_type
     */
    omit?: tb_inter_typeOmit<ExtArgs> | null
    /**
     * The filter to search for the tb_inter_type to update in case it exists.
     */
    where: tb_inter_typeWhereUniqueInput
    /**
     * In case the tb_inter_type found by the `where` argument doesn't exist, create a new tb_inter_type with this data.
     */
    create: XOR<tb_inter_typeCreateInput, tb_inter_typeUncheckedCreateInput>
    /**
     * In case the tb_inter_type was found with the provided `where` argument, update it with this data.
     */
    update: XOR<tb_inter_typeUpdateInput, tb_inter_typeUncheckedUpdateInput>
  }

  /**
   * tb_inter_type delete
   */
  export type tb_inter_typeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_inter_type
     */
    select?: tb_inter_typeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_inter_type
     */
    omit?: tb_inter_typeOmit<ExtArgs> | null
    /**
     * Filter which tb_inter_type to delete.
     */
    where: tb_inter_typeWhereUniqueInput
  }

  /**
   * tb_inter_type deleteMany
   */
  export type tb_inter_typeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tb_inter_types to delete
     */
    where?: tb_inter_typeWhereInput
    /**
     * Limit how many tb_inter_types to delete.
     */
    limit?: number
  }

  /**
   * tb_inter_type without action
   */
  export type tb_inter_typeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_inter_type
     */
    select?: tb_inter_typeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_inter_type
     */
    omit?: tb_inter_typeOmit<ExtArgs> | null
  }


  /**
   * Model tb_lawyer
   */

  export type AggregateTb_lawyer = {
    _count: Tb_lawyerCountAggregateOutputType | null
    _avg: Tb_lawyerAvgAggregateOutputType | null
    _sum: Tb_lawyerSumAggregateOutputType | null
    _min: Tb_lawyerMinAggregateOutputType | null
    _max: Tb_lawyerMaxAggregateOutputType | null
  }

  export type Tb_lawyerAvgAggregateOutputType = {
    lawyer_id: number | null
    case_id: number | null
    actual: number | null
  }

  export type Tb_lawyerSumAggregateOutputType = {
    lawyer_id: number | null
    case_id: number | null
    actual: number | null
  }

  export type Tb_lawyerMinAggregateOutputType = {
    lawyer_id: number | null
    lawyer_name: string | null
    lawyer_surname: string | null
    lawyer_organization: string | null
    lawyer_tel: string | null
    lawyer_address: string | null
    lawyer_email: string | null
    case_id: number | null
    actual: number | null
  }

  export type Tb_lawyerMaxAggregateOutputType = {
    lawyer_id: number | null
    lawyer_name: string | null
    lawyer_surname: string | null
    lawyer_organization: string | null
    lawyer_tel: string | null
    lawyer_address: string | null
    lawyer_email: string | null
    case_id: number | null
    actual: number | null
  }

  export type Tb_lawyerCountAggregateOutputType = {
    lawyer_id: number
    lawyer_name: number
    lawyer_surname: number
    lawyer_organization: number
    lawyer_tel: number
    lawyer_address: number
    lawyer_email: number
    case_id: number
    actual: number
    _all: number
  }


  export type Tb_lawyerAvgAggregateInputType = {
    lawyer_id?: true
    case_id?: true
    actual?: true
  }

  export type Tb_lawyerSumAggregateInputType = {
    lawyer_id?: true
    case_id?: true
    actual?: true
  }

  export type Tb_lawyerMinAggregateInputType = {
    lawyer_id?: true
    lawyer_name?: true
    lawyer_surname?: true
    lawyer_organization?: true
    lawyer_tel?: true
    lawyer_address?: true
    lawyer_email?: true
    case_id?: true
    actual?: true
  }

  export type Tb_lawyerMaxAggregateInputType = {
    lawyer_id?: true
    lawyer_name?: true
    lawyer_surname?: true
    lawyer_organization?: true
    lawyer_tel?: true
    lawyer_address?: true
    lawyer_email?: true
    case_id?: true
    actual?: true
  }

  export type Tb_lawyerCountAggregateInputType = {
    lawyer_id?: true
    lawyer_name?: true
    lawyer_surname?: true
    lawyer_organization?: true
    lawyer_tel?: true
    lawyer_address?: true
    lawyer_email?: true
    case_id?: true
    actual?: true
    _all?: true
  }

  export type Tb_lawyerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tb_lawyer to aggregate.
     */
    where?: tb_lawyerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tb_lawyers to fetch.
     */
    orderBy?: tb_lawyerOrderByWithRelationInput | tb_lawyerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: tb_lawyerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tb_lawyers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tb_lawyers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned tb_lawyers
    **/
    _count?: true | Tb_lawyerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Tb_lawyerAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Tb_lawyerSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Tb_lawyerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Tb_lawyerMaxAggregateInputType
  }

  export type GetTb_lawyerAggregateType<T extends Tb_lawyerAggregateArgs> = {
        [P in keyof T & keyof AggregateTb_lawyer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTb_lawyer[P]>
      : GetScalarType<T[P], AggregateTb_lawyer[P]>
  }




  export type tb_lawyerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: tb_lawyerWhereInput
    orderBy?: tb_lawyerOrderByWithAggregationInput | tb_lawyerOrderByWithAggregationInput[]
    by: Tb_lawyerScalarFieldEnum[] | Tb_lawyerScalarFieldEnum
    having?: tb_lawyerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Tb_lawyerCountAggregateInputType | true
    _avg?: Tb_lawyerAvgAggregateInputType
    _sum?: Tb_lawyerSumAggregateInputType
    _min?: Tb_lawyerMinAggregateInputType
    _max?: Tb_lawyerMaxAggregateInputType
  }

  export type Tb_lawyerGroupByOutputType = {
    lawyer_id: number
    lawyer_name: string
    lawyer_surname: string
    lawyer_organization: string | null
    lawyer_tel: string | null
    lawyer_address: string | null
    lawyer_email: string | null
    case_id: number
    actual: number | null
    _count: Tb_lawyerCountAggregateOutputType | null
    _avg: Tb_lawyerAvgAggregateOutputType | null
    _sum: Tb_lawyerSumAggregateOutputType | null
    _min: Tb_lawyerMinAggregateOutputType | null
    _max: Tb_lawyerMaxAggregateOutputType | null
  }

  type GetTb_lawyerGroupByPayload<T extends tb_lawyerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Tb_lawyerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Tb_lawyerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Tb_lawyerGroupByOutputType[P]>
            : GetScalarType<T[P], Tb_lawyerGroupByOutputType[P]>
        }
      >
    >


  export type tb_lawyerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    lawyer_id?: boolean
    lawyer_name?: boolean
    lawyer_surname?: boolean
    lawyer_organization?: boolean
    lawyer_tel?: boolean
    lawyer_address?: boolean
    lawyer_email?: boolean
    case_id?: boolean
    actual?: boolean
  }, ExtArgs["result"]["tb_lawyer"]>



  export type tb_lawyerSelectScalar = {
    lawyer_id?: boolean
    lawyer_name?: boolean
    lawyer_surname?: boolean
    lawyer_organization?: boolean
    lawyer_tel?: boolean
    lawyer_address?: boolean
    lawyer_email?: boolean
    case_id?: boolean
    actual?: boolean
  }

  export type tb_lawyerOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"lawyer_id" | "lawyer_name" | "lawyer_surname" | "lawyer_organization" | "lawyer_tel" | "lawyer_address" | "lawyer_email" | "case_id" | "actual", ExtArgs["result"]["tb_lawyer"]>

  export type $tb_lawyerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "tb_lawyer"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      lawyer_id: number
      lawyer_name: string
      lawyer_surname: string
      lawyer_organization: string | null
      lawyer_tel: string | null
      lawyer_address: string | null
      lawyer_email: string | null
      case_id: number
      actual: number | null
    }, ExtArgs["result"]["tb_lawyer"]>
    composites: {}
  }

  type tb_lawyerGetPayload<S extends boolean | null | undefined | tb_lawyerDefaultArgs> = $Result.GetResult<Prisma.$tb_lawyerPayload, S>

  type tb_lawyerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<tb_lawyerFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Tb_lawyerCountAggregateInputType | true
    }

  export interface tb_lawyerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['tb_lawyer'], meta: { name: 'tb_lawyer' } }
    /**
     * Find zero or one Tb_lawyer that matches the filter.
     * @param {tb_lawyerFindUniqueArgs} args - Arguments to find a Tb_lawyer
     * @example
     * // Get one Tb_lawyer
     * const tb_lawyer = await prisma.tb_lawyer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends tb_lawyerFindUniqueArgs>(args: SelectSubset<T, tb_lawyerFindUniqueArgs<ExtArgs>>): Prisma__tb_lawyerClient<$Result.GetResult<Prisma.$tb_lawyerPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Tb_lawyer that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {tb_lawyerFindUniqueOrThrowArgs} args - Arguments to find a Tb_lawyer
     * @example
     * // Get one Tb_lawyer
     * const tb_lawyer = await prisma.tb_lawyer.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends tb_lawyerFindUniqueOrThrowArgs>(args: SelectSubset<T, tb_lawyerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__tb_lawyerClient<$Result.GetResult<Prisma.$tb_lawyerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tb_lawyer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_lawyerFindFirstArgs} args - Arguments to find a Tb_lawyer
     * @example
     * // Get one Tb_lawyer
     * const tb_lawyer = await prisma.tb_lawyer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends tb_lawyerFindFirstArgs>(args?: SelectSubset<T, tb_lawyerFindFirstArgs<ExtArgs>>): Prisma__tb_lawyerClient<$Result.GetResult<Prisma.$tb_lawyerPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tb_lawyer that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_lawyerFindFirstOrThrowArgs} args - Arguments to find a Tb_lawyer
     * @example
     * // Get one Tb_lawyer
     * const tb_lawyer = await prisma.tb_lawyer.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends tb_lawyerFindFirstOrThrowArgs>(args?: SelectSubset<T, tb_lawyerFindFirstOrThrowArgs<ExtArgs>>): Prisma__tb_lawyerClient<$Result.GetResult<Prisma.$tb_lawyerPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Tb_lawyers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_lawyerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tb_lawyers
     * const tb_lawyers = await prisma.tb_lawyer.findMany()
     * 
     * // Get first 10 Tb_lawyers
     * const tb_lawyers = await prisma.tb_lawyer.findMany({ take: 10 })
     * 
     * // Only select the `lawyer_id`
     * const tb_lawyerWithLawyer_idOnly = await prisma.tb_lawyer.findMany({ select: { lawyer_id: true } })
     * 
     */
    findMany<T extends tb_lawyerFindManyArgs>(args?: SelectSubset<T, tb_lawyerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tb_lawyerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Tb_lawyer.
     * @param {tb_lawyerCreateArgs} args - Arguments to create a Tb_lawyer.
     * @example
     * // Create one Tb_lawyer
     * const Tb_lawyer = await prisma.tb_lawyer.create({
     *   data: {
     *     // ... data to create a Tb_lawyer
     *   }
     * })
     * 
     */
    create<T extends tb_lawyerCreateArgs>(args: SelectSubset<T, tb_lawyerCreateArgs<ExtArgs>>): Prisma__tb_lawyerClient<$Result.GetResult<Prisma.$tb_lawyerPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Tb_lawyers.
     * @param {tb_lawyerCreateManyArgs} args - Arguments to create many Tb_lawyers.
     * @example
     * // Create many Tb_lawyers
     * const tb_lawyer = await prisma.tb_lawyer.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends tb_lawyerCreateManyArgs>(args?: SelectSubset<T, tb_lawyerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Tb_lawyer.
     * @param {tb_lawyerDeleteArgs} args - Arguments to delete one Tb_lawyer.
     * @example
     * // Delete one Tb_lawyer
     * const Tb_lawyer = await prisma.tb_lawyer.delete({
     *   where: {
     *     // ... filter to delete one Tb_lawyer
     *   }
     * })
     * 
     */
    delete<T extends tb_lawyerDeleteArgs>(args: SelectSubset<T, tb_lawyerDeleteArgs<ExtArgs>>): Prisma__tb_lawyerClient<$Result.GetResult<Prisma.$tb_lawyerPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Tb_lawyer.
     * @param {tb_lawyerUpdateArgs} args - Arguments to update one Tb_lawyer.
     * @example
     * // Update one Tb_lawyer
     * const tb_lawyer = await prisma.tb_lawyer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends tb_lawyerUpdateArgs>(args: SelectSubset<T, tb_lawyerUpdateArgs<ExtArgs>>): Prisma__tb_lawyerClient<$Result.GetResult<Prisma.$tb_lawyerPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Tb_lawyers.
     * @param {tb_lawyerDeleteManyArgs} args - Arguments to filter Tb_lawyers to delete.
     * @example
     * // Delete a few Tb_lawyers
     * const { count } = await prisma.tb_lawyer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends tb_lawyerDeleteManyArgs>(args?: SelectSubset<T, tb_lawyerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tb_lawyers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_lawyerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tb_lawyers
     * const tb_lawyer = await prisma.tb_lawyer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends tb_lawyerUpdateManyArgs>(args: SelectSubset<T, tb_lawyerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Tb_lawyer.
     * @param {tb_lawyerUpsertArgs} args - Arguments to update or create a Tb_lawyer.
     * @example
     * // Update or create a Tb_lawyer
     * const tb_lawyer = await prisma.tb_lawyer.upsert({
     *   create: {
     *     // ... data to create a Tb_lawyer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tb_lawyer we want to update
     *   }
     * })
     */
    upsert<T extends tb_lawyerUpsertArgs>(args: SelectSubset<T, tb_lawyerUpsertArgs<ExtArgs>>): Prisma__tb_lawyerClient<$Result.GetResult<Prisma.$tb_lawyerPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Tb_lawyers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_lawyerCountArgs} args - Arguments to filter Tb_lawyers to count.
     * @example
     * // Count the number of Tb_lawyers
     * const count = await prisma.tb_lawyer.count({
     *   where: {
     *     // ... the filter for the Tb_lawyers we want to count
     *   }
     * })
    **/
    count<T extends tb_lawyerCountArgs>(
      args?: Subset<T, tb_lawyerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Tb_lawyerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tb_lawyer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Tb_lawyerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Tb_lawyerAggregateArgs>(args: Subset<T, Tb_lawyerAggregateArgs>): Prisma.PrismaPromise<GetTb_lawyerAggregateType<T>>

    /**
     * Group by Tb_lawyer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_lawyerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends tb_lawyerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: tb_lawyerGroupByArgs['orderBy'] }
        : { orderBy?: tb_lawyerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, tb_lawyerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTb_lawyerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the tb_lawyer model
   */
  readonly fields: tb_lawyerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for tb_lawyer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__tb_lawyerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the tb_lawyer model
   */
  interface tb_lawyerFieldRefs {
    readonly lawyer_id: FieldRef<"tb_lawyer", 'Int'>
    readonly lawyer_name: FieldRef<"tb_lawyer", 'String'>
    readonly lawyer_surname: FieldRef<"tb_lawyer", 'String'>
    readonly lawyer_organization: FieldRef<"tb_lawyer", 'String'>
    readonly lawyer_tel: FieldRef<"tb_lawyer", 'String'>
    readonly lawyer_address: FieldRef<"tb_lawyer", 'String'>
    readonly lawyer_email: FieldRef<"tb_lawyer", 'String'>
    readonly case_id: FieldRef<"tb_lawyer", 'Int'>
    readonly actual: FieldRef<"tb_lawyer", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * tb_lawyer findUnique
   */
  export type tb_lawyerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_lawyer
     */
    select?: tb_lawyerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_lawyer
     */
    omit?: tb_lawyerOmit<ExtArgs> | null
    /**
     * Filter, which tb_lawyer to fetch.
     */
    where: tb_lawyerWhereUniqueInput
  }

  /**
   * tb_lawyer findUniqueOrThrow
   */
  export type tb_lawyerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_lawyer
     */
    select?: tb_lawyerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_lawyer
     */
    omit?: tb_lawyerOmit<ExtArgs> | null
    /**
     * Filter, which tb_lawyer to fetch.
     */
    where: tb_lawyerWhereUniqueInput
  }

  /**
   * tb_lawyer findFirst
   */
  export type tb_lawyerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_lawyer
     */
    select?: tb_lawyerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_lawyer
     */
    omit?: tb_lawyerOmit<ExtArgs> | null
    /**
     * Filter, which tb_lawyer to fetch.
     */
    where?: tb_lawyerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tb_lawyers to fetch.
     */
    orderBy?: tb_lawyerOrderByWithRelationInput | tb_lawyerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tb_lawyers.
     */
    cursor?: tb_lawyerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tb_lawyers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tb_lawyers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tb_lawyers.
     */
    distinct?: Tb_lawyerScalarFieldEnum | Tb_lawyerScalarFieldEnum[]
  }

  /**
   * tb_lawyer findFirstOrThrow
   */
  export type tb_lawyerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_lawyer
     */
    select?: tb_lawyerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_lawyer
     */
    omit?: tb_lawyerOmit<ExtArgs> | null
    /**
     * Filter, which tb_lawyer to fetch.
     */
    where?: tb_lawyerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tb_lawyers to fetch.
     */
    orderBy?: tb_lawyerOrderByWithRelationInput | tb_lawyerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tb_lawyers.
     */
    cursor?: tb_lawyerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tb_lawyers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tb_lawyers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tb_lawyers.
     */
    distinct?: Tb_lawyerScalarFieldEnum | Tb_lawyerScalarFieldEnum[]
  }

  /**
   * tb_lawyer findMany
   */
  export type tb_lawyerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_lawyer
     */
    select?: tb_lawyerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_lawyer
     */
    omit?: tb_lawyerOmit<ExtArgs> | null
    /**
     * Filter, which tb_lawyers to fetch.
     */
    where?: tb_lawyerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tb_lawyers to fetch.
     */
    orderBy?: tb_lawyerOrderByWithRelationInput | tb_lawyerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing tb_lawyers.
     */
    cursor?: tb_lawyerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tb_lawyers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tb_lawyers.
     */
    skip?: number
    distinct?: Tb_lawyerScalarFieldEnum | Tb_lawyerScalarFieldEnum[]
  }

  /**
   * tb_lawyer create
   */
  export type tb_lawyerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_lawyer
     */
    select?: tb_lawyerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_lawyer
     */
    omit?: tb_lawyerOmit<ExtArgs> | null
    /**
     * The data needed to create a tb_lawyer.
     */
    data: XOR<tb_lawyerCreateInput, tb_lawyerUncheckedCreateInput>
  }

  /**
   * tb_lawyer createMany
   */
  export type tb_lawyerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many tb_lawyers.
     */
    data: tb_lawyerCreateManyInput | tb_lawyerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * tb_lawyer update
   */
  export type tb_lawyerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_lawyer
     */
    select?: tb_lawyerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_lawyer
     */
    omit?: tb_lawyerOmit<ExtArgs> | null
    /**
     * The data needed to update a tb_lawyer.
     */
    data: XOR<tb_lawyerUpdateInput, tb_lawyerUncheckedUpdateInput>
    /**
     * Choose, which tb_lawyer to update.
     */
    where: tb_lawyerWhereUniqueInput
  }

  /**
   * tb_lawyer updateMany
   */
  export type tb_lawyerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update tb_lawyers.
     */
    data: XOR<tb_lawyerUpdateManyMutationInput, tb_lawyerUncheckedUpdateManyInput>
    /**
     * Filter which tb_lawyers to update
     */
    where?: tb_lawyerWhereInput
    /**
     * Limit how many tb_lawyers to update.
     */
    limit?: number
  }

  /**
   * tb_lawyer upsert
   */
  export type tb_lawyerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_lawyer
     */
    select?: tb_lawyerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_lawyer
     */
    omit?: tb_lawyerOmit<ExtArgs> | null
    /**
     * The filter to search for the tb_lawyer to update in case it exists.
     */
    where: tb_lawyerWhereUniqueInput
    /**
     * In case the tb_lawyer found by the `where` argument doesn't exist, create a new tb_lawyer with this data.
     */
    create: XOR<tb_lawyerCreateInput, tb_lawyerUncheckedCreateInput>
    /**
     * In case the tb_lawyer was found with the provided `where` argument, update it with this data.
     */
    update: XOR<tb_lawyerUpdateInput, tb_lawyerUncheckedUpdateInput>
  }

  /**
   * tb_lawyer delete
   */
  export type tb_lawyerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_lawyer
     */
    select?: tb_lawyerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_lawyer
     */
    omit?: tb_lawyerOmit<ExtArgs> | null
    /**
     * Filter which tb_lawyer to delete.
     */
    where: tb_lawyerWhereUniqueInput
  }

  /**
   * tb_lawyer deleteMany
   */
  export type tb_lawyerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tb_lawyers to delete
     */
    where?: tb_lawyerWhereInput
    /**
     * Limit how many tb_lawyers to delete.
     */
    limit?: number
  }

  /**
   * tb_lawyer without action
   */
  export type tb_lawyerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_lawyer
     */
    select?: tb_lawyerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_lawyer
     */
    omit?: tb_lawyerOmit<ExtArgs> | null
  }


  /**
   * Model tb_marz
   */

  export type AggregateTb_marz = {
    _count: Tb_marzCountAggregateOutputType | null
    _avg: Tb_marzAvgAggregateOutputType | null
    _sum: Tb_marzSumAggregateOutputType | null
    _min: Tb_marzMinAggregateOutputType | null
    _max: Tb_marzMaxAggregateOutputType | null
  }

  export type Tb_marzAvgAggregateOutputType = {
    marz_id: number | null
  }

  export type Tb_marzSumAggregateOutputType = {
    marz_id: number | null
  }

  export type Tb_marzMinAggregateOutputType = {
    marz_id: number | null
    ADM1_ARM: string | null
    ADM1_EN: string | null
    ADM1_PCODE: string | null
  }

  export type Tb_marzMaxAggregateOutputType = {
    marz_id: number | null
    ADM1_ARM: string | null
    ADM1_EN: string | null
    ADM1_PCODE: string | null
  }

  export type Tb_marzCountAggregateOutputType = {
    marz_id: number
    ADM1_ARM: number
    ADM1_EN: number
    ADM1_PCODE: number
    _all: number
  }


  export type Tb_marzAvgAggregateInputType = {
    marz_id?: true
  }

  export type Tb_marzSumAggregateInputType = {
    marz_id?: true
  }

  export type Tb_marzMinAggregateInputType = {
    marz_id?: true
    ADM1_ARM?: true
    ADM1_EN?: true
    ADM1_PCODE?: true
  }

  export type Tb_marzMaxAggregateInputType = {
    marz_id?: true
    ADM1_ARM?: true
    ADM1_EN?: true
    ADM1_PCODE?: true
  }

  export type Tb_marzCountAggregateInputType = {
    marz_id?: true
    ADM1_ARM?: true
    ADM1_EN?: true
    ADM1_PCODE?: true
    _all?: true
  }

  export type Tb_marzAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tb_marz to aggregate.
     */
    where?: tb_marzWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tb_marzs to fetch.
     */
    orderBy?: tb_marzOrderByWithRelationInput | tb_marzOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: tb_marzWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tb_marzs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tb_marzs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned tb_marzs
    **/
    _count?: true | Tb_marzCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Tb_marzAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Tb_marzSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Tb_marzMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Tb_marzMaxAggregateInputType
  }

  export type GetTb_marzAggregateType<T extends Tb_marzAggregateArgs> = {
        [P in keyof T & keyof AggregateTb_marz]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTb_marz[P]>
      : GetScalarType<T[P], AggregateTb_marz[P]>
  }




  export type tb_marzGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: tb_marzWhereInput
    orderBy?: tb_marzOrderByWithAggregationInput | tb_marzOrderByWithAggregationInput[]
    by: Tb_marzScalarFieldEnum[] | Tb_marzScalarFieldEnum
    having?: tb_marzScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Tb_marzCountAggregateInputType | true
    _avg?: Tb_marzAvgAggregateInputType
    _sum?: Tb_marzSumAggregateInputType
    _min?: Tb_marzMinAggregateInputType
    _max?: Tb_marzMaxAggregateInputType
  }

  export type Tb_marzGroupByOutputType = {
    marz_id: number
    ADM1_ARM: string
    ADM1_EN: string
    ADM1_PCODE: string
    _count: Tb_marzCountAggregateOutputType | null
    _avg: Tb_marzAvgAggregateOutputType | null
    _sum: Tb_marzSumAggregateOutputType | null
    _min: Tb_marzMinAggregateOutputType | null
    _max: Tb_marzMaxAggregateOutputType | null
  }

  type GetTb_marzGroupByPayload<T extends tb_marzGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Tb_marzGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Tb_marzGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Tb_marzGroupByOutputType[P]>
            : GetScalarType<T[P], Tb_marzGroupByOutputType[P]>
        }
      >
    >


  export type tb_marzSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    marz_id?: boolean
    ADM1_ARM?: boolean
    ADM1_EN?: boolean
    ADM1_PCODE?: boolean
  }, ExtArgs["result"]["tb_marz"]>



  export type tb_marzSelectScalar = {
    marz_id?: boolean
    ADM1_ARM?: boolean
    ADM1_EN?: boolean
    ADM1_PCODE?: boolean
  }

  export type tb_marzOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"marz_id" | "ADM1_ARM" | "ADM1_EN" | "ADM1_PCODE", ExtArgs["result"]["tb_marz"]>

  export type $tb_marzPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "tb_marz"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      marz_id: number
      ADM1_ARM: string
      ADM1_EN: string
      ADM1_PCODE: string
    }, ExtArgs["result"]["tb_marz"]>
    composites: {}
  }

  type tb_marzGetPayload<S extends boolean | null | undefined | tb_marzDefaultArgs> = $Result.GetResult<Prisma.$tb_marzPayload, S>

  type tb_marzCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<tb_marzFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Tb_marzCountAggregateInputType | true
    }

  export interface tb_marzDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['tb_marz'], meta: { name: 'tb_marz' } }
    /**
     * Find zero or one Tb_marz that matches the filter.
     * @param {tb_marzFindUniqueArgs} args - Arguments to find a Tb_marz
     * @example
     * // Get one Tb_marz
     * const tb_marz = await prisma.tb_marz.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends tb_marzFindUniqueArgs>(args: SelectSubset<T, tb_marzFindUniqueArgs<ExtArgs>>): Prisma__tb_marzClient<$Result.GetResult<Prisma.$tb_marzPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Tb_marz that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {tb_marzFindUniqueOrThrowArgs} args - Arguments to find a Tb_marz
     * @example
     * // Get one Tb_marz
     * const tb_marz = await prisma.tb_marz.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends tb_marzFindUniqueOrThrowArgs>(args: SelectSubset<T, tb_marzFindUniqueOrThrowArgs<ExtArgs>>): Prisma__tb_marzClient<$Result.GetResult<Prisma.$tb_marzPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tb_marz that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_marzFindFirstArgs} args - Arguments to find a Tb_marz
     * @example
     * // Get one Tb_marz
     * const tb_marz = await prisma.tb_marz.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends tb_marzFindFirstArgs>(args?: SelectSubset<T, tb_marzFindFirstArgs<ExtArgs>>): Prisma__tb_marzClient<$Result.GetResult<Prisma.$tb_marzPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tb_marz that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_marzFindFirstOrThrowArgs} args - Arguments to find a Tb_marz
     * @example
     * // Get one Tb_marz
     * const tb_marz = await prisma.tb_marz.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends tb_marzFindFirstOrThrowArgs>(args?: SelectSubset<T, tb_marzFindFirstOrThrowArgs<ExtArgs>>): Prisma__tb_marzClient<$Result.GetResult<Prisma.$tb_marzPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Tb_marzs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_marzFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tb_marzs
     * const tb_marzs = await prisma.tb_marz.findMany()
     * 
     * // Get first 10 Tb_marzs
     * const tb_marzs = await prisma.tb_marz.findMany({ take: 10 })
     * 
     * // Only select the `marz_id`
     * const tb_marzWithMarz_idOnly = await prisma.tb_marz.findMany({ select: { marz_id: true } })
     * 
     */
    findMany<T extends tb_marzFindManyArgs>(args?: SelectSubset<T, tb_marzFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tb_marzPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Tb_marz.
     * @param {tb_marzCreateArgs} args - Arguments to create a Tb_marz.
     * @example
     * // Create one Tb_marz
     * const Tb_marz = await prisma.tb_marz.create({
     *   data: {
     *     // ... data to create a Tb_marz
     *   }
     * })
     * 
     */
    create<T extends tb_marzCreateArgs>(args: SelectSubset<T, tb_marzCreateArgs<ExtArgs>>): Prisma__tb_marzClient<$Result.GetResult<Prisma.$tb_marzPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Tb_marzs.
     * @param {tb_marzCreateManyArgs} args - Arguments to create many Tb_marzs.
     * @example
     * // Create many Tb_marzs
     * const tb_marz = await prisma.tb_marz.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends tb_marzCreateManyArgs>(args?: SelectSubset<T, tb_marzCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Tb_marz.
     * @param {tb_marzDeleteArgs} args - Arguments to delete one Tb_marz.
     * @example
     * // Delete one Tb_marz
     * const Tb_marz = await prisma.tb_marz.delete({
     *   where: {
     *     // ... filter to delete one Tb_marz
     *   }
     * })
     * 
     */
    delete<T extends tb_marzDeleteArgs>(args: SelectSubset<T, tb_marzDeleteArgs<ExtArgs>>): Prisma__tb_marzClient<$Result.GetResult<Prisma.$tb_marzPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Tb_marz.
     * @param {tb_marzUpdateArgs} args - Arguments to update one Tb_marz.
     * @example
     * // Update one Tb_marz
     * const tb_marz = await prisma.tb_marz.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends tb_marzUpdateArgs>(args: SelectSubset<T, tb_marzUpdateArgs<ExtArgs>>): Prisma__tb_marzClient<$Result.GetResult<Prisma.$tb_marzPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Tb_marzs.
     * @param {tb_marzDeleteManyArgs} args - Arguments to filter Tb_marzs to delete.
     * @example
     * // Delete a few Tb_marzs
     * const { count } = await prisma.tb_marz.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends tb_marzDeleteManyArgs>(args?: SelectSubset<T, tb_marzDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tb_marzs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_marzUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tb_marzs
     * const tb_marz = await prisma.tb_marz.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends tb_marzUpdateManyArgs>(args: SelectSubset<T, tb_marzUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Tb_marz.
     * @param {tb_marzUpsertArgs} args - Arguments to update or create a Tb_marz.
     * @example
     * // Update or create a Tb_marz
     * const tb_marz = await prisma.tb_marz.upsert({
     *   create: {
     *     // ... data to create a Tb_marz
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tb_marz we want to update
     *   }
     * })
     */
    upsert<T extends tb_marzUpsertArgs>(args: SelectSubset<T, tb_marzUpsertArgs<ExtArgs>>): Prisma__tb_marzClient<$Result.GetResult<Prisma.$tb_marzPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Tb_marzs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_marzCountArgs} args - Arguments to filter Tb_marzs to count.
     * @example
     * // Count the number of Tb_marzs
     * const count = await prisma.tb_marz.count({
     *   where: {
     *     // ... the filter for the Tb_marzs we want to count
     *   }
     * })
    **/
    count<T extends tb_marzCountArgs>(
      args?: Subset<T, tb_marzCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Tb_marzCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tb_marz.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Tb_marzAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Tb_marzAggregateArgs>(args: Subset<T, Tb_marzAggregateArgs>): Prisma.PrismaPromise<GetTb_marzAggregateType<T>>

    /**
     * Group by Tb_marz.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_marzGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends tb_marzGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: tb_marzGroupByArgs['orderBy'] }
        : { orderBy?: tb_marzGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, tb_marzGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTb_marzGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the tb_marz model
   */
  readonly fields: tb_marzFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for tb_marz.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__tb_marzClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the tb_marz model
   */
  interface tb_marzFieldRefs {
    readonly marz_id: FieldRef<"tb_marz", 'Int'>
    readonly ADM1_ARM: FieldRef<"tb_marz", 'String'>
    readonly ADM1_EN: FieldRef<"tb_marz", 'String'>
    readonly ADM1_PCODE: FieldRef<"tb_marz", 'String'>
  }
    

  // Custom InputTypes
  /**
   * tb_marz findUnique
   */
  export type tb_marzFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_marz
     */
    select?: tb_marzSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_marz
     */
    omit?: tb_marzOmit<ExtArgs> | null
    /**
     * Filter, which tb_marz to fetch.
     */
    where: tb_marzWhereUniqueInput
  }

  /**
   * tb_marz findUniqueOrThrow
   */
  export type tb_marzFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_marz
     */
    select?: tb_marzSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_marz
     */
    omit?: tb_marzOmit<ExtArgs> | null
    /**
     * Filter, which tb_marz to fetch.
     */
    where: tb_marzWhereUniqueInput
  }

  /**
   * tb_marz findFirst
   */
  export type tb_marzFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_marz
     */
    select?: tb_marzSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_marz
     */
    omit?: tb_marzOmit<ExtArgs> | null
    /**
     * Filter, which tb_marz to fetch.
     */
    where?: tb_marzWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tb_marzs to fetch.
     */
    orderBy?: tb_marzOrderByWithRelationInput | tb_marzOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tb_marzs.
     */
    cursor?: tb_marzWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tb_marzs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tb_marzs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tb_marzs.
     */
    distinct?: Tb_marzScalarFieldEnum | Tb_marzScalarFieldEnum[]
  }

  /**
   * tb_marz findFirstOrThrow
   */
  export type tb_marzFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_marz
     */
    select?: tb_marzSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_marz
     */
    omit?: tb_marzOmit<ExtArgs> | null
    /**
     * Filter, which tb_marz to fetch.
     */
    where?: tb_marzWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tb_marzs to fetch.
     */
    orderBy?: tb_marzOrderByWithRelationInput | tb_marzOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tb_marzs.
     */
    cursor?: tb_marzWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tb_marzs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tb_marzs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tb_marzs.
     */
    distinct?: Tb_marzScalarFieldEnum | Tb_marzScalarFieldEnum[]
  }

  /**
   * tb_marz findMany
   */
  export type tb_marzFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_marz
     */
    select?: tb_marzSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_marz
     */
    omit?: tb_marzOmit<ExtArgs> | null
    /**
     * Filter, which tb_marzs to fetch.
     */
    where?: tb_marzWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tb_marzs to fetch.
     */
    orderBy?: tb_marzOrderByWithRelationInput | tb_marzOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing tb_marzs.
     */
    cursor?: tb_marzWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tb_marzs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tb_marzs.
     */
    skip?: number
    distinct?: Tb_marzScalarFieldEnum | Tb_marzScalarFieldEnum[]
  }

  /**
   * tb_marz create
   */
  export type tb_marzCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_marz
     */
    select?: tb_marzSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_marz
     */
    omit?: tb_marzOmit<ExtArgs> | null
    /**
     * The data needed to create a tb_marz.
     */
    data: XOR<tb_marzCreateInput, tb_marzUncheckedCreateInput>
  }

  /**
   * tb_marz createMany
   */
  export type tb_marzCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many tb_marzs.
     */
    data: tb_marzCreateManyInput | tb_marzCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * tb_marz update
   */
  export type tb_marzUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_marz
     */
    select?: tb_marzSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_marz
     */
    omit?: tb_marzOmit<ExtArgs> | null
    /**
     * The data needed to update a tb_marz.
     */
    data: XOR<tb_marzUpdateInput, tb_marzUncheckedUpdateInput>
    /**
     * Choose, which tb_marz to update.
     */
    where: tb_marzWhereUniqueInput
  }

  /**
   * tb_marz updateMany
   */
  export type tb_marzUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update tb_marzs.
     */
    data: XOR<tb_marzUpdateManyMutationInput, tb_marzUncheckedUpdateManyInput>
    /**
     * Filter which tb_marzs to update
     */
    where?: tb_marzWhereInput
    /**
     * Limit how many tb_marzs to update.
     */
    limit?: number
  }

  /**
   * tb_marz upsert
   */
  export type tb_marzUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_marz
     */
    select?: tb_marzSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_marz
     */
    omit?: tb_marzOmit<ExtArgs> | null
    /**
     * The filter to search for the tb_marz to update in case it exists.
     */
    where: tb_marzWhereUniqueInput
    /**
     * In case the tb_marz found by the `where` argument doesn't exist, create a new tb_marz with this data.
     */
    create: XOR<tb_marzCreateInput, tb_marzUncheckedCreateInput>
    /**
     * In case the tb_marz was found with the provided `where` argument, update it with this data.
     */
    update: XOR<tb_marzUpdateInput, tb_marzUncheckedUpdateInput>
  }

  /**
   * tb_marz delete
   */
  export type tb_marzDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_marz
     */
    select?: tb_marzSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_marz
     */
    omit?: tb_marzOmit<ExtArgs> | null
    /**
     * Filter which tb_marz to delete.
     */
    where: tb_marzWhereUniqueInput
  }

  /**
   * tb_marz deleteMany
   */
  export type tb_marzDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tb_marzs to delete
     */
    where?: tb_marzWhereInput
    /**
     * Limit how many tb_marzs to delete.
     */
    limit?: number
  }

  /**
   * tb_marz without action
   */
  export type tb_marzDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_marz
     */
    select?: tb_marzSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_marz
     */
    omit?: tb_marzOmit<ExtArgs> | null
  }


  /**
   * Model tb_members
   */

  export type AggregateTb_members = {
    _count: Tb_membersCountAggregateOutputType | null
    _avg: Tb_membersAvgAggregateOutputType | null
    _sum: Tb_membersSumAggregateOutputType | null
    _min: Tb_membersMinAggregateOutputType | null
    _max: Tb_membersMaxAggregateOutputType | null
  }

  export type Tb_membersAvgAggregateOutputType = {
    member_id: number | null
    case_id: number | null
    sex: number | null
    citizenship: number | null
    residence: number | null
    role: number | null
  }

  export type Tb_membersSumAggregateOutputType = {
    member_id: number | null
    case_id: number | null
    sex: number | null
    citizenship: number | null
    residence: number | null
    role: number | null
  }

  export type Tb_membersMinAggregateOutputType = {
    member_id: number | null
    case_id: number | null
    f_name_arm: string | null
    f_name_eng: string | null
    l_name_arm: string | null
    l_name_eng: string | null
    m_name_arm: string | null
    m_name_eng: string | null
    b_day: string | null
    b_month: string | null
    b_year: string | null
    sex: number | null
    citizenship: number | null
    residence: number | null
    role: number | null
  }

  export type Tb_membersMaxAggregateOutputType = {
    member_id: number | null
    case_id: number | null
    f_name_arm: string | null
    f_name_eng: string | null
    l_name_arm: string | null
    l_name_eng: string | null
    m_name_arm: string | null
    m_name_eng: string | null
    b_day: string | null
    b_month: string | null
    b_year: string | null
    sex: number | null
    citizenship: number | null
    residence: number | null
    role: number | null
  }

  export type Tb_membersCountAggregateOutputType = {
    member_id: number
    case_id: number
    f_name_arm: number
    f_name_eng: number
    l_name_arm: number
    l_name_eng: number
    m_name_arm: number
    m_name_eng: number
    b_day: number
    b_month: number
    b_year: number
    sex: number
    citizenship: number
    residence: number
    role: number
    _all: number
  }


  export type Tb_membersAvgAggregateInputType = {
    member_id?: true
    case_id?: true
    sex?: true
    citizenship?: true
    residence?: true
    role?: true
  }

  export type Tb_membersSumAggregateInputType = {
    member_id?: true
    case_id?: true
    sex?: true
    citizenship?: true
    residence?: true
    role?: true
  }

  export type Tb_membersMinAggregateInputType = {
    member_id?: true
    case_id?: true
    f_name_arm?: true
    f_name_eng?: true
    l_name_arm?: true
    l_name_eng?: true
    m_name_arm?: true
    m_name_eng?: true
    b_day?: true
    b_month?: true
    b_year?: true
    sex?: true
    citizenship?: true
    residence?: true
    role?: true
  }

  export type Tb_membersMaxAggregateInputType = {
    member_id?: true
    case_id?: true
    f_name_arm?: true
    f_name_eng?: true
    l_name_arm?: true
    l_name_eng?: true
    m_name_arm?: true
    m_name_eng?: true
    b_day?: true
    b_month?: true
    b_year?: true
    sex?: true
    citizenship?: true
    residence?: true
    role?: true
  }

  export type Tb_membersCountAggregateInputType = {
    member_id?: true
    case_id?: true
    f_name_arm?: true
    f_name_eng?: true
    l_name_arm?: true
    l_name_eng?: true
    m_name_arm?: true
    m_name_eng?: true
    b_day?: true
    b_month?: true
    b_year?: true
    sex?: true
    citizenship?: true
    residence?: true
    role?: true
    _all?: true
  }

  export type Tb_membersAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tb_members to aggregate.
     */
    where?: tb_membersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tb_members to fetch.
     */
    orderBy?: tb_membersOrderByWithRelationInput | tb_membersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: tb_membersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tb_members from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tb_members.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned tb_members
    **/
    _count?: true | Tb_membersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Tb_membersAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Tb_membersSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Tb_membersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Tb_membersMaxAggregateInputType
  }

  export type GetTb_membersAggregateType<T extends Tb_membersAggregateArgs> = {
        [P in keyof T & keyof AggregateTb_members]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTb_members[P]>
      : GetScalarType<T[P], AggregateTb_members[P]>
  }




  export type tb_membersGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: tb_membersWhereInput
    orderBy?: tb_membersOrderByWithAggregationInput | tb_membersOrderByWithAggregationInput[]
    by: Tb_membersScalarFieldEnum[] | Tb_membersScalarFieldEnum
    having?: tb_membersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Tb_membersCountAggregateInputType | true
    _avg?: Tb_membersAvgAggregateInputType
    _sum?: Tb_membersSumAggregateInputType
    _min?: Tb_membersMinAggregateInputType
    _max?: Tb_membersMaxAggregateInputType
  }

  export type Tb_membersGroupByOutputType = {
    member_id: number
    case_id: number
    f_name_arm: string
    f_name_eng: string
    l_name_arm: string
    l_name_eng: string
    m_name_arm: string | null
    m_name_eng: string | null
    b_day: string
    b_month: string
    b_year: string
    sex: number
    citizenship: number | null
    residence: number | null
    role: number
    _count: Tb_membersCountAggregateOutputType | null
    _avg: Tb_membersAvgAggregateOutputType | null
    _sum: Tb_membersSumAggregateOutputType | null
    _min: Tb_membersMinAggregateOutputType | null
    _max: Tb_membersMaxAggregateOutputType | null
  }

  type GetTb_membersGroupByPayload<T extends tb_membersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Tb_membersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Tb_membersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Tb_membersGroupByOutputType[P]>
            : GetScalarType<T[P], Tb_membersGroupByOutputType[P]>
        }
      >
    >


  export type tb_membersSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    member_id?: boolean
    case_id?: boolean
    f_name_arm?: boolean
    f_name_eng?: boolean
    l_name_arm?: boolean
    l_name_eng?: boolean
    m_name_arm?: boolean
    m_name_eng?: boolean
    b_day?: boolean
    b_month?: boolean
    b_year?: boolean
    sex?: boolean
    citizenship?: boolean
    residence?: boolean
    role?: boolean
  }, ExtArgs["result"]["tb_members"]>



  export type tb_membersSelectScalar = {
    member_id?: boolean
    case_id?: boolean
    f_name_arm?: boolean
    f_name_eng?: boolean
    l_name_arm?: boolean
    l_name_eng?: boolean
    m_name_arm?: boolean
    m_name_eng?: boolean
    b_day?: boolean
    b_month?: boolean
    b_year?: boolean
    sex?: boolean
    citizenship?: boolean
    residence?: boolean
    role?: boolean
  }

  export type tb_membersOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"member_id" | "case_id" | "f_name_arm" | "f_name_eng" | "l_name_arm" | "l_name_eng" | "m_name_arm" | "m_name_eng" | "b_day" | "b_month" | "b_year" | "sex" | "citizenship" | "residence" | "role", ExtArgs["result"]["tb_members"]>

  export type $tb_membersPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "tb_members"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      member_id: number
      case_id: number
      f_name_arm: string
      f_name_eng: string
      l_name_arm: string
      l_name_eng: string
      m_name_arm: string | null
      m_name_eng: string | null
      b_day: string
      b_month: string
      b_year: string
      sex: number
      citizenship: number | null
      residence: number | null
      role: number
    }, ExtArgs["result"]["tb_members"]>
    composites: {}
  }

  type tb_membersGetPayload<S extends boolean | null | undefined | tb_membersDefaultArgs> = $Result.GetResult<Prisma.$tb_membersPayload, S>

  type tb_membersCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<tb_membersFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Tb_membersCountAggregateInputType | true
    }

  export interface tb_membersDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['tb_members'], meta: { name: 'tb_members' } }
    /**
     * Find zero or one Tb_members that matches the filter.
     * @param {tb_membersFindUniqueArgs} args - Arguments to find a Tb_members
     * @example
     * // Get one Tb_members
     * const tb_members = await prisma.tb_members.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends tb_membersFindUniqueArgs>(args: SelectSubset<T, tb_membersFindUniqueArgs<ExtArgs>>): Prisma__tb_membersClient<$Result.GetResult<Prisma.$tb_membersPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Tb_members that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {tb_membersFindUniqueOrThrowArgs} args - Arguments to find a Tb_members
     * @example
     * // Get one Tb_members
     * const tb_members = await prisma.tb_members.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends tb_membersFindUniqueOrThrowArgs>(args: SelectSubset<T, tb_membersFindUniqueOrThrowArgs<ExtArgs>>): Prisma__tb_membersClient<$Result.GetResult<Prisma.$tb_membersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tb_members that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_membersFindFirstArgs} args - Arguments to find a Tb_members
     * @example
     * // Get one Tb_members
     * const tb_members = await prisma.tb_members.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends tb_membersFindFirstArgs>(args?: SelectSubset<T, tb_membersFindFirstArgs<ExtArgs>>): Prisma__tb_membersClient<$Result.GetResult<Prisma.$tb_membersPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tb_members that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_membersFindFirstOrThrowArgs} args - Arguments to find a Tb_members
     * @example
     * // Get one Tb_members
     * const tb_members = await prisma.tb_members.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends tb_membersFindFirstOrThrowArgs>(args?: SelectSubset<T, tb_membersFindFirstOrThrowArgs<ExtArgs>>): Prisma__tb_membersClient<$Result.GetResult<Prisma.$tb_membersPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Tb_members that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_membersFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tb_members
     * const tb_members = await prisma.tb_members.findMany()
     * 
     * // Get first 10 Tb_members
     * const tb_members = await prisma.tb_members.findMany({ take: 10 })
     * 
     * // Only select the `member_id`
     * const tb_membersWithMember_idOnly = await prisma.tb_members.findMany({ select: { member_id: true } })
     * 
     */
    findMany<T extends tb_membersFindManyArgs>(args?: SelectSubset<T, tb_membersFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tb_membersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Tb_members.
     * @param {tb_membersCreateArgs} args - Arguments to create a Tb_members.
     * @example
     * // Create one Tb_members
     * const Tb_members = await prisma.tb_members.create({
     *   data: {
     *     // ... data to create a Tb_members
     *   }
     * })
     * 
     */
    create<T extends tb_membersCreateArgs>(args: SelectSubset<T, tb_membersCreateArgs<ExtArgs>>): Prisma__tb_membersClient<$Result.GetResult<Prisma.$tb_membersPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Tb_members.
     * @param {tb_membersCreateManyArgs} args - Arguments to create many Tb_members.
     * @example
     * // Create many Tb_members
     * const tb_members = await prisma.tb_members.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends tb_membersCreateManyArgs>(args?: SelectSubset<T, tb_membersCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Tb_members.
     * @param {tb_membersDeleteArgs} args - Arguments to delete one Tb_members.
     * @example
     * // Delete one Tb_members
     * const Tb_members = await prisma.tb_members.delete({
     *   where: {
     *     // ... filter to delete one Tb_members
     *   }
     * })
     * 
     */
    delete<T extends tb_membersDeleteArgs>(args: SelectSubset<T, tb_membersDeleteArgs<ExtArgs>>): Prisma__tb_membersClient<$Result.GetResult<Prisma.$tb_membersPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Tb_members.
     * @param {tb_membersUpdateArgs} args - Arguments to update one Tb_members.
     * @example
     * // Update one Tb_members
     * const tb_members = await prisma.tb_members.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends tb_membersUpdateArgs>(args: SelectSubset<T, tb_membersUpdateArgs<ExtArgs>>): Prisma__tb_membersClient<$Result.GetResult<Prisma.$tb_membersPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Tb_members.
     * @param {tb_membersDeleteManyArgs} args - Arguments to filter Tb_members to delete.
     * @example
     * // Delete a few Tb_members
     * const { count } = await prisma.tb_members.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends tb_membersDeleteManyArgs>(args?: SelectSubset<T, tb_membersDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tb_members.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_membersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tb_members
     * const tb_members = await prisma.tb_members.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends tb_membersUpdateManyArgs>(args: SelectSubset<T, tb_membersUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Tb_members.
     * @param {tb_membersUpsertArgs} args - Arguments to update or create a Tb_members.
     * @example
     * // Update or create a Tb_members
     * const tb_members = await prisma.tb_members.upsert({
     *   create: {
     *     // ... data to create a Tb_members
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tb_members we want to update
     *   }
     * })
     */
    upsert<T extends tb_membersUpsertArgs>(args: SelectSubset<T, tb_membersUpsertArgs<ExtArgs>>): Prisma__tb_membersClient<$Result.GetResult<Prisma.$tb_membersPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Tb_members.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_membersCountArgs} args - Arguments to filter Tb_members to count.
     * @example
     * // Count the number of Tb_members
     * const count = await prisma.tb_members.count({
     *   where: {
     *     // ... the filter for the Tb_members we want to count
     *   }
     * })
    **/
    count<T extends tb_membersCountArgs>(
      args?: Subset<T, tb_membersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Tb_membersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tb_members.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Tb_membersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Tb_membersAggregateArgs>(args: Subset<T, Tb_membersAggregateArgs>): Prisma.PrismaPromise<GetTb_membersAggregateType<T>>

    /**
     * Group by Tb_members.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_membersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends tb_membersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: tb_membersGroupByArgs['orderBy'] }
        : { orderBy?: tb_membersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, tb_membersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTb_membersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the tb_members model
   */
  readonly fields: tb_membersFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for tb_members.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__tb_membersClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the tb_members model
   */
  interface tb_membersFieldRefs {
    readonly member_id: FieldRef<"tb_members", 'Int'>
    readonly case_id: FieldRef<"tb_members", 'Int'>
    readonly f_name_arm: FieldRef<"tb_members", 'String'>
    readonly f_name_eng: FieldRef<"tb_members", 'String'>
    readonly l_name_arm: FieldRef<"tb_members", 'String'>
    readonly l_name_eng: FieldRef<"tb_members", 'String'>
    readonly m_name_arm: FieldRef<"tb_members", 'String'>
    readonly m_name_eng: FieldRef<"tb_members", 'String'>
    readonly b_day: FieldRef<"tb_members", 'String'>
    readonly b_month: FieldRef<"tb_members", 'String'>
    readonly b_year: FieldRef<"tb_members", 'String'>
    readonly sex: FieldRef<"tb_members", 'Int'>
    readonly citizenship: FieldRef<"tb_members", 'Int'>
    readonly residence: FieldRef<"tb_members", 'Int'>
    readonly role: FieldRef<"tb_members", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * tb_members findUnique
   */
  export type tb_membersFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_members
     */
    select?: tb_membersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_members
     */
    omit?: tb_membersOmit<ExtArgs> | null
    /**
     * Filter, which tb_members to fetch.
     */
    where: tb_membersWhereUniqueInput
  }

  /**
   * tb_members findUniqueOrThrow
   */
  export type tb_membersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_members
     */
    select?: tb_membersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_members
     */
    omit?: tb_membersOmit<ExtArgs> | null
    /**
     * Filter, which tb_members to fetch.
     */
    where: tb_membersWhereUniqueInput
  }

  /**
   * tb_members findFirst
   */
  export type tb_membersFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_members
     */
    select?: tb_membersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_members
     */
    omit?: tb_membersOmit<ExtArgs> | null
    /**
     * Filter, which tb_members to fetch.
     */
    where?: tb_membersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tb_members to fetch.
     */
    orderBy?: tb_membersOrderByWithRelationInput | tb_membersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tb_members.
     */
    cursor?: tb_membersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tb_members from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tb_members.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tb_members.
     */
    distinct?: Tb_membersScalarFieldEnum | Tb_membersScalarFieldEnum[]
  }

  /**
   * tb_members findFirstOrThrow
   */
  export type tb_membersFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_members
     */
    select?: tb_membersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_members
     */
    omit?: tb_membersOmit<ExtArgs> | null
    /**
     * Filter, which tb_members to fetch.
     */
    where?: tb_membersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tb_members to fetch.
     */
    orderBy?: tb_membersOrderByWithRelationInput | tb_membersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tb_members.
     */
    cursor?: tb_membersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tb_members from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tb_members.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tb_members.
     */
    distinct?: Tb_membersScalarFieldEnum | Tb_membersScalarFieldEnum[]
  }

  /**
   * tb_members findMany
   */
  export type tb_membersFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_members
     */
    select?: tb_membersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_members
     */
    omit?: tb_membersOmit<ExtArgs> | null
    /**
     * Filter, which tb_members to fetch.
     */
    where?: tb_membersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tb_members to fetch.
     */
    orderBy?: tb_membersOrderByWithRelationInput | tb_membersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing tb_members.
     */
    cursor?: tb_membersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tb_members from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tb_members.
     */
    skip?: number
    distinct?: Tb_membersScalarFieldEnum | Tb_membersScalarFieldEnum[]
  }

  /**
   * tb_members create
   */
  export type tb_membersCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_members
     */
    select?: tb_membersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_members
     */
    omit?: tb_membersOmit<ExtArgs> | null
    /**
     * The data needed to create a tb_members.
     */
    data: XOR<tb_membersCreateInput, tb_membersUncheckedCreateInput>
  }

  /**
   * tb_members createMany
   */
  export type tb_membersCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many tb_members.
     */
    data: tb_membersCreateManyInput | tb_membersCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * tb_members update
   */
  export type tb_membersUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_members
     */
    select?: tb_membersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_members
     */
    omit?: tb_membersOmit<ExtArgs> | null
    /**
     * The data needed to update a tb_members.
     */
    data: XOR<tb_membersUpdateInput, tb_membersUncheckedUpdateInput>
    /**
     * Choose, which tb_members to update.
     */
    where: tb_membersWhereUniqueInput
  }

  /**
   * tb_members updateMany
   */
  export type tb_membersUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update tb_members.
     */
    data: XOR<tb_membersUpdateManyMutationInput, tb_membersUncheckedUpdateManyInput>
    /**
     * Filter which tb_members to update
     */
    where?: tb_membersWhereInput
    /**
     * Limit how many tb_members to update.
     */
    limit?: number
  }

  /**
   * tb_members upsert
   */
  export type tb_membersUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_members
     */
    select?: tb_membersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_members
     */
    omit?: tb_membersOmit<ExtArgs> | null
    /**
     * The filter to search for the tb_members to update in case it exists.
     */
    where: tb_membersWhereUniqueInput
    /**
     * In case the tb_members found by the `where` argument doesn't exist, create a new tb_members with this data.
     */
    create: XOR<tb_membersCreateInput, tb_membersUncheckedCreateInput>
    /**
     * In case the tb_members was found with the provided `where` argument, update it with this data.
     */
    update: XOR<tb_membersUpdateInput, tb_membersUncheckedUpdateInput>
  }

  /**
   * tb_members delete
   */
  export type tb_membersDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_members
     */
    select?: tb_membersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_members
     */
    omit?: tb_membersOmit<ExtArgs> | null
    /**
     * Filter which tb_members to delete.
     */
    where: tb_membersWhereUniqueInput
  }

  /**
   * tb_members deleteMany
   */
  export type tb_membersDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tb_members to delete
     */
    where?: tb_membersWhereInput
    /**
     * Limit how many tb_members to delete.
     */
    limit?: number
  }

  /**
   * tb_members without action
   */
  export type tb_membersDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_members
     */
    select?: tb_membersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_members
     */
    omit?: tb_membersOmit<ExtArgs> | null
  }


  /**
   * Model tb_notifications
   */

  export type AggregateTb_notifications = {
    _count: Tb_notificationsCountAggregateOutputType | null
    _avg: Tb_notificationsAvgAggregateOutputType | null
    _sum: Tb_notificationsSumAggregateOutputType | null
    _min: Tb_notificationsMinAggregateOutputType | null
    _max: Tb_notificationsMaxAggregateOutputType | null
  }

  export type Tb_notificationsAvgAggregateOutputType = {
    comment_id: number | null
    comment_status: number | null
    comment_from: number | null
    comment_to: number | null
    case_id: number | null
    coi_id: number | null
    request_id: number | null
    note_type: number | null
    draft_id: number | null
    order_id: number | null
    readed: number | null
    msg_read: number | null
  }

  export type Tb_notificationsSumAggregateOutputType = {
    comment_id: number | null
    comment_status: number | null
    comment_from: number | null
    comment_to: number | null
    case_id: number | null
    coi_id: number | null
    request_id: number | null
    note_type: number | null
    draft_id: number | null
    order_id: number | null
    readed: number | null
    msg_read: number | null
  }

  export type Tb_notificationsMinAggregateOutputType = {
    comment_id: number | null
    comment_subject: string | null
    comment_text: string | null
    comment_status: number | null
    comment_from: number | null
    comment_to: number | null
    case_id: number | null
    coi_id: number | null
    request_id: number | null
    note_type: number | null
    draft_id: number | null
    order_id: number | null
    readed: number | null
    note_date: Date | null
    msg_read: number | null
  }

  export type Tb_notificationsMaxAggregateOutputType = {
    comment_id: number | null
    comment_subject: string | null
    comment_text: string | null
    comment_status: number | null
    comment_from: number | null
    comment_to: number | null
    case_id: number | null
    coi_id: number | null
    request_id: number | null
    note_type: number | null
    draft_id: number | null
    order_id: number | null
    readed: number | null
    note_date: Date | null
    msg_read: number | null
  }

  export type Tb_notificationsCountAggregateOutputType = {
    comment_id: number
    comment_subject: number
    comment_text: number
    comment_status: number
    comment_from: number
    comment_to: number
    case_id: number
    coi_id: number
    request_id: number
    note_type: number
    draft_id: number
    order_id: number
    readed: number
    note_date: number
    msg_read: number
    _all: number
  }


  export type Tb_notificationsAvgAggregateInputType = {
    comment_id?: true
    comment_status?: true
    comment_from?: true
    comment_to?: true
    case_id?: true
    coi_id?: true
    request_id?: true
    note_type?: true
    draft_id?: true
    order_id?: true
    readed?: true
    msg_read?: true
  }

  export type Tb_notificationsSumAggregateInputType = {
    comment_id?: true
    comment_status?: true
    comment_from?: true
    comment_to?: true
    case_id?: true
    coi_id?: true
    request_id?: true
    note_type?: true
    draft_id?: true
    order_id?: true
    readed?: true
    msg_read?: true
  }

  export type Tb_notificationsMinAggregateInputType = {
    comment_id?: true
    comment_subject?: true
    comment_text?: true
    comment_status?: true
    comment_from?: true
    comment_to?: true
    case_id?: true
    coi_id?: true
    request_id?: true
    note_type?: true
    draft_id?: true
    order_id?: true
    readed?: true
    note_date?: true
    msg_read?: true
  }

  export type Tb_notificationsMaxAggregateInputType = {
    comment_id?: true
    comment_subject?: true
    comment_text?: true
    comment_status?: true
    comment_from?: true
    comment_to?: true
    case_id?: true
    coi_id?: true
    request_id?: true
    note_type?: true
    draft_id?: true
    order_id?: true
    readed?: true
    note_date?: true
    msg_read?: true
  }

  export type Tb_notificationsCountAggregateInputType = {
    comment_id?: true
    comment_subject?: true
    comment_text?: true
    comment_status?: true
    comment_from?: true
    comment_to?: true
    case_id?: true
    coi_id?: true
    request_id?: true
    note_type?: true
    draft_id?: true
    order_id?: true
    readed?: true
    note_date?: true
    msg_read?: true
    _all?: true
  }

  export type Tb_notificationsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tb_notifications to aggregate.
     */
    where?: tb_notificationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tb_notifications to fetch.
     */
    orderBy?: tb_notificationsOrderByWithRelationInput | tb_notificationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: tb_notificationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tb_notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tb_notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned tb_notifications
    **/
    _count?: true | Tb_notificationsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Tb_notificationsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Tb_notificationsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Tb_notificationsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Tb_notificationsMaxAggregateInputType
  }

  export type GetTb_notificationsAggregateType<T extends Tb_notificationsAggregateArgs> = {
        [P in keyof T & keyof AggregateTb_notifications]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTb_notifications[P]>
      : GetScalarType<T[P], AggregateTb_notifications[P]>
  }




  export type tb_notificationsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: tb_notificationsWhereInput
    orderBy?: tb_notificationsOrderByWithAggregationInput | tb_notificationsOrderByWithAggregationInput[]
    by: Tb_notificationsScalarFieldEnum[] | Tb_notificationsScalarFieldEnum
    having?: tb_notificationsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Tb_notificationsCountAggregateInputType | true
    _avg?: Tb_notificationsAvgAggregateInputType
    _sum?: Tb_notificationsSumAggregateInputType
    _min?: Tb_notificationsMinAggregateInputType
    _max?: Tb_notificationsMaxAggregateInputType
  }

  export type Tb_notificationsGroupByOutputType = {
    comment_id: number
    comment_subject: string
    comment_text: string | null
    comment_status: number
    comment_from: number
    comment_to: number
    case_id: number | null
    coi_id: number | null
    request_id: number | null
    note_type: number | null
    draft_id: number | null
    order_id: number | null
    readed: number | null
    note_date: Date
    msg_read: number
    _count: Tb_notificationsCountAggregateOutputType | null
    _avg: Tb_notificationsAvgAggregateOutputType | null
    _sum: Tb_notificationsSumAggregateOutputType | null
    _min: Tb_notificationsMinAggregateOutputType | null
    _max: Tb_notificationsMaxAggregateOutputType | null
  }

  type GetTb_notificationsGroupByPayload<T extends tb_notificationsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Tb_notificationsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Tb_notificationsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Tb_notificationsGroupByOutputType[P]>
            : GetScalarType<T[P], Tb_notificationsGroupByOutputType[P]>
        }
      >
    >


  export type tb_notificationsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    comment_id?: boolean
    comment_subject?: boolean
    comment_text?: boolean
    comment_status?: boolean
    comment_from?: boolean
    comment_to?: boolean
    case_id?: boolean
    coi_id?: boolean
    request_id?: boolean
    note_type?: boolean
    draft_id?: boolean
    order_id?: boolean
    readed?: boolean
    note_date?: boolean
    msg_read?: boolean
  }, ExtArgs["result"]["tb_notifications"]>



  export type tb_notificationsSelectScalar = {
    comment_id?: boolean
    comment_subject?: boolean
    comment_text?: boolean
    comment_status?: boolean
    comment_from?: boolean
    comment_to?: boolean
    case_id?: boolean
    coi_id?: boolean
    request_id?: boolean
    note_type?: boolean
    draft_id?: boolean
    order_id?: boolean
    readed?: boolean
    note_date?: boolean
    msg_read?: boolean
  }

  export type tb_notificationsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"comment_id" | "comment_subject" | "comment_text" | "comment_status" | "comment_from" | "comment_to" | "case_id" | "coi_id" | "request_id" | "note_type" | "draft_id" | "order_id" | "readed" | "note_date" | "msg_read", ExtArgs["result"]["tb_notifications"]>

  export type $tb_notificationsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "tb_notifications"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      comment_id: number
      comment_subject: string
      comment_text: string | null
      comment_status: number
      comment_from: number
      comment_to: number
      case_id: number | null
      coi_id: number | null
      request_id: number | null
      note_type: number | null
      draft_id: number | null
      order_id: number | null
      readed: number | null
      note_date: Date
      msg_read: number
    }, ExtArgs["result"]["tb_notifications"]>
    composites: {}
  }

  type tb_notificationsGetPayload<S extends boolean | null | undefined | tb_notificationsDefaultArgs> = $Result.GetResult<Prisma.$tb_notificationsPayload, S>

  type tb_notificationsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<tb_notificationsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Tb_notificationsCountAggregateInputType | true
    }

  export interface tb_notificationsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['tb_notifications'], meta: { name: 'tb_notifications' } }
    /**
     * Find zero or one Tb_notifications that matches the filter.
     * @param {tb_notificationsFindUniqueArgs} args - Arguments to find a Tb_notifications
     * @example
     * // Get one Tb_notifications
     * const tb_notifications = await prisma.tb_notifications.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends tb_notificationsFindUniqueArgs>(args: SelectSubset<T, tb_notificationsFindUniqueArgs<ExtArgs>>): Prisma__tb_notificationsClient<$Result.GetResult<Prisma.$tb_notificationsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Tb_notifications that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {tb_notificationsFindUniqueOrThrowArgs} args - Arguments to find a Tb_notifications
     * @example
     * // Get one Tb_notifications
     * const tb_notifications = await prisma.tb_notifications.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends tb_notificationsFindUniqueOrThrowArgs>(args: SelectSubset<T, tb_notificationsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__tb_notificationsClient<$Result.GetResult<Prisma.$tb_notificationsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tb_notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_notificationsFindFirstArgs} args - Arguments to find a Tb_notifications
     * @example
     * // Get one Tb_notifications
     * const tb_notifications = await prisma.tb_notifications.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends tb_notificationsFindFirstArgs>(args?: SelectSubset<T, tb_notificationsFindFirstArgs<ExtArgs>>): Prisma__tb_notificationsClient<$Result.GetResult<Prisma.$tb_notificationsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tb_notifications that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_notificationsFindFirstOrThrowArgs} args - Arguments to find a Tb_notifications
     * @example
     * // Get one Tb_notifications
     * const tb_notifications = await prisma.tb_notifications.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends tb_notificationsFindFirstOrThrowArgs>(args?: SelectSubset<T, tb_notificationsFindFirstOrThrowArgs<ExtArgs>>): Prisma__tb_notificationsClient<$Result.GetResult<Prisma.$tb_notificationsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Tb_notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_notificationsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tb_notifications
     * const tb_notifications = await prisma.tb_notifications.findMany()
     * 
     * // Get first 10 Tb_notifications
     * const tb_notifications = await prisma.tb_notifications.findMany({ take: 10 })
     * 
     * // Only select the `comment_id`
     * const tb_notificationsWithComment_idOnly = await prisma.tb_notifications.findMany({ select: { comment_id: true } })
     * 
     */
    findMany<T extends tb_notificationsFindManyArgs>(args?: SelectSubset<T, tb_notificationsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tb_notificationsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Tb_notifications.
     * @param {tb_notificationsCreateArgs} args - Arguments to create a Tb_notifications.
     * @example
     * // Create one Tb_notifications
     * const Tb_notifications = await prisma.tb_notifications.create({
     *   data: {
     *     // ... data to create a Tb_notifications
     *   }
     * })
     * 
     */
    create<T extends tb_notificationsCreateArgs>(args: SelectSubset<T, tb_notificationsCreateArgs<ExtArgs>>): Prisma__tb_notificationsClient<$Result.GetResult<Prisma.$tb_notificationsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Tb_notifications.
     * @param {tb_notificationsCreateManyArgs} args - Arguments to create many Tb_notifications.
     * @example
     * // Create many Tb_notifications
     * const tb_notifications = await prisma.tb_notifications.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends tb_notificationsCreateManyArgs>(args?: SelectSubset<T, tb_notificationsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Tb_notifications.
     * @param {tb_notificationsDeleteArgs} args - Arguments to delete one Tb_notifications.
     * @example
     * // Delete one Tb_notifications
     * const Tb_notifications = await prisma.tb_notifications.delete({
     *   where: {
     *     // ... filter to delete one Tb_notifications
     *   }
     * })
     * 
     */
    delete<T extends tb_notificationsDeleteArgs>(args: SelectSubset<T, tb_notificationsDeleteArgs<ExtArgs>>): Prisma__tb_notificationsClient<$Result.GetResult<Prisma.$tb_notificationsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Tb_notifications.
     * @param {tb_notificationsUpdateArgs} args - Arguments to update one Tb_notifications.
     * @example
     * // Update one Tb_notifications
     * const tb_notifications = await prisma.tb_notifications.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends tb_notificationsUpdateArgs>(args: SelectSubset<T, tb_notificationsUpdateArgs<ExtArgs>>): Prisma__tb_notificationsClient<$Result.GetResult<Prisma.$tb_notificationsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Tb_notifications.
     * @param {tb_notificationsDeleteManyArgs} args - Arguments to filter Tb_notifications to delete.
     * @example
     * // Delete a few Tb_notifications
     * const { count } = await prisma.tb_notifications.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends tb_notificationsDeleteManyArgs>(args?: SelectSubset<T, tb_notificationsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tb_notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_notificationsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tb_notifications
     * const tb_notifications = await prisma.tb_notifications.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends tb_notificationsUpdateManyArgs>(args: SelectSubset<T, tb_notificationsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Tb_notifications.
     * @param {tb_notificationsUpsertArgs} args - Arguments to update or create a Tb_notifications.
     * @example
     * // Update or create a Tb_notifications
     * const tb_notifications = await prisma.tb_notifications.upsert({
     *   create: {
     *     // ... data to create a Tb_notifications
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tb_notifications we want to update
     *   }
     * })
     */
    upsert<T extends tb_notificationsUpsertArgs>(args: SelectSubset<T, tb_notificationsUpsertArgs<ExtArgs>>): Prisma__tb_notificationsClient<$Result.GetResult<Prisma.$tb_notificationsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Tb_notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_notificationsCountArgs} args - Arguments to filter Tb_notifications to count.
     * @example
     * // Count the number of Tb_notifications
     * const count = await prisma.tb_notifications.count({
     *   where: {
     *     // ... the filter for the Tb_notifications we want to count
     *   }
     * })
    **/
    count<T extends tb_notificationsCountArgs>(
      args?: Subset<T, tb_notificationsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Tb_notificationsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tb_notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Tb_notificationsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Tb_notificationsAggregateArgs>(args: Subset<T, Tb_notificationsAggregateArgs>): Prisma.PrismaPromise<GetTb_notificationsAggregateType<T>>

    /**
     * Group by Tb_notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_notificationsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends tb_notificationsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: tb_notificationsGroupByArgs['orderBy'] }
        : { orderBy?: tb_notificationsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, tb_notificationsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTb_notificationsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the tb_notifications model
   */
  readonly fields: tb_notificationsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for tb_notifications.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__tb_notificationsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the tb_notifications model
   */
  interface tb_notificationsFieldRefs {
    readonly comment_id: FieldRef<"tb_notifications", 'Int'>
    readonly comment_subject: FieldRef<"tb_notifications", 'String'>
    readonly comment_text: FieldRef<"tb_notifications", 'String'>
    readonly comment_status: FieldRef<"tb_notifications", 'Int'>
    readonly comment_from: FieldRef<"tb_notifications", 'Int'>
    readonly comment_to: FieldRef<"tb_notifications", 'Int'>
    readonly case_id: FieldRef<"tb_notifications", 'Int'>
    readonly coi_id: FieldRef<"tb_notifications", 'Int'>
    readonly request_id: FieldRef<"tb_notifications", 'Int'>
    readonly note_type: FieldRef<"tb_notifications", 'Int'>
    readonly draft_id: FieldRef<"tb_notifications", 'Int'>
    readonly order_id: FieldRef<"tb_notifications", 'Int'>
    readonly readed: FieldRef<"tb_notifications", 'Int'>
    readonly note_date: FieldRef<"tb_notifications", 'DateTime'>
    readonly msg_read: FieldRef<"tb_notifications", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * tb_notifications findUnique
   */
  export type tb_notificationsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_notifications
     */
    select?: tb_notificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_notifications
     */
    omit?: tb_notificationsOmit<ExtArgs> | null
    /**
     * Filter, which tb_notifications to fetch.
     */
    where: tb_notificationsWhereUniqueInput
  }

  /**
   * tb_notifications findUniqueOrThrow
   */
  export type tb_notificationsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_notifications
     */
    select?: tb_notificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_notifications
     */
    omit?: tb_notificationsOmit<ExtArgs> | null
    /**
     * Filter, which tb_notifications to fetch.
     */
    where: tb_notificationsWhereUniqueInput
  }

  /**
   * tb_notifications findFirst
   */
  export type tb_notificationsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_notifications
     */
    select?: tb_notificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_notifications
     */
    omit?: tb_notificationsOmit<ExtArgs> | null
    /**
     * Filter, which tb_notifications to fetch.
     */
    where?: tb_notificationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tb_notifications to fetch.
     */
    orderBy?: tb_notificationsOrderByWithRelationInput | tb_notificationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tb_notifications.
     */
    cursor?: tb_notificationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tb_notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tb_notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tb_notifications.
     */
    distinct?: Tb_notificationsScalarFieldEnum | Tb_notificationsScalarFieldEnum[]
  }

  /**
   * tb_notifications findFirstOrThrow
   */
  export type tb_notificationsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_notifications
     */
    select?: tb_notificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_notifications
     */
    omit?: tb_notificationsOmit<ExtArgs> | null
    /**
     * Filter, which tb_notifications to fetch.
     */
    where?: tb_notificationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tb_notifications to fetch.
     */
    orderBy?: tb_notificationsOrderByWithRelationInput | tb_notificationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tb_notifications.
     */
    cursor?: tb_notificationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tb_notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tb_notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tb_notifications.
     */
    distinct?: Tb_notificationsScalarFieldEnum | Tb_notificationsScalarFieldEnum[]
  }

  /**
   * tb_notifications findMany
   */
  export type tb_notificationsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_notifications
     */
    select?: tb_notificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_notifications
     */
    omit?: tb_notificationsOmit<ExtArgs> | null
    /**
     * Filter, which tb_notifications to fetch.
     */
    where?: tb_notificationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tb_notifications to fetch.
     */
    orderBy?: tb_notificationsOrderByWithRelationInput | tb_notificationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing tb_notifications.
     */
    cursor?: tb_notificationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tb_notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tb_notifications.
     */
    skip?: number
    distinct?: Tb_notificationsScalarFieldEnum | Tb_notificationsScalarFieldEnum[]
  }

  /**
   * tb_notifications create
   */
  export type tb_notificationsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_notifications
     */
    select?: tb_notificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_notifications
     */
    omit?: tb_notificationsOmit<ExtArgs> | null
    /**
     * The data needed to create a tb_notifications.
     */
    data: XOR<tb_notificationsCreateInput, tb_notificationsUncheckedCreateInput>
  }

  /**
   * tb_notifications createMany
   */
  export type tb_notificationsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many tb_notifications.
     */
    data: tb_notificationsCreateManyInput | tb_notificationsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * tb_notifications update
   */
  export type tb_notificationsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_notifications
     */
    select?: tb_notificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_notifications
     */
    omit?: tb_notificationsOmit<ExtArgs> | null
    /**
     * The data needed to update a tb_notifications.
     */
    data: XOR<tb_notificationsUpdateInput, tb_notificationsUncheckedUpdateInput>
    /**
     * Choose, which tb_notifications to update.
     */
    where: tb_notificationsWhereUniqueInput
  }

  /**
   * tb_notifications updateMany
   */
  export type tb_notificationsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update tb_notifications.
     */
    data: XOR<tb_notificationsUpdateManyMutationInput, tb_notificationsUncheckedUpdateManyInput>
    /**
     * Filter which tb_notifications to update
     */
    where?: tb_notificationsWhereInput
    /**
     * Limit how many tb_notifications to update.
     */
    limit?: number
  }

  /**
   * tb_notifications upsert
   */
  export type tb_notificationsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_notifications
     */
    select?: tb_notificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_notifications
     */
    omit?: tb_notificationsOmit<ExtArgs> | null
    /**
     * The filter to search for the tb_notifications to update in case it exists.
     */
    where: tb_notificationsWhereUniqueInput
    /**
     * In case the tb_notifications found by the `where` argument doesn't exist, create a new tb_notifications with this data.
     */
    create: XOR<tb_notificationsCreateInput, tb_notificationsUncheckedCreateInput>
    /**
     * In case the tb_notifications was found with the provided `where` argument, update it with this data.
     */
    update: XOR<tb_notificationsUpdateInput, tb_notificationsUncheckedUpdateInput>
  }

  /**
   * tb_notifications delete
   */
  export type tb_notificationsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_notifications
     */
    select?: tb_notificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_notifications
     */
    omit?: tb_notificationsOmit<ExtArgs> | null
    /**
     * Filter which tb_notifications to delete.
     */
    where: tb_notificationsWhereUniqueInput
  }

  /**
   * tb_notifications deleteMany
   */
  export type tb_notificationsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tb_notifications to delete
     */
    where?: tb_notificationsWhereInput
    /**
     * Limit how many tb_notifications to delete.
     */
    limit?: number
  }

  /**
   * tb_notifications without action
   */
  export type tb_notificationsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_notifications
     */
    select?: tb_notificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_notifications
     */
    omit?: tb_notificationsOmit<ExtArgs> | null
  }


  /**
   * Model tb_orders
   */

  export type AggregateTb_orders = {
    _count: Tb_ordersCountAggregateOutputType | null
    _avg: Tb_ordersAvgAggregateOutputType | null
    _sum: Tb_ordersSumAggregateOutputType | null
    _min: Tb_ordersMinAggregateOutputType | null
    _max: Tb_ordersMaxAggregateOutputType | null
  }

  export type Tb_ordersAvgAggregateOutputType = {
    order_id: number | null
    case_id: number | null
    order_status: number | null
  }

  export type Tb_ordersSumAggregateOutputType = {
    order_id: number | null
    case_id: number | null
    order_status: number | null
  }

  export type Tb_ordersMinAggregateOutputType = {
    order_id: number | null
    case_id: number | null
    order_status: number | null
    date: Date | null
  }

  export type Tb_ordersMaxAggregateOutputType = {
    order_id: number | null
    case_id: number | null
    order_status: number | null
    date: Date | null
  }

  export type Tb_ordersCountAggregateOutputType = {
    order_id: number
    case_id: number
    order_status: number
    date: number
    _all: number
  }


  export type Tb_ordersAvgAggregateInputType = {
    order_id?: true
    case_id?: true
    order_status?: true
  }

  export type Tb_ordersSumAggregateInputType = {
    order_id?: true
    case_id?: true
    order_status?: true
  }

  export type Tb_ordersMinAggregateInputType = {
    order_id?: true
    case_id?: true
    order_status?: true
    date?: true
  }

  export type Tb_ordersMaxAggregateInputType = {
    order_id?: true
    case_id?: true
    order_status?: true
    date?: true
  }

  export type Tb_ordersCountAggregateInputType = {
    order_id?: true
    case_id?: true
    order_status?: true
    date?: true
    _all?: true
  }

  export type Tb_ordersAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tb_orders to aggregate.
     */
    where?: tb_ordersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tb_orders to fetch.
     */
    orderBy?: tb_ordersOrderByWithRelationInput | tb_ordersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: tb_ordersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tb_orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tb_orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned tb_orders
    **/
    _count?: true | Tb_ordersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Tb_ordersAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Tb_ordersSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Tb_ordersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Tb_ordersMaxAggregateInputType
  }

  export type GetTb_ordersAggregateType<T extends Tb_ordersAggregateArgs> = {
        [P in keyof T & keyof AggregateTb_orders]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTb_orders[P]>
      : GetScalarType<T[P], AggregateTb_orders[P]>
  }




  export type tb_ordersGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: tb_ordersWhereInput
    orderBy?: tb_ordersOrderByWithAggregationInput | tb_ordersOrderByWithAggregationInput[]
    by: Tb_ordersScalarFieldEnum[] | Tb_ordersScalarFieldEnum
    having?: tb_ordersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Tb_ordersCountAggregateInputType | true
    _avg?: Tb_ordersAvgAggregateInputType
    _sum?: Tb_ordersSumAggregateInputType
    _min?: Tb_ordersMinAggregateInputType
    _max?: Tb_ordersMaxAggregateInputType
  }

  export type Tb_ordersGroupByOutputType = {
    order_id: number
    case_id: number
    order_status: number
    date: Date
    _count: Tb_ordersCountAggregateOutputType | null
    _avg: Tb_ordersAvgAggregateOutputType | null
    _sum: Tb_ordersSumAggregateOutputType | null
    _min: Tb_ordersMinAggregateOutputType | null
    _max: Tb_ordersMaxAggregateOutputType | null
  }

  type GetTb_ordersGroupByPayload<T extends tb_ordersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Tb_ordersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Tb_ordersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Tb_ordersGroupByOutputType[P]>
            : GetScalarType<T[P], Tb_ordersGroupByOutputType[P]>
        }
      >
    >


  export type tb_ordersSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    order_id?: boolean
    case_id?: boolean
    order_status?: boolean
    date?: boolean
  }, ExtArgs["result"]["tb_orders"]>



  export type tb_ordersSelectScalar = {
    order_id?: boolean
    case_id?: boolean
    order_status?: boolean
    date?: boolean
  }

  export type tb_ordersOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"order_id" | "case_id" | "order_status" | "date", ExtArgs["result"]["tb_orders"]>

  export type $tb_ordersPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "tb_orders"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      order_id: number
      case_id: number
      order_status: number
      date: Date
    }, ExtArgs["result"]["tb_orders"]>
    composites: {}
  }

  type tb_ordersGetPayload<S extends boolean | null | undefined | tb_ordersDefaultArgs> = $Result.GetResult<Prisma.$tb_ordersPayload, S>

  type tb_ordersCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<tb_ordersFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Tb_ordersCountAggregateInputType | true
    }

  export interface tb_ordersDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['tb_orders'], meta: { name: 'tb_orders' } }
    /**
     * Find zero or one Tb_orders that matches the filter.
     * @param {tb_ordersFindUniqueArgs} args - Arguments to find a Tb_orders
     * @example
     * // Get one Tb_orders
     * const tb_orders = await prisma.tb_orders.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends tb_ordersFindUniqueArgs>(args: SelectSubset<T, tb_ordersFindUniqueArgs<ExtArgs>>): Prisma__tb_ordersClient<$Result.GetResult<Prisma.$tb_ordersPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Tb_orders that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {tb_ordersFindUniqueOrThrowArgs} args - Arguments to find a Tb_orders
     * @example
     * // Get one Tb_orders
     * const tb_orders = await prisma.tb_orders.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends tb_ordersFindUniqueOrThrowArgs>(args: SelectSubset<T, tb_ordersFindUniqueOrThrowArgs<ExtArgs>>): Prisma__tb_ordersClient<$Result.GetResult<Prisma.$tb_ordersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tb_orders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_ordersFindFirstArgs} args - Arguments to find a Tb_orders
     * @example
     * // Get one Tb_orders
     * const tb_orders = await prisma.tb_orders.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends tb_ordersFindFirstArgs>(args?: SelectSubset<T, tb_ordersFindFirstArgs<ExtArgs>>): Prisma__tb_ordersClient<$Result.GetResult<Prisma.$tb_ordersPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tb_orders that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_ordersFindFirstOrThrowArgs} args - Arguments to find a Tb_orders
     * @example
     * // Get one Tb_orders
     * const tb_orders = await prisma.tb_orders.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends tb_ordersFindFirstOrThrowArgs>(args?: SelectSubset<T, tb_ordersFindFirstOrThrowArgs<ExtArgs>>): Prisma__tb_ordersClient<$Result.GetResult<Prisma.$tb_ordersPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Tb_orders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_ordersFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tb_orders
     * const tb_orders = await prisma.tb_orders.findMany()
     * 
     * // Get first 10 Tb_orders
     * const tb_orders = await prisma.tb_orders.findMany({ take: 10 })
     * 
     * // Only select the `order_id`
     * const tb_ordersWithOrder_idOnly = await prisma.tb_orders.findMany({ select: { order_id: true } })
     * 
     */
    findMany<T extends tb_ordersFindManyArgs>(args?: SelectSubset<T, tb_ordersFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tb_ordersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Tb_orders.
     * @param {tb_ordersCreateArgs} args - Arguments to create a Tb_orders.
     * @example
     * // Create one Tb_orders
     * const Tb_orders = await prisma.tb_orders.create({
     *   data: {
     *     // ... data to create a Tb_orders
     *   }
     * })
     * 
     */
    create<T extends tb_ordersCreateArgs>(args: SelectSubset<T, tb_ordersCreateArgs<ExtArgs>>): Prisma__tb_ordersClient<$Result.GetResult<Prisma.$tb_ordersPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Tb_orders.
     * @param {tb_ordersCreateManyArgs} args - Arguments to create many Tb_orders.
     * @example
     * // Create many Tb_orders
     * const tb_orders = await prisma.tb_orders.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends tb_ordersCreateManyArgs>(args?: SelectSubset<T, tb_ordersCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Tb_orders.
     * @param {tb_ordersDeleteArgs} args - Arguments to delete one Tb_orders.
     * @example
     * // Delete one Tb_orders
     * const Tb_orders = await prisma.tb_orders.delete({
     *   where: {
     *     // ... filter to delete one Tb_orders
     *   }
     * })
     * 
     */
    delete<T extends tb_ordersDeleteArgs>(args: SelectSubset<T, tb_ordersDeleteArgs<ExtArgs>>): Prisma__tb_ordersClient<$Result.GetResult<Prisma.$tb_ordersPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Tb_orders.
     * @param {tb_ordersUpdateArgs} args - Arguments to update one Tb_orders.
     * @example
     * // Update one Tb_orders
     * const tb_orders = await prisma.tb_orders.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends tb_ordersUpdateArgs>(args: SelectSubset<T, tb_ordersUpdateArgs<ExtArgs>>): Prisma__tb_ordersClient<$Result.GetResult<Prisma.$tb_ordersPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Tb_orders.
     * @param {tb_ordersDeleteManyArgs} args - Arguments to filter Tb_orders to delete.
     * @example
     * // Delete a few Tb_orders
     * const { count } = await prisma.tb_orders.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends tb_ordersDeleteManyArgs>(args?: SelectSubset<T, tb_ordersDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tb_orders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_ordersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tb_orders
     * const tb_orders = await prisma.tb_orders.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends tb_ordersUpdateManyArgs>(args: SelectSubset<T, tb_ordersUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Tb_orders.
     * @param {tb_ordersUpsertArgs} args - Arguments to update or create a Tb_orders.
     * @example
     * // Update or create a Tb_orders
     * const tb_orders = await prisma.tb_orders.upsert({
     *   create: {
     *     // ... data to create a Tb_orders
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tb_orders we want to update
     *   }
     * })
     */
    upsert<T extends tb_ordersUpsertArgs>(args: SelectSubset<T, tb_ordersUpsertArgs<ExtArgs>>): Prisma__tb_ordersClient<$Result.GetResult<Prisma.$tb_ordersPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Tb_orders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_ordersCountArgs} args - Arguments to filter Tb_orders to count.
     * @example
     * // Count the number of Tb_orders
     * const count = await prisma.tb_orders.count({
     *   where: {
     *     // ... the filter for the Tb_orders we want to count
     *   }
     * })
    **/
    count<T extends tb_ordersCountArgs>(
      args?: Subset<T, tb_ordersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Tb_ordersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tb_orders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Tb_ordersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Tb_ordersAggregateArgs>(args: Subset<T, Tb_ordersAggregateArgs>): Prisma.PrismaPromise<GetTb_ordersAggregateType<T>>

    /**
     * Group by Tb_orders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_ordersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends tb_ordersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: tb_ordersGroupByArgs['orderBy'] }
        : { orderBy?: tb_ordersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, tb_ordersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTb_ordersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the tb_orders model
   */
  readonly fields: tb_ordersFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for tb_orders.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__tb_ordersClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the tb_orders model
   */
  interface tb_ordersFieldRefs {
    readonly order_id: FieldRef<"tb_orders", 'Int'>
    readonly case_id: FieldRef<"tb_orders", 'Int'>
    readonly order_status: FieldRef<"tb_orders", 'Int'>
    readonly date: FieldRef<"tb_orders", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * tb_orders findUnique
   */
  export type tb_ordersFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_orders
     */
    select?: tb_ordersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_orders
     */
    omit?: tb_ordersOmit<ExtArgs> | null
    /**
     * Filter, which tb_orders to fetch.
     */
    where: tb_ordersWhereUniqueInput
  }

  /**
   * tb_orders findUniqueOrThrow
   */
  export type tb_ordersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_orders
     */
    select?: tb_ordersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_orders
     */
    omit?: tb_ordersOmit<ExtArgs> | null
    /**
     * Filter, which tb_orders to fetch.
     */
    where: tb_ordersWhereUniqueInput
  }

  /**
   * tb_orders findFirst
   */
  export type tb_ordersFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_orders
     */
    select?: tb_ordersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_orders
     */
    omit?: tb_ordersOmit<ExtArgs> | null
    /**
     * Filter, which tb_orders to fetch.
     */
    where?: tb_ordersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tb_orders to fetch.
     */
    orderBy?: tb_ordersOrderByWithRelationInput | tb_ordersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tb_orders.
     */
    cursor?: tb_ordersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tb_orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tb_orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tb_orders.
     */
    distinct?: Tb_ordersScalarFieldEnum | Tb_ordersScalarFieldEnum[]
  }

  /**
   * tb_orders findFirstOrThrow
   */
  export type tb_ordersFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_orders
     */
    select?: tb_ordersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_orders
     */
    omit?: tb_ordersOmit<ExtArgs> | null
    /**
     * Filter, which tb_orders to fetch.
     */
    where?: tb_ordersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tb_orders to fetch.
     */
    orderBy?: tb_ordersOrderByWithRelationInput | tb_ordersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tb_orders.
     */
    cursor?: tb_ordersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tb_orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tb_orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tb_orders.
     */
    distinct?: Tb_ordersScalarFieldEnum | Tb_ordersScalarFieldEnum[]
  }

  /**
   * tb_orders findMany
   */
  export type tb_ordersFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_orders
     */
    select?: tb_ordersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_orders
     */
    omit?: tb_ordersOmit<ExtArgs> | null
    /**
     * Filter, which tb_orders to fetch.
     */
    where?: tb_ordersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tb_orders to fetch.
     */
    orderBy?: tb_ordersOrderByWithRelationInput | tb_ordersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing tb_orders.
     */
    cursor?: tb_ordersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tb_orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tb_orders.
     */
    skip?: number
    distinct?: Tb_ordersScalarFieldEnum | Tb_ordersScalarFieldEnum[]
  }

  /**
   * tb_orders create
   */
  export type tb_ordersCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_orders
     */
    select?: tb_ordersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_orders
     */
    omit?: tb_ordersOmit<ExtArgs> | null
    /**
     * The data needed to create a tb_orders.
     */
    data: XOR<tb_ordersCreateInput, tb_ordersUncheckedCreateInput>
  }

  /**
   * tb_orders createMany
   */
  export type tb_ordersCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many tb_orders.
     */
    data: tb_ordersCreateManyInput | tb_ordersCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * tb_orders update
   */
  export type tb_ordersUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_orders
     */
    select?: tb_ordersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_orders
     */
    omit?: tb_ordersOmit<ExtArgs> | null
    /**
     * The data needed to update a tb_orders.
     */
    data: XOR<tb_ordersUpdateInput, tb_ordersUncheckedUpdateInput>
    /**
     * Choose, which tb_orders to update.
     */
    where: tb_ordersWhereUniqueInput
  }

  /**
   * tb_orders updateMany
   */
  export type tb_ordersUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update tb_orders.
     */
    data: XOR<tb_ordersUpdateManyMutationInput, tb_ordersUncheckedUpdateManyInput>
    /**
     * Filter which tb_orders to update
     */
    where?: tb_ordersWhereInput
    /**
     * Limit how many tb_orders to update.
     */
    limit?: number
  }

  /**
   * tb_orders upsert
   */
  export type tb_ordersUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_orders
     */
    select?: tb_ordersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_orders
     */
    omit?: tb_ordersOmit<ExtArgs> | null
    /**
     * The filter to search for the tb_orders to update in case it exists.
     */
    where: tb_ordersWhereUniqueInput
    /**
     * In case the tb_orders found by the `where` argument doesn't exist, create a new tb_orders with this data.
     */
    create: XOR<tb_ordersCreateInput, tb_ordersUncheckedCreateInput>
    /**
     * In case the tb_orders was found with the provided `where` argument, update it with this data.
     */
    update: XOR<tb_ordersUpdateInput, tb_ordersUncheckedUpdateInput>
  }

  /**
   * tb_orders delete
   */
  export type tb_ordersDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_orders
     */
    select?: tb_ordersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_orders
     */
    omit?: tb_ordersOmit<ExtArgs> | null
    /**
     * Filter which tb_orders to delete.
     */
    where: tb_ordersWhereUniqueInput
  }

  /**
   * tb_orders deleteMany
   */
  export type tb_ordersDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tb_orders to delete
     */
    where?: tb_ordersWhereInput
    /**
     * Limit how many tb_orders to delete.
     */
    limit?: number
  }

  /**
   * tb_orders without action
   */
  export type tb_ordersDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_orders
     */
    select?: tb_ordersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_orders
     */
    omit?: tb_ordersOmit<ExtArgs> | null
  }


  /**
   * Model tb_person
   */

  export type AggregateTb_person = {
    _count: Tb_personCountAggregateOutputType | null
    _avg: Tb_personAvgAggregateOutputType | null
    _sum: Tb_personSumAggregateOutputType | null
    _min: Tb_personMinAggregateOutputType | null
    _max: Tb_personMaxAggregateOutputType | null
  }

  export type Tb_personAvgAggregateOutputType = {
    personal_id: number | null
    case_id: number | null
    sex: number | null
    citizenship: number | null
    previous_residence: number | null
    etnicity: number | null
    religion: number | null
    preferred_traslator_sex: number | null
    preferred_interviewer_sex: number | null
    invalid: number | null
    pregnant: number | null
    seriously_ill: number | null
    trafficking_victim: number | null
    violence_victim: number | null
    illegal_border: number | null
    transfer_moj: number | null
    deport_prescurator: number | null
    prison: number | null
    role: number | null
    person_status: number | null
    ident: number | null
  }

  export type Tb_personSumAggregateOutputType = {
    personal_id: number | null
    case_id: number | null
    sex: number | null
    citizenship: number | null
    previous_residence: number | null
    etnicity: number | null
    religion: number | null
    preferred_traslator_sex: number | null
    preferred_interviewer_sex: number | null
    invalid: number | null
    pregnant: number | null
    seriously_ill: number | null
    trafficking_victim: number | null
    violence_victim: number | null
    illegal_border: number | null
    transfer_moj: number | null
    deport_prescurator: number | null
    prison: number | null
    role: number | null
    person_status: number | null
    ident: number | null
  }

  export type Tb_personMinAggregateOutputType = {
    personal_id: number | null
    case_id: number | null
    f_name_arm: string | null
    f_name_eng: string | null
    l_name_arm: string | null
    l_name_eng: string | null
    m_name_arm: string | null
    m_name_eng: string | null
    b_day: string | null
    b_month: string | null
    b_year: string | null
    sex: number | null
    citizenship: number | null
    previous_residence: number | null
    citizen_adr: string | null
    residence_adr: string | null
    departure_from_citizen: string | null
    departure_from_residence: string | null
    arrival_date: Date | null
    doc_num: string | null
    etnicity: number | null
    religion: number | null
    preferred_traslator_sex: number | null
    preferred_interviewer_sex: number | null
    invalid: number | null
    pregnant: number | null
    seriously_ill: number | null
    trafficking_victim: number | null
    violence_victim: number | null
    comment: string | null
    illegal_border: number | null
    transfer_moj: number | null
    deport_prescurator: number | null
    prison: number | null
    role: number | null
    image: string | null
    person_status: number | null
    ident: number | null
    pnum: string | null
    doc_type: string | null
    document_num: string | null
    doc_issued_date: Date | null
    doc_valid: Date | null
    doc_issued_by: string | null
    bpr_community: string | null
    bpr_bnakavayr: string | null
    bpr_street: string | null
    bpr_house: string | null
    bpr_aprt: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Tb_personMaxAggregateOutputType = {
    personal_id: number | null
    case_id: number | null
    f_name_arm: string | null
    f_name_eng: string | null
    l_name_arm: string | null
    l_name_eng: string | null
    m_name_arm: string | null
    m_name_eng: string | null
    b_day: string | null
    b_month: string | null
    b_year: string | null
    sex: number | null
    citizenship: number | null
    previous_residence: number | null
    citizen_adr: string | null
    residence_adr: string | null
    departure_from_citizen: string | null
    departure_from_residence: string | null
    arrival_date: Date | null
    doc_num: string | null
    etnicity: number | null
    religion: number | null
    preferred_traslator_sex: number | null
    preferred_interviewer_sex: number | null
    invalid: number | null
    pregnant: number | null
    seriously_ill: number | null
    trafficking_victim: number | null
    violence_victim: number | null
    comment: string | null
    illegal_border: number | null
    transfer_moj: number | null
    deport_prescurator: number | null
    prison: number | null
    role: number | null
    image: string | null
    person_status: number | null
    ident: number | null
    pnum: string | null
    doc_type: string | null
    document_num: string | null
    doc_issued_date: Date | null
    doc_valid: Date | null
    doc_issued_by: string | null
    bpr_community: string | null
    bpr_bnakavayr: string | null
    bpr_street: string | null
    bpr_house: string | null
    bpr_aprt: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Tb_personCountAggregateOutputType = {
    personal_id: number
    case_id: number
    f_name_arm: number
    f_name_eng: number
    l_name_arm: number
    l_name_eng: number
    m_name_arm: number
    m_name_eng: number
    b_day: number
    b_month: number
    b_year: number
    sex: number
    citizenship: number
    previous_residence: number
    citizen_adr: number
    residence_adr: number
    departure_from_citizen: number
    departure_from_residence: number
    arrival_date: number
    doc_num: number
    etnicity: number
    religion: number
    preferred_traslator_sex: number
    preferred_interviewer_sex: number
    invalid: number
    pregnant: number
    seriously_ill: number
    trafficking_victim: number
    violence_victim: number
    comment: number
    illegal_border: number
    transfer_moj: number
    deport_prescurator: number
    prison: number
    role: number
    image: number
    person_status: number
    ident: number
    pnum: number
    doc_type: number
    document_num: number
    doc_issued_date: number
    doc_valid: number
    doc_issued_by: number
    bpr_community: number
    bpr_bnakavayr: number
    bpr_street: number
    bpr_house: number
    bpr_aprt: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type Tb_personAvgAggregateInputType = {
    personal_id?: true
    case_id?: true
    sex?: true
    citizenship?: true
    previous_residence?: true
    etnicity?: true
    religion?: true
    preferred_traslator_sex?: true
    preferred_interviewer_sex?: true
    invalid?: true
    pregnant?: true
    seriously_ill?: true
    trafficking_victim?: true
    violence_victim?: true
    illegal_border?: true
    transfer_moj?: true
    deport_prescurator?: true
    prison?: true
    role?: true
    person_status?: true
    ident?: true
  }

  export type Tb_personSumAggregateInputType = {
    personal_id?: true
    case_id?: true
    sex?: true
    citizenship?: true
    previous_residence?: true
    etnicity?: true
    religion?: true
    preferred_traslator_sex?: true
    preferred_interviewer_sex?: true
    invalid?: true
    pregnant?: true
    seriously_ill?: true
    trafficking_victim?: true
    violence_victim?: true
    illegal_border?: true
    transfer_moj?: true
    deport_prescurator?: true
    prison?: true
    role?: true
    person_status?: true
    ident?: true
  }

  export type Tb_personMinAggregateInputType = {
    personal_id?: true
    case_id?: true
    f_name_arm?: true
    f_name_eng?: true
    l_name_arm?: true
    l_name_eng?: true
    m_name_arm?: true
    m_name_eng?: true
    b_day?: true
    b_month?: true
    b_year?: true
    sex?: true
    citizenship?: true
    previous_residence?: true
    citizen_adr?: true
    residence_adr?: true
    departure_from_citizen?: true
    departure_from_residence?: true
    arrival_date?: true
    doc_num?: true
    etnicity?: true
    religion?: true
    preferred_traslator_sex?: true
    preferred_interviewer_sex?: true
    invalid?: true
    pregnant?: true
    seriously_ill?: true
    trafficking_victim?: true
    violence_victim?: true
    comment?: true
    illegal_border?: true
    transfer_moj?: true
    deport_prescurator?: true
    prison?: true
    role?: true
    image?: true
    person_status?: true
    ident?: true
    pnum?: true
    doc_type?: true
    document_num?: true
    doc_issued_date?: true
    doc_valid?: true
    doc_issued_by?: true
    bpr_community?: true
    bpr_bnakavayr?: true
    bpr_street?: true
    bpr_house?: true
    bpr_aprt?: true
    created_at?: true
    updated_at?: true
  }

  export type Tb_personMaxAggregateInputType = {
    personal_id?: true
    case_id?: true
    f_name_arm?: true
    f_name_eng?: true
    l_name_arm?: true
    l_name_eng?: true
    m_name_arm?: true
    m_name_eng?: true
    b_day?: true
    b_month?: true
    b_year?: true
    sex?: true
    citizenship?: true
    previous_residence?: true
    citizen_adr?: true
    residence_adr?: true
    departure_from_citizen?: true
    departure_from_residence?: true
    arrival_date?: true
    doc_num?: true
    etnicity?: true
    religion?: true
    preferred_traslator_sex?: true
    preferred_interviewer_sex?: true
    invalid?: true
    pregnant?: true
    seriously_ill?: true
    trafficking_victim?: true
    violence_victim?: true
    comment?: true
    illegal_border?: true
    transfer_moj?: true
    deport_prescurator?: true
    prison?: true
    role?: true
    image?: true
    person_status?: true
    ident?: true
    pnum?: true
    doc_type?: true
    document_num?: true
    doc_issued_date?: true
    doc_valid?: true
    doc_issued_by?: true
    bpr_community?: true
    bpr_bnakavayr?: true
    bpr_street?: true
    bpr_house?: true
    bpr_aprt?: true
    created_at?: true
    updated_at?: true
  }

  export type Tb_personCountAggregateInputType = {
    personal_id?: true
    case_id?: true
    f_name_arm?: true
    f_name_eng?: true
    l_name_arm?: true
    l_name_eng?: true
    m_name_arm?: true
    m_name_eng?: true
    b_day?: true
    b_month?: true
    b_year?: true
    sex?: true
    citizenship?: true
    previous_residence?: true
    citizen_adr?: true
    residence_adr?: true
    departure_from_citizen?: true
    departure_from_residence?: true
    arrival_date?: true
    doc_num?: true
    etnicity?: true
    religion?: true
    preferred_traslator_sex?: true
    preferred_interviewer_sex?: true
    invalid?: true
    pregnant?: true
    seriously_ill?: true
    trafficking_victim?: true
    violence_victim?: true
    comment?: true
    illegal_border?: true
    transfer_moj?: true
    deport_prescurator?: true
    prison?: true
    role?: true
    image?: true
    person_status?: true
    ident?: true
    pnum?: true
    doc_type?: true
    document_num?: true
    doc_issued_date?: true
    doc_valid?: true
    doc_issued_by?: true
    bpr_community?: true
    bpr_bnakavayr?: true
    bpr_street?: true
    bpr_house?: true
    bpr_aprt?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type Tb_personAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tb_person to aggregate.
     */
    where?: tb_personWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tb_people to fetch.
     */
    orderBy?: tb_personOrderByWithRelationInput | tb_personOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: tb_personWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tb_people from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tb_people.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned tb_people
    **/
    _count?: true | Tb_personCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Tb_personAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Tb_personSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Tb_personMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Tb_personMaxAggregateInputType
  }

  export type GetTb_personAggregateType<T extends Tb_personAggregateArgs> = {
        [P in keyof T & keyof AggregateTb_person]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTb_person[P]>
      : GetScalarType<T[P], AggregateTb_person[P]>
  }




  export type tb_personGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: tb_personWhereInput
    orderBy?: tb_personOrderByWithAggregationInput | tb_personOrderByWithAggregationInput[]
    by: Tb_personScalarFieldEnum[] | Tb_personScalarFieldEnum
    having?: tb_personScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Tb_personCountAggregateInputType | true
    _avg?: Tb_personAvgAggregateInputType
    _sum?: Tb_personSumAggregateInputType
    _min?: Tb_personMinAggregateInputType
    _max?: Tb_personMaxAggregateInputType
  }

  export type Tb_personGroupByOutputType = {
    personal_id: number
    case_id: number
    f_name_arm: string
    f_name_eng: string
    l_name_arm: string
    l_name_eng: string
    m_name_arm: string | null
    m_name_eng: string | null
    b_day: string
    b_month: string
    b_year: string
    sex: number
    citizenship: number
    previous_residence: number | null
    citizen_adr: string | null
    residence_adr: string | null
    departure_from_citizen: string | null
    departure_from_residence: string | null
    arrival_date: Date | null
    doc_num: string | null
    etnicity: number | null
    religion: number | null
    preferred_traslator_sex: number
    preferred_interviewer_sex: number
    invalid: number
    pregnant: number
    seriously_ill: number
    trafficking_victim: number
    violence_victim: number
    comment: string | null
    illegal_border: number
    transfer_moj: number
    deport_prescurator: number
    prison: number | null
    role: number
    image: string | null
    person_status: number
    ident: number
    pnum: string | null
    doc_type: string | null
    document_num: string | null
    doc_issued_date: Date | null
    doc_valid: Date | null
    doc_issued_by: string | null
    bpr_community: string | null
    bpr_bnakavayr: string | null
    bpr_street: string | null
    bpr_house: string | null
    bpr_aprt: string | null
    created_at: Date
    updated_at: Date
    _count: Tb_personCountAggregateOutputType | null
    _avg: Tb_personAvgAggregateOutputType | null
    _sum: Tb_personSumAggregateOutputType | null
    _min: Tb_personMinAggregateOutputType | null
    _max: Tb_personMaxAggregateOutputType | null
  }

  type GetTb_personGroupByPayload<T extends tb_personGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Tb_personGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Tb_personGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Tb_personGroupByOutputType[P]>
            : GetScalarType<T[P], Tb_personGroupByOutputType[P]>
        }
      >
    >


  export type tb_personSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    personal_id?: boolean
    case_id?: boolean
    f_name_arm?: boolean
    f_name_eng?: boolean
    l_name_arm?: boolean
    l_name_eng?: boolean
    m_name_arm?: boolean
    m_name_eng?: boolean
    b_day?: boolean
    b_month?: boolean
    b_year?: boolean
    sex?: boolean
    citizenship?: boolean
    previous_residence?: boolean
    citizen_adr?: boolean
    residence_adr?: boolean
    departure_from_citizen?: boolean
    departure_from_residence?: boolean
    arrival_date?: boolean
    doc_num?: boolean
    etnicity?: boolean
    religion?: boolean
    preferred_traslator_sex?: boolean
    preferred_interviewer_sex?: boolean
    invalid?: boolean
    pregnant?: boolean
    seriously_ill?: boolean
    trafficking_victim?: boolean
    violence_victim?: boolean
    comment?: boolean
    illegal_border?: boolean
    transfer_moj?: boolean
    deport_prescurator?: boolean
    prison?: boolean
    role?: boolean
    image?: boolean
    person_status?: boolean
    ident?: boolean
    pnum?: boolean
    doc_type?: boolean
    document_num?: boolean
    doc_issued_date?: boolean
    doc_valid?: boolean
    doc_issued_by?: boolean
    bpr_community?: boolean
    bpr_bnakavayr?: boolean
    bpr_street?: boolean
    bpr_house?: boolean
    bpr_aprt?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["tb_person"]>



  export type tb_personSelectScalar = {
    personal_id?: boolean
    case_id?: boolean
    f_name_arm?: boolean
    f_name_eng?: boolean
    l_name_arm?: boolean
    l_name_eng?: boolean
    m_name_arm?: boolean
    m_name_eng?: boolean
    b_day?: boolean
    b_month?: boolean
    b_year?: boolean
    sex?: boolean
    citizenship?: boolean
    previous_residence?: boolean
    citizen_adr?: boolean
    residence_adr?: boolean
    departure_from_citizen?: boolean
    departure_from_residence?: boolean
    arrival_date?: boolean
    doc_num?: boolean
    etnicity?: boolean
    religion?: boolean
    preferred_traslator_sex?: boolean
    preferred_interviewer_sex?: boolean
    invalid?: boolean
    pregnant?: boolean
    seriously_ill?: boolean
    trafficking_victim?: boolean
    violence_victim?: boolean
    comment?: boolean
    illegal_border?: boolean
    transfer_moj?: boolean
    deport_prescurator?: boolean
    prison?: boolean
    role?: boolean
    image?: boolean
    person_status?: boolean
    ident?: boolean
    pnum?: boolean
    doc_type?: boolean
    document_num?: boolean
    doc_issued_date?: boolean
    doc_valid?: boolean
    doc_issued_by?: boolean
    bpr_community?: boolean
    bpr_bnakavayr?: boolean
    bpr_street?: boolean
    bpr_house?: boolean
    bpr_aprt?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type tb_personOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"personal_id" | "case_id" | "f_name_arm" | "f_name_eng" | "l_name_arm" | "l_name_eng" | "m_name_arm" | "m_name_eng" | "b_day" | "b_month" | "b_year" | "sex" | "citizenship" | "previous_residence" | "citizen_adr" | "residence_adr" | "departure_from_citizen" | "departure_from_residence" | "arrival_date" | "doc_num" | "etnicity" | "religion" | "preferred_traslator_sex" | "preferred_interviewer_sex" | "invalid" | "pregnant" | "seriously_ill" | "trafficking_victim" | "violence_victim" | "comment" | "illegal_border" | "transfer_moj" | "deport_prescurator" | "prison" | "role" | "image" | "person_status" | "ident" | "pnum" | "doc_type" | "document_num" | "doc_issued_date" | "doc_valid" | "doc_issued_by" | "bpr_community" | "bpr_bnakavayr" | "bpr_street" | "bpr_house" | "bpr_aprt" | "created_at" | "updated_at", ExtArgs["result"]["tb_person"]>

  export type $tb_personPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "tb_person"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      personal_id: number
      case_id: number
      f_name_arm: string
      f_name_eng: string
      l_name_arm: string
      l_name_eng: string
      m_name_arm: string | null
      m_name_eng: string | null
      b_day: string
      b_month: string
      b_year: string
      sex: number
      citizenship: number
      previous_residence: number | null
      citizen_adr: string | null
      residence_adr: string | null
      departure_from_citizen: string | null
      departure_from_residence: string | null
      arrival_date: Date | null
      doc_num: string | null
      etnicity: number | null
      religion: number | null
      preferred_traslator_sex: number
      preferred_interviewer_sex: number
      invalid: number
      pregnant: number
      seriously_ill: number
      trafficking_victim: number
      violence_victim: number
      comment: string | null
      illegal_border: number
      transfer_moj: number
      deport_prescurator: number
      prison: number | null
      role: number
      image: string | null
      person_status: number
      ident: number
      pnum: string | null
      doc_type: string | null
      document_num: string | null
      doc_issued_date: Date | null
      doc_valid: Date | null
      doc_issued_by: string | null
      bpr_community: string | null
      bpr_bnakavayr: string | null
      bpr_street: string | null
      bpr_house: string | null
      bpr_aprt: string | null
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["tb_person"]>
    composites: {}
  }

  type tb_personGetPayload<S extends boolean | null | undefined | tb_personDefaultArgs> = $Result.GetResult<Prisma.$tb_personPayload, S>

  type tb_personCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<tb_personFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Tb_personCountAggregateInputType | true
    }

  export interface tb_personDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['tb_person'], meta: { name: 'tb_person' } }
    /**
     * Find zero or one Tb_person that matches the filter.
     * @param {tb_personFindUniqueArgs} args - Arguments to find a Tb_person
     * @example
     * // Get one Tb_person
     * const tb_person = await prisma.tb_person.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends tb_personFindUniqueArgs>(args: SelectSubset<T, tb_personFindUniqueArgs<ExtArgs>>): Prisma__tb_personClient<$Result.GetResult<Prisma.$tb_personPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Tb_person that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {tb_personFindUniqueOrThrowArgs} args - Arguments to find a Tb_person
     * @example
     * // Get one Tb_person
     * const tb_person = await prisma.tb_person.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends tb_personFindUniqueOrThrowArgs>(args: SelectSubset<T, tb_personFindUniqueOrThrowArgs<ExtArgs>>): Prisma__tb_personClient<$Result.GetResult<Prisma.$tb_personPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tb_person that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_personFindFirstArgs} args - Arguments to find a Tb_person
     * @example
     * // Get one Tb_person
     * const tb_person = await prisma.tb_person.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends tb_personFindFirstArgs>(args?: SelectSubset<T, tb_personFindFirstArgs<ExtArgs>>): Prisma__tb_personClient<$Result.GetResult<Prisma.$tb_personPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tb_person that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_personFindFirstOrThrowArgs} args - Arguments to find a Tb_person
     * @example
     * // Get one Tb_person
     * const tb_person = await prisma.tb_person.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends tb_personFindFirstOrThrowArgs>(args?: SelectSubset<T, tb_personFindFirstOrThrowArgs<ExtArgs>>): Prisma__tb_personClient<$Result.GetResult<Prisma.$tb_personPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Tb_people that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_personFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tb_people
     * const tb_people = await prisma.tb_person.findMany()
     * 
     * // Get first 10 Tb_people
     * const tb_people = await prisma.tb_person.findMany({ take: 10 })
     * 
     * // Only select the `personal_id`
     * const tb_personWithPersonal_idOnly = await prisma.tb_person.findMany({ select: { personal_id: true } })
     * 
     */
    findMany<T extends tb_personFindManyArgs>(args?: SelectSubset<T, tb_personFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tb_personPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Tb_person.
     * @param {tb_personCreateArgs} args - Arguments to create a Tb_person.
     * @example
     * // Create one Tb_person
     * const Tb_person = await prisma.tb_person.create({
     *   data: {
     *     // ... data to create a Tb_person
     *   }
     * })
     * 
     */
    create<T extends tb_personCreateArgs>(args: SelectSubset<T, tb_personCreateArgs<ExtArgs>>): Prisma__tb_personClient<$Result.GetResult<Prisma.$tb_personPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Tb_people.
     * @param {tb_personCreateManyArgs} args - Arguments to create many Tb_people.
     * @example
     * // Create many Tb_people
     * const tb_person = await prisma.tb_person.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends tb_personCreateManyArgs>(args?: SelectSubset<T, tb_personCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Tb_person.
     * @param {tb_personDeleteArgs} args - Arguments to delete one Tb_person.
     * @example
     * // Delete one Tb_person
     * const Tb_person = await prisma.tb_person.delete({
     *   where: {
     *     // ... filter to delete one Tb_person
     *   }
     * })
     * 
     */
    delete<T extends tb_personDeleteArgs>(args: SelectSubset<T, tb_personDeleteArgs<ExtArgs>>): Prisma__tb_personClient<$Result.GetResult<Prisma.$tb_personPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Tb_person.
     * @param {tb_personUpdateArgs} args - Arguments to update one Tb_person.
     * @example
     * // Update one Tb_person
     * const tb_person = await prisma.tb_person.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends tb_personUpdateArgs>(args: SelectSubset<T, tb_personUpdateArgs<ExtArgs>>): Prisma__tb_personClient<$Result.GetResult<Prisma.$tb_personPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Tb_people.
     * @param {tb_personDeleteManyArgs} args - Arguments to filter Tb_people to delete.
     * @example
     * // Delete a few Tb_people
     * const { count } = await prisma.tb_person.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends tb_personDeleteManyArgs>(args?: SelectSubset<T, tb_personDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tb_people.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_personUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tb_people
     * const tb_person = await prisma.tb_person.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends tb_personUpdateManyArgs>(args: SelectSubset<T, tb_personUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Tb_person.
     * @param {tb_personUpsertArgs} args - Arguments to update or create a Tb_person.
     * @example
     * // Update or create a Tb_person
     * const tb_person = await prisma.tb_person.upsert({
     *   create: {
     *     // ... data to create a Tb_person
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tb_person we want to update
     *   }
     * })
     */
    upsert<T extends tb_personUpsertArgs>(args: SelectSubset<T, tb_personUpsertArgs<ExtArgs>>): Prisma__tb_personClient<$Result.GetResult<Prisma.$tb_personPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Tb_people.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_personCountArgs} args - Arguments to filter Tb_people to count.
     * @example
     * // Count the number of Tb_people
     * const count = await prisma.tb_person.count({
     *   where: {
     *     // ... the filter for the Tb_people we want to count
     *   }
     * })
    **/
    count<T extends tb_personCountArgs>(
      args?: Subset<T, tb_personCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Tb_personCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tb_person.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Tb_personAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Tb_personAggregateArgs>(args: Subset<T, Tb_personAggregateArgs>): Prisma.PrismaPromise<GetTb_personAggregateType<T>>

    /**
     * Group by Tb_person.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_personGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends tb_personGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: tb_personGroupByArgs['orderBy'] }
        : { orderBy?: tb_personGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, tb_personGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTb_personGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the tb_person model
   */
  readonly fields: tb_personFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for tb_person.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__tb_personClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the tb_person model
   */
  interface tb_personFieldRefs {
    readonly personal_id: FieldRef<"tb_person", 'Int'>
    readonly case_id: FieldRef<"tb_person", 'Int'>
    readonly f_name_arm: FieldRef<"tb_person", 'String'>
    readonly f_name_eng: FieldRef<"tb_person", 'String'>
    readonly l_name_arm: FieldRef<"tb_person", 'String'>
    readonly l_name_eng: FieldRef<"tb_person", 'String'>
    readonly m_name_arm: FieldRef<"tb_person", 'String'>
    readonly m_name_eng: FieldRef<"tb_person", 'String'>
    readonly b_day: FieldRef<"tb_person", 'String'>
    readonly b_month: FieldRef<"tb_person", 'String'>
    readonly b_year: FieldRef<"tb_person", 'String'>
    readonly sex: FieldRef<"tb_person", 'Int'>
    readonly citizenship: FieldRef<"tb_person", 'Int'>
    readonly previous_residence: FieldRef<"tb_person", 'Int'>
    readonly citizen_adr: FieldRef<"tb_person", 'String'>
    readonly residence_adr: FieldRef<"tb_person", 'String'>
    readonly departure_from_citizen: FieldRef<"tb_person", 'String'>
    readonly departure_from_residence: FieldRef<"tb_person", 'String'>
    readonly arrival_date: FieldRef<"tb_person", 'DateTime'>
    readonly doc_num: FieldRef<"tb_person", 'String'>
    readonly etnicity: FieldRef<"tb_person", 'Int'>
    readonly religion: FieldRef<"tb_person", 'Int'>
    readonly preferred_traslator_sex: FieldRef<"tb_person", 'Int'>
    readonly preferred_interviewer_sex: FieldRef<"tb_person", 'Int'>
    readonly invalid: FieldRef<"tb_person", 'Int'>
    readonly pregnant: FieldRef<"tb_person", 'Int'>
    readonly seriously_ill: FieldRef<"tb_person", 'Int'>
    readonly trafficking_victim: FieldRef<"tb_person", 'Int'>
    readonly violence_victim: FieldRef<"tb_person", 'Int'>
    readonly comment: FieldRef<"tb_person", 'String'>
    readonly illegal_border: FieldRef<"tb_person", 'Int'>
    readonly transfer_moj: FieldRef<"tb_person", 'Int'>
    readonly deport_prescurator: FieldRef<"tb_person", 'Int'>
    readonly prison: FieldRef<"tb_person", 'Int'>
    readonly role: FieldRef<"tb_person", 'Int'>
    readonly image: FieldRef<"tb_person", 'String'>
    readonly person_status: FieldRef<"tb_person", 'Int'>
    readonly ident: FieldRef<"tb_person", 'Int'>
    readonly pnum: FieldRef<"tb_person", 'String'>
    readonly doc_type: FieldRef<"tb_person", 'String'>
    readonly document_num: FieldRef<"tb_person", 'String'>
    readonly doc_issued_date: FieldRef<"tb_person", 'DateTime'>
    readonly doc_valid: FieldRef<"tb_person", 'DateTime'>
    readonly doc_issued_by: FieldRef<"tb_person", 'String'>
    readonly bpr_community: FieldRef<"tb_person", 'String'>
    readonly bpr_bnakavayr: FieldRef<"tb_person", 'String'>
    readonly bpr_street: FieldRef<"tb_person", 'String'>
    readonly bpr_house: FieldRef<"tb_person", 'String'>
    readonly bpr_aprt: FieldRef<"tb_person", 'String'>
    readonly created_at: FieldRef<"tb_person", 'DateTime'>
    readonly updated_at: FieldRef<"tb_person", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * tb_person findUnique
   */
  export type tb_personFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_person
     */
    select?: tb_personSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_person
     */
    omit?: tb_personOmit<ExtArgs> | null
    /**
     * Filter, which tb_person to fetch.
     */
    where: tb_personWhereUniqueInput
  }

  /**
   * tb_person findUniqueOrThrow
   */
  export type tb_personFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_person
     */
    select?: tb_personSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_person
     */
    omit?: tb_personOmit<ExtArgs> | null
    /**
     * Filter, which tb_person to fetch.
     */
    where: tb_personWhereUniqueInput
  }

  /**
   * tb_person findFirst
   */
  export type tb_personFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_person
     */
    select?: tb_personSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_person
     */
    omit?: tb_personOmit<ExtArgs> | null
    /**
     * Filter, which tb_person to fetch.
     */
    where?: tb_personWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tb_people to fetch.
     */
    orderBy?: tb_personOrderByWithRelationInput | tb_personOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tb_people.
     */
    cursor?: tb_personWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tb_people from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tb_people.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tb_people.
     */
    distinct?: Tb_personScalarFieldEnum | Tb_personScalarFieldEnum[]
  }

  /**
   * tb_person findFirstOrThrow
   */
  export type tb_personFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_person
     */
    select?: tb_personSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_person
     */
    omit?: tb_personOmit<ExtArgs> | null
    /**
     * Filter, which tb_person to fetch.
     */
    where?: tb_personWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tb_people to fetch.
     */
    orderBy?: tb_personOrderByWithRelationInput | tb_personOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tb_people.
     */
    cursor?: tb_personWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tb_people from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tb_people.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tb_people.
     */
    distinct?: Tb_personScalarFieldEnum | Tb_personScalarFieldEnum[]
  }

  /**
   * tb_person findMany
   */
  export type tb_personFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_person
     */
    select?: tb_personSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_person
     */
    omit?: tb_personOmit<ExtArgs> | null
    /**
     * Filter, which tb_people to fetch.
     */
    where?: tb_personWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tb_people to fetch.
     */
    orderBy?: tb_personOrderByWithRelationInput | tb_personOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing tb_people.
     */
    cursor?: tb_personWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tb_people from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tb_people.
     */
    skip?: number
    distinct?: Tb_personScalarFieldEnum | Tb_personScalarFieldEnum[]
  }

  /**
   * tb_person create
   */
  export type tb_personCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_person
     */
    select?: tb_personSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_person
     */
    omit?: tb_personOmit<ExtArgs> | null
    /**
     * The data needed to create a tb_person.
     */
    data: XOR<tb_personCreateInput, tb_personUncheckedCreateInput>
  }

  /**
   * tb_person createMany
   */
  export type tb_personCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many tb_people.
     */
    data: tb_personCreateManyInput | tb_personCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * tb_person update
   */
  export type tb_personUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_person
     */
    select?: tb_personSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_person
     */
    omit?: tb_personOmit<ExtArgs> | null
    /**
     * The data needed to update a tb_person.
     */
    data: XOR<tb_personUpdateInput, tb_personUncheckedUpdateInput>
    /**
     * Choose, which tb_person to update.
     */
    where: tb_personWhereUniqueInput
  }

  /**
   * tb_person updateMany
   */
  export type tb_personUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update tb_people.
     */
    data: XOR<tb_personUpdateManyMutationInput, tb_personUncheckedUpdateManyInput>
    /**
     * Filter which tb_people to update
     */
    where?: tb_personWhereInput
    /**
     * Limit how many tb_people to update.
     */
    limit?: number
  }

  /**
   * tb_person upsert
   */
  export type tb_personUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_person
     */
    select?: tb_personSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_person
     */
    omit?: tb_personOmit<ExtArgs> | null
    /**
     * The filter to search for the tb_person to update in case it exists.
     */
    where: tb_personWhereUniqueInput
    /**
     * In case the tb_person found by the `where` argument doesn't exist, create a new tb_person with this data.
     */
    create: XOR<tb_personCreateInput, tb_personUncheckedCreateInput>
    /**
     * In case the tb_person was found with the provided `where` argument, update it with this data.
     */
    update: XOR<tb_personUpdateInput, tb_personUncheckedUpdateInput>
  }

  /**
   * tb_person delete
   */
  export type tb_personDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_person
     */
    select?: tb_personSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_person
     */
    omit?: tb_personOmit<ExtArgs> | null
    /**
     * Filter which tb_person to delete.
     */
    where: tb_personWhereUniqueInput
  }

  /**
   * tb_person deleteMany
   */
  export type tb_personDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tb_people to delete
     */
    where?: tb_personWhereInput
    /**
     * Limit how many tb_people to delete.
     */
    limit?: number
  }

  /**
   * tb_person without action
   */
  export type tb_personDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_person
     */
    select?: tb_personSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_person
     */
    omit?: tb_personOmit<ExtArgs> | null
  }


  /**
   * Model tb_person_status
   */

  export type AggregateTb_person_status = {
    _count: Tb_person_statusCountAggregateOutputType | null
    _avg: Tb_person_statusAvgAggregateOutputType | null
    _sum: Tb_person_statusSumAggregateOutputType | null
    _min: Tb_person_statusMinAggregateOutputType | null
    _max: Tb_person_statusMaxAggregateOutputType | null
  }

  export type Tb_person_statusAvgAggregateOutputType = {
    person_status_id: number | null
  }

  export type Tb_person_statusSumAggregateOutputType = {
    person_status_id: number | null
  }

  export type Tb_person_statusMinAggregateOutputType = {
    person_status_id: number | null
    person_status: string | null
    person_status_eng: string | null
  }

  export type Tb_person_statusMaxAggregateOutputType = {
    person_status_id: number | null
    person_status: string | null
    person_status_eng: string | null
  }

  export type Tb_person_statusCountAggregateOutputType = {
    person_status_id: number
    person_status: number
    person_status_eng: number
    _all: number
  }


  export type Tb_person_statusAvgAggregateInputType = {
    person_status_id?: true
  }

  export type Tb_person_statusSumAggregateInputType = {
    person_status_id?: true
  }

  export type Tb_person_statusMinAggregateInputType = {
    person_status_id?: true
    person_status?: true
    person_status_eng?: true
  }

  export type Tb_person_statusMaxAggregateInputType = {
    person_status_id?: true
    person_status?: true
    person_status_eng?: true
  }

  export type Tb_person_statusCountAggregateInputType = {
    person_status_id?: true
    person_status?: true
    person_status_eng?: true
    _all?: true
  }

  export type Tb_person_statusAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tb_person_status to aggregate.
     */
    where?: tb_person_statusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tb_person_statuses to fetch.
     */
    orderBy?: tb_person_statusOrderByWithRelationInput | tb_person_statusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: tb_person_statusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tb_person_statuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tb_person_statuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned tb_person_statuses
    **/
    _count?: true | Tb_person_statusCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Tb_person_statusAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Tb_person_statusSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Tb_person_statusMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Tb_person_statusMaxAggregateInputType
  }

  export type GetTb_person_statusAggregateType<T extends Tb_person_statusAggregateArgs> = {
        [P in keyof T & keyof AggregateTb_person_status]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTb_person_status[P]>
      : GetScalarType<T[P], AggregateTb_person_status[P]>
  }




  export type tb_person_statusGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: tb_person_statusWhereInput
    orderBy?: tb_person_statusOrderByWithAggregationInput | tb_person_statusOrderByWithAggregationInput[]
    by: Tb_person_statusScalarFieldEnum[] | Tb_person_statusScalarFieldEnum
    having?: tb_person_statusScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Tb_person_statusCountAggregateInputType | true
    _avg?: Tb_person_statusAvgAggregateInputType
    _sum?: Tb_person_statusSumAggregateInputType
    _min?: Tb_person_statusMinAggregateInputType
    _max?: Tb_person_statusMaxAggregateInputType
  }

  export type Tb_person_statusGroupByOutputType = {
    person_status_id: number
    person_status: string
    person_status_eng: string | null
    _count: Tb_person_statusCountAggregateOutputType | null
    _avg: Tb_person_statusAvgAggregateOutputType | null
    _sum: Tb_person_statusSumAggregateOutputType | null
    _min: Tb_person_statusMinAggregateOutputType | null
    _max: Tb_person_statusMaxAggregateOutputType | null
  }

  type GetTb_person_statusGroupByPayload<T extends tb_person_statusGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Tb_person_statusGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Tb_person_statusGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Tb_person_statusGroupByOutputType[P]>
            : GetScalarType<T[P], Tb_person_statusGroupByOutputType[P]>
        }
      >
    >


  export type tb_person_statusSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    person_status_id?: boolean
    person_status?: boolean
    person_status_eng?: boolean
  }, ExtArgs["result"]["tb_person_status"]>



  export type tb_person_statusSelectScalar = {
    person_status_id?: boolean
    person_status?: boolean
    person_status_eng?: boolean
  }

  export type tb_person_statusOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"person_status_id" | "person_status" | "person_status_eng", ExtArgs["result"]["tb_person_status"]>

  export type $tb_person_statusPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "tb_person_status"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      person_status_id: number
      person_status: string
      person_status_eng: string | null
    }, ExtArgs["result"]["tb_person_status"]>
    composites: {}
  }

  type tb_person_statusGetPayload<S extends boolean | null | undefined | tb_person_statusDefaultArgs> = $Result.GetResult<Prisma.$tb_person_statusPayload, S>

  type tb_person_statusCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<tb_person_statusFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Tb_person_statusCountAggregateInputType | true
    }

  export interface tb_person_statusDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['tb_person_status'], meta: { name: 'tb_person_status' } }
    /**
     * Find zero or one Tb_person_status that matches the filter.
     * @param {tb_person_statusFindUniqueArgs} args - Arguments to find a Tb_person_status
     * @example
     * // Get one Tb_person_status
     * const tb_person_status = await prisma.tb_person_status.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends tb_person_statusFindUniqueArgs>(args: SelectSubset<T, tb_person_statusFindUniqueArgs<ExtArgs>>): Prisma__tb_person_statusClient<$Result.GetResult<Prisma.$tb_person_statusPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Tb_person_status that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {tb_person_statusFindUniqueOrThrowArgs} args - Arguments to find a Tb_person_status
     * @example
     * // Get one Tb_person_status
     * const tb_person_status = await prisma.tb_person_status.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends tb_person_statusFindUniqueOrThrowArgs>(args: SelectSubset<T, tb_person_statusFindUniqueOrThrowArgs<ExtArgs>>): Prisma__tb_person_statusClient<$Result.GetResult<Prisma.$tb_person_statusPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tb_person_status that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_person_statusFindFirstArgs} args - Arguments to find a Tb_person_status
     * @example
     * // Get one Tb_person_status
     * const tb_person_status = await prisma.tb_person_status.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends tb_person_statusFindFirstArgs>(args?: SelectSubset<T, tb_person_statusFindFirstArgs<ExtArgs>>): Prisma__tb_person_statusClient<$Result.GetResult<Prisma.$tb_person_statusPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tb_person_status that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_person_statusFindFirstOrThrowArgs} args - Arguments to find a Tb_person_status
     * @example
     * // Get one Tb_person_status
     * const tb_person_status = await prisma.tb_person_status.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends tb_person_statusFindFirstOrThrowArgs>(args?: SelectSubset<T, tb_person_statusFindFirstOrThrowArgs<ExtArgs>>): Prisma__tb_person_statusClient<$Result.GetResult<Prisma.$tb_person_statusPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Tb_person_statuses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_person_statusFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tb_person_statuses
     * const tb_person_statuses = await prisma.tb_person_status.findMany()
     * 
     * // Get first 10 Tb_person_statuses
     * const tb_person_statuses = await prisma.tb_person_status.findMany({ take: 10 })
     * 
     * // Only select the `person_status_id`
     * const tb_person_statusWithPerson_status_idOnly = await prisma.tb_person_status.findMany({ select: { person_status_id: true } })
     * 
     */
    findMany<T extends tb_person_statusFindManyArgs>(args?: SelectSubset<T, tb_person_statusFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tb_person_statusPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Tb_person_status.
     * @param {tb_person_statusCreateArgs} args - Arguments to create a Tb_person_status.
     * @example
     * // Create one Tb_person_status
     * const Tb_person_status = await prisma.tb_person_status.create({
     *   data: {
     *     // ... data to create a Tb_person_status
     *   }
     * })
     * 
     */
    create<T extends tb_person_statusCreateArgs>(args: SelectSubset<T, tb_person_statusCreateArgs<ExtArgs>>): Prisma__tb_person_statusClient<$Result.GetResult<Prisma.$tb_person_statusPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Tb_person_statuses.
     * @param {tb_person_statusCreateManyArgs} args - Arguments to create many Tb_person_statuses.
     * @example
     * // Create many Tb_person_statuses
     * const tb_person_status = await prisma.tb_person_status.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends tb_person_statusCreateManyArgs>(args?: SelectSubset<T, tb_person_statusCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Tb_person_status.
     * @param {tb_person_statusDeleteArgs} args - Arguments to delete one Tb_person_status.
     * @example
     * // Delete one Tb_person_status
     * const Tb_person_status = await prisma.tb_person_status.delete({
     *   where: {
     *     // ... filter to delete one Tb_person_status
     *   }
     * })
     * 
     */
    delete<T extends tb_person_statusDeleteArgs>(args: SelectSubset<T, tb_person_statusDeleteArgs<ExtArgs>>): Prisma__tb_person_statusClient<$Result.GetResult<Prisma.$tb_person_statusPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Tb_person_status.
     * @param {tb_person_statusUpdateArgs} args - Arguments to update one Tb_person_status.
     * @example
     * // Update one Tb_person_status
     * const tb_person_status = await prisma.tb_person_status.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends tb_person_statusUpdateArgs>(args: SelectSubset<T, tb_person_statusUpdateArgs<ExtArgs>>): Prisma__tb_person_statusClient<$Result.GetResult<Prisma.$tb_person_statusPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Tb_person_statuses.
     * @param {tb_person_statusDeleteManyArgs} args - Arguments to filter Tb_person_statuses to delete.
     * @example
     * // Delete a few Tb_person_statuses
     * const { count } = await prisma.tb_person_status.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends tb_person_statusDeleteManyArgs>(args?: SelectSubset<T, tb_person_statusDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tb_person_statuses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_person_statusUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tb_person_statuses
     * const tb_person_status = await prisma.tb_person_status.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends tb_person_statusUpdateManyArgs>(args: SelectSubset<T, tb_person_statusUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Tb_person_status.
     * @param {tb_person_statusUpsertArgs} args - Arguments to update or create a Tb_person_status.
     * @example
     * // Update or create a Tb_person_status
     * const tb_person_status = await prisma.tb_person_status.upsert({
     *   create: {
     *     // ... data to create a Tb_person_status
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tb_person_status we want to update
     *   }
     * })
     */
    upsert<T extends tb_person_statusUpsertArgs>(args: SelectSubset<T, tb_person_statusUpsertArgs<ExtArgs>>): Prisma__tb_person_statusClient<$Result.GetResult<Prisma.$tb_person_statusPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Tb_person_statuses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_person_statusCountArgs} args - Arguments to filter Tb_person_statuses to count.
     * @example
     * // Count the number of Tb_person_statuses
     * const count = await prisma.tb_person_status.count({
     *   where: {
     *     // ... the filter for the Tb_person_statuses we want to count
     *   }
     * })
    **/
    count<T extends tb_person_statusCountArgs>(
      args?: Subset<T, tb_person_statusCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Tb_person_statusCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tb_person_status.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Tb_person_statusAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Tb_person_statusAggregateArgs>(args: Subset<T, Tb_person_statusAggregateArgs>): Prisma.PrismaPromise<GetTb_person_statusAggregateType<T>>

    /**
     * Group by Tb_person_status.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_person_statusGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends tb_person_statusGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: tb_person_statusGroupByArgs['orderBy'] }
        : { orderBy?: tb_person_statusGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, tb_person_statusGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTb_person_statusGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the tb_person_status model
   */
  readonly fields: tb_person_statusFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for tb_person_status.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__tb_person_statusClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the tb_person_status model
   */
  interface tb_person_statusFieldRefs {
    readonly person_status_id: FieldRef<"tb_person_status", 'Int'>
    readonly person_status: FieldRef<"tb_person_status", 'String'>
    readonly person_status_eng: FieldRef<"tb_person_status", 'String'>
  }
    

  // Custom InputTypes
  /**
   * tb_person_status findUnique
   */
  export type tb_person_statusFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_person_status
     */
    select?: tb_person_statusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_person_status
     */
    omit?: tb_person_statusOmit<ExtArgs> | null
    /**
     * Filter, which tb_person_status to fetch.
     */
    where: tb_person_statusWhereUniqueInput
  }

  /**
   * tb_person_status findUniqueOrThrow
   */
  export type tb_person_statusFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_person_status
     */
    select?: tb_person_statusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_person_status
     */
    omit?: tb_person_statusOmit<ExtArgs> | null
    /**
     * Filter, which tb_person_status to fetch.
     */
    where: tb_person_statusWhereUniqueInput
  }

  /**
   * tb_person_status findFirst
   */
  export type tb_person_statusFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_person_status
     */
    select?: tb_person_statusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_person_status
     */
    omit?: tb_person_statusOmit<ExtArgs> | null
    /**
     * Filter, which tb_person_status to fetch.
     */
    where?: tb_person_statusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tb_person_statuses to fetch.
     */
    orderBy?: tb_person_statusOrderByWithRelationInput | tb_person_statusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tb_person_statuses.
     */
    cursor?: tb_person_statusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tb_person_statuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tb_person_statuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tb_person_statuses.
     */
    distinct?: Tb_person_statusScalarFieldEnum | Tb_person_statusScalarFieldEnum[]
  }

  /**
   * tb_person_status findFirstOrThrow
   */
  export type tb_person_statusFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_person_status
     */
    select?: tb_person_statusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_person_status
     */
    omit?: tb_person_statusOmit<ExtArgs> | null
    /**
     * Filter, which tb_person_status to fetch.
     */
    where?: tb_person_statusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tb_person_statuses to fetch.
     */
    orderBy?: tb_person_statusOrderByWithRelationInput | tb_person_statusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tb_person_statuses.
     */
    cursor?: tb_person_statusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tb_person_statuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tb_person_statuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tb_person_statuses.
     */
    distinct?: Tb_person_statusScalarFieldEnum | Tb_person_statusScalarFieldEnum[]
  }

  /**
   * tb_person_status findMany
   */
  export type tb_person_statusFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_person_status
     */
    select?: tb_person_statusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_person_status
     */
    omit?: tb_person_statusOmit<ExtArgs> | null
    /**
     * Filter, which tb_person_statuses to fetch.
     */
    where?: tb_person_statusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tb_person_statuses to fetch.
     */
    orderBy?: tb_person_statusOrderByWithRelationInput | tb_person_statusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing tb_person_statuses.
     */
    cursor?: tb_person_statusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tb_person_statuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tb_person_statuses.
     */
    skip?: number
    distinct?: Tb_person_statusScalarFieldEnum | Tb_person_statusScalarFieldEnum[]
  }

  /**
   * tb_person_status create
   */
  export type tb_person_statusCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_person_status
     */
    select?: tb_person_statusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_person_status
     */
    omit?: tb_person_statusOmit<ExtArgs> | null
    /**
     * The data needed to create a tb_person_status.
     */
    data: XOR<tb_person_statusCreateInput, tb_person_statusUncheckedCreateInput>
  }

  /**
   * tb_person_status createMany
   */
  export type tb_person_statusCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many tb_person_statuses.
     */
    data: tb_person_statusCreateManyInput | tb_person_statusCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * tb_person_status update
   */
  export type tb_person_statusUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_person_status
     */
    select?: tb_person_statusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_person_status
     */
    omit?: tb_person_statusOmit<ExtArgs> | null
    /**
     * The data needed to update a tb_person_status.
     */
    data: XOR<tb_person_statusUpdateInput, tb_person_statusUncheckedUpdateInput>
    /**
     * Choose, which tb_person_status to update.
     */
    where: tb_person_statusWhereUniqueInput
  }

  /**
   * tb_person_status updateMany
   */
  export type tb_person_statusUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update tb_person_statuses.
     */
    data: XOR<tb_person_statusUpdateManyMutationInput, tb_person_statusUncheckedUpdateManyInput>
    /**
     * Filter which tb_person_statuses to update
     */
    where?: tb_person_statusWhereInput
    /**
     * Limit how many tb_person_statuses to update.
     */
    limit?: number
  }

  /**
   * tb_person_status upsert
   */
  export type tb_person_statusUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_person_status
     */
    select?: tb_person_statusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_person_status
     */
    omit?: tb_person_statusOmit<ExtArgs> | null
    /**
     * The filter to search for the tb_person_status to update in case it exists.
     */
    where: tb_person_statusWhereUniqueInput
    /**
     * In case the tb_person_status found by the `where` argument doesn't exist, create a new tb_person_status with this data.
     */
    create: XOR<tb_person_statusCreateInput, tb_person_statusUncheckedCreateInput>
    /**
     * In case the tb_person_status was found with the provided `where` argument, update it with this data.
     */
    update: XOR<tb_person_statusUpdateInput, tb_person_statusUncheckedUpdateInput>
  }

  /**
   * tb_person_status delete
   */
  export type tb_person_statusDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_person_status
     */
    select?: tb_person_statusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_person_status
     */
    omit?: tb_person_statusOmit<ExtArgs> | null
    /**
     * Filter which tb_person_status to delete.
     */
    where: tb_person_statusWhereUniqueInput
  }

  /**
   * tb_person_status deleteMany
   */
  export type tb_person_statusDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tb_person_statuses to delete
     */
    where?: tb_person_statusWhereInput
    /**
     * Limit how many tb_person_statuses to delete.
     */
    limit?: number
  }

  /**
   * tb_person_status without action
   */
  export type tb_person_statusDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_person_status
     */
    select?: tb_person_statusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_person_status
     */
    omit?: tb_person_statusOmit<ExtArgs> | null
  }


  /**
   * Model tb_process
   */

  export type AggregateTb_process = {
    _count: Tb_processCountAggregateOutputType | null
    _avg: Tb_processAvgAggregateOutputType | null
    _sum: Tb_processSumAggregateOutputType | null
    _min: Tb_processMinAggregateOutputType | null
    _max: Tb_processMaxAggregateOutputType | null
  }

  export type Tb_processAvgAggregateOutputType = {
    process_id: number | null
    process_type_id: number | null
    case_id: number | null
    draft_id: number | null
    coi_id: number | null
    request_id: number | null
    order_id: number | null
    decision_id: number | null
    notification_id: number | null
    sign_status: number | null
    sign_by: number | null
    processor: number | null
    actual: number | null
    comment_status: number | null
  }

  export type Tb_processSumAggregateOutputType = {
    process_id: number | null
    process_type_id: number | null
    case_id: number | null
    draft_id: number | null
    coi_id: number | null
    request_id: number | null
    order_id: number | null
    decision_id: number | null
    notification_id: number | null
    sign_status: number | null
    sign_by: number | null
    processor: number | null
    actual: number | null
    comment_status: number | null
  }

  export type Tb_processMinAggregateOutputType = {
    process_id: number | null
    process_type_id: number | null
    case_id: number | null
    draft_id: number | null
    coi_id: number | null
    request_id: number | null
    order_id: number | null
    decision_id: number | null
    notification_id: number | null
    sign_status: number | null
    sign_date: Date | null
    sign_by: number | null
    processor: number | null
    comment_to: string | null
    actual: number | null
    comment_status: number | null
    out_num: string | null
  }

  export type Tb_processMaxAggregateOutputType = {
    process_id: number | null
    process_type_id: number | null
    case_id: number | null
    draft_id: number | null
    coi_id: number | null
    request_id: number | null
    order_id: number | null
    decision_id: number | null
    notification_id: number | null
    sign_status: number | null
    sign_date: Date | null
    sign_by: number | null
    processor: number | null
    comment_to: string | null
    actual: number | null
    comment_status: number | null
    out_num: string | null
  }

  export type Tb_processCountAggregateOutputType = {
    process_id: number
    process_type_id: number
    case_id: number
    draft_id: number
    coi_id: number
    request_id: number
    order_id: number
    decision_id: number
    notification_id: number
    sign_status: number
    sign_date: number
    sign_by: number
    processor: number
    comment_to: number
    actual: number
    comment_status: number
    out_num: number
    _all: number
  }


  export type Tb_processAvgAggregateInputType = {
    process_id?: true
    process_type_id?: true
    case_id?: true
    draft_id?: true
    coi_id?: true
    request_id?: true
    order_id?: true
    decision_id?: true
    notification_id?: true
    sign_status?: true
    sign_by?: true
    processor?: true
    actual?: true
    comment_status?: true
  }

  export type Tb_processSumAggregateInputType = {
    process_id?: true
    process_type_id?: true
    case_id?: true
    draft_id?: true
    coi_id?: true
    request_id?: true
    order_id?: true
    decision_id?: true
    notification_id?: true
    sign_status?: true
    sign_by?: true
    processor?: true
    actual?: true
    comment_status?: true
  }

  export type Tb_processMinAggregateInputType = {
    process_id?: true
    process_type_id?: true
    case_id?: true
    draft_id?: true
    coi_id?: true
    request_id?: true
    order_id?: true
    decision_id?: true
    notification_id?: true
    sign_status?: true
    sign_date?: true
    sign_by?: true
    processor?: true
    comment_to?: true
    actual?: true
    comment_status?: true
    out_num?: true
  }

  export type Tb_processMaxAggregateInputType = {
    process_id?: true
    process_type_id?: true
    case_id?: true
    draft_id?: true
    coi_id?: true
    request_id?: true
    order_id?: true
    decision_id?: true
    notification_id?: true
    sign_status?: true
    sign_date?: true
    sign_by?: true
    processor?: true
    comment_to?: true
    actual?: true
    comment_status?: true
    out_num?: true
  }

  export type Tb_processCountAggregateInputType = {
    process_id?: true
    process_type_id?: true
    case_id?: true
    draft_id?: true
    coi_id?: true
    request_id?: true
    order_id?: true
    decision_id?: true
    notification_id?: true
    sign_status?: true
    sign_date?: true
    sign_by?: true
    processor?: true
    comment_to?: true
    actual?: true
    comment_status?: true
    out_num?: true
    _all?: true
  }

  export type Tb_processAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tb_process to aggregate.
     */
    where?: tb_processWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tb_processes to fetch.
     */
    orderBy?: tb_processOrderByWithRelationInput | tb_processOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: tb_processWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tb_processes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tb_processes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned tb_processes
    **/
    _count?: true | Tb_processCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Tb_processAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Tb_processSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Tb_processMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Tb_processMaxAggregateInputType
  }

  export type GetTb_processAggregateType<T extends Tb_processAggregateArgs> = {
        [P in keyof T & keyof AggregateTb_process]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTb_process[P]>
      : GetScalarType<T[P], AggregateTb_process[P]>
  }




  export type tb_processGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: tb_processWhereInput
    orderBy?: tb_processOrderByWithAggregationInput | tb_processOrderByWithAggregationInput[]
    by: Tb_processScalarFieldEnum[] | Tb_processScalarFieldEnum
    having?: tb_processScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Tb_processCountAggregateInputType | true
    _avg?: Tb_processAvgAggregateInputType
    _sum?: Tb_processSumAggregateInputType
    _min?: Tb_processMinAggregateInputType
    _max?: Tb_processMaxAggregateInputType
  }

  export type Tb_processGroupByOutputType = {
    process_id: number
    process_type_id: number
    case_id: number
    draft_id: number | null
    coi_id: number | null
    request_id: number | null
    order_id: number | null
    decision_id: number | null
    notification_id: number | null
    sign_status: number
    sign_date: Date
    sign_by: number
    processor: number
    comment_to: string | null
    actual: number
    comment_status: number
    out_num: string | null
    _count: Tb_processCountAggregateOutputType | null
    _avg: Tb_processAvgAggregateOutputType | null
    _sum: Tb_processSumAggregateOutputType | null
    _min: Tb_processMinAggregateOutputType | null
    _max: Tb_processMaxAggregateOutputType | null
  }

  type GetTb_processGroupByPayload<T extends tb_processGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Tb_processGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Tb_processGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Tb_processGroupByOutputType[P]>
            : GetScalarType<T[P], Tb_processGroupByOutputType[P]>
        }
      >
    >


  export type tb_processSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    process_id?: boolean
    process_type_id?: boolean
    case_id?: boolean
    draft_id?: boolean
    coi_id?: boolean
    request_id?: boolean
    order_id?: boolean
    decision_id?: boolean
    notification_id?: boolean
    sign_status?: boolean
    sign_date?: boolean
    sign_by?: boolean
    processor?: boolean
    comment_to?: boolean
    actual?: boolean
    comment_status?: boolean
    out_num?: boolean
  }, ExtArgs["result"]["tb_process"]>



  export type tb_processSelectScalar = {
    process_id?: boolean
    process_type_id?: boolean
    case_id?: boolean
    draft_id?: boolean
    coi_id?: boolean
    request_id?: boolean
    order_id?: boolean
    decision_id?: boolean
    notification_id?: boolean
    sign_status?: boolean
    sign_date?: boolean
    sign_by?: boolean
    processor?: boolean
    comment_to?: boolean
    actual?: boolean
    comment_status?: boolean
    out_num?: boolean
  }

  export type tb_processOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"process_id" | "process_type_id" | "case_id" | "draft_id" | "coi_id" | "request_id" | "order_id" | "decision_id" | "notification_id" | "sign_status" | "sign_date" | "sign_by" | "processor" | "comment_to" | "actual" | "comment_status" | "out_num", ExtArgs["result"]["tb_process"]>

  export type $tb_processPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "tb_process"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      process_id: number
      process_type_id: number
      case_id: number
      draft_id: number | null
      coi_id: number | null
      request_id: number | null
      order_id: number | null
      decision_id: number | null
      notification_id: number | null
      sign_status: number
      sign_date: Date
      sign_by: number
      processor: number
      comment_to: string | null
      actual: number
      comment_status: number
      out_num: string | null
    }, ExtArgs["result"]["tb_process"]>
    composites: {}
  }

  type tb_processGetPayload<S extends boolean | null | undefined | tb_processDefaultArgs> = $Result.GetResult<Prisma.$tb_processPayload, S>

  type tb_processCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<tb_processFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Tb_processCountAggregateInputType | true
    }

  export interface tb_processDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['tb_process'], meta: { name: 'tb_process' } }
    /**
     * Find zero or one Tb_process that matches the filter.
     * @param {tb_processFindUniqueArgs} args - Arguments to find a Tb_process
     * @example
     * // Get one Tb_process
     * const tb_process = await prisma.tb_process.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends tb_processFindUniqueArgs>(args: SelectSubset<T, tb_processFindUniqueArgs<ExtArgs>>): Prisma__tb_processClient<$Result.GetResult<Prisma.$tb_processPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Tb_process that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {tb_processFindUniqueOrThrowArgs} args - Arguments to find a Tb_process
     * @example
     * // Get one Tb_process
     * const tb_process = await prisma.tb_process.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends tb_processFindUniqueOrThrowArgs>(args: SelectSubset<T, tb_processFindUniqueOrThrowArgs<ExtArgs>>): Prisma__tb_processClient<$Result.GetResult<Prisma.$tb_processPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tb_process that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_processFindFirstArgs} args - Arguments to find a Tb_process
     * @example
     * // Get one Tb_process
     * const tb_process = await prisma.tb_process.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends tb_processFindFirstArgs>(args?: SelectSubset<T, tb_processFindFirstArgs<ExtArgs>>): Prisma__tb_processClient<$Result.GetResult<Prisma.$tb_processPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tb_process that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_processFindFirstOrThrowArgs} args - Arguments to find a Tb_process
     * @example
     * // Get one Tb_process
     * const tb_process = await prisma.tb_process.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends tb_processFindFirstOrThrowArgs>(args?: SelectSubset<T, tb_processFindFirstOrThrowArgs<ExtArgs>>): Prisma__tb_processClient<$Result.GetResult<Prisma.$tb_processPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Tb_processes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_processFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tb_processes
     * const tb_processes = await prisma.tb_process.findMany()
     * 
     * // Get first 10 Tb_processes
     * const tb_processes = await prisma.tb_process.findMany({ take: 10 })
     * 
     * // Only select the `process_id`
     * const tb_processWithProcess_idOnly = await prisma.tb_process.findMany({ select: { process_id: true } })
     * 
     */
    findMany<T extends tb_processFindManyArgs>(args?: SelectSubset<T, tb_processFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tb_processPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Tb_process.
     * @param {tb_processCreateArgs} args - Arguments to create a Tb_process.
     * @example
     * // Create one Tb_process
     * const Tb_process = await prisma.tb_process.create({
     *   data: {
     *     // ... data to create a Tb_process
     *   }
     * })
     * 
     */
    create<T extends tb_processCreateArgs>(args: SelectSubset<T, tb_processCreateArgs<ExtArgs>>): Prisma__tb_processClient<$Result.GetResult<Prisma.$tb_processPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Tb_processes.
     * @param {tb_processCreateManyArgs} args - Arguments to create many Tb_processes.
     * @example
     * // Create many Tb_processes
     * const tb_process = await prisma.tb_process.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends tb_processCreateManyArgs>(args?: SelectSubset<T, tb_processCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Tb_process.
     * @param {tb_processDeleteArgs} args - Arguments to delete one Tb_process.
     * @example
     * // Delete one Tb_process
     * const Tb_process = await prisma.tb_process.delete({
     *   where: {
     *     // ... filter to delete one Tb_process
     *   }
     * })
     * 
     */
    delete<T extends tb_processDeleteArgs>(args: SelectSubset<T, tb_processDeleteArgs<ExtArgs>>): Prisma__tb_processClient<$Result.GetResult<Prisma.$tb_processPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Tb_process.
     * @param {tb_processUpdateArgs} args - Arguments to update one Tb_process.
     * @example
     * // Update one Tb_process
     * const tb_process = await prisma.tb_process.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends tb_processUpdateArgs>(args: SelectSubset<T, tb_processUpdateArgs<ExtArgs>>): Prisma__tb_processClient<$Result.GetResult<Prisma.$tb_processPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Tb_processes.
     * @param {tb_processDeleteManyArgs} args - Arguments to filter Tb_processes to delete.
     * @example
     * // Delete a few Tb_processes
     * const { count } = await prisma.tb_process.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends tb_processDeleteManyArgs>(args?: SelectSubset<T, tb_processDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tb_processes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_processUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tb_processes
     * const tb_process = await prisma.tb_process.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends tb_processUpdateManyArgs>(args: SelectSubset<T, tb_processUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Tb_process.
     * @param {tb_processUpsertArgs} args - Arguments to update or create a Tb_process.
     * @example
     * // Update or create a Tb_process
     * const tb_process = await prisma.tb_process.upsert({
     *   create: {
     *     // ... data to create a Tb_process
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tb_process we want to update
     *   }
     * })
     */
    upsert<T extends tb_processUpsertArgs>(args: SelectSubset<T, tb_processUpsertArgs<ExtArgs>>): Prisma__tb_processClient<$Result.GetResult<Prisma.$tb_processPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Tb_processes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_processCountArgs} args - Arguments to filter Tb_processes to count.
     * @example
     * // Count the number of Tb_processes
     * const count = await prisma.tb_process.count({
     *   where: {
     *     // ... the filter for the Tb_processes we want to count
     *   }
     * })
    **/
    count<T extends tb_processCountArgs>(
      args?: Subset<T, tb_processCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Tb_processCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tb_process.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Tb_processAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Tb_processAggregateArgs>(args: Subset<T, Tb_processAggregateArgs>): Prisma.PrismaPromise<GetTb_processAggregateType<T>>

    /**
     * Group by Tb_process.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_processGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends tb_processGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: tb_processGroupByArgs['orderBy'] }
        : { orderBy?: tb_processGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, tb_processGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTb_processGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the tb_process model
   */
  readonly fields: tb_processFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for tb_process.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__tb_processClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the tb_process model
   */
  interface tb_processFieldRefs {
    readonly process_id: FieldRef<"tb_process", 'Int'>
    readonly process_type_id: FieldRef<"tb_process", 'Int'>
    readonly case_id: FieldRef<"tb_process", 'Int'>
    readonly draft_id: FieldRef<"tb_process", 'Int'>
    readonly coi_id: FieldRef<"tb_process", 'Int'>
    readonly request_id: FieldRef<"tb_process", 'Int'>
    readonly order_id: FieldRef<"tb_process", 'Int'>
    readonly decision_id: FieldRef<"tb_process", 'Int'>
    readonly notification_id: FieldRef<"tb_process", 'Int'>
    readonly sign_status: FieldRef<"tb_process", 'Int'>
    readonly sign_date: FieldRef<"tb_process", 'DateTime'>
    readonly sign_by: FieldRef<"tb_process", 'Int'>
    readonly processor: FieldRef<"tb_process", 'Int'>
    readonly comment_to: FieldRef<"tb_process", 'String'>
    readonly actual: FieldRef<"tb_process", 'Int'>
    readonly comment_status: FieldRef<"tb_process", 'Int'>
    readonly out_num: FieldRef<"tb_process", 'String'>
  }
    

  // Custom InputTypes
  /**
   * tb_process findUnique
   */
  export type tb_processFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_process
     */
    select?: tb_processSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_process
     */
    omit?: tb_processOmit<ExtArgs> | null
    /**
     * Filter, which tb_process to fetch.
     */
    where: tb_processWhereUniqueInput
  }

  /**
   * tb_process findUniqueOrThrow
   */
  export type tb_processFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_process
     */
    select?: tb_processSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_process
     */
    omit?: tb_processOmit<ExtArgs> | null
    /**
     * Filter, which tb_process to fetch.
     */
    where: tb_processWhereUniqueInput
  }

  /**
   * tb_process findFirst
   */
  export type tb_processFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_process
     */
    select?: tb_processSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_process
     */
    omit?: tb_processOmit<ExtArgs> | null
    /**
     * Filter, which tb_process to fetch.
     */
    where?: tb_processWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tb_processes to fetch.
     */
    orderBy?: tb_processOrderByWithRelationInput | tb_processOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tb_processes.
     */
    cursor?: tb_processWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tb_processes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tb_processes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tb_processes.
     */
    distinct?: Tb_processScalarFieldEnum | Tb_processScalarFieldEnum[]
  }

  /**
   * tb_process findFirstOrThrow
   */
  export type tb_processFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_process
     */
    select?: tb_processSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_process
     */
    omit?: tb_processOmit<ExtArgs> | null
    /**
     * Filter, which tb_process to fetch.
     */
    where?: tb_processWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tb_processes to fetch.
     */
    orderBy?: tb_processOrderByWithRelationInput | tb_processOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tb_processes.
     */
    cursor?: tb_processWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tb_processes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tb_processes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tb_processes.
     */
    distinct?: Tb_processScalarFieldEnum | Tb_processScalarFieldEnum[]
  }

  /**
   * tb_process findMany
   */
  export type tb_processFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_process
     */
    select?: tb_processSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_process
     */
    omit?: tb_processOmit<ExtArgs> | null
    /**
     * Filter, which tb_processes to fetch.
     */
    where?: tb_processWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tb_processes to fetch.
     */
    orderBy?: tb_processOrderByWithRelationInput | tb_processOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing tb_processes.
     */
    cursor?: tb_processWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tb_processes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tb_processes.
     */
    skip?: number
    distinct?: Tb_processScalarFieldEnum | Tb_processScalarFieldEnum[]
  }

  /**
   * tb_process create
   */
  export type tb_processCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_process
     */
    select?: tb_processSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_process
     */
    omit?: tb_processOmit<ExtArgs> | null
    /**
     * The data needed to create a tb_process.
     */
    data: XOR<tb_processCreateInput, tb_processUncheckedCreateInput>
  }

  /**
   * tb_process createMany
   */
  export type tb_processCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many tb_processes.
     */
    data: tb_processCreateManyInput | tb_processCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * tb_process update
   */
  export type tb_processUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_process
     */
    select?: tb_processSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_process
     */
    omit?: tb_processOmit<ExtArgs> | null
    /**
     * The data needed to update a tb_process.
     */
    data: XOR<tb_processUpdateInput, tb_processUncheckedUpdateInput>
    /**
     * Choose, which tb_process to update.
     */
    where: tb_processWhereUniqueInput
  }

  /**
   * tb_process updateMany
   */
  export type tb_processUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update tb_processes.
     */
    data: XOR<tb_processUpdateManyMutationInput, tb_processUncheckedUpdateManyInput>
    /**
     * Filter which tb_processes to update
     */
    where?: tb_processWhereInput
    /**
     * Limit how many tb_processes to update.
     */
    limit?: number
  }

  /**
   * tb_process upsert
   */
  export type tb_processUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_process
     */
    select?: tb_processSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_process
     */
    omit?: tb_processOmit<ExtArgs> | null
    /**
     * The filter to search for the tb_process to update in case it exists.
     */
    where: tb_processWhereUniqueInput
    /**
     * In case the tb_process found by the `where` argument doesn't exist, create a new tb_process with this data.
     */
    create: XOR<tb_processCreateInput, tb_processUncheckedCreateInput>
    /**
     * In case the tb_process was found with the provided `where` argument, update it with this data.
     */
    update: XOR<tb_processUpdateInput, tb_processUncheckedUpdateInput>
  }

  /**
   * tb_process delete
   */
  export type tb_processDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_process
     */
    select?: tb_processSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_process
     */
    omit?: tb_processOmit<ExtArgs> | null
    /**
     * Filter which tb_process to delete.
     */
    where: tb_processWhereUniqueInput
  }

  /**
   * tb_process deleteMany
   */
  export type tb_processDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tb_processes to delete
     */
    where?: tb_processWhereInput
    /**
     * Limit how many tb_processes to delete.
     */
    limit?: number
  }

  /**
   * tb_process without action
   */
  export type tb_processDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_process
     */
    select?: tb_processSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_process
     */
    omit?: tb_processOmit<ExtArgs> | null
  }


  /**
   * Model tb_process_type
   */

  export type AggregateTb_process_type = {
    _count: Tb_process_typeCountAggregateOutputType | null
    _avg: Tb_process_typeAvgAggregateOutputType | null
    _sum: Tb_process_typeSumAggregateOutputType | null
    _min: Tb_process_typeMinAggregateOutputType | null
    _max: Tb_process_typeMaxAggregateOutputType | null
  }

  export type Tb_process_typeAvgAggregateOutputType = {
    process_type_id: number | null
  }

  export type Tb_process_typeSumAggregateOutputType = {
    process_type_id: number | null
  }

  export type Tb_process_typeMinAggregateOutputType = {
    process_type_id: number | null
    process_type: string | null
  }

  export type Tb_process_typeMaxAggregateOutputType = {
    process_type_id: number | null
    process_type: string | null
  }

  export type Tb_process_typeCountAggregateOutputType = {
    process_type_id: number
    process_type: number
    _all: number
  }


  export type Tb_process_typeAvgAggregateInputType = {
    process_type_id?: true
  }

  export type Tb_process_typeSumAggregateInputType = {
    process_type_id?: true
  }

  export type Tb_process_typeMinAggregateInputType = {
    process_type_id?: true
    process_type?: true
  }

  export type Tb_process_typeMaxAggregateInputType = {
    process_type_id?: true
    process_type?: true
  }

  export type Tb_process_typeCountAggregateInputType = {
    process_type_id?: true
    process_type?: true
    _all?: true
  }

  export type Tb_process_typeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tb_process_type to aggregate.
     */
    where?: tb_process_typeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tb_process_types to fetch.
     */
    orderBy?: tb_process_typeOrderByWithRelationInput | tb_process_typeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: tb_process_typeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tb_process_types from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tb_process_types.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned tb_process_types
    **/
    _count?: true | Tb_process_typeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Tb_process_typeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Tb_process_typeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Tb_process_typeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Tb_process_typeMaxAggregateInputType
  }

  export type GetTb_process_typeAggregateType<T extends Tb_process_typeAggregateArgs> = {
        [P in keyof T & keyof AggregateTb_process_type]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTb_process_type[P]>
      : GetScalarType<T[P], AggregateTb_process_type[P]>
  }




  export type tb_process_typeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: tb_process_typeWhereInput
    orderBy?: tb_process_typeOrderByWithAggregationInput | tb_process_typeOrderByWithAggregationInput[]
    by: Tb_process_typeScalarFieldEnum[] | Tb_process_typeScalarFieldEnum
    having?: tb_process_typeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Tb_process_typeCountAggregateInputType | true
    _avg?: Tb_process_typeAvgAggregateInputType
    _sum?: Tb_process_typeSumAggregateInputType
    _min?: Tb_process_typeMinAggregateInputType
    _max?: Tb_process_typeMaxAggregateInputType
  }

  export type Tb_process_typeGroupByOutputType = {
    process_type_id: number
    process_type: string
    _count: Tb_process_typeCountAggregateOutputType | null
    _avg: Tb_process_typeAvgAggregateOutputType | null
    _sum: Tb_process_typeSumAggregateOutputType | null
    _min: Tb_process_typeMinAggregateOutputType | null
    _max: Tb_process_typeMaxAggregateOutputType | null
  }

  type GetTb_process_typeGroupByPayload<T extends tb_process_typeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Tb_process_typeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Tb_process_typeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Tb_process_typeGroupByOutputType[P]>
            : GetScalarType<T[P], Tb_process_typeGroupByOutputType[P]>
        }
      >
    >


  export type tb_process_typeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    process_type_id?: boolean
    process_type?: boolean
  }, ExtArgs["result"]["tb_process_type"]>



  export type tb_process_typeSelectScalar = {
    process_type_id?: boolean
    process_type?: boolean
  }

  export type tb_process_typeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"process_type_id" | "process_type", ExtArgs["result"]["tb_process_type"]>

  export type $tb_process_typePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "tb_process_type"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      process_type_id: number
      process_type: string
    }, ExtArgs["result"]["tb_process_type"]>
    composites: {}
  }

  type tb_process_typeGetPayload<S extends boolean | null | undefined | tb_process_typeDefaultArgs> = $Result.GetResult<Prisma.$tb_process_typePayload, S>

  type tb_process_typeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<tb_process_typeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Tb_process_typeCountAggregateInputType | true
    }

  export interface tb_process_typeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['tb_process_type'], meta: { name: 'tb_process_type' } }
    /**
     * Find zero or one Tb_process_type that matches the filter.
     * @param {tb_process_typeFindUniqueArgs} args - Arguments to find a Tb_process_type
     * @example
     * // Get one Tb_process_type
     * const tb_process_type = await prisma.tb_process_type.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends tb_process_typeFindUniqueArgs>(args: SelectSubset<T, tb_process_typeFindUniqueArgs<ExtArgs>>): Prisma__tb_process_typeClient<$Result.GetResult<Prisma.$tb_process_typePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Tb_process_type that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {tb_process_typeFindUniqueOrThrowArgs} args - Arguments to find a Tb_process_type
     * @example
     * // Get one Tb_process_type
     * const tb_process_type = await prisma.tb_process_type.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends tb_process_typeFindUniqueOrThrowArgs>(args: SelectSubset<T, tb_process_typeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__tb_process_typeClient<$Result.GetResult<Prisma.$tb_process_typePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tb_process_type that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_process_typeFindFirstArgs} args - Arguments to find a Tb_process_type
     * @example
     * // Get one Tb_process_type
     * const tb_process_type = await prisma.tb_process_type.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends tb_process_typeFindFirstArgs>(args?: SelectSubset<T, tb_process_typeFindFirstArgs<ExtArgs>>): Prisma__tb_process_typeClient<$Result.GetResult<Prisma.$tb_process_typePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tb_process_type that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_process_typeFindFirstOrThrowArgs} args - Arguments to find a Tb_process_type
     * @example
     * // Get one Tb_process_type
     * const tb_process_type = await prisma.tb_process_type.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends tb_process_typeFindFirstOrThrowArgs>(args?: SelectSubset<T, tb_process_typeFindFirstOrThrowArgs<ExtArgs>>): Prisma__tb_process_typeClient<$Result.GetResult<Prisma.$tb_process_typePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Tb_process_types that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_process_typeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tb_process_types
     * const tb_process_types = await prisma.tb_process_type.findMany()
     * 
     * // Get first 10 Tb_process_types
     * const tb_process_types = await prisma.tb_process_type.findMany({ take: 10 })
     * 
     * // Only select the `process_type_id`
     * const tb_process_typeWithProcess_type_idOnly = await prisma.tb_process_type.findMany({ select: { process_type_id: true } })
     * 
     */
    findMany<T extends tb_process_typeFindManyArgs>(args?: SelectSubset<T, tb_process_typeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tb_process_typePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Tb_process_type.
     * @param {tb_process_typeCreateArgs} args - Arguments to create a Tb_process_type.
     * @example
     * // Create one Tb_process_type
     * const Tb_process_type = await prisma.tb_process_type.create({
     *   data: {
     *     // ... data to create a Tb_process_type
     *   }
     * })
     * 
     */
    create<T extends tb_process_typeCreateArgs>(args: SelectSubset<T, tb_process_typeCreateArgs<ExtArgs>>): Prisma__tb_process_typeClient<$Result.GetResult<Prisma.$tb_process_typePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Tb_process_types.
     * @param {tb_process_typeCreateManyArgs} args - Arguments to create many Tb_process_types.
     * @example
     * // Create many Tb_process_types
     * const tb_process_type = await prisma.tb_process_type.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends tb_process_typeCreateManyArgs>(args?: SelectSubset<T, tb_process_typeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Tb_process_type.
     * @param {tb_process_typeDeleteArgs} args - Arguments to delete one Tb_process_type.
     * @example
     * // Delete one Tb_process_type
     * const Tb_process_type = await prisma.tb_process_type.delete({
     *   where: {
     *     // ... filter to delete one Tb_process_type
     *   }
     * })
     * 
     */
    delete<T extends tb_process_typeDeleteArgs>(args: SelectSubset<T, tb_process_typeDeleteArgs<ExtArgs>>): Prisma__tb_process_typeClient<$Result.GetResult<Prisma.$tb_process_typePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Tb_process_type.
     * @param {tb_process_typeUpdateArgs} args - Arguments to update one Tb_process_type.
     * @example
     * // Update one Tb_process_type
     * const tb_process_type = await prisma.tb_process_type.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends tb_process_typeUpdateArgs>(args: SelectSubset<T, tb_process_typeUpdateArgs<ExtArgs>>): Prisma__tb_process_typeClient<$Result.GetResult<Prisma.$tb_process_typePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Tb_process_types.
     * @param {tb_process_typeDeleteManyArgs} args - Arguments to filter Tb_process_types to delete.
     * @example
     * // Delete a few Tb_process_types
     * const { count } = await prisma.tb_process_type.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends tb_process_typeDeleteManyArgs>(args?: SelectSubset<T, tb_process_typeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tb_process_types.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_process_typeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tb_process_types
     * const tb_process_type = await prisma.tb_process_type.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends tb_process_typeUpdateManyArgs>(args: SelectSubset<T, tb_process_typeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Tb_process_type.
     * @param {tb_process_typeUpsertArgs} args - Arguments to update or create a Tb_process_type.
     * @example
     * // Update or create a Tb_process_type
     * const tb_process_type = await prisma.tb_process_type.upsert({
     *   create: {
     *     // ... data to create a Tb_process_type
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tb_process_type we want to update
     *   }
     * })
     */
    upsert<T extends tb_process_typeUpsertArgs>(args: SelectSubset<T, tb_process_typeUpsertArgs<ExtArgs>>): Prisma__tb_process_typeClient<$Result.GetResult<Prisma.$tb_process_typePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Tb_process_types.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_process_typeCountArgs} args - Arguments to filter Tb_process_types to count.
     * @example
     * // Count the number of Tb_process_types
     * const count = await prisma.tb_process_type.count({
     *   where: {
     *     // ... the filter for the Tb_process_types we want to count
     *   }
     * })
    **/
    count<T extends tb_process_typeCountArgs>(
      args?: Subset<T, tb_process_typeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Tb_process_typeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tb_process_type.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Tb_process_typeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Tb_process_typeAggregateArgs>(args: Subset<T, Tb_process_typeAggregateArgs>): Prisma.PrismaPromise<GetTb_process_typeAggregateType<T>>

    /**
     * Group by Tb_process_type.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_process_typeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends tb_process_typeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: tb_process_typeGroupByArgs['orderBy'] }
        : { orderBy?: tb_process_typeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, tb_process_typeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTb_process_typeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the tb_process_type model
   */
  readonly fields: tb_process_typeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for tb_process_type.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__tb_process_typeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the tb_process_type model
   */
  interface tb_process_typeFieldRefs {
    readonly process_type_id: FieldRef<"tb_process_type", 'Int'>
    readonly process_type: FieldRef<"tb_process_type", 'String'>
  }
    

  // Custom InputTypes
  /**
   * tb_process_type findUnique
   */
  export type tb_process_typeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_process_type
     */
    select?: tb_process_typeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_process_type
     */
    omit?: tb_process_typeOmit<ExtArgs> | null
    /**
     * Filter, which tb_process_type to fetch.
     */
    where: tb_process_typeWhereUniqueInput
  }

  /**
   * tb_process_type findUniqueOrThrow
   */
  export type tb_process_typeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_process_type
     */
    select?: tb_process_typeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_process_type
     */
    omit?: tb_process_typeOmit<ExtArgs> | null
    /**
     * Filter, which tb_process_type to fetch.
     */
    where: tb_process_typeWhereUniqueInput
  }

  /**
   * tb_process_type findFirst
   */
  export type tb_process_typeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_process_type
     */
    select?: tb_process_typeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_process_type
     */
    omit?: tb_process_typeOmit<ExtArgs> | null
    /**
     * Filter, which tb_process_type to fetch.
     */
    where?: tb_process_typeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tb_process_types to fetch.
     */
    orderBy?: tb_process_typeOrderByWithRelationInput | tb_process_typeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tb_process_types.
     */
    cursor?: tb_process_typeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tb_process_types from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tb_process_types.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tb_process_types.
     */
    distinct?: Tb_process_typeScalarFieldEnum | Tb_process_typeScalarFieldEnum[]
  }

  /**
   * tb_process_type findFirstOrThrow
   */
  export type tb_process_typeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_process_type
     */
    select?: tb_process_typeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_process_type
     */
    omit?: tb_process_typeOmit<ExtArgs> | null
    /**
     * Filter, which tb_process_type to fetch.
     */
    where?: tb_process_typeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tb_process_types to fetch.
     */
    orderBy?: tb_process_typeOrderByWithRelationInput | tb_process_typeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tb_process_types.
     */
    cursor?: tb_process_typeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tb_process_types from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tb_process_types.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tb_process_types.
     */
    distinct?: Tb_process_typeScalarFieldEnum | Tb_process_typeScalarFieldEnum[]
  }

  /**
   * tb_process_type findMany
   */
  export type tb_process_typeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_process_type
     */
    select?: tb_process_typeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_process_type
     */
    omit?: tb_process_typeOmit<ExtArgs> | null
    /**
     * Filter, which tb_process_types to fetch.
     */
    where?: tb_process_typeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tb_process_types to fetch.
     */
    orderBy?: tb_process_typeOrderByWithRelationInput | tb_process_typeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing tb_process_types.
     */
    cursor?: tb_process_typeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tb_process_types from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tb_process_types.
     */
    skip?: number
    distinct?: Tb_process_typeScalarFieldEnum | Tb_process_typeScalarFieldEnum[]
  }

  /**
   * tb_process_type create
   */
  export type tb_process_typeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_process_type
     */
    select?: tb_process_typeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_process_type
     */
    omit?: tb_process_typeOmit<ExtArgs> | null
    /**
     * The data needed to create a tb_process_type.
     */
    data: XOR<tb_process_typeCreateInput, tb_process_typeUncheckedCreateInput>
  }

  /**
   * tb_process_type createMany
   */
  export type tb_process_typeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many tb_process_types.
     */
    data: tb_process_typeCreateManyInput | tb_process_typeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * tb_process_type update
   */
  export type tb_process_typeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_process_type
     */
    select?: tb_process_typeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_process_type
     */
    omit?: tb_process_typeOmit<ExtArgs> | null
    /**
     * The data needed to update a tb_process_type.
     */
    data: XOR<tb_process_typeUpdateInput, tb_process_typeUncheckedUpdateInput>
    /**
     * Choose, which tb_process_type to update.
     */
    where: tb_process_typeWhereUniqueInput
  }

  /**
   * tb_process_type updateMany
   */
  export type tb_process_typeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update tb_process_types.
     */
    data: XOR<tb_process_typeUpdateManyMutationInput, tb_process_typeUncheckedUpdateManyInput>
    /**
     * Filter which tb_process_types to update
     */
    where?: tb_process_typeWhereInput
    /**
     * Limit how many tb_process_types to update.
     */
    limit?: number
  }

  /**
   * tb_process_type upsert
   */
  export type tb_process_typeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_process_type
     */
    select?: tb_process_typeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_process_type
     */
    omit?: tb_process_typeOmit<ExtArgs> | null
    /**
     * The filter to search for the tb_process_type to update in case it exists.
     */
    where: tb_process_typeWhereUniqueInput
    /**
     * In case the tb_process_type found by the `where` argument doesn't exist, create a new tb_process_type with this data.
     */
    create: XOR<tb_process_typeCreateInput, tb_process_typeUncheckedCreateInput>
    /**
     * In case the tb_process_type was found with the provided `where` argument, update it with this data.
     */
    update: XOR<tb_process_typeUpdateInput, tb_process_typeUncheckedUpdateInput>
  }

  /**
   * tb_process_type delete
   */
  export type tb_process_typeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_process_type
     */
    select?: tb_process_typeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_process_type
     */
    omit?: tb_process_typeOmit<ExtArgs> | null
    /**
     * Filter which tb_process_type to delete.
     */
    where: tb_process_typeWhereUniqueInput
  }

  /**
   * tb_process_type deleteMany
   */
  export type tb_process_typeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tb_process_types to delete
     */
    where?: tb_process_typeWhereInput
    /**
     * Limit how many tb_process_types to delete.
     */
    limit?: number
  }

  /**
   * tb_process_type without action
   */
  export type tb_process_typeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_process_type
     */
    select?: tb_process_typeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_process_type
     */
    omit?: tb_process_typeOmit<ExtArgs> | null
  }


  /**
   * Model tb_religions
   */

  export type AggregateTb_religions = {
    _count: Tb_religionsCountAggregateOutputType | null
    _avg: Tb_religionsAvgAggregateOutputType | null
    _sum: Tb_religionsSumAggregateOutputType | null
    _min: Tb_religionsMinAggregateOutputType | null
    _max: Tb_religionsMaxAggregateOutputType | null
  }

  export type Tb_religionsAvgAggregateOutputType = {
    religion_id: number | null
  }

  export type Tb_religionsSumAggregateOutputType = {
    religion_id: number | null
  }

  export type Tb_religionsMinAggregateOutputType = {
    religion_id: number | null
    religion_arm: string | null
    religion_eng: string | null
  }

  export type Tb_religionsMaxAggregateOutputType = {
    religion_id: number | null
    religion_arm: string | null
    religion_eng: string | null
  }

  export type Tb_religionsCountAggregateOutputType = {
    religion_id: number
    religion_arm: number
    religion_eng: number
    _all: number
  }


  export type Tb_religionsAvgAggregateInputType = {
    religion_id?: true
  }

  export type Tb_religionsSumAggregateInputType = {
    religion_id?: true
  }

  export type Tb_religionsMinAggregateInputType = {
    religion_id?: true
    religion_arm?: true
    religion_eng?: true
  }

  export type Tb_religionsMaxAggregateInputType = {
    religion_id?: true
    religion_arm?: true
    religion_eng?: true
  }

  export type Tb_religionsCountAggregateInputType = {
    religion_id?: true
    religion_arm?: true
    religion_eng?: true
    _all?: true
  }

  export type Tb_religionsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tb_religions to aggregate.
     */
    where?: tb_religionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tb_religions to fetch.
     */
    orderBy?: tb_religionsOrderByWithRelationInput | tb_religionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: tb_religionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tb_religions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tb_religions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned tb_religions
    **/
    _count?: true | Tb_religionsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Tb_religionsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Tb_religionsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Tb_religionsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Tb_religionsMaxAggregateInputType
  }

  export type GetTb_religionsAggregateType<T extends Tb_religionsAggregateArgs> = {
        [P in keyof T & keyof AggregateTb_religions]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTb_religions[P]>
      : GetScalarType<T[P], AggregateTb_religions[P]>
  }




  export type tb_religionsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: tb_religionsWhereInput
    orderBy?: tb_religionsOrderByWithAggregationInput | tb_religionsOrderByWithAggregationInput[]
    by: Tb_religionsScalarFieldEnum[] | Tb_religionsScalarFieldEnum
    having?: tb_religionsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Tb_religionsCountAggregateInputType | true
    _avg?: Tb_religionsAvgAggregateInputType
    _sum?: Tb_religionsSumAggregateInputType
    _min?: Tb_religionsMinAggregateInputType
    _max?: Tb_religionsMaxAggregateInputType
  }

  export type Tb_religionsGroupByOutputType = {
    religion_id: number
    religion_arm: string
    religion_eng: string
    _count: Tb_religionsCountAggregateOutputType | null
    _avg: Tb_religionsAvgAggregateOutputType | null
    _sum: Tb_religionsSumAggregateOutputType | null
    _min: Tb_religionsMinAggregateOutputType | null
    _max: Tb_religionsMaxAggregateOutputType | null
  }

  type GetTb_religionsGroupByPayload<T extends tb_religionsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Tb_religionsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Tb_religionsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Tb_religionsGroupByOutputType[P]>
            : GetScalarType<T[P], Tb_religionsGroupByOutputType[P]>
        }
      >
    >


  export type tb_religionsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    religion_id?: boolean
    religion_arm?: boolean
    religion_eng?: boolean
  }, ExtArgs["result"]["tb_religions"]>



  export type tb_religionsSelectScalar = {
    religion_id?: boolean
    religion_arm?: boolean
    religion_eng?: boolean
  }

  export type tb_religionsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"religion_id" | "religion_arm" | "religion_eng", ExtArgs["result"]["tb_religions"]>

  export type $tb_religionsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "tb_religions"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      religion_id: number
      religion_arm: string
      religion_eng: string
    }, ExtArgs["result"]["tb_religions"]>
    composites: {}
  }

  type tb_religionsGetPayload<S extends boolean | null | undefined | tb_religionsDefaultArgs> = $Result.GetResult<Prisma.$tb_religionsPayload, S>

  type tb_religionsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<tb_religionsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Tb_religionsCountAggregateInputType | true
    }

  export interface tb_religionsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['tb_religions'], meta: { name: 'tb_religions' } }
    /**
     * Find zero or one Tb_religions that matches the filter.
     * @param {tb_religionsFindUniqueArgs} args - Arguments to find a Tb_religions
     * @example
     * // Get one Tb_religions
     * const tb_religions = await prisma.tb_religions.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends tb_religionsFindUniqueArgs>(args: SelectSubset<T, tb_religionsFindUniqueArgs<ExtArgs>>): Prisma__tb_religionsClient<$Result.GetResult<Prisma.$tb_religionsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Tb_religions that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {tb_religionsFindUniqueOrThrowArgs} args - Arguments to find a Tb_religions
     * @example
     * // Get one Tb_religions
     * const tb_religions = await prisma.tb_religions.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends tb_religionsFindUniqueOrThrowArgs>(args: SelectSubset<T, tb_religionsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__tb_religionsClient<$Result.GetResult<Prisma.$tb_religionsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tb_religions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_religionsFindFirstArgs} args - Arguments to find a Tb_religions
     * @example
     * // Get one Tb_religions
     * const tb_religions = await prisma.tb_religions.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends tb_religionsFindFirstArgs>(args?: SelectSubset<T, tb_religionsFindFirstArgs<ExtArgs>>): Prisma__tb_religionsClient<$Result.GetResult<Prisma.$tb_religionsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tb_religions that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_religionsFindFirstOrThrowArgs} args - Arguments to find a Tb_religions
     * @example
     * // Get one Tb_religions
     * const tb_religions = await prisma.tb_religions.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends tb_religionsFindFirstOrThrowArgs>(args?: SelectSubset<T, tb_religionsFindFirstOrThrowArgs<ExtArgs>>): Prisma__tb_religionsClient<$Result.GetResult<Prisma.$tb_religionsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Tb_religions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_religionsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tb_religions
     * const tb_religions = await prisma.tb_religions.findMany()
     * 
     * // Get first 10 Tb_religions
     * const tb_religions = await prisma.tb_religions.findMany({ take: 10 })
     * 
     * // Only select the `religion_id`
     * const tb_religionsWithReligion_idOnly = await prisma.tb_religions.findMany({ select: { religion_id: true } })
     * 
     */
    findMany<T extends tb_religionsFindManyArgs>(args?: SelectSubset<T, tb_religionsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tb_religionsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Tb_religions.
     * @param {tb_religionsCreateArgs} args - Arguments to create a Tb_religions.
     * @example
     * // Create one Tb_religions
     * const Tb_religions = await prisma.tb_religions.create({
     *   data: {
     *     // ... data to create a Tb_religions
     *   }
     * })
     * 
     */
    create<T extends tb_religionsCreateArgs>(args: SelectSubset<T, tb_religionsCreateArgs<ExtArgs>>): Prisma__tb_religionsClient<$Result.GetResult<Prisma.$tb_religionsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Tb_religions.
     * @param {tb_religionsCreateManyArgs} args - Arguments to create many Tb_religions.
     * @example
     * // Create many Tb_religions
     * const tb_religions = await prisma.tb_religions.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends tb_religionsCreateManyArgs>(args?: SelectSubset<T, tb_religionsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Tb_religions.
     * @param {tb_religionsDeleteArgs} args - Arguments to delete one Tb_religions.
     * @example
     * // Delete one Tb_religions
     * const Tb_religions = await prisma.tb_religions.delete({
     *   where: {
     *     // ... filter to delete one Tb_religions
     *   }
     * })
     * 
     */
    delete<T extends tb_religionsDeleteArgs>(args: SelectSubset<T, tb_religionsDeleteArgs<ExtArgs>>): Prisma__tb_religionsClient<$Result.GetResult<Prisma.$tb_religionsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Tb_religions.
     * @param {tb_religionsUpdateArgs} args - Arguments to update one Tb_religions.
     * @example
     * // Update one Tb_religions
     * const tb_religions = await prisma.tb_religions.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends tb_religionsUpdateArgs>(args: SelectSubset<T, tb_religionsUpdateArgs<ExtArgs>>): Prisma__tb_religionsClient<$Result.GetResult<Prisma.$tb_religionsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Tb_religions.
     * @param {tb_religionsDeleteManyArgs} args - Arguments to filter Tb_religions to delete.
     * @example
     * // Delete a few Tb_religions
     * const { count } = await prisma.tb_religions.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends tb_religionsDeleteManyArgs>(args?: SelectSubset<T, tb_religionsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tb_religions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_religionsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tb_religions
     * const tb_religions = await prisma.tb_religions.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends tb_religionsUpdateManyArgs>(args: SelectSubset<T, tb_religionsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Tb_religions.
     * @param {tb_religionsUpsertArgs} args - Arguments to update or create a Tb_religions.
     * @example
     * // Update or create a Tb_religions
     * const tb_religions = await prisma.tb_religions.upsert({
     *   create: {
     *     // ... data to create a Tb_religions
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tb_religions we want to update
     *   }
     * })
     */
    upsert<T extends tb_religionsUpsertArgs>(args: SelectSubset<T, tb_religionsUpsertArgs<ExtArgs>>): Prisma__tb_religionsClient<$Result.GetResult<Prisma.$tb_religionsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Tb_religions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_religionsCountArgs} args - Arguments to filter Tb_religions to count.
     * @example
     * // Count the number of Tb_religions
     * const count = await prisma.tb_religions.count({
     *   where: {
     *     // ... the filter for the Tb_religions we want to count
     *   }
     * })
    **/
    count<T extends tb_religionsCountArgs>(
      args?: Subset<T, tb_religionsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Tb_religionsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tb_religions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Tb_religionsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Tb_religionsAggregateArgs>(args: Subset<T, Tb_religionsAggregateArgs>): Prisma.PrismaPromise<GetTb_religionsAggregateType<T>>

    /**
     * Group by Tb_religions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_religionsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends tb_religionsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: tb_religionsGroupByArgs['orderBy'] }
        : { orderBy?: tb_religionsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, tb_religionsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTb_religionsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the tb_religions model
   */
  readonly fields: tb_religionsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for tb_religions.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__tb_religionsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the tb_religions model
   */
  interface tb_religionsFieldRefs {
    readonly religion_id: FieldRef<"tb_religions", 'Int'>
    readonly religion_arm: FieldRef<"tb_religions", 'String'>
    readonly religion_eng: FieldRef<"tb_religions", 'String'>
  }
    

  // Custom InputTypes
  /**
   * tb_religions findUnique
   */
  export type tb_religionsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_religions
     */
    select?: tb_religionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_religions
     */
    omit?: tb_religionsOmit<ExtArgs> | null
    /**
     * Filter, which tb_religions to fetch.
     */
    where: tb_religionsWhereUniqueInput
  }

  /**
   * tb_religions findUniqueOrThrow
   */
  export type tb_religionsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_religions
     */
    select?: tb_religionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_religions
     */
    omit?: tb_religionsOmit<ExtArgs> | null
    /**
     * Filter, which tb_religions to fetch.
     */
    where: tb_religionsWhereUniqueInput
  }

  /**
   * tb_religions findFirst
   */
  export type tb_religionsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_religions
     */
    select?: tb_religionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_religions
     */
    omit?: tb_religionsOmit<ExtArgs> | null
    /**
     * Filter, which tb_religions to fetch.
     */
    where?: tb_religionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tb_religions to fetch.
     */
    orderBy?: tb_religionsOrderByWithRelationInput | tb_religionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tb_religions.
     */
    cursor?: tb_religionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tb_religions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tb_religions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tb_religions.
     */
    distinct?: Tb_religionsScalarFieldEnum | Tb_religionsScalarFieldEnum[]
  }

  /**
   * tb_religions findFirstOrThrow
   */
  export type tb_religionsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_religions
     */
    select?: tb_religionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_religions
     */
    omit?: tb_religionsOmit<ExtArgs> | null
    /**
     * Filter, which tb_religions to fetch.
     */
    where?: tb_religionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tb_religions to fetch.
     */
    orderBy?: tb_religionsOrderByWithRelationInput | tb_religionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tb_religions.
     */
    cursor?: tb_religionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tb_religions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tb_religions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tb_religions.
     */
    distinct?: Tb_religionsScalarFieldEnum | Tb_religionsScalarFieldEnum[]
  }

  /**
   * tb_religions findMany
   */
  export type tb_religionsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_religions
     */
    select?: tb_religionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_religions
     */
    omit?: tb_religionsOmit<ExtArgs> | null
    /**
     * Filter, which tb_religions to fetch.
     */
    where?: tb_religionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tb_religions to fetch.
     */
    orderBy?: tb_religionsOrderByWithRelationInput | tb_religionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing tb_religions.
     */
    cursor?: tb_religionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tb_religions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tb_religions.
     */
    skip?: number
    distinct?: Tb_religionsScalarFieldEnum | Tb_religionsScalarFieldEnum[]
  }

  /**
   * tb_religions create
   */
  export type tb_religionsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_religions
     */
    select?: tb_religionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_religions
     */
    omit?: tb_religionsOmit<ExtArgs> | null
    /**
     * The data needed to create a tb_religions.
     */
    data: XOR<tb_religionsCreateInput, tb_religionsUncheckedCreateInput>
  }

  /**
   * tb_religions createMany
   */
  export type tb_religionsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many tb_religions.
     */
    data: tb_religionsCreateManyInput | tb_religionsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * tb_religions update
   */
  export type tb_religionsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_religions
     */
    select?: tb_religionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_religions
     */
    omit?: tb_religionsOmit<ExtArgs> | null
    /**
     * The data needed to update a tb_religions.
     */
    data: XOR<tb_religionsUpdateInput, tb_religionsUncheckedUpdateInput>
    /**
     * Choose, which tb_religions to update.
     */
    where: tb_religionsWhereUniqueInput
  }

  /**
   * tb_religions updateMany
   */
  export type tb_religionsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update tb_religions.
     */
    data: XOR<tb_religionsUpdateManyMutationInput, tb_religionsUncheckedUpdateManyInput>
    /**
     * Filter which tb_religions to update
     */
    where?: tb_religionsWhereInput
    /**
     * Limit how many tb_religions to update.
     */
    limit?: number
  }

  /**
   * tb_religions upsert
   */
  export type tb_religionsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_religions
     */
    select?: tb_religionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_religions
     */
    omit?: tb_religionsOmit<ExtArgs> | null
    /**
     * The filter to search for the tb_religions to update in case it exists.
     */
    where: tb_religionsWhereUniqueInput
    /**
     * In case the tb_religions found by the `where` argument doesn't exist, create a new tb_religions with this data.
     */
    create: XOR<tb_religionsCreateInput, tb_religionsUncheckedCreateInput>
    /**
     * In case the tb_religions was found with the provided `where` argument, update it with this data.
     */
    update: XOR<tb_religionsUpdateInput, tb_religionsUncheckedUpdateInput>
  }

  /**
   * tb_religions delete
   */
  export type tb_religionsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_religions
     */
    select?: tb_religionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_religions
     */
    omit?: tb_religionsOmit<ExtArgs> | null
    /**
     * Filter which tb_religions to delete.
     */
    where: tb_religionsWhereUniqueInput
  }

  /**
   * tb_religions deleteMany
   */
  export type tb_religionsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tb_religions to delete
     */
    where?: tb_religionsWhereInput
    /**
     * Limit how many tb_religions to delete.
     */
    limit?: number
  }

  /**
   * tb_religions without action
   */
  export type tb_religionsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_religions
     */
    select?: tb_religionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_religions
     */
    omit?: tb_religionsOmit<ExtArgs> | null
  }


  /**
   * Model tb_request_bodies
   */

  export type AggregateTb_request_bodies = {
    _count: Tb_request_bodiesCountAggregateOutputType | null
    _avg: Tb_request_bodiesAvgAggregateOutputType | null
    _sum: Tb_request_bodiesSumAggregateOutputType | null
    _min: Tb_request_bodiesMinAggregateOutputType | null
    _max: Tb_request_bodiesMaxAggregateOutputType | null
  }

  export type Tb_request_bodiesAvgAggregateOutputType = {
    body_id: number | null
  }

  export type Tb_request_bodiesSumAggregateOutputType = {
    body_id: number | null
  }

  export type Tb_request_bodiesMinAggregateOutputType = {
    body_id: number | null
    body: string | null
  }

  export type Tb_request_bodiesMaxAggregateOutputType = {
    body_id: number | null
    body: string | null
  }

  export type Tb_request_bodiesCountAggregateOutputType = {
    body_id: number
    body: number
    _all: number
  }


  export type Tb_request_bodiesAvgAggregateInputType = {
    body_id?: true
  }

  export type Tb_request_bodiesSumAggregateInputType = {
    body_id?: true
  }

  export type Tb_request_bodiesMinAggregateInputType = {
    body_id?: true
    body?: true
  }

  export type Tb_request_bodiesMaxAggregateInputType = {
    body_id?: true
    body?: true
  }

  export type Tb_request_bodiesCountAggregateInputType = {
    body_id?: true
    body?: true
    _all?: true
  }

  export type Tb_request_bodiesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tb_request_bodies to aggregate.
     */
    where?: tb_request_bodiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tb_request_bodies to fetch.
     */
    orderBy?: tb_request_bodiesOrderByWithRelationInput | tb_request_bodiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: tb_request_bodiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tb_request_bodies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tb_request_bodies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned tb_request_bodies
    **/
    _count?: true | Tb_request_bodiesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Tb_request_bodiesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Tb_request_bodiesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Tb_request_bodiesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Tb_request_bodiesMaxAggregateInputType
  }

  export type GetTb_request_bodiesAggregateType<T extends Tb_request_bodiesAggregateArgs> = {
        [P in keyof T & keyof AggregateTb_request_bodies]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTb_request_bodies[P]>
      : GetScalarType<T[P], AggregateTb_request_bodies[P]>
  }




  export type tb_request_bodiesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: tb_request_bodiesWhereInput
    orderBy?: tb_request_bodiesOrderByWithAggregationInput | tb_request_bodiesOrderByWithAggregationInput[]
    by: Tb_request_bodiesScalarFieldEnum[] | Tb_request_bodiesScalarFieldEnum
    having?: tb_request_bodiesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Tb_request_bodiesCountAggregateInputType | true
    _avg?: Tb_request_bodiesAvgAggregateInputType
    _sum?: Tb_request_bodiesSumAggregateInputType
    _min?: Tb_request_bodiesMinAggregateInputType
    _max?: Tb_request_bodiesMaxAggregateInputType
  }

  export type Tb_request_bodiesGroupByOutputType = {
    body_id: number
    body: string
    _count: Tb_request_bodiesCountAggregateOutputType | null
    _avg: Tb_request_bodiesAvgAggregateOutputType | null
    _sum: Tb_request_bodiesSumAggregateOutputType | null
    _min: Tb_request_bodiesMinAggregateOutputType | null
    _max: Tb_request_bodiesMaxAggregateOutputType | null
  }

  type GetTb_request_bodiesGroupByPayload<T extends tb_request_bodiesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Tb_request_bodiesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Tb_request_bodiesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Tb_request_bodiesGroupByOutputType[P]>
            : GetScalarType<T[P], Tb_request_bodiesGroupByOutputType[P]>
        }
      >
    >


  export type tb_request_bodiesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    body_id?: boolean
    body?: boolean
  }, ExtArgs["result"]["tb_request_bodies"]>



  export type tb_request_bodiesSelectScalar = {
    body_id?: boolean
    body?: boolean
  }

  export type tb_request_bodiesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"body_id" | "body", ExtArgs["result"]["tb_request_bodies"]>

  export type $tb_request_bodiesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "tb_request_bodies"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      body_id: number
      body: string
    }, ExtArgs["result"]["tb_request_bodies"]>
    composites: {}
  }

  type tb_request_bodiesGetPayload<S extends boolean | null | undefined | tb_request_bodiesDefaultArgs> = $Result.GetResult<Prisma.$tb_request_bodiesPayload, S>

  type tb_request_bodiesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<tb_request_bodiesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Tb_request_bodiesCountAggregateInputType | true
    }

  export interface tb_request_bodiesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['tb_request_bodies'], meta: { name: 'tb_request_bodies' } }
    /**
     * Find zero or one Tb_request_bodies that matches the filter.
     * @param {tb_request_bodiesFindUniqueArgs} args - Arguments to find a Tb_request_bodies
     * @example
     * // Get one Tb_request_bodies
     * const tb_request_bodies = await prisma.tb_request_bodies.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends tb_request_bodiesFindUniqueArgs>(args: SelectSubset<T, tb_request_bodiesFindUniqueArgs<ExtArgs>>): Prisma__tb_request_bodiesClient<$Result.GetResult<Prisma.$tb_request_bodiesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Tb_request_bodies that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {tb_request_bodiesFindUniqueOrThrowArgs} args - Arguments to find a Tb_request_bodies
     * @example
     * // Get one Tb_request_bodies
     * const tb_request_bodies = await prisma.tb_request_bodies.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends tb_request_bodiesFindUniqueOrThrowArgs>(args: SelectSubset<T, tb_request_bodiesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__tb_request_bodiesClient<$Result.GetResult<Prisma.$tb_request_bodiesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tb_request_bodies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_request_bodiesFindFirstArgs} args - Arguments to find a Tb_request_bodies
     * @example
     * // Get one Tb_request_bodies
     * const tb_request_bodies = await prisma.tb_request_bodies.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends tb_request_bodiesFindFirstArgs>(args?: SelectSubset<T, tb_request_bodiesFindFirstArgs<ExtArgs>>): Prisma__tb_request_bodiesClient<$Result.GetResult<Prisma.$tb_request_bodiesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tb_request_bodies that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_request_bodiesFindFirstOrThrowArgs} args - Arguments to find a Tb_request_bodies
     * @example
     * // Get one Tb_request_bodies
     * const tb_request_bodies = await prisma.tb_request_bodies.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends tb_request_bodiesFindFirstOrThrowArgs>(args?: SelectSubset<T, tb_request_bodiesFindFirstOrThrowArgs<ExtArgs>>): Prisma__tb_request_bodiesClient<$Result.GetResult<Prisma.$tb_request_bodiesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Tb_request_bodies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_request_bodiesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tb_request_bodies
     * const tb_request_bodies = await prisma.tb_request_bodies.findMany()
     * 
     * // Get first 10 Tb_request_bodies
     * const tb_request_bodies = await prisma.tb_request_bodies.findMany({ take: 10 })
     * 
     * // Only select the `body_id`
     * const tb_request_bodiesWithBody_idOnly = await prisma.tb_request_bodies.findMany({ select: { body_id: true } })
     * 
     */
    findMany<T extends tb_request_bodiesFindManyArgs>(args?: SelectSubset<T, tb_request_bodiesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tb_request_bodiesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Tb_request_bodies.
     * @param {tb_request_bodiesCreateArgs} args - Arguments to create a Tb_request_bodies.
     * @example
     * // Create one Tb_request_bodies
     * const Tb_request_bodies = await prisma.tb_request_bodies.create({
     *   data: {
     *     // ... data to create a Tb_request_bodies
     *   }
     * })
     * 
     */
    create<T extends tb_request_bodiesCreateArgs>(args: SelectSubset<T, tb_request_bodiesCreateArgs<ExtArgs>>): Prisma__tb_request_bodiesClient<$Result.GetResult<Prisma.$tb_request_bodiesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Tb_request_bodies.
     * @param {tb_request_bodiesCreateManyArgs} args - Arguments to create many Tb_request_bodies.
     * @example
     * // Create many Tb_request_bodies
     * const tb_request_bodies = await prisma.tb_request_bodies.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends tb_request_bodiesCreateManyArgs>(args?: SelectSubset<T, tb_request_bodiesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Tb_request_bodies.
     * @param {tb_request_bodiesDeleteArgs} args - Arguments to delete one Tb_request_bodies.
     * @example
     * // Delete one Tb_request_bodies
     * const Tb_request_bodies = await prisma.tb_request_bodies.delete({
     *   where: {
     *     // ... filter to delete one Tb_request_bodies
     *   }
     * })
     * 
     */
    delete<T extends tb_request_bodiesDeleteArgs>(args: SelectSubset<T, tb_request_bodiesDeleteArgs<ExtArgs>>): Prisma__tb_request_bodiesClient<$Result.GetResult<Prisma.$tb_request_bodiesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Tb_request_bodies.
     * @param {tb_request_bodiesUpdateArgs} args - Arguments to update one Tb_request_bodies.
     * @example
     * // Update one Tb_request_bodies
     * const tb_request_bodies = await prisma.tb_request_bodies.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends tb_request_bodiesUpdateArgs>(args: SelectSubset<T, tb_request_bodiesUpdateArgs<ExtArgs>>): Prisma__tb_request_bodiesClient<$Result.GetResult<Prisma.$tb_request_bodiesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Tb_request_bodies.
     * @param {tb_request_bodiesDeleteManyArgs} args - Arguments to filter Tb_request_bodies to delete.
     * @example
     * // Delete a few Tb_request_bodies
     * const { count } = await prisma.tb_request_bodies.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends tb_request_bodiesDeleteManyArgs>(args?: SelectSubset<T, tb_request_bodiesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tb_request_bodies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_request_bodiesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tb_request_bodies
     * const tb_request_bodies = await prisma.tb_request_bodies.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends tb_request_bodiesUpdateManyArgs>(args: SelectSubset<T, tb_request_bodiesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Tb_request_bodies.
     * @param {tb_request_bodiesUpsertArgs} args - Arguments to update or create a Tb_request_bodies.
     * @example
     * // Update or create a Tb_request_bodies
     * const tb_request_bodies = await prisma.tb_request_bodies.upsert({
     *   create: {
     *     // ... data to create a Tb_request_bodies
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tb_request_bodies we want to update
     *   }
     * })
     */
    upsert<T extends tb_request_bodiesUpsertArgs>(args: SelectSubset<T, tb_request_bodiesUpsertArgs<ExtArgs>>): Prisma__tb_request_bodiesClient<$Result.GetResult<Prisma.$tb_request_bodiesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Tb_request_bodies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_request_bodiesCountArgs} args - Arguments to filter Tb_request_bodies to count.
     * @example
     * // Count the number of Tb_request_bodies
     * const count = await prisma.tb_request_bodies.count({
     *   where: {
     *     // ... the filter for the Tb_request_bodies we want to count
     *   }
     * })
    **/
    count<T extends tb_request_bodiesCountArgs>(
      args?: Subset<T, tb_request_bodiesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Tb_request_bodiesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tb_request_bodies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Tb_request_bodiesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Tb_request_bodiesAggregateArgs>(args: Subset<T, Tb_request_bodiesAggregateArgs>): Prisma.PrismaPromise<GetTb_request_bodiesAggregateType<T>>

    /**
     * Group by Tb_request_bodies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_request_bodiesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends tb_request_bodiesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: tb_request_bodiesGroupByArgs['orderBy'] }
        : { orderBy?: tb_request_bodiesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, tb_request_bodiesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTb_request_bodiesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the tb_request_bodies model
   */
  readonly fields: tb_request_bodiesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for tb_request_bodies.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__tb_request_bodiesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the tb_request_bodies model
   */
  interface tb_request_bodiesFieldRefs {
    readonly body_id: FieldRef<"tb_request_bodies", 'Int'>
    readonly body: FieldRef<"tb_request_bodies", 'String'>
  }
    

  // Custom InputTypes
  /**
   * tb_request_bodies findUnique
   */
  export type tb_request_bodiesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_request_bodies
     */
    select?: tb_request_bodiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_request_bodies
     */
    omit?: tb_request_bodiesOmit<ExtArgs> | null
    /**
     * Filter, which tb_request_bodies to fetch.
     */
    where: tb_request_bodiesWhereUniqueInput
  }

  /**
   * tb_request_bodies findUniqueOrThrow
   */
  export type tb_request_bodiesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_request_bodies
     */
    select?: tb_request_bodiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_request_bodies
     */
    omit?: tb_request_bodiesOmit<ExtArgs> | null
    /**
     * Filter, which tb_request_bodies to fetch.
     */
    where: tb_request_bodiesWhereUniqueInput
  }

  /**
   * tb_request_bodies findFirst
   */
  export type tb_request_bodiesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_request_bodies
     */
    select?: tb_request_bodiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_request_bodies
     */
    omit?: tb_request_bodiesOmit<ExtArgs> | null
    /**
     * Filter, which tb_request_bodies to fetch.
     */
    where?: tb_request_bodiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tb_request_bodies to fetch.
     */
    orderBy?: tb_request_bodiesOrderByWithRelationInput | tb_request_bodiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tb_request_bodies.
     */
    cursor?: tb_request_bodiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tb_request_bodies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tb_request_bodies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tb_request_bodies.
     */
    distinct?: Tb_request_bodiesScalarFieldEnum | Tb_request_bodiesScalarFieldEnum[]
  }

  /**
   * tb_request_bodies findFirstOrThrow
   */
  export type tb_request_bodiesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_request_bodies
     */
    select?: tb_request_bodiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_request_bodies
     */
    omit?: tb_request_bodiesOmit<ExtArgs> | null
    /**
     * Filter, which tb_request_bodies to fetch.
     */
    where?: tb_request_bodiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tb_request_bodies to fetch.
     */
    orderBy?: tb_request_bodiesOrderByWithRelationInput | tb_request_bodiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tb_request_bodies.
     */
    cursor?: tb_request_bodiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tb_request_bodies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tb_request_bodies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tb_request_bodies.
     */
    distinct?: Tb_request_bodiesScalarFieldEnum | Tb_request_bodiesScalarFieldEnum[]
  }

  /**
   * tb_request_bodies findMany
   */
  export type tb_request_bodiesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_request_bodies
     */
    select?: tb_request_bodiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_request_bodies
     */
    omit?: tb_request_bodiesOmit<ExtArgs> | null
    /**
     * Filter, which tb_request_bodies to fetch.
     */
    where?: tb_request_bodiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tb_request_bodies to fetch.
     */
    orderBy?: tb_request_bodiesOrderByWithRelationInput | tb_request_bodiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing tb_request_bodies.
     */
    cursor?: tb_request_bodiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tb_request_bodies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tb_request_bodies.
     */
    skip?: number
    distinct?: Tb_request_bodiesScalarFieldEnum | Tb_request_bodiesScalarFieldEnum[]
  }

  /**
   * tb_request_bodies create
   */
  export type tb_request_bodiesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_request_bodies
     */
    select?: tb_request_bodiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_request_bodies
     */
    omit?: tb_request_bodiesOmit<ExtArgs> | null
    /**
     * The data needed to create a tb_request_bodies.
     */
    data: XOR<tb_request_bodiesCreateInput, tb_request_bodiesUncheckedCreateInput>
  }

  /**
   * tb_request_bodies createMany
   */
  export type tb_request_bodiesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many tb_request_bodies.
     */
    data: tb_request_bodiesCreateManyInput | tb_request_bodiesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * tb_request_bodies update
   */
  export type tb_request_bodiesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_request_bodies
     */
    select?: tb_request_bodiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_request_bodies
     */
    omit?: tb_request_bodiesOmit<ExtArgs> | null
    /**
     * The data needed to update a tb_request_bodies.
     */
    data: XOR<tb_request_bodiesUpdateInput, tb_request_bodiesUncheckedUpdateInput>
    /**
     * Choose, which tb_request_bodies to update.
     */
    where: tb_request_bodiesWhereUniqueInput
  }

  /**
   * tb_request_bodies updateMany
   */
  export type tb_request_bodiesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update tb_request_bodies.
     */
    data: XOR<tb_request_bodiesUpdateManyMutationInput, tb_request_bodiesUncheckedUpdateManyInput>
    /**
     * Filter which tb_request_bodies to update
     */
    where?: tb_request_bodiesWhereInput
    /**
     * Limit how many tb_request_bodies to update.
     */
    limit?: number
  }

  /**
   * tb_request_bodies upsert
   */
  export type tb_request_bodiesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_request_bodies
     */
    select?: tb_request_bodiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_request_bodies
     */
    omit?: tb_request_bodiesOmit<ExtArgs> | null
    /**
     * The filter to search for the tb_request_bodies to update in case it exists.
     */
    where: tb_request_bodiesWhereUniqueInput
    /**
     * In case the tb_request_bodies found by the `where` argument doesn't exist, create a new tb_request_bodies with this data.
     */
    create: XOR<tb_request_bodiesCreateInput, tb_request_bodiesUncheckedCreateInput>
    /**
     * In case the tb_request_bodies was found with the provided `where` argument, update it with this data.
     */
    update: XOR<tb_request_bodiesUpdateInput, tb_request_bodiesUncheckedUpdateInput>
  }

  /**
   * tb_request_bodies delete
   */
  export type tb_request_bodiesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_request_bodies
     */
    select?: tb_request_bodiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_request_bodies
     */
    omit?: tb_request_bodiesOmit<ExtArgs> | null
    /**
     * Filter which tb_request_bodies to delete.
     */
    where: tb_request_bodiesWhereUniqueInput
  }

  /**
   * tb_request_bodies deleteMany
   */
  export type tb_request_bodiesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tb_request_bodies to delete
     */
    where?: tb_request_bodiesWhereInput
    /**
     * Limit how many tb_request_bodies to delete.
     */
    limit?: number
  }

  /**
   * tb_request_bodies without action
   */
  export type tb_request_bodiesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_request_bodies
     */
    select?: tb_request_bodiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_request_bodies
     */
    omit?: tb_request_bodiesOmit<ExtArgs> | null
  }


  /**
   * Model tb_request_out
   */

  export type AggregateTb_request_out = {
    _count: Tb_request_outCountAggregateOutputType | null
    _avg: Tb_request_outAvgAggregateOutputType | null
    _sum: Tb_request_outSumAggregateOutputType | null
    _min: Tb_request_outMinAggregateOutputType | null
    _max: Tb_request_outMaxAggregateOutputType | null
  }

  export type Tb_request_outAvgAggregateOutputType = {
    request_id: number | null
    case_id: number | null
    author: number | null
    body: number | null
    request_status: number | null
  }

  export type Tb_request_outSumAggregateOutputType = {
    request_id: number | null
    case_id: number | null
    author: number | null
    body: number | null
    request_status: number | null
  }

  export type Tb_request_outMinAggregateOutputType = {
    request_id: number | null
    case_id: number | null
    author: number | null
    body: number | null
    request_date: Date | null
    request_status: number | null
  }

  export type Tb_request_outMaxAggregateOutputType = {
    request_id: number | null
    case_id: number | null
    author: number | null
    body: number | null
    request_date: Date | null
    request_status: number | null
  }

  export type Tb_request_outCountAggregateOutputType = {
    request_id: number
    case_id: number
    author: number
    body: number
    request_date: number
    request_status: number
    _all: number
  }


  export type Tb_request_outAvgAggregateInputType = {
    request_id?: true
    case_id?: true
    author?: true
    body?: true
    request_status?: true
  }

  export type Tb_request_outSumAggregateInputType = {
    request_id?: true
    case_id?: true
    author?: true
    body?: true
    request_status?: true
  }

  export type Tb_request_outMinAggregateInputType = {
    request_id?: true
    case_id?: true
    author?: true
    body?: true
    request_date?: true
    request_status?: true
  }

  export type Tb_request_outMaxAggregateInputType = {
    request_id?: true
    case_id?: true
    author?: true
    body?: true
    request_date?: true
    request_status?: true
  }

  export type Tb_request_outCountAggregateInputType = {
    request_id?: true
    case_id?: true
    author?: true
    body?: true
    request_date?: true
    request_status?: true
    _all?: true
  }

  export type Tb_request_outAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tb_request_out to aggregate.
     */
    where?: tb_request_outWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tb_request_outs to fetch.
     */
    orderBy?: tb_request_outOrderByWithRelationInput | tb_request_outOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: tb_request_outWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tb_request_outs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tb_request_outs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned tb_request_outs
    **/
    _count?: true | Tb_request_outCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Tb_request_outAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Tb_request_outSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Tb_request_outMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Tb_request_outMaxAggregateInputType
  }

  export type GetTb_request_outAggregateType<T extends Tb_request_outAggregateArgs> = {
        [P in keyof T & keyof AggregateTb_request_out]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTb_request_out[P]>
      : GetScalarType<T[P], AggregateTb_request_out[P]>
  }




  export type tb_request_outGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: tb_request_outWhereInput
    orderBy?: tb_request_outOrderByWithAggregationInput | tb_request_outOrderByWithAggregationInput[]
    by: Tb_request_outScalarFieldEnum[] | Tb_request_outScalarFieldEnum
    having?: tb_request_outScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Tb_request_outCountAggregateInputType | true
    _avg?: Tb_request_outAvgAggregateInputType
    _sum?: Tb_request_outSumAggregateInputType
    _min?: Tb_request_outMinAggregateInputType
    _max?: Tb_request_outMaxAggregateInputType
  }

  export type Tb_request_outGroupByOutputType = {
    request_id: number
    case_id: number
    author: number
    body: number
    request_date: Date
    request_status: number
    _count: Tb_request_outCountAggregateOutputType | null
    _avg: Tb_request_outAvgAggregateOutputType | null
    _sum: Tb_request_outSumAggregateOutputType | null
    _min: Tb_request_outMinAggregateOutputType | null
    _max: Tb_request_outMaxAggregateOutputType | null
  }

  type GetTb_request_outGroupByPayload<T extends tb_request_outGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Tb_request_outGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Tb_request_outGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Tb_request_outGroupByOutputType[P]>
            : GetScalarType<T[P], Tb_request_outGroupByOutputType[P]>
        }
      >
    >


  export type tb_request_outSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    request_id?: boolean
    case_id?: boolean
    author?: boolean
    body?: boolean
    request_date?: boolean
    request_status?: boolean
  }, ExtArgs["result"]["tb_request_out"]>



  export type tb_request_outSelectScalar = {
    request_id?: boolean
    case_id?: boolean
    author?: boolean
    body?: boolean
    request_date?: boolean
    request_status?: boolean
  }

  export type tb_request_outOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"request_id" | "case_id" | "author" | "body" | "request_date" | "request_status", ExtArgs["result"]["tb_request_out"]>

  export type $tb_request_outPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "tb_request_out"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      request_id: number
      case_id: number
      author: number
      body: number
      request_date: Date
      request_status: number
    }, ExtArgs["result"]["tb_request_out"]>
    composites: {}
  }

  type tb_request_outGetPayload<S extends boolean | null | undefined | tb_request_outDefaultArgs> = $Result.GetResult<Prisma.$tb_request_outPayload, S>

  type tb_request_outCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<tb_request_outFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Tb_request_outCountAggregateInputType | true
    }

  export interface tb_request_outDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['tb_request_out'], meta: { name: 'tb_request_out' } }
    /**
     * Find zero or one Tb_request_out that matches the filter.
     * @param {tb_request_outFindUniqueArgs} args - Arguments to find a Tb_request_out
     * @example
     * // Get one Tb_request_out
     * const tb_request_out = await prisma.tb_request_out.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends tb_request_outFindUniqueArgs>(args: SelectSubset<T, tb_request_outFindUniqueArgs<ExtArgs>>): Prisma__tb_request_outClient<$Result.GetResult<Prisma.$tb_request_outPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Tb_request_out that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {tb_request_outFindUniqueOrThrowArgs} args - Arguments to find a Tb_request_out
     * @example
     * // Get one Tb_request_out
     * const tb_request_out = await prisma.tb_request_out.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends tb_request_outFindUniqueOrThrowArgs>(args: SelectSubset<T, tb_request_outFindUniqueOrThrowArgs<ExtArgs>>): Prisma__tb_request_outClient<$Result.GetResult<Prisma.$tb_request_outPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tb_request_out that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_request_outFindFirstArgs} args - Arguments to find a Tb_request_out
     * @example
     * // Get one Tb_request_out
     * const tb_request_out = await prisma.tb_request_out.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends tb_request_outFindFirstArgs>(args?: SelectSubset<T, tb_request_outFindFirstArgs<ExtArgs>>): Prisma__tb_request_outClient<$Result.GetResult<Prisma.$tb_request_outPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tb_request_out that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_request_outFindFirstOrThrowArgs} args - Arguments to find a Tb_request_out
     * @example
     * // Get one Tb_request_out
     * const tb_request_out = await prisma.tb_request_out.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends tb_request_outFindFirstOrThrowArgs>(args?: SelectSubset<T, tb_request_outFindFirstOrThrowArgs<ExtArgs>>): Prisma__tb_request_outClient<$Result.GetResult<Prisma.$tb_request_outPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Tb_request_outs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_request_outFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tb_request_outs
     * const tb_request_outs = await prisma.tb_request_out.findMany()
     * 
     * // Get first 10 Tb_request_outs
     * const tb_request_outs = await prisma.tb_request_out.findMany({ take: 10 })
     * 
     * // Only select the `request_id`
     * const tb_request_outWithRequest_idOnly = await prisma.tb_request_out.findMany({ select: { request_id: true } })
     * 
     */
    findMany<T extends tb_request_outFindManyArgs>(args?: SelectSubset<T, tb_request_outFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tb_request_outPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Tb_request_out.
     * @param {tb_request_outCreateArgs} args - Arguments to create a Tb_request_out.
     * @example
     * // Create one Tb_request_out
     * const Tb_request_out = await prisma.tb_request_out.create({
     *   data: {
     *     // ... data to create a Tb_request_out
     *   }
     * })
     * 
     */
    create<T extends tb_request_outCreateArgs>(args: SelectSubset<T, tb_request_outCreateArgs<ExtArgs>>): Prisma__tb_request_outClient<$Result.GetResult<Prisma.$tb_request_outPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Tb_request_outs.
     * @param {tb_request_outCreateManyArgs} args - Arguments to create many Tb_request_outs.
     * @example
     * // Create many Tb_request_outs
     * const tb_request_out = await prisma.tb_request_out.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends tb_request_outCreateManyArgs>(args?: SelectSubset<T, tb_request_outCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Tb_request_out.
     * @param {tb_request_outDeleteArgs} args - Arguments to delete one Tb_request_out.
     * @example
     * // Delete one Tb_request_out
     * const Tb_request_out = await prisma.tb_request_out.delete({
     *   where: {
     *     // ... filter to delete one Tb_request_out
     *   }
     * })
     * 
     */
    delete<T extends tb_request_outDeleteArgs>(args: SelectSubset<T, tb_request_outDeleteArgs<ExtArgs>>): Prisma__tb_request_outClient<$Result.GetResult<Prisma.$tb_request_outPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Tb_request_out.
     * @param {tb_request_outUpdateArgs} args - Arguments to update one Tb_request_out.
     * @example
     * // Update one Tb_request_out
     * const tb_request_out = await prisma.tb_request_out.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends tb_request_outUpdateArgs>(args: SelectSubset<T, tb_request_outUpdateArgs<ExtArgs>>): Prisma__tb_request_outClient<$Result.GetResult<Prisma.$tb_request_outPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Tb_request_outs.
     * @param {tb_request_outDeleteManyArgs} args - Arguments to filter Tb_request_outs to delete.
     * @example
     * // Delete a few Tb_request_outs
     * const { count } = await prisma.tb_request_out.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends tb_request_outDeleteManyArgs>(args?: SelectSubset<T, tb_request_outDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tb_request_outs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_request_outUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tb_request_outs
     * const tb_request_out = await prisma.tb_request_out.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends tb_request_outUpdateManyArgs>(args: SelectSubset<T, tb_request_outUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Tb_request_out.
     * @param {tb_request_outUpsertArgs} args - Arguments to update or create a Tb_request_out.
     * @example
     * // Update or create a Tb_request_out
     * const tb_request_out = await prisma.tb_request_out.upsert({
     *   create: {
     *     // ... data to create a Tb_request_out
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tb_request_out we want to update
     *   }
     * })
     */
    upsert<T extends tb_request_outUpsertArgs>(args: SelectSubset<T, tb_request_outUpsertArgs<ExtArgs>>): Prisma__tb_request_outClient<$Result.GetResult<Prisma.$tb_request_outPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Tb_request_outs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_request_outCountArgs} args - Arguments to filter Tb_request_outs to count.
     * @example
     * // Count the number of Tb_request_outs
     * const count = await prisma.tb_request_out.count({
     *   where: {
     *     // ... the filter for the Tb_request_outs we want to count
     *   }
     * })
    **/
    count<T extends tb_request_outCountArgs>(
      args?: Subset<T, tb_request_outCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Tb_request_outCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tb_request_out.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Tb_request_outAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Tb_request_outAggregateArgs>(args: Subset<T, Tb_request_outAggregateArgs>): Prisma.PrismaPromise<GetTb_request_outAggregateType<T>>

    /**
     * Group by Tb_request_out.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_request_outGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends tb_request_outGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: tb_request_outGroupByArgs['orderBy'] }
        : { orderBy?: tb_request_outGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, tb_request_outGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTb_request_outGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the tb_request_out model
   */
  readonly fields: tb_request_outFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for tb_request_out.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__tb_request_outClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the tb_request_out model
   */
  interface tb_request_outFieldRefs {
    readonly request_id: FieldRef<"tb_request_out", 'Int'>
    readonly case_id: FieldRef<"tb_request_out", 'Int'>
    readonly author: FieldRef<"tb_request_out", 'Int'>
    readonly body: FieldRef<"tb_request_out", 'Int'>
    readonly request_date: FieldRef<"tb_request_out", 'DateTime'>
    readonly request_status: FieldRef<"tb_request_out", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * tb_request_out findUnique
   */
  export type tb_request_outFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_request_out
     */
    select?: tb_request_outSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_request_out
     */
    omit?: tb_request_outOmit<ExtArgs> | null
    /**
     * Filter, which tb_request_out to fetch.
     */
    where: tb_request_outWhereUniqueInput
  }

  /**
   * tb_request_out findUniqueOrThrow
   */
  export type tb_request_outFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_request_out
     */
    select?: tb_request_outSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_request_out
     */
    omit?: tb_request_outOmit<ExtArgs> | null
    /**
     * Filter, which tb_request_out to fetch.
     */
    where: tb_request_outWhereUniqueInput
  }

  /**
   * tb_request_out findFirst
   */
  export type tb_request_outFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_request_out
     */
    select?: tb_request_outSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_request_out
     */
    omit?: tb_request_outOmit<ExtArgs> | null
    /**
     * Filter, which tb_request_out to fetch.
     */
    where?: tb_request_outWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tb_request_outs to fetch.
     */
    orderBy?: tb_request_outOrderByWithRelationInput | tb_request_outOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tb_request_outs.
     */
    cursor?: tb_request_outWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tb_request_outs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tb_request_outs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tb_request_outs.
     */
    distinct?: Tb_request_outScalarFieldEnum | Tb_request_outScalarFieldEnum[]
  }

  /**
   * tb_request_out findFirstOrThrow
   */
  export type tb_request_outFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_request_out
     */
    select?: tb_request_outSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_request_out
     */
    omit?: tb_request_outOmit<ExtArgs> | null
    /**
     * Filter, which tb_request_out to fetch.
     */
    where?: tb_request_outWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tb_request_outs to fetch.
     */
    orderBy?: tb_request_outOrderByWithRelationInput | tb_request_outOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tb_request_outs.
     */
    cursor?: tb_request_outWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tb_request_outs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tb_request_outs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tb_request_outs.
     */
    distinct?: Tb_request_outScalarFieldEnum | Tb_request_outScalarFieldEnum[]
  }

  /**
   * tb_request_out findMany
   */
  export type tb_request_outFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_request_out
     */
    select?: tb_request_outSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_request_out
     */
    omit?: tb_request_outOmit<ExtArgs> | null
    /**
     * Filter, which tb_request_outs to fetch.
     */
    where?: tb_request_outWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tb_request_outs to fetch.
     */
    orderBy?: tb_request_outOrderByWithRelationInput | tb_request_outOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing tb_request_outs.
     */
    cursor?: tb_request_outWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tb_request_outs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tb_request_outs.
     */
    skip?: number
    distinct?: Tb_request_outScalarFieldEnum | Tb_request_outScalarFieldEnum[]
  }

  /**
   * tb_request_out create
   */
  export type tb_request_outCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_request_out
     */
    select?: tb_request_outSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_request_out
     */
    omit?: tb_request_outOmit<ExtArgs> | null
    /**
     * The data needed to create a tb_request_out.
     */
    data: XOR<tb_request_outCreateInput, tb_request_outUncheckedCreateInput>
  }

  /**
   * tb_request_out createMany
   */
  export type tb_request_outCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many tb_request_outs.
     */
    data: tb_request_outCreateManyInput | tb_request_outCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * tb_request_out update
   */
  export type tb_request_outUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_request_out
     */
    select?: tb_request_outSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_request_out
     */
    omit?: tb_request_outOmit<ExtArgs> | null
    /**
     * The data needed to update a tb_request_out.
     */
    data: XOR<tb_request_outUpdateInput, tb_request_outUncheckedUpdateInput>
    /**
     * Choose, which tb_request_out to update.
     */
    where: tb_request_outWhereUniqueInput
  }

  /**
   * tb_request_out updateMany
   */
  export type tb_request_outUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update tb_request_outs.
     */
    data: XOR<tb_request_outUpdateManyMutationInput, tb_request_outUncheckedUpdateManyInput>
    /**
     * Filter which tb_request_outs to update
     */
    where?: tb_request_outWhereInput
    /**
     * Limit how many tb_request_outs to update.
     */
    limit?: number
  }

  /**
   * tb_request_out upsert
   */
  export type tb_request_outUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_request_out
     */
    select?: tb_request_outSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_request_out
     */
    omit?: tb_request_outOmit<ExtArgs> | null
    /**
     * The filter to search for the tb_request_out to update in case it exists.
     */
    where: tb_request_outWhereUniqueInput
    /**
     * In case the tb_request_out found by the `where` argument doesn't exist, create a new tb_request_out with this data.
     */
    create: XOR<tb_request_outCreateInput, tb_request_outUncheckedCreateInput>
    /**
     * In case the tb_request_out was found with the provided `where` argument, update it with this data.
     */
    update: XOR<tb_request_outUpdateInput, tb_request_outUncheckedUpdateInput>
  }

  /**
   * tb_request_out delete
   */
  export type tb_request_outDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_request_out
     */
    select?: tb_request_outSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_request_out
     */
    omit?: tb_request_outOmit<ExtArgs> | null
    /**
     * Filter which tb_request_out to delete.
     */
    where: tb_request_outWhereUniqueInput
  }

  /**
   * tb_request_out deleteMany
   */
  export type tb_request_outDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tb_request_outs to delete
     */
    where?: tb_request_outWhereInput
    /**
     * Limit how many tb_request_outs to delete.
     */
    limit?: number
  }

  /**
   * tb_request_out without action
   */
  export type tb_request_outDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_request_out
     */
    select?: tb_request_outSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_request_out
     */
    omit?: tb_request_outOmit<ExtArgs> | null
  }


  /**
   * Model tb_role
   */

  export type AggregateTb_role = {
    _count: Tb_roleCountAggregateOutputType | null
    _avg: Tb_roleAvgAggregateOutputType | null
    _sum: Tb_roleSumAggregateOutputType | null
    _min: Tb_roleMinAggregateOutputType | null
    _max: Tb_roleMaxAggregateOutputType | null
  }

  export type Tb_roleAvgAggregateOutputType = {
    role_id: number | null
  }

  export type Tb_roleSumAggregateOutputType = {
    role_id: number | null
  }

  export type Tb_roleMinAggregateOutputType = {
    role_id: number | null
    der: string | null
  }

  export type Tb_roleMaxAggregateOutputType = {
    role_id: number | null
    der: string | null
  }

  export type Tb_roleCountAggregateOutputType = {
    role_id: number
    der: number
    _all: number
  }


  export type Tb_roleAvgAggregateInputType = {
    role_id?: true
  }

  export type Tb_roleSumAggregateInputType = {
    role_id?: true
  }

  export type Tb_roleMinAggregateInputType = {
    role_id?: true
    der?: true
  }

  export type Tb_roleMaxAggregateInputType = {
    role_id?: true
    der?: true
  }

  export type Tb_roleCountAggregateInputType = {
    role_id?: true
    der?: true
    _all?: true
  }

  export type Tb_roleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tb_role to aggregate.
     */
    where?: tb_roleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tb_roles to fetch.
     */
    orderBy?: tb_roleOrderByWithRelationInput | tb_roleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: tb_roleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tb_roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tb_roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned tb_roles
    **/
    _count?: true | Tb_roleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Tb_roleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Tb_roleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Tb_roleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Tb_roleMaxAggregateInputType
  }

  export type GetTb_roleAggregateType<T extends Tb_roleAggregateArgs> = {
        [P in keyof T & keyof AggregateTb_role]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTb_role[P]>
      : GetScalarType<T[P], AggregateTb_role[P]>
  }




  export type tb_roleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: tb_roleWhereInput
    orderBy?: tb_roleOrderByWithAggregationInput | tb_roleOrderByWithAggregationInput[]
    by: Tb_roleScalarFieldEnum[] | Tb_roleScalarFieldEnum
    having?: tb_roleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Tb_roleCountAggregateInputType | true
    _avg?: Tb_roleAvgAggregateInputType
    _sum?: Tb_roleSumAggregateInputType
    _min?: Tb_roleMinAggregateInputType
    _max?: Tb_roleMaxAggregateInputType
  }

  export type Tb_roleGroupByOutputType = {
    role_id: number
    der: string
    _count: Tb_roleCountAggregateOutputType | null
    _avg: Tb_roleAvgAggregateOutputType | null
    _sum: Tb_roleSumAggregateOutputType | null
    _min: Tb_roleMinAggregateOutputType | null
    _max: Tb_roleMaxAggregateOutputType | null
  }

  type GetTb_roleGroupByPayload<T extends tb_roleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Tb_roleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Tb_roleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Tb_roleGroupByOutputType[P]>
            : GetScalarType<T[P], Tb_roleGroupByOutputType[P]>
        }
      >
    >


  export type tb_roleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    role_id?: boolean
    der?: boolean
  }, ExtArgs["result"]["tb_role"]>



  export type tb_roleSelectScalar = {
    role_id?: boolean
    der?: boolean
  }

  export type tb_roleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"role_id" | "der", ExtArgs["result"]["tb_role"]>

  export type $tb_rolePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "tb_role"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      role_id: number
      der: string
    }, ExtArgs["result"]["tb_role"]>
    composites: {}
  }

  type tb_roleGetPayload<S extends boolean | null | undefined | tb_roleDefaultArgs> = $Result.GetResult<Prisma.$tb_rolePayload, S>

  type tb_roleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<tb_roleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Tb_roleCountAggregateInputType | true
    }

  export interface tb_roleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['tb_role'], meta: { name: 'tb_role' } }
    /**
     * Find zero or one Tb_role that matches the filter.
     * @param {tb_roleFindUniqueArgs} args - Arguments to find a Tb_role
     * @example
     * // Get one Tb_role
     * const tb_role = await prisma.tb_role.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends tb_roleFindUniqueArgs>(args: SelectSubset<T, tb_roleFindUniqueArgs<ExtArgs>>): Prisma__tb_roleClient<$Result.GetResult<Prisma.$tb_rolePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Tb_role that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {tb_roleFindUniqueOrThrowArgs} args - Arguments to find a Tb_role
     * @example
     * // Get one Tb_role
     * const tb_role = await prisma.tb_role.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends tb_roleFindUniqueOrThrowArgs>(args: SelectSubset<T, tb_roleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__tb_roleClient<$Result.GetResult<Prisma.$tb_rolePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tb_role that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_roleFindFirstArgs} args - Arguments to find a Tb_role
     * @example
     * // Get one Tb_role
     * const tb_role = await prisma.tb_role.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends tb_roleFindFirstArgs>(args?: SelectSubset<T, tb_roleFindFirstArgs<ExtArgs>>): Prisma__tb_roleClient<$Result.GetResult<Prisma.$tb_rolePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tb_role that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_roleFindFirstOrThrowArgs} args - Arguments to find a Tb_role
     * @example
     * // Get one Tb_role
     * const tb_role = await prisma.tb_role.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends tb_roleFindFirstOrThrowArgs>(args?: SelectSubset<T, tb_roleFindFirstOrThrowArgs<ExtArgs>>): Prisma__tb_roleClient<$Result.GetResult<Prisma.$tb_rolePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Tb_roles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_roleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tb_roles
     * const tb_roles = await prisma.tb_role.findMany()
     * 
     * // Get first 10 Tb_roles
     * const tb_roles = await prisma.tb_role.findMany({ take: 10 })
     * 
     * // Only select the `role_id`
     * const tb_roleWithRole_idOnly = await prisma.tb_role.findMany({ select: { role_id: true } })
     * 
     */
    findMany<T extends tb_roleFindManyArgs>(args?: SelectSubset<T, tb_roleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tb_rolePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Tb_role.
     * @param {tb_roleCreateArgs} args - Arguments to create a Tb_role.
     * @example
     * // Create one Tb_role
     * const Tb_role = await prisma.tb_role.create({
     *   data: {
     *     // ... data to create a Tb_role
     *   }
     * })
     * 
     */
    create<T extends tb_roleCreateArgs>(args: SelectSubset<T, tb_roleCreateArgs<ExtArgs>>): Prisma__tb_roleClient<$Result.GetResult<Prisma.$tb_rolePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Tb_roles.
     * @param {tb_roleCreateManyArgs} args - Arguments to create many Tb_roles.
     * @example
     * // Create many Tb_roles
     * const tb_role = await prisma.tb_role.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends tb_roleCreateManyArgs>(args?: SelectSubset<T, tb_roleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Tb_role.
     * @param {tb_roleDeleteArgs} args - Arguments to delete one Tb_role.
     * @example
     * // Delete one Tb_role
     * const Tb_role = await prisma.tb_role.delete({
     *   where: {
     *     // ... filter to delete one Tb_role
     *   }
     * })
     * 
     */
    delete<T extends tb_roleDeleteArgs>(args: SelectSubset<T, tb_roleDeleteArgs<ExtArgs>>): Prisma__tb_roleClient<$Result.GetResult<Prisma.$tb_rolePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Tb_role.
     * @param {tb_roleUpdateArgs} args - Arguments to update one Tb_role.
     * @example
     * // Update one Tb_role
     * const tb_role = await prisma.tb_role.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends tb_roleUpdateArgs>(args: SelectSubset<T, tb_roleUpdateArgs<ExtArgs>>): Prisma__tb_roleClient<$Result.GetResult<Prisma.$tb_rolePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Tb_roles.
     * @param {tb_roleDeleteManyArgs} args - Arguments to filter Tb_roles to delete.
     * @example
     * // Delete a few Tb_roles
     * const { count } = await prisma.tb_role.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends tb_roleDeleteManyArgs>(args?: SelectSubset<T, tb_roleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tb_roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_roleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tb_roles
     * const tb_role = await prisma.tb_role.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends tb_roleUpdateManyArgs>(args: SelectSubset<T, tb_roleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Tb_role.
     * @param {tb_roleUpsertArgs} args - Arguments to update or create a Tb_role.
     * @example
     * // Update or create a Tb_role
     * const tb_role = await prisma.tb_role.upsert({
     *   create: {
     *     // ... data to create a Tb_role
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tb_role we want to update
     *   }
     * })
     */
    upsert<T extends tb_roleUpsertArgs>(args: SelectSubset<T, tb_roleUpsertArgs<ExtArgs>>): Prisma__tb_roleClient<$Result.GetResult<Prisma.$tb_rolePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Tb_roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_roleCountArgs} args - Arguments to filter Tb_roles to count.
     * @example
     * // Count the number of Tb_roles
     * const count = await prisma.tb_role.count({
     *   where: {
     *     // ... the filter for the Tb_roles we want to count
     *   }
     * })
    **/
    count<T extends tb_roleCountArgs>(
      args?: Subset<T, tb_roleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Tb_roleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tb_role.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Tb_roleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Tb_roleAggregateArgs>(args: Subset<T, Tb_roleAggregateArgs>): Prisma.PrismaPromise<GetTb_roleAggregateType<T>>

    /**
     * Group by Tb_role.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_roleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends tb_roleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: tb_roleGroupByArgs['orderBy'] }
        : { orderBy?: tb_roleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, tb_roleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTb_roleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the tb_role model
   */
  readonly fields: tb_roleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for tb_role.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__tb_roleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the tb_role model
   */
  interface tb_roleFieldRefs {
    readonly role_id: FieldRef<"tb_role", 'Int'>
    readonly der: FieldRef<"tb_role", 'String'>
  }
    

  // Custom InputTypes
  /**
   * tb_role findUnique
   */
  export type tb_roleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_role
     */
    select?: tb_roleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_role
     */
    omit?: tb_roleOmit<ExtArgs> | null
    /**
     * Filter, which tb_role to fetch.
     */
    where: tb_roleWhereUniqueInput
  }

  /**
   * tb_role findUniqueOrThrow
   */
  export type tb_roleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_role
     */
    select?: tb_roleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_role
     */
    omit?: tb_roleOmit<ExtArgs> | null
    /**
     * Filter, which tb_role to fetch.
     */
    where: tb_roleWhereUniqueInput
  }

  /**
   * tb_role findFirst
   */
  export type tb_roleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_role
     */
    select?: tb_roleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_role
     */
    omit?: tb_roleOmit<ExtArgs> | null
    /**
     * Filter, which tb_role to fetch.
     */
    where?: tb_roleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tb_roles to fetch.
     */
    orderBy?: tb_roleOrderByWithRelationInput | tb_roleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tb_roles.
     */
    cursor?: tb_roleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tb_roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tb_roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tb_roles.
     */
    distinct?: Tb_roleScalarFieldEnum | Tb_roleScalarFieldEnum[]
  }

  /**
   * tb_role findFirstOrThrow
   */
  export type tb_roleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_role
     */
    select?: tb_roleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_role
     */
    omit?: tb_roleOmit<ExtArgs> | null
    /**
     * Filter, which tb_role to fetch.
     */
    where?: tb_roleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tb_roles to fetch.
     */
    orderBy?: tb_roleOrderByWithRelationInput | tb_roleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tb_roles.
     */
    cursor?: tb_roleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tb_roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tb_roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tb_roles.
     */
    distinct?: Tb_roleScalarFieldEnum | Tb_roleScalarFieldEnum[]
  }

  /**
   * tb_role findMany
   */
  export type tb_roleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_role
     */
    select?: tb_roleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_role
     */
    omit?: tb_roleOmit<ExtArgs> | null
    /**
     * Filter, which tb_roles to fetch.
     */
    where?: tb_roleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tb_roles to fetch.
     */
    orderBy?: tb_roleOrderByWithRelationInput | tb_roleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing tb_roles.
     */
    cursor?: tb_roleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tb_roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tb_roles.
     */
    skip?: number
    distinct?: Tb_roleScalarFieldEnum | Tb_roleScalarFieldEnum[]
  }

  /**
   * tb_role create
   */
  export type tb_roleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_role
     */
    select?: tb_roleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_role
     */
    omit?: tb_roleOmit<ExtArgs> | null
    /**
     * The data needed to create a tb_role.
     */
    data: XOR<tb_roleCreateInput, tb_roleUncheckedCreateInput>
  }

  /**
   * tb_role createMany
   */
  export type tb_roleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many tb_roles.
     */
    data: tb_roleCreateManyInput | tb_roleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * tb_role update
   */
  export type tb_roleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_role
     */
    select?: tb_roleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_role
     */
    omit?: tb_roleOmit<ExtArgs> | null
    /**
     * The data needed to update a tb_role.
     */
    data: XOR<tb_roleUpdateInput, tb_roleUncheckedUpdateInput>
    /**
     * Choose, which tb_role to update.
     */
    where: tb_roleWhereUniqueInput
  }

  /**
   * tb_role updateMany
   */
  export type tb_roleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update tb_roles.
     */
    data: XOR<tb_roleUpdateManyMutationInput, tb_roleUncheckedUpdateManyInput>
    /**
     * Filter which tb_roles to update
     */
    where?: tb_roleWhereInput
    /**
     * Limit how many tb_roles to update.
     */
    limit?: number
  }

  /**
   * tb_role upsert
   */
  export type tb_roleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_role
     */
    select?: tb_roleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_role
     */
    omit?: tb_roleOmit<ExtArgs> | null
    /**
     * The filter to search for the tb_role to update in case it exists.
     */
    where: tb_roleWhereUniqueInput
    /**
     * In case the tb_role found by the `where` argument doesn't exist, create a new tb_role with this data.
     */
    create: XOR<tb_roleCreateInput, tb_roleUncheckedCreateInput>
    /**
     * In case the tb_role was found with the provided `where` argument, update it with this data.
     */
    update: XOR<tb_roleUpdateInput, tb_roleUncheckedUpdateInput>
  }

  /**
   * tb_role delete
   */
  export type tb_roleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_role
     */
    select?: tb_roleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_role
     */
    omit?: tb_roleOmit<ExtArgs> | null
    /**
     * Filter which tb_role to delete.
     */
    where: tb_roleWhereUniqueInput
  }

  /**
   * tb_role deleteMany
   */
  export type tb_roleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tb_roles to delete
     */
    where?: tb_roleWhereInput
    /**
     * Limit how many tb_roles to delete.
     */
    limit?: number
  }

  /**
   * tb_role without action
   */
  export type tb_roleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_role
     */
    select?: tb_roleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_role
     */
    omit?: tb_roleOmit<ExtArgs> | null
  }


  /**
   * Model tb_settlement
   */

  export type AggregateTb_settlement = {
    _count: Tb_settlementCountAggregateOutputType | null
    _avg: Tb_settlementAvgAggregateOutputType | null
    _sum: Tb_settlementSumAggregateOutputType | null
    _min: Tb_settlementMinAggregateOutputType | null
    _max: Tb_settlementMaxAggregateOutputType | null
  }

  export type Tb_settlementAvgAggregateOutputType = {
    settlement_id: number | null
    com_id: number | null
  }

  export type Tb_settlementSumAggregateOutputType = {
    settlement_id: number | null
    com_id: number | null
  }

  export type Tb_settlementMinAggregateOutputType = {
    settlement_id: number | null
    com_id: number | null
    ADM3_CODE: string | null
    ADM4_PCODE: string | null
    ADM4_ARM: string | null
    ADM4_ENG: string | null
  }

  export type Tb_settlementMaxAggregateOutputType = {
    settlement_id: number | null
    com_id: number | null
    ADM3_CODE: string | null
    ADM4_PCODE: string | null
    ADM4_ARM: string | null
    ADM4_ENG: string | null
  }

  export type Tb_settlementCountAggregateOutputType = {
    settlement_id: number
    com_id: number
    ADM3_CODE: number
    ADM4_PCODE: number
    ADM4_ARM: number
    ADM4_ENG: number
    _all: number
  }


  export type Tb_settlementAvgAggregateInputType = {
    settlement_id?: true
    com_id?: true
  }

  export type Tb_settlementSumAggregateInputType = {
    settlement_id?: true
    com_id?: true
  }

  export type Tb_settlementMinAggregateInputType = {
    settlement_id?: true
    com_id?: true
    ADM3_CODE?: true
    ADM4_PCODE?: true
    ADM4_ARM?: true
    ADM4_ENG?: true
  }

  export type Tb_settlementMaxAggregateInputType = {
    settlement_id?: true
    com_id?: true
    ADM3_CODE?: true
    ADM4_PCODE?: true
    ADM4_ARM?: true
    ADM4_ENG?: true
  }

  export type Tb_settlementCountAggregateInputType = {
    settlement_id?: true
    com_id?: true
    ADM3_CODE?: true
    ADM4_PCODE?: true
    ADM4_ARM?: true
    ADM4_ENG?: true
    _all?: true
  }

  export type Tb_settlementAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tb_settlement to aggregate.
     */
    where?: tb_settlementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tb_settlements to fetch.
     */
    orderBy?: tb_settlementOrderByWithRelationInput | tb_settlementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: tb_settlementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tb_settlements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tb_settlements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned tb_settlements
    **/
    _count?: true | Tb_settlementCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Tb_settlementAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Tb_settlementSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Tb_settlementMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Tb_settlementMaxAggregateInputType
  }

  export type GetTb_settlementAggregateType<T extends Tb_settlementAggregateArgs> = {
        [P in keyof T & keyof AggregateTb_settlement]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTb_settlement[P]>
      : GetScalarType<T[P], AggregateTb_settlement[P]>
  }




  export type tb_settlementGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: tb_settlementWhereInput
    orderBy?: tb_settlementOrderByWithAggregationInput | tb_settlementOrderByWithAggregationInput[]
    by: Tb_settlementScalarFieldEnum[] | Tb_settlementScalarFieldEnum
    having?: tb_settlementScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Tb_settlementCountAggregateInputType | true
    _avg?: Tb_settlementAvgAggregateInputType
    _sum?: Tb_settlementSumAggregateInputType
    _min?: Tb_settlementMinAggregateInputType
    _max?: Tb_settlementMaxAggregateInputType
  }

  export type Tb_settlementGroupByOutputType = {
    settlement_id: number
    com_id: number
    ADM3_CODE: string
    ADM4_PCODE: string
    ADM4_ARM: string
    ADM4_ENG: string
    _count: Tb_settlementCountAggregateOutputType | null
    _avg: Tb_settlementAvgAggregateOutputType | null
    _sum: Tb_settlementSumAggregateOutputType | null
    _min: Tb_settlementMinAggregateOutputType | null
    _max: Tb_settlementMaxAggregateOutputType | null
  }

  type GetTb_settlementGroupByPayload<T extends tb_settlementGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Tb_settlementGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Tb_settlementGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Tb_settlementGroupByOutputType[P]>
            : GetScalarType<T[P], Tb_settlementGroupByOutputType[P]>
        }
      >
    >


  export type tb_settlementSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    settlement_id?: boolean
    com_id?: boolean
    ADM3_CODE?: boolean
    ADM4_PCODE?: boolean
    ADM4_ARM?: boolean
    ADM4_ENG?: boolean
  }, ExtArgs["result"]["tb_settlement"]>



  export type tb_settlementSelectScalar = {
    settlement_id?: boolean
    com_id?: boolean
    ADM3_CODE?: boolean
    ADM4_PCODE?: boolean
    ADM4_ARM?: boolean
    ADM4_ENG?: boolean
  }

  export type tb_settlementOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"settlement_id" | "com_id" | "ADM3_CODE" | "ADM4_PCODE" | "ADM4_ARM" | "ADM4_ENG", ExtArgs["result"]["tb_settlement"]>

  export type $tb_settlementPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "tb_settlement"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      settlement_id: number
      com_id: number
      ADM3_CODE: string
      ADM4_PCODE: string
      ADM4_ARM: string
      ADM4_ENG: string
    }, ExtArgs["result"]["tb_settlement"]>
    composites: {}
  }

  type tb_settlementGetPayload<S extends boolean | null | undefined | tb_settlementDefaultArgs> = $Result.GetResult<Prisma.$tb_settlementPayload, S>

  type tb_settlementCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<tb_settlementFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Tb_settlementCountAggregateInputType | true
    }

  export interface tb_settlementDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['tb_settlement'], meta: { name: 'tb_settlement' } }
    /**
     * Find zero or one Tb_settlement that matches the filter.
     * @param {tb_settlementFindUniqueArgs} args - Arguments to find a Tb_settlement
     * @example
     * // Get one Tb_settlement
     * const tb_settlement = await prisma.tb_settlement.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends tb_settlementFindUniqueArgs>(args: SelectSubset<T, tb_settlementFindUniqueArgs<ExtArgs>>): Prisma__tb_settlementClient<$Result.GetResult<Prisma.$tb_settlementPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Tb_settlement that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {tb_settlementFindUniqueOrThrowArgs} args - Arguments to find a Tb_settlement
     * @example
     * // Get one Tb_settlement
     * const tb_settlement = await prisma.tb_settlement.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends tb_settlementFindUniqueOrThrowArgs>(args: SelectSubset<T, tb_settlementFindUniqueOrThrowArgs<ExtArgs>>): Prisma__tb_settlementClient<$Result.GetResult<Prisma.$tb_settlementPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tb_settlement that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_settlementFindFirstArgs} args - Arguments to find a Tb_settlement
     * @example
     * // Get one Tb_settlement
     * const tb_settlement = await prisma.tb_settlement.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends tb_settlementFindFirstArgs>(args?: SelectSubset<T, tb_settlementFindFirstArgs<ExtArgs>>): Prisma__tb_settlementClient<$Result.GetResult<Prisma.$tb_settlementPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tb_settlement that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_settlementFindFirstOrThrowArgs} args - Arguments to find a Tb_settlement
     * @example
     * // Get one Tb_settlement
     * const tb_settlement = await prisma.tb_settlement.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends tb_settlementFindFirstOrThrowArgs>(args?: SelectSubset<T, tb_settlementFindFirstOrThrowArgs<ExtArgs>>): Prisma__tb_settlementClient<$Result.GetResult<Prisma.$tb_settlementPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Tb_settlements that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_settlementFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tb_settlements
     * const tb_settlements = await prisma.tb_settlement.findMany()
     * 
     * // Get first 10 Tb_settlements
     * const tb_settlements = await prisma.tb_settlement.findMany({ take: 10 })
     * 
     * // Only select the `settlement_id`
     * const tb_settlementWithSettlement_idOnly = await prisma.tb_settlement.findMany({ select: { settlement_id: true } })
     * 
     */
    findMany<T extends tb_settlementFindManyArgs>(args?: SelectSubset<T, tb_settlementFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tb_settlementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Tb_settlement.
     * @param {tb_settlementCreateArgs} args - Arguments to create a Tb_settlement.
     * @example
     * // Create one Tb_settlement
     * const Tb_settlement = await prisma.tb_settlement.create({
     *   data: {
     *     // ... data to create a Tb_settlement
     *   }
     * })
     * 
     */
    create<T extends tb_settlementCreateArgs>(args: SelectSubset<T, tb_settlementCreateArgs<ExtArgs>>): Prisma__tb_settlementClient<$Result.GetResult<Prisma.$tb_settlementPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Tb_settlements.
     * @param {tb_settlementCreateManyArgs} args - Arguments to create many Tb_settlements.
     * @example
     * // Create many Tb_settlements
     * const tb_settlement = await prisma.tb_settlement.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends tb_settlementCreateManyArgs>(args?: SelectSubset<T, tb_settlementCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Tb_settlement.
     * @param {tb_settlementDeleteArgs} args - Arguments to delete one Tb_settlement.
     * @example
     * // Delete one Tb_settlement
     * const Tb_settlement = await prisma.tb_settlement.delete({
     *   where: {
     *     // ... filter to delete one Tb_settlement
     *   }
     * })
     * 
     */
    delete<T extends tb_settlementDeleteArgs>(args: SelectSubset<T, tb_settlementDeleteArgs<ExtArgs>>): Prisma__tb_settlementClient<$Result.GetResult<Prisma.$tb_settlementPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Tb_settlement.
     * @param {tb_settlementUpdateArgs} args - Arguments to update one Tb_settlement.
     * @example
     * // Update one Tb_settlement
     * const tb_settlement = await prisma.tb_settlement.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends tb_settlementUpdateArgs>(args: SelectSubset<T, tb_settlementUpdateArgs<ExtArgs>>): Prisma__tb_settlementClient<$Result.GetResult<Prisma.$tb_settlementPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Tb_settlements.
     * @param {tb_settlementDeleteManyArgs} args - Arguments to filter Tb_settlements to delete.
     * @example
     * // Delete a few Tb_settlements
     * const { count } = await prisma.tb_settlement.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends tb_settlementDeleteManyArgs>(args?: SelectSubset<T, tb_settlementDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tb_settlements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_settlementUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tb_settlements
     * const tb_settlement = await prisma.tb_settlement.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends tb_settlementUpdateManyArgs>(args: SelectSubset<T, tb_settlementUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Tb_settlement.
     * @param {tb_settlementUpsertArgs} args - Arguments to update or create a Tb_settlement.
     * @example
     * // Update or create a Tb_settlement
     * const tb_settlement = await prisma.tb_settlement.upsert({
     *   create: {
     *     // ... data to create a Tb_settlement
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tb_settlement we want to update
     *   }
     * })
     */
    upsert<T extends tb_settlementUpsertArgs>(args: SelectSubset<T, tb_settlementUpsertArgs<ExtArgs>>): Prisma__tb_settlementClient<$Result.GetResult<Prisma.$tb_settlementPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Tb_settlements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_settlementCountArgs} args - Arguments to filter Tb_settlements to count.
     * @example
     * // Count the number of Tb_settlements
     * const count = await prisma.tb_settlement.count({
     *   where: {
     *     // ... the filter for the Tb_settlements we want to count
     *   }
     * })
    **/
    count<T extends tb_settlementCountArgs>(
      args?: Subset<T, tb_settlementCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Tb_settlementCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tb_settlement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Tb_settlementAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Tb_settlementAggregateArgs>(args: Subset<T, Tb_settlementAggregateArgs>): Prisma.PrismaPromise<GetTb_settlementAggregateType<T>>

    /**
     * Group by Tb_settlement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_settlementGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends tb_settlementGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: tb_settlementGroupByArgs['orderBy'] }
        : { orderBy?: tb_settlementGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, tb_settlementGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTb_settlementGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the tb_settlement model
   */
  readonly fields: tb_settlementFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for tb_settlement.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__tb_settlementClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the tb_settlement model
   */
  interface tb_settlementFieldRefs {
    readonly settlement_id: FieldRef<"tb_settlement", 'Int'>
    readonly com_id: FieldRef<"tb_settlement", 'Int'>
    readonly ADM3_CODE: FieldRef<"tb_settlement", 'String'>
    readonly ADM4_PCODE: FieldRef<"tb_settlement", 'String'>
    readonly ADM4_ARM: FieldRef<"tb_settlement", 'String'>
    readonly ADM4_ENG: FieldRef<"tb_settlement", 'String'>
  }
    

  // Custom InputTypes
  /**
   * tb_settlement findUnique
   */
  export type tb_settlementFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_settlement
     */
    select?: tb_settlementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_settlement
     */
    omit?: tb_settlementOmit<ExtArgs> | null
    /**
     * Filter, which tb_settlement to fetch.
     */
    where: tb_settlementWhereUniqueInput
  }

  /**
   * tb_settlement findUniqueOrThrow
   */
  export type tb_settlementFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_settlement
     */
    select?: tb_settlementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_settlement
     */
    omit?: tb_settlementOmit<ExtArgs> | null
    /**
     * Filter, which tb_settlement to fetch.
     */
    where: tb_settlementWhereUniqueInput
  }

  /**
   * tb_settlement findFirst
   */
  export type tb_settlementFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_settlement
     */
    select?: tb_settlementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_settlement
     */
    omit?: tb_settlementOmit<ExtArgs> | null
    /**
     * Filter, which tb_settlement to fetch.
     */
    where?: tb_settlementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tb_settlements to fetch.
     */
    orderBy?: tb_settlementOrderByWithRelationInput | tb_settlementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tb_settlements.
     */
    cursor?: tb_settlementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tb_settlements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tb_settlements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tb_settlements.
     */
    distinct?: Tb_settlementScalarFieldEnum | Tb_settlementScalarFieldEnum[]
  }

  /**
   * tb_settlement findFirstOrThrow
   */
  export type tb_settlementFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_settlement
     */
    select?: tb_settlementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_settlement
     */
    omit?: tb_settlementOmit<ExtArgs> | null
    /**
     * Filter, which tb_settlement to fetch.
     */
    where?: tb_settlementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tb_settlements to fetch.
     */
    orderBy?: tb_settlementOrderByWithRelationInput | tb_settlementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tb_settlements.
     */
    cursor?: tb_settlementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tb_settlements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tb_settlements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tb_settlements.
     */
    distinct?: Tb_settlementScalarFieldEnum | Tb_settlementScalarFieldEnum[]
  }

  /**
   * tb_settlement findMany
   */
  export type tb_settlementFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_settlement
     */
    select?: tb_settlementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_settlement
     */
    omit?: tb_settlementOmit<ExtArgs> | null
    /**
     * Filter, which tb_settlements to fetch.
     */
    where?: tb_settlementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tb_settlements to fetch.
     */
    orderBy?: tb_settlementOrderByWithRelationInput | tb_settlementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing tb_settlements.
     */
    cursor?: tb_settlementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tb_settlements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tb_settlements.
     */
    skip?: number
    distinct?: Tb_settlementScalarFieldEnum | Tb_settlementScalarFieldEnum[]
  }

  /**
   * tb_settlement create
   */
  export type tb_settlementCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_settlement
     */
    select?: tb_settlementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_settlement
     */
    omit?: tb_settlementOmit<ExtArgs> | null
    /**
     * The data needed to create a tb_settlement.
     */
    data: XOR<tb_settlementCreateInput, tb_settlementUncheckedCreateInput>
  }

  /**
   * tb_settlement createMany
   */
  export type tb_settlementCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many tb_settlements.
     */
    data: tb_settlementCreateManyInput | tb_settlementCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * tb_settlement update
   */
  export type tb_settlementUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_settlement
     */
    select?: tb_settlementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_settlement
     */
    omit?: tb_settlementOmit<ExtArgs> | null
    /**
     * The data needed to update a tb_settlement.
     */
    data: XOR<tb_settlementUpdateInput, tb_settlementUncheckedUpdateInput>
    /**
     * Choose, which tb_settlement to update.
     */
    where: tb_settlementWhereUniqueInput
  }

  /**
   * tb_settlement updateMany
   */
  export type tb_settlementUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update tb_settlements.
     */
    data: XOR<tb_settlementUpdateManyMutationInput, tb_settlementUncheckedUpdateManyInput>
    /**
     * Filter which tb_settlements to update
     */
    where?: tb_settlementWhereInput
    /**
     * Limit how many tb_settlements to update.
     */
    limit?: number
  }

  /**
   * tb_settlement upsert
   */
  export type tb_settlementUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_settlement
     */
    select?: tb_settlementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_settlement
     */
    omit?: tb_settlementOmit<ExtArgs> | null
    /**
     * The filter to search for the tb_settlement to update in case it exists.
     */
    where: tb_settlementWhereUniqueInput
    /**
     * In case the tb_settlement found by the `where` argument doesn't exist, create a new tb_settlement with this data.
     */
    create: XOR<tb_settlementCreateInput, tb_settlementUncheckedCreateInput>
    /**
     * In case the tb_settlement was found with the provided `where` argument, update it with this data.
     */
    update: XOR<tb_settlementUpdateInput, tb_settlementUncheckedUpdateInput>
  }

  /**
   * tb_settlement delete
   */
  export type tb_settlementDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_settlement
     */
    select?: tb_settlementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_settlement
     */
    omit?: tb_settlementOmit<ExtArgs> | null
    /**
     * Filter which tb_settlement to delete.
     */
    where: tb_settlementWhereUniqueInput
  }

  /**
   * tb_settlement deleteMany
   */
  export type tb_settlementDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tb_settlements to delete
     */
    where?: tb_settlementWhereInput
    /**
     * Limit how many tb_settlements to delete.
     */
    limit?: number
  }

  /**
   * tb_settlement without action
   */
  export type tb_settlementDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_settlement
     */
    select?: tb_settlementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_settlement
     */
    omit?: tb_settlementOmit<ExtArgs> | null
  }


  /**
   * Model tb_settlement_
   */

  export type AggregateTb_settlement_ = {
    _count: Tb_settlement_CountAggregateOutputType | null
    _avg: Tb_settlement_AvgAggregateOutputType | null
    _sum: Tb_settlement_SumAggregateOutputType | null
    _min: Tb_settlement_MinAggregateOutputType | null
    _max: Tb_settlement_MaxAggregateOutputType | null
  }

  export type Tb_settlement_AvgAggregateOutputType = {
    settlement_id: number | null
    com_id: number | null
    active: number | null
  }

  export type Tb_settlement_SumAggregateOutputType = {
    settlement_id: number | null
    com_id: number | null
    active: number | null
  }

  export type Tb_settlement_MinAggregateOutputType = {
    settlement_id: number | null
    com_id: number | null
    ADM3_CODE: string | null
    ADM4_PCODE: string | null
    ADM4_ARM: string | null
    ADM4_ENG: string | null
    active: number | null
  }

  export type Tb_settlement_MaxAggregateOutputType = {
    settlement_id: number | null
    com_id: number | null
    ADM3_CODE: string | null
    ADM4_PCODE: string | null
    ADM4_ARM: string | null
    ADM4_ENG: string | null
    active: number | null
  }

  export type Tb_settlement_CountAggregateOutputType = {
    settlement_id: number
    com_id: number
    ADM3_CODE: number
    ADM4_PCODE: number
    ADM4_ARM: number
    ADM4_ENG: number
    active: number
    _all: number
  }


  export type Tb_settlement_AvgAggregateInputType = {
    settlement_id?: true
    com_id?: true
    active?: true
  }

  export type Tb_settlement_SumAggregateInputType = {
    settlement_id?: true
    com_id?: true
    active?: true
  }

  export type Tb_settlement_MinAggregateInputType = {
    settlement_id?: true
    com_id?: true
    ADM3_CODE?: true
    ADM4_PCODE?: true
    ADM4_ARM?: true
    ADM4_ENG?: true
    active?: true
  }

  export type Tb_settlement_MaxAggregateInputType = {
    settlement_id?: true
    com_id?: true
    ADM3_CODE?: true
    ADM4_PCODE?: true
    ADM4_ARM?: true
    ADM4_ENG?: true
    active?: true
  }

  export type Tb_settlement_CountAggregateInputType = {
    settlement_id?: true
    com_id?: true
    ADM3_CODE?: true
    ADM4_PCODE?: true
    ADM4_ARM?: true
    ADM4_ENG?: true
    active?: true
    _all?: true
  }

  export type Tb_settlement_AggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tb_settlement_ to aggregate.
     */
    where?: tb_settlement_WhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tb_settlement_s to fetch.
     */
    orderBy?: tb_settlement_OrderByWithRelationInput | tb_settlement_OrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: tb_settlement_WhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tb_settlement_s from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tb_settlement_s.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned tb_settlement_s
    **/
    _count?: true | Tb_settlement_CountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Tb_settlement_AvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Tb_settlement_SumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Tb_settlement_MinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Tb_settlement_MaxAggregateInputType
  }

  export type GetTb_settlement_AggregateType<T extends Tb_settlement_AggregateArgs> = {
        [P in keyof T & keyof AggregateTb_settlement_]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTb_settlement_[P]>
      : GetScalarType<T[P], AggregateTb_settlement_[P]>
  }




  export type tb_settlement_GroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: tb_settlement_WhereInput
    orderBy?: tb_settlement_OrderByWithAggregationInput | tb_settlement_OrderByWithAggregationInput[]
    by: Tb_settlement_ScalarFieldEnum[] | Tb_settlement_ScalarFieldEnum
    having?: tb_settlement_ScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Tb_settlement_CountAggregateInputType | true
    _avg?: Tb_settlement_AvgAggregateInputType
    _sum?: Tb_settlement_SumAggregateInputType
    _min?: Tb_settlement_MinAggregateInputType
    _max?: Tb_settlement_MaxAggregateInputType
  }

  export type Tb_settlement_GroupByOutputType = {
    settlement_id: number
    com_id: number
    ADM3_CODE: string
    ADM4_PCODE: string
    ADM4_ARM: string
    ADM4_ENG: string
    active: number
    _count: Tb_settlement_CountAggregateOutputType | null
    _avg: Tb_settlement_AvgAggregateOutputType | null
    _sum: Tb_settlement_SumAggregateOutputType | null
    _min: Tb_settlement_MinAggregateOutputType | null
    _max: Tb_settlement_MaxAggregateOutputType | null
  }

  type GetTb_settlement_GroupByPayload<T extends tb_settlement_GroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Tb_settlement_GroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Tb_settlement_GroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Tb_settlement_GroupByOutputType[P]>
            : GetScalarType<T[P], Tb_settlement_GroupByOutputType[P]>
        }
      >
    >


  export type tb_settlement_Select<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    settlement_id?: boolean
    com_id?: boolean
    ADM3_CODE?: boolean
    ADM4_PCODE?: boolean
    ADM4_ARM?: boolean
    ADM4_ENG?: boolean
    active?: boolean
  }, ExtArgs["result"]["tb_settlement_"]>



  export type tb_settlement_SelectScalar = {
    settlement_id?: boolean
    com_id?: boolean
    ADM3_CODE?: boolean
    ADM4_PCODE?: boolean
    ADM4_ARM?: boolean
    ADM4_ENG?: boolean
    active?: boolean
  }

  export type tb_settlement_Omit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"settlement_id" | "com_id" | "ADM3_CODE" | "ADM4_PCODE" | "ADM4_ARM" | "ADM4_ENG" | "active", ExtArgs["result"]["tb_settlement_"]>

  export type $tb_settlement_Payload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "tb_settlement_"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      settlement_id: number
      com_id: number
      ADM3_CODE: string
      ADM4_PCODE: string
      ADM4_ARM: string
      ADM4_ENG: string
      active: number
    }, ExtArgs["result"]["tb_settlement_"]>
    composites: {}
  }

  type tb_settlement_GetPayload<S extends boolean | null | undefined | tb_settlement_DefaultArgs> = $Result.GetResult<Prisma.$tb_settlement_Payload, S>

  type tb_settlement_CountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<tb_settlement_FindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Tb_settlement_CountAggregateInputType | true
    }

  export interface tb_settlement_Delegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['tb_settlement_'], meta: { name: 'tb_settlement_' } }
    /**
     * Find zero or one Tb_settlement_ that matches the filter.
     * @param {tb_settlement_FindUniqueArgs} args - Arguments to find a Tb_settlement_
     * @example
     * // Get one Tb_settlement_
     * const tb_settlement_ = await prisma.tb_settlement_.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends tb_settlement_FindUniqueArgs>(args: SelectSubset<T, tb_settlement_FindUniqueArgs<ExtArgs>>): Prisma__tb_settlement_Client<$Result.GetResult<Prisma.$tb_settlement_Payload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Tb_settlement_ that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {tb_settlement_FindUniqueOrThrowArgs} args - Arguments to find a Tb_settlement_
     * @example
     * // Get one Tb_settlement_
     * const tb_settlement_ = await prisma.tb_settlement_.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends tb_settlement_FindUniqueOrThrowArgs>(args: SelectSubset<T, tb_settlement_FindUniqueOrThrowArgs<ExtArgs>>): Prisma__tb_settlement_Client<$Result.GetResult<Prisma.$tb_settlement_Payload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tb_settlement_ that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_settlement_FindFirstArgs} args - Arguments to find a Tb_settlement_
     * @example
     * // Get one Tb_settlement_
     * const tb_settlement_ = await prisma.tb_settlement_.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends tb_settlement_FindFirstArgs>(args?: SelectSubset<T, tb_settlement_FindFirstArgs<ExtArgs>>): Prisma__tb_settlement_Client<$Result.GetResult<Prisma.$tb_settlement_Payload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tb_settlement_ that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_settlement_FindFirstOrThrowArgs} args - Arguments to find a Tb_settlement_
     * @example
     * // Get one Tb_settlement_
     * const tb_settlement_ = await prisma.tb_settlement_.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends tb_settlement_FindFirstOrThrowArgs>(args?: SelectSubset<T, tb_settlement_FindFirstOrThrowArgs<ExtArgs>>): Prisma__tb_settlement_Client<$Result.GetResult<Prisma.$tb_settlement_Payload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Tb_settlement_s that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_settlement_FindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tb_settlement_s
     * const tb_settlement_s = await prisma.tb_settlement_.findMany()
     * 
     * // Get first 10 Tb_settlement_s
     * const tb_settlement_s = await prisma.tb_settlement_.findMany({ take: 10 })
     * 
     * // Only select the `settlement_id`
     * const tb_settlement_WithSettlement_idOnly = await prisma.tb_settlement_.findMany({ select: { settlement_id: true } })
     * 
     */
    findMany<T extends tb_settlement_FindManyArgs>(args?: SelectSubset<T, tb_settlement_FindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tb_settlement_Payload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Tb_settlement_.
     * @param {tb_settlement_CreateArgs} args - Arguments to create a Tb_settlement_.
     * @example
     * // Create one Tb_settlement_
     * const Tb_settlement_ = await prisma.tb_settlement_.create({
     *   data: {
     *     // ... data to create a Tb_settlement_
     *   }
     * })
     * 
     */
    create<T extends tb_settlement_CreateArgs>(args: SelectSubset<T, tb_settlement_CreateArgs<ExtArgs>>): Prisma__tb_settlement_Client<$Result.GetResult<Prisma.$tb_settlement_Payload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Tb_settlement_s.
     * @param {tb_settlement_CreateManyArgs} args - Arguments to create many Tb_settlement_s.
     * @example
     * // Create many Tb_settlement_s
     * const tb_settlement_ = await prisma.tb_settlement_.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends tb_settlement_CreateManyArgs>(args?: SelectSubset<T, tb_settlement_CreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Tb_settlement_.
     * @param {tb_settlement_DeleteArgs} args - Arguments to delete one Tb_settlement_.
     * @example
     * // Delete one Tb_settlement_
     * const Tb_settlement_ = await prisma.tb_settlement_.delete({
     *   where: {
     *     // ... filter to delete one Tb_settlement_
     *   }
     * })
     * 
     */
    delete<T extends tb_settlement_DeleteArgs>(args: SelectSubset<T, tb_settlement_DeleteArgs<ExtArgs>>): Prisma__tb_settlement_Client<$Result.GetResult<Prisma.$tb_settlement_Payload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Tb_settlement_.
     * @param {tb_settlement_UpdateArgs} args - Arguments to update one Tb_settlement_.
     * @example
     * // Update one Tb_settlement_
     * const tb_settlement_ = await prisma.tb_settlement_.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends tb_settlement_UpdateArgs>(args: SelectSubset<T, tb_settlement_UpdateArgs<ExtArgs>>): Prisma__tb_settlement_Client<$Result.GetResult<Prisma.$tb_settlement_Payload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Tb_settlement_s.
     * @param {tb_settlement_DeleteManyArgs} args - Arguments to filter Tb_settlement_s to delete.
     * @example
     * // Delete a few Tb_settlement_s
     * const { count } = await prisma.tb_settlement_.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends tb_settlement_DeleteManyArgs>(args?: SelectSubset<T, tb_settlement_DeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tb_settlement_s.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_settlement_UpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tb_settlement_s
     * const tb_settlement_ = await prisma.tb_settlement_.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends tb_settlement_UpdateManyArgs>(args: SelectSubset<T, tb_settlement_UpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Tb_settlement_.
     * @param {tb_settlement_UpsertArgs} args - Arguments to update or create a Tb_settlement_.
     * @example
     * // Update or create a Tb_settlement_
     * const tb_settlement_ = await prisma.tb_settlement_.upsert({
     *   create: {
     *     // ... data to create a Tb_settlement_
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tb_settlement_ we want to update
     *   }
     * })
     */
    upsert<T extends tb_settlement_UpsertArgs>(args: SelectSubset<T, tb_settlement_UpsertArgs<ExtArgs>>): Prisma__tb_settlement_Client<$Result.GetResult<Prisma.$tb_settlement_Payload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Tb_settlement_s.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_settlement_CountArgs} args - Arguments to filter Tb_settlement_s to count.
     * @example
     * // Count the number of Tb_settlement_s
     * const count = await prisma.tb_settlement_.count({
     *   where: {
     *     // ... the filter for the Tb_settlement_s we want to count
     *   }
     * })
    **/
    count<T extends tb_settlement_CountArgs>(
      args?: Subset<T, tb_settlement_CountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Tb_settlement_CountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tb_settlement_.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Tb_settlement_AggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Tb_settlement_AggregateArgs>(args: Subset<T, Tb_settlement_AggregateArgs>): Prisma.PrismaPromise<GetTb_settlement_AggregateType<T>>

    /**
     * Group by Tb_settlement_.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_settlement_GroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends tb_settlement_GroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: tb_settlement_GroupByArgs['orderBy'] }
        : { orderBy?: tb_settlement_GroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, tb_settlement_GroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTb_settlement_GroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the tb_settlement_ model
   */
  readonly fields: tb_settlement_FieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for tb_settlement_.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__tb_settlement_Client<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the tb_settlement_ model
   */
  interface tb_settlement_FieldRefs {
    readonly settlement_id: FieldRef<"tb_settlement_", 'Int'>
    readonly com_id: FieldRef<"tb_settlement_", 'Int'>
    readonly ADM3_CODE: FieldRef<"tb_settlement_", 'String'>
    readonly ADM4_PCODE: FieldRef<"tb_settlement_", 'String'>
    readonly ADM4_ARM: FieldRef<"tb_settlement_", 'String'>
    readonly ADM4_ENG: FieldRef<"tb_settlement_", 'String'>
    readonly active: FieldRef<"tb_settlement_", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * tb_settlement_ findUnique
   */
  export type tb_settlement_FindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_settlement_
     */
    select?: tb_settlement_Select<ExtArgs> | null
    /**
     * Omit specific fields from the tb_settlement_
     */
    omit?: tb_settlement_Omit<ExtArgs> | null
    /**
     * Filter, which tb_settlement_ to fetch.
     */
    where: tb_settlement_WhereUniqueInput
  }

  /**
   * tb_settlement_ findUniqueOrThrow
   */
  export type tb_settlement_FindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_settlement_
     */
    select?: tb_settlement_Select<ExtArgs> | null
    /**
     * Omit specific fields from the tb_settlement_
     */
    omit?: tb_settlement_Omit<ExtArgs> | null
    /**
     * Filter, which tb_settlement_ to fetch.
     */
    where: tb_settlement_WhereUniqueInput
  }

  /**
   * tb_settlement_ findFirst
   */
  export type tb_settlement_FindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_settlement_
     */
    select?: tb_settlement_Select<ExtArgs> | null
    /**
     * Omit specific fields from the tb_settlement_
     */
    omit?: tb_settlement_Omit<ExtArgs> | null
    /**
     * Filter, which tb_settlement_ to fetch.
     */
    where?: tb_settlement_WhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tb_settlement_s to fetch.
     */
    orderBy?: tb_settlement_OrderByWithRelationInput | tb_settlement_OrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tb_settlement_s.
     */
    cursor?: tb_settlement_WhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tb_settlement_s from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tb_settlement_s.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tb_settlement_s.
     */
    distinct?: Tb_settlement_ScalarFieldEnum | Tb_settlement_ScalarFieldEnum[]
  }

  /**
   * tb_settlement_ findFirstOrThrow
   */
  export type tb_settlement_FindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_settlement_
     */
    select?: tb_settlement_Select<ExtArgs> | null
    /**
     * Omit specific fields from the tb_settlement_
     */
    omit?: tb_settlement_Omit<ExtArgs> | null
    /**
     * Filter, which tb_settlement_ to fetch.
     */
    where?: tb_settlement_WhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tb_settlement_s to fetch.
     */
    orderBy?: tb_settlement_OrderByWithRelationInput | tb_settlement_OrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tb_settlement_s.
     */
    cursor?: tb_settlement_WhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tb_settlement_s from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tb_settlement_s.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tb_settlement_s.
     */
    distinct?: Tb_settlement_ScalarFieldEnum | Tb_settlement_ScalarFieldEnum[]
  }

  /**
   * tb_settlement_ findMany
   */
  export type tb_settlement_FindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_settlement_
     */
    select?: tb_settlement_Select<ExtArgs> | null
    /**
     * Omit specific fields from the tb_settlement_
     */
    omit?: tb_settlement_Omit<ExtArgs> | null
    /**
     * Filter, which tb_settlement_s to fetch.
     */
    where?: tb_settlement_WhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tb_settlement_s to fetch.
     */
    orderBy?: tb_settlement_OrderByWithRelationInput | tb_settlement_OrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing tb_settlement_s.
     */
    cursor?: tb_settlement_WhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tb_settlement_s from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tb_settlement_s.
     */
    skip?: number
    distinct?: Tb_settlement_ScalarFieldEnum | Tb_settlement_ScalarFieldEnum[]
  }

  /**
   * tb_settlement_ create
   */
  export type tb_settlement_CreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_settlement_
     */
    select?: tb_settlement_Select<ExtArgs> | null
    /**
     * Omit specific fields from the tb_settlement_
     */
    omit?: tb_settlement_Omit<ExtArgs> | null
    /**
     * The data needed to create a tb_settlement_.
     */
    data: XOR<tb_settlement_CreateInput, tb_settlement_UncheckedCreateInput>
  }

  /**
   * tb_settlement_ createMany
   */
  export type tb_settlement_CreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many tb_settlement_s.
     */
    data: tb_settlement_CreateManyInput | tb_settlement_CreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * tb_settlement_ update
   */
  export type tb_settlement_UpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_settlement_
     */
    select?: tb_settlement_Select<ExtArgs> | null
    /**
     * Omit specific fields from the tb_settlement_
     */
    omit?: tb_settlement_Omit<ExtArgs> | null
    /**
     * The data needed to update a tb_settlement_.
     */
    data: XOR<tb_settlement_UpdateInput, tb_settlement_UncheckedUpdateInput>
    /**
     * Choose, which tb_settlement_ to update.
     */
    where: tb_settlement_WhereUniqueInput
  }

  /**
   * tb_settlement_ updateMany
   */
  export type tb_settlement_UpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update tb_settlement_s.
     */
    data: XOR<tb_settlement_UpdateManyMutationInput, tb_settlement_UncheckedUpdateManyInput>
    /**
     * Filter which tb_settlement_s to update
     */
    where?: tb_settlement_WhereInput
    /**
     * Limit how many tb_settlement_s to update.
     */
    limit?: number
  }

  /**
   * tb_settlement_ upsert
   */
  export type tb_settlement_UpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_settlement_
     */
    select?: tb_settlement_Select<ExtArgs> | null
    /**
     * Omit specific fields from the tb_settlement_
     */
    omit?: tb_settlement_Omit<ExtArgs> | null
    /**
     * The filter to search for the tb_settlement_ to update in case it exists.
     */
    where: tb_settlement_WhereUniqueInput
    /**
     * In case the tb_settlement_ found by the `where` argument doesn't exist, create a new tb_settlement_ with this data.
     */
    create: XOR<tb_settlement_CreateInput, tb_settlement_UncheckedCreateInput>
    /**
     * In case the tb_settlement_ was found with the provided `where` argument, update it with this data.
     */
    update: XOR<tb_settlement_UpdateInput, tb_settlement_UncheckedUpdateInput>
  }

  /**
   * tb_settlement_ delete
   */
  export type tb_settlement_DeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_settlement_
     */
    select?: tb_settlement_Select<ExtArgs> | null
    /**
     * Omit specific fields from the tb_settlement_
     */
    omit?: tb_settlement_Omit<ExtArgs> | null
    /**
     * Filter which tb_settlement_ to delete.
     */
    where: tb_settlement_WhereUniqueInput
  }

  /**
   * tb_settlement_ deleteMany
   */
  export type tb_settlement_DeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tb_settlement_s to delete
     */
    where?: tb_settlement_WhereInput
    /**
     * Limit how many tb_settlement_s to delete.
     */
    limit?: number
  }

  /**
   * tb_settlement_ without action
   */
  export type tb_settlement_DefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_settlement_
     */
    select?: tb_settlement_Select<ExtArgs> | null
    /**
     * Omit specific fields from the tb_settlement_
     */
    omit?: tb_settlement_Omit<ExtArgs> | null
  }


  /**
   * Model tb_sign_status
   */

  export type AggregateTb_sign_status = {
    _count: Tb_sign_statusCountAggregateOutputType | null
    _avg: Tb_sign_statusAvgAggregateOutputType | null
    _sum: Tb_sign_statusSumAggregateOutputType | null
    _min: Tb_sign_statusMinAggregateOutputType | null
    _max: Tb_sign_statusMaxAggregateOutputType | null
  }

  export type Tb_sign_statusAvgAggregateOutputType = {
    status_id: number | null
  }

  export type Tb_sign_statusSumAggregateOutputType = {
    status_id: number | null
  }

  export type Tb_sign_statusMinAggregateOutputType = {
    status_id: number | null
    status: string | null
  }

  export type Tb_sign_statusMaxAggregateOutputType = {
    status_id: number | null
    status: string | null
  }

  export type Tb_sign_statusCountAggregateOutputType = {
    status_id: number
    status: number
    _all: number
  }


  export type Tb_sign_statusAvgAggregateInputType = {
    status_id?: true
  }

  export type Tb_sign_statusSumAggregateInputType = {
    status_id?: true
  }

  export type Tb_sign_statusMinAggregateInputType = {
    status_id?: true
    status?: true
  }

  export type Tb_sign_statusMaxAggregateInputType = {
    status_id?: true
    status?: true
  }

  export type Tb_sign_statusCountAggregateInputType = {
    status_id?: true
    status?: true
    _all?: true
  }

  export type Tb_sign_statusAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tb_sign_status to aggregate.
     */
    where?: tb_sign_statusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tb_sign_statuses to fetch.
     */
    orderBy?: tb_sign_statusOrderByWithRelationInput | tb_sign_statusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: tb_sign_statusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tb_sign_statuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tb_sign_statuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned tb_sign_statuses
    **/
    _count?: true | Tb_sign_statusCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Tb_sign_statusAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Tb_sign_statusSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Tb_sign_statusMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Tb_sign_statusMaxAggregateInputType
  }

  export type GetTb_sign_statusAggregateType<T extends Tb_sign_statusAggregateArgs> = {
        [P in keyof T & keyof AggregateTb_sign_status]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTb_sign_status[P]>
      : GetScalarType<T[P], AggregateTb_sign_status[P]>
  }




  export type tb_sign_statusGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: tb_sign_statusWhereInput
    orderBy?: tb_sign_statusOrderByWithAggregationInput | tb_sign_statusOrderByWithAggregationInput[]
    by: Tb_sign_statusScalarFieldEnum[] | Tb_sign_statusScalarFieldEnum
    having?: tb_sign_statusScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Tb_sign_statusCountAggregateInputType | true
    _avg?: Tb_sign_statusAvgAggregateInputType
    _sum?: Tb_sign_statusSumAggregateInputType
    _min?: Tb_sign_statusMinAggregateInputType
    _max?: Tb_sign_statusMaxAggregateInputType
  }

  export type Tb_sign_statusGroupByOutputType = {
    status_id: number
    status: string
    _count: Tb_sign_statusCountAggregateOutputType | null
    _avg: Tb_sign_statusAvgAggregateOutputType | null
    _sum: Tb_sign_statusSumAggregateOutputType | null
    _min: Tb_sign_statusMinAggregateOutputType | null
    _max: Tb_sign_statusMaxAggregateOutputType | null
  }

  type GetTb_sign_statusGroupByPayload<T extends tb_sign_statusGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Tb_sign_statusGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Tb_sign_statusGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Tb_sign_statusGroupByOutputType[P]>
            : GetScalarType<T[P], Tb_sign_statusGroupByOutputType[P]>
        }
      >
    >


  export type tb_sign_statusSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    status_id?: boolean
    status?: boolean
  }, ExtArgs["result"]["tb_sign_status"]>



  export type tb_sign_statusSelectScalar = {
    status_id?: boolean
    status?: boolean
  }

  export type tb_sign_statusOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"status_id" | "status", ExtArgs["result"]["tb_sign_status"]>

  export type $tb_sign_statusPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "tb_sign_status"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      status_id: number
      status: string
    }, ExtArgs["result"]["tb_sign_status"]>
    composites: {}
  }

  type tb_sign_statusGetPayload<S extends boolean | null | undefined | tb_sign_statusDefaultArgs> = $Result.GetResult<Prisma.$tb_sign_statusPayload, S>

  type tb_sign_statusCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<tb_sign_statusFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Tb_sign_statusCountAggregateInputType | true
    }

  export interface tb_sign_statusDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['tb_sign_status'], meta: { name: 'tb_sign_status' } }
    /**
     * Find zero or one Tb_sign_status that matches the filter.
     * @param {tb_sign_statusFindUniqueArgs} args - Arguments to find a Tb_sign_status
     * @example
     * // Get one Tb_sign_status
     * const tb_sign_status = await prisma.tb_sign_status.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends tb_sign_statusFindUniqueArgs>(args: SelectSubset<T, tb_sign_statusFindUniqueArgs<ExtArgs>>): Prisma__tb_sign_statusClient<$Result.GetResult<Prisma.$tb_sign_statusPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Tb_sign_status that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {tb_sign_statusFindUniqueOrThrowArgs} args - Arguments to find a Tb_sign_status
     * @example
     * // Get one Tb_sign_status
     * const tb_sign_status = await prisma.tb_sign_status.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends tb_sign_statusFindUniqueOrThrowArgs>(args: SelectSubset<T, tb_sign_statusFindUniqueOrThrowArgs<ExtArgs>>): Prisma__tb_sign_statusClient<$Result.GetResult<Prisma.$tb_sign_statusPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tb_sign_status that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_sign_statusFindFirstArgs} args - Arguments to find a Tb_sign_status
     * @example
     * // Get one Tb_sign_status
     * const tb_sign_status = await prisma.tb_sign_status.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends tb_sign_statusFindFirstArgs>(args?: SelectSubset<T, tb_sign_statusFindFirstArgs<ExtArgs>>): Prisma__tb_sign_statusClient<$Result.GetResult<Prisma.$tb_sign_statusPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tb_sign_status that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_sign_statusFindFirstOrThrowArgs} args - Arguments to find a Tb_sign_status
     * @example
     * // Get one Tb_sign_status
     * const tb_sign_status = await prisma.tb_sign_status.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends tb_sign_statusFindFirstOrThrowArgs>(args?: SelectSubset<T, tb_sign_statusFindFirstOrThrowArgs<ExtArgs>>): Prisma__tb_sign_statusClient<$Result.GetResult<Prisma.$tb_sign_statusPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Tb_sign_statuses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_sign_statusFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tb_sign_statuses
     * const tb_sign_statuses = await prisma.tb_sign_status.findMany()
     * 
     * // Get first 10 Tb_sign_statuses
     * const tb_sign_statuses = await prisma.tb_sign_status.findMany({ take: 10 })
     * 
     * // Only select the `status_id`
     * const tb_sign_statusWithStatus_idOnly = await prisma.tb_sign_status.findMany({ select: { status_id: true } })
     * 
     */
    findMany<T extends tb_sign_statusFindManyArgs>(args?: SelectSubset<T, tb_sign_statusFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tb_sign_statusPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Tb_sign_status.
     * @param {tb_sign_statusCreateArgs} args - Arguments to create a Tb_sign_status.
     * @example
     * // Create one Tb_sign_status
     * const Tb_sign_status = await prisma.tb_sign_status.create({
     *   data: {
     *     // ... data to create a Tb_sign_status
     *   }
     * })
     * 
     */
    create<T extends tb_sign_statusCreateArgs>(args: SelectSubset<T, tb_sign_statusCreateArgs<ExtArgs>>): Prisma__tb_sign_statusClient<$Result.GetResult<Prisma.$tb_sign_statusPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Tb_sign_statuses.
     * @param {tb_sign_statusCreateManyArgs} args - Arguments to create many Tb_sign_statuses.
     * @example
     * // Create many Tb_sign_statuses
     * const tb_sign_status = await prisma.tb_sign_status.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends tb_sign_statusCreateManyArgs>(args?: SelectSubset<T, tb_sign_statusCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Tb_sign_status.
     * @param {tb_sign_statusDeleteArgs} args - Arguments to delete one Tb_sign_status.
     * @example
     * // Delete one Tb_sign_status
     * const Tb_sign_status = await prisma.tb_sign_status.delete({
     *   where: {
     *     // ... filter to delete one Tb_sign_status
     *   }
     * })
     * 
     */
    delete<T extends tb_sign_statusDeleteArgs>(args: SelectSubset<T, tb_sign_statusDeleteArgs<ExtArgs>>): Prisma__tb_sign_statusClient<$Result.GetResult<Prisma.$tb_sign_statusPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Tb_sign_status.
     * @param {tb_sign_statusUpdateArgs} args - Arguments to update one Tb_sign_status.
     * @example
     * // Update one Tb_sign_status
     * const tb_sign_status = await prisma.tb_sign_status.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends tb_sign_statusUpdateArgs>(args: SelectSubset<T, tb_sign_statusUpdateArgs<ExtArgs>>): Prisma__tb_sign_statusClient<$Result.GetResult<Prisma.$tb_sign_statusPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Tb_sign_statuses.
     * @param {tb_sign_statusDeleteManyArgs} args - Arguments to filter Tb_sign_statuses to delete.
     * @example
     * // Delete a few Tb_sign_statuses
     * const { count } = await prisma.tb_sign_status.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends tb_sign_statusDeleteManyArgs>(args?: SelectSubset<T, tb_sign_statusDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tb_sign_statuses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_sign_statusUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tb_sign_statuses
     * const tb_sign_status = await prisma.tb_sign_status.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends tb_sign_statusUpdateManyArgs>(args: SelectSubset<T, tb_sign_statusUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Tb_sign_status.
     * @param {tb_sign_statusUpsertArgs} args - Arguments to update or create a Tb_sign_status.
     * @example
     * // Update or create a Tb_sign_status
     * const tb_sign_status = await prisma.tb_sign_status.upsert({
     *   create: {
     *     // ... data to create a Tb_sign_status
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tb_sign_status we want to update
     *   }
     * })
     */
    upsert<T extends tb_sign_statusUpsertArgs>(args: SelectSubset<T, tb_sign_statusUpsertArgs<ExtArgs>>): Prisma__tb_sign_statusClient<$Result.GetResult<Prisma.$tb_sign_statusPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Tb_sign_statuses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_sign_statusCountArgs} args - Arguments to filter Tb_sign_statuses to count.
     * @example
     * // Count the number of Tb_sign_statuses
     * const count = await prisma.tb_sign_status.count({
     *   where: {
     *     // ... the filter for the Tb_sign_statuses we want to count
     *   }
     * })
    **/
    count<T extends tb_sign_statusCountArgs>(
      args?: Subset<T, tb_sign_statusCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Tb_sign_statusCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tb_sign_status.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Tb_sign_statusAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Tb_sign_statusAggregateArgs>(args: Subset<T, Tb_sign_statusAggregateArgs>): Prisma.PrismaPromise<GetTb_sign_statusAggregateType<T>>

    /**
     * Group by Tb_sign_status.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_sign_statusGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends tb_sign_statusGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: tb_sign_statusGroupByArgs['orderBy'] }
        : { orderBy?: tb_sign_statusGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, tb_sign_statusGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTb_sign_statusGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the tb_sign_status model
   */
  readonly fields: tb_sign_statusFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for tb_sign_status.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__tb_sign_statusClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the tb_sign_status model
   */
  interface tb_sign_statusFieldRefs {
    readonly status_id: FieldRef<"tb_sign_status", 'Int'>
    readonly status: FieldRef<"tb_sign_status", 'String'>
  }
    

  // Custom InputTypes
  /**
   * tb_sign_status findUnique
   */
  export type tb_sign_statusFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_sign_status
     */
    select?: tb_sign_statusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_sign_status
     */
    omit?: tb_sign_statusOmit<ExtArgs> | null
    /**
     * Filter, which tb_sign_status to fetch.
     */
    where: tb_sign_statusWhereUniqueInput
  }

  /**
   * tb_sign_status findUniqueOrThrow
   */
  export type tb_sign_statusFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_sign_status
     */
    select?: tb_sign_statusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_sign_status
     */
    omit?: tb_sign_statusOmit<ExtArgs> | null
    /**
     * Filter, which tb_sign_status to fetch.
     */
    where: tb_sign_statusWhereUniqueInput
  }

  /**
   * tb_sign_status findFirst
   */
  export type tb_sign_statusFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_sign_status
     */
    select?: tb_sign_statusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_sign_status
     */
    omit?: tb_sign_statusOmit<ExtArgs> | null
    /**
     * Filter, which tb_sign_status to fetch.
     */
    where?: tb_sign_statusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tb_sign_statuses to fetch.
     */
    orderBy?: tb_sign_statusOrderByWithRelationInput | tb_sign_statusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tb_sign_statuses.
     */
    cursor?: tb_sign_statusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tb_sign_statuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tb_sign_statuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tb_sign_statuses.
     */
    distinct?: Tb_sign_statusScalarFieldEnum | Tb_sign_statusScalarFieldEnum[]
  }

  /**
   * tb_sign_status findFirstOrThrow
   */
  export type tb_sign_statusFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_sign_status
     */
    select?: tb_sign_statusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_sign_status
     */
    omit?: tb_sign_statusOmit<ExtArgs> | null
    /**
     * Filter, which tb_sign_status to fetch.
     */
    where?: tb_sign_statusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tb_sign_statuses to fetch.
     */
    orderBy?: tb_sign_statusOrderByWithRelationInput | tb_sign_statusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tb_sign_statuses.
     */
    cursor?: tb_sign_statusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tb_sign_statuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tb_sign_statuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tb_sign_statuses.
     */
    distinct?: Tb_sign_statusScalarFieldEnum | Tb_sign_statusScalarFieldEnum[]
  }

  /**
   * tb_sign_status findMany
   */
  export type tb_sign_statusFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_sign_status
     */
    select?: tb_sign_statusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_sign_status
     */
    omit?: tb_sign_statusOmit<ExtArgs> | null
    /**
     * Filter, which tb_sign_statuses to fetch.
     */
    where?: tb_sign_statusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tb_sign_statuses to fetch.
     */
    orderBy?: tb_sign_statusOrderByWithRelationInput | tb_sign_statusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing tb_sign_statuses.
     */
    cursor?: tb_sign_statusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tb_sign_statuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tb_sign_statuses.
     */
    skip?: number
    distinct?: Tb_sign_statusScalarFieldEnum | Tb_sign_statusScalarFieldEnum[]
  }

  /**
   * tb_sign_status create
   */
  export type tb_sign_statusCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_sign_status
     */
    select?: tb_sign_statusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_sign_status
     */
    omit?: tb_sign_statusOmit<ExtArgs> | null
    /**
     * The data needed to create a tb_sign_status.
     */
    data: XOR<tb_sign_statusCreateInput, tb_sign_statusUncheckedCreateInput>
  }

  /**
   * tb_sign_status createMany
   */
  export type tb_sign_statusCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many tb_sign_statuses.
     */
    data: tb_sign_statusCreateManyInput | tb_sign_statusCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * tb_sign_status update
   */
  export type tb_sign_statusUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_sign_status
     */
    select?: tb_sign_statusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_sign_status
     */
    omit?: tb_sign_statusOmit<ExtArgs> | null
    /**
     * The data needed to update a tb_sign_status.
     */
    data: XOR<tb_sign_statusUpdateInput, tb_sign_statusUncheckedUpdateInput>
    /**
     * Choose, which tb_sign_status to update.
     */
    where: tb_sign_statusWhereUniqueInput
  }

  /**
   * tb_sign_status updateMany
   */
  export type tb_sign_statusUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update tb_sign_statuses.
     */
    data: XOR<tb_sign_statusUpdateManyMutationInput, tb_sign_statusUncheckedUpdateManyInput>
    /**
     * Filter which tb_sign_statuses to update
     */
    where?: tb_sign_statusWhereInput
    /**
     * Limit how many tb_sign_statuses to update.
     */
    limit?: number
  }

  /**
   * tb_sign_status upsert
   */
  export type tb_sign_statusUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_sign_status
     */
    select?: tb_sign_statusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_sign_status
     */
    omit?: tb_sign_statusOmit<ExtArgs> | null
    /**
     * The filter to search for the tb_sign_status to update in case it exists.
     */
    where: tb_sign_statusWhereUniqueInput
    /**
     * In case the tb_sign_status found by the `where` argument doesn't exist, create a new tb_sign_status with this data.
     */
    create: XOR<tb_sign_statusCreateInput, tb_sign_statusUncheckedCreateInput>
    /**
     * In case the tb_sign_status was found with the provided `where` argument, update it with this data.
     */
    update: XOR<tb_sign_statusUpdateInput, tb_sign_statusUncheckedUpdateInput>
  }

  /**
   * tb_sign_status delete
   */
  export type tb_sign_statusDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_sign_status
     */
    select?: tb_sign_statusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_sign_status
     */
    omit?: tb_sign_statusOmit<ExtArgs> | null
    /**
     * Filter which tb_sign_status to delete.
     */
    where: tb_sign_statusWhereUniqueInput
  }

  /**
   * tb_sign_status deleteMany
   */
  export type tb_sign_statusDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tb_sign_statuses to delete
     */
    where?: tb_sign_statusWhereInput
    /**
     * Limit how many tb_sign_statuses to delete.
     */
    limit?: number
  }

  /**
   * tb_sign_status without action
   */
  export type tb_sign_statusDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_sign_status
     */
    select?: tb_sign_statusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_sign_status
     */
    omit?: tb_sign_statusOmit<ExtArgs> | null
  }


  /**
   * Model tb_translate
   */

  export type AggregateTb_translate = {
    _count: Tb_translateCountAggregateOutputType | null
    _avg: Tb_translateAvgAggregateOutputType | null
    _sum: Tb_translateSumAggregateOutputType | null
    _min: Tb_translateMinAggregateOutputType | null
    _max: Tb_translateMaxAggregateOutputType | null
  }

  export type Tb_translateAvgAggregateOutputType = {
    translate_id: number | null
    case_id: number | null
    translate_type: number | null
    user_from: number | null
    user_to: number | null
    translator_company: number | null
    sign_status: number | null
  }

  export type Tb_translateSumAggregateOutputType = {
    translate_id: number | null
    case_id: number | null
    translate_type: number | null
    user_from: number | null
    user_to: number | null
    translator_company: number | null
    sign_status: number | null
  }

  export type Tb_translateMinAggregateOutputType = {
    translate_id: number | null
    case_id: number | null
    translate_type: number | null
    user_from: number | null
    user_to: number | null
    filled_in_date: Date | null
    translator_company: number | null
    file_path: string | null
    file_ids: string | null
    translate_date: Date | null
    translate_time_from: string | null
    translate_time_to: string | null
    sign_status: number | null
    mailed_to_translators: Date | null
  }

  export type Tb_translateMaxAggregateOutputType = {
    translate_id: number | null
    case_id: number | null
    translate_type: number | null
    user_from: number | null
    user_to: number | null
    filled_in_date: Date | null
    translator_company: number | null
    file_path: string | null
    file_ids: string | null
    translate_date: Date | null
    translate_time_from: string | null
    translate_time_to: string | null
    sign_status: number | null
    mailed_to_translators: Date | null
  }

  export type Tb_translateCountAggregateOutputType = {
    translate_id: number
    case_id: number
    translate_type: number
    user_from: number
    user_to: number
    filled_in_date: number
    translator_company: number
    file_path: number
    file_ids: number
    translate_date: number
    translate_time_from: number
    translate_time_to: number
    sign_status: number
    mailed_to_translators: number
    _all: number
  }


  export type Tb_translateAvgAggregateInputType = {
    translate_id?: true
    case_id?: true
    translate_type?: true
    user_from?: true
    user_to?: true
    translator_company?: true
    sign_status?: true
  }

  export type Tb_translateSumAggregateInputType = {
    translate_id?: true
    case_id?: true
    translate_type?: true
    user_from?: true
    user_to?: true
    translator_company?: true
    sign_status?: true
  }

  export type Tb_translateMinAggregateInputType = {
    translate_id?: true
    case_id?: true
    translate_type?: true
    user_from?: true
    user_to?: true
    filled_in_date?: true
    translator_company?: true
    file_path?: true
    file_ids?: true
    translate_date?: true
    translate_time_from?: true
    translate_time_to?: true
    sign_status?: true
    mailed_to_translators?: true
  }

  export type Tb_translateMaxAggregateInputType = {
    translate_id?: true
    case_id?: true
    translate_type?: true
    user_from?: true
    user_to?: true
    filled_in_date?: true
    translator_company?: true
    file_path?: true
    file_ids?: true
    translate_date?: true
    translate_time_from?: true
    translate_time_to?: true
    sign_status?: true
    mailed_to_translators?: true
  }

  export type Tb_translateCountAggregateInputType = {
    translate_id?: true
    case_id?: true
    translate_type?: true
    user_from?: true
    user_to?: true
    filled_in_date?: true
    translator_company?: true
    file_path?: true
    file_ids?: true
    translate_date?: true
    translate_time_from?: true
    translate_time_to?: true
    sign_status?: true
    mailed_to_translators?: true
    _all?: true
  }

  export type Tb_translateAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tb_translate to aggregate.
     */
    where?: tb_translateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tb_translates to fetch.
     */
    orderBy?: tb_translateOrderByWithRelationInput | tb_translateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: tb_translateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tb_translates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tb_translates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned tb_translates
    **/
    _count?: true | Tb_translateCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Tb_translateAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Tb_translateSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Tb_translateMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Tb_translateMaxAggregateInputType
  }

  export type GetTb_translateAggregateType<T extends Tb_translateAggregateArgs> = {
        [P in keyof T & keyof AggregateTb_translate]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTb_translate[P]>
      : GetScalarType<T[P], AggregateTb_translate[P]>
  }




  export type tb_translateGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: tb_translateWhereInput
    orderBy?: tb_translateOrderByWithAggregationInput | tb_translateOrderByWithAggregationInput[]
    by: Tb_translateScalarFieldEnum[] | Tb_translateScalarFieldEnum
    having?: tb_translateScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Tb_translateCountAggregateInputType | true
    _avg?: Tb_translateAvgAggregateInputType
    _sum?: Tb_translateSumAggregateInputType
    _min?: Tb_translateMinAggregateInputType
    _max?: Tb_translateMaxAggregateInputType
  }

  export type Tb_translateGroupByOutputType = {
    translate_id: number
    case_id: number
    translate_type: number
    user_from: number
    user_to: number
    filled_in_date: Date
    translator_company: number
    file_path: string | null
    file_ids: string | null
    translate_date: Date | null
    translate_time_from: string | null
    translate_time_to: string | null
    sign_status: number | null
    mailed_to_translators: Date | null
    _count: Tb_translateCountAggregateOutputType | null
    _avg: Tb_translateAvgAggregateOutputType | null
    _sum: Tb_translateSumAggregateOutputType | null
    _min: Tb_translateMinAggregateOutputType | null
    _max: Tb_translateMaxAggregateOutputType | null
  }

  type GetTb_translateGroupByPayload<T extends tb_translateGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Tb_translateGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Tb_translateGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Tb_translateGroupByOutputType[P]>
            : GetScalarType<T[P], Tb_translateGroupByOutputType[P]>
        }
      >
    >


  export type tb_translateSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    translate_id?: boolean
    case_id?: boolean
    translate_type?: boolean
    user_from?: boolean
    user_to?: boolean
    filled_in_date?: boolean
    translator_company?: boolean
    file_path?: boolean
    file_ids?: boolean
    translate_date?: boolean
    translate_time_from?: boolean
    translate_time_to?: boolean
    sign_status?: boolean
    mailed_to_translators?: boolean
  }, ExtArgs["result"]["tb_translate"]>



  export type tb_translateSelectScalar = {
    translate_id?: boolean
    case_id?: boolean
    translate_type?: boolean
    user_from?: boolean
    user_to?: boolean
    filled_in_date?: boolean
    translator_company?: boolean
    file_path?: boolean
    file_ids?: boolean
    translate_date?: boolean
    translate_time_from?: boolean
    translate_time_to?: boolean
    sign_status?: boolean
    mailed_to_translators?: boolean
  }

  export type tb_translateOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"translate_id" | "case_id" | "translate_type" | "user_from" | "user_to" | "filled_in_date" | "translator_company" | "file_path" | "file_ids" | "translate_date" | "translate_time_from" | "translate_time_to" | "sign_status" | "mailed_to_translators", ExtArgs["result"]["tb_translate"]>

  export type $tb_translatePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "tb_translate"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      translate_id: number
      case_id: number
      translate_type: number
      user_from: number
      user_to: number
      filled_in_date: Date
      translator_company: number
      file_path: string | null
      file_ids: string | null
      translate_date: Date | null
      translate_time_from: string | null
      translate_time_to: string | null
      sign_status: number | null
      mailed_to_translators: Date | null
    }, ExtArgs["result"]["tb_translate"]>
    composites: {}
  }

  type tb_translateGetPayload<S extends boolean | null | undefined | tb_translateDefaultArgs> = $Result.GetResult<Prisma.$tb_translatePayload, S>

  type tb_translateCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<tb_translateFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Tb_translateCountAggregateInputType | true
    }

  export interface tb_translateDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['tb_translate'], meta: { name: 'tb_translate' } }
    /**
     * Find zero or one Tb_translate that matches the filter.
     * @param {tb_translateFindUniqueArgs} args - Arguments to find a Tb_translate
     * @example
     * // Get one Tb_translate
     * const tb_translate = await prisma.tb_translate.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends tb_translateFindUniqueArgs>(args: SelectSubset<T, tb_translateFindUniqueArgs<ExtArgs>>): Prisma__tb_translateClient<$Result.GetResult<Prisma.$tb_translatePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Tb_translate that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {tb_translateFindUniqueOrThrowArgs} args - Arguments to find a Tb_translate
     * @example
     * // Get one Tb_translate
     * const tb_translate = await prisma.tb_translate.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends tb_translateFindUniqueOrThrowArgs>(args: SelectSubset<T, tb_translateFindUniqueOrThrowArgs<ExtArgs>>): Prisma__tb_translateClient<$Result.GetResult<Prisma.$tb_translatePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tb_translate that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_translateFindFirstArgs} args - Arguments to find a Tb_translate
     * @example
     * // Get one Tb_translate
     * const tb_translate = await prisma.tb_translate.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends tb_translateFindFirstArgs>(args?: SelectSubset<T, tb_translateFindFirstArgs<ExtArgs>>): Prisma__tb_translateClient<$Result.GetResult<Prisma.$tb_translatePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tb_translate that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_translateFindFirstOrThrowArgs} args - Arguments to find a Tb_translate
     * @example
     * // Get one Tb_translate
     * const tb_translate = await prisma.tb_translate.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends tb_translateFindFirstOrThrowArgs>(args?: SelectSubset<T, tb_translateFindFirstOrThrowArgs<ExtArgs>>): Prisma__tb_translateClient<$Result.GetResult<Prisma.$tb_translatePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Tb_translates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_translateFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tb_translates
     * const tb_translates = await prisma.tb_translate.findMany()
     * 
     * // Get first 10 Tb_translates
     * const tb_translates = await prisma.tb_translate.findMany({ take: 10 })
     * 
     * // Only select the `translate_id`
     * const tb_translateWithTranslate_idOnly = await prisma.tb_translate.findMany({ select: { translate_id: true } })
     * 
     */
    findMany<T extends tb_translateFindManyArgs>(args?: SelectSubset<T, tb_translateFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tb_translatePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Tb_translate.
     * @param {tb_translateCreateArgs} args - Arguments to create a Tb_translate.
     * @example
     * // Create one Tb_translate
     * const Tb_translate = await prisma.tb_translate.create({
     *   data: {
     *     // ... data to create a Tb_translate
     *   }
     * })
     * 
     */
    create<T extends tb_translateCreateArgs>(args: SelectSubset<T, tb_translateCreateArgs<ExtArgs>>): Prisma__tb_translateClient<$Result.GetResult<Prisma.$tb_translatePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Tb_translates.
     * @param {tb_translateCreateManyArgs} args - Arguments to create many Tb_translates.
     * @example
     * // Create many Tb_translates
     * const tb_translate = await prisma.tb_translate.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends tb_translateCreateManyArgs>(args?: SelectSubset<T, tb_translateCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Tb_translate.
     * @param {tb_translateDeleteArgs} args - Arguments to delete one Tb_translate.
     * @example
     * // Delete one Tb_translate
     * const Tb_translate = await prisma.tb_translate.delete({
     *   where: {
     *     // ... filter to delete one Tb_translate
     *   }
     * })
     * 
     */
    delete<T extends tb_translateDeleteArgs>(args: SelectSubset<T, tb_translateDeleteArgs<ExtArgs>>): Prisma__tb_translateClient<$Result.GetResult<Prisma.$tb_translatePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Tb_translate.
     * @param {tb_translateUpdateArgs} args - Arguments to update one Tb_translate.
     * @example
     * // Update one Tb_translate
     * const tb_translate = await prisma.tb_translate.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends tb_translateUpdateArgs>(args: SelectSubset<T, tb_translateUpdateArgs<ExtArgs>>): Prisma__tb_translateClient<$Result.GetResult<Prisma.$tb_translatePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Tb_translates.
     * @param {tb_translateDeleteManyArgs} args - Arguments to filter Tb_translates to delete.
     * @example
     * // Delete a few Tb_translates
     * const { count } = await prisma.tb_translate.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends tb_translateDeleteManyArgs>(args?: SelectSubset<T, tb_translateDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tb_translates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_translateUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tb_translates
     * const tb_translate = await prisma.tb_translate.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends tb_translateUpdateManyArgs>(args: SelectSubset<T, tb_translateUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Tb_translate.
     * @param {tb_translateUpsertArgs} args - Arguments to update or create a Tb_translate.
     * @example
     * // Update or create a Tb_translate
     * const tb_translate = await prisma.tb_translate.upsert({
     *   create: {
     *     // ... data to create a Tb_translate
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tb_translate we want to update
     *   }
     * })
     */
    upsert<T extends tb_translateUpsertArgs>(args: SelectSubset<T, tb_translateUpsertArgs<ExtArgs>>): Prisma__tb_translateClient<$Result.GetResult<Prisma.$tb_translatePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Tb_translates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_translateCountArgs} args - Arguments to filter Tb_translates to count.
     * @example
     * // Count the number of Tb_translates
     * const count = await prisma.tb_translate.count({
     *   where: {
     *     // ... the filter for the Tb_translates we want to count
     *   }
     * })
    **/
    count<T extends tb_translateCountArgs>(
      args?: Subset<T, tb_translateCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Tb_translateCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tb_translate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Tb_translateAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Tb_translateAggregateArgs>(args: Subset<T, Tb_translateAggregateArgs>): Prisma.PrismaPromise<GetTb_translateAggregateType<T>>

    /**
     * Group by Tb_translate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_translateGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends tb_translateGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: tb_translateGroupByArgs['orderBy'] }
        : { orderBy?: tb_translateGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, tb_translateGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTb_translateGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the tb_translate model
   */
  readonly fields: tb_translateFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for tb_translate.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__tb_translateClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the tb_translate model
   */
  interface tb_translateFieldRefs {
    readonly translate_id: FieldRef<"tb_translate", 'Int'>
    readonly case_id: FieldRef<"tb_translate", 'Int'>
    readonly translate_type: FieldRef<"tb_translate", 'Int'>
    readonly user_from: FieldRef<"tb_translate", 'Int'>
    readonly user_to: FieldRef<"tb_translate", 'Int'>
    readonly filled_in_date: FieldRef<"tb_translate", 'DateTime'>
    readonly translator_company: FieldRef<"tb_translate", 'Int'>
    readonly file_path: FieldRef<"tb_translate", 'String'>
    readonly file_ids: FieldRef<"tb_translate", 'String'>
    readonly translate_date: FieldRef<"tb_translate", 'DateTime'>
    readonly translate_time_from: FieldRef<"tb_translate", 'String'>
    readonly translate_time_to: FieldRef<"tb_translate", 'String'>
    readonly sign_status: FieldRef<"tb_translate", 'Int'>
    readonly mailed_to_translators: FieldRef<"tb_translate", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * tb_translate findUnique
   */
  export type tb_translateFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_translate
     */
    select?: tb_translateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_translate
     */
    omit?: tb_translateOmit<ExtArgs> | null
    /**
     * Filter, which tb_translate to fetch.
     */
    where: tb_translateWhereUniqueInput
  }

  /**
   * tb_translate findUniqueOrThrow
   */
  export type tb_translateFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_translate
     */
    select?: tb_translateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_translate
     */
    omit?: tb_translateOmit<ExtArgs> | null
    /**
     * Filter, which tb_translate to fetch.
     */
    where: tb_translateWhereUniqueInput
  }

  /**
   * tb_translate findFirst
   */
  export type tb_translateFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_translate
     */
    select?: tb_translateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_translate
     */
    omit?: tb_translateOmit<ExtArgs> | null
    /**
     * Filter, which tb_translate to fetch.
     */
    where?: tb_translateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tb_translates to fetch.
     */
    orderBy?: tb_translateOrderByWithRelationInput | tb_translateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tb_translates.
     */
    cursor?: tb_translateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tb_translates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tb_translates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tb_translates.
     */
    distinct?: Tb_translateScalarFieldEnum | Tb_translateScalarFieldEnum[]
  }

  /**
   * tb_translate findFirstOrThrow
   */
  export type tb_translateFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_translate
     */
    select?: tb_translateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_translate
     */
    omit?: tb_translateOmit<ExtArgs> | null
    /**
     * Filter, which tb_translate to fetch.
     */
    where?: tb_translateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tb_translates to fetch.
     */
    orderBy?: tb_translateOrderByWithRelationInput | tb_translateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tb_translates.
     */
    cursor?: tb_translateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tb_translates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tb_translates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tb_translates.
     */
    distinct?: Tb_translateScalarFieldEnum | Tb_translateScalarFieldEnum[]
  }

  /**
   * tb_translate findMany
   */
  export type tb_translateFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_translate
     */
    select?: tb_translateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_translate
     */
    omit?: tb_translateOmit<ExtArgs> | null
    /**
     * Filter, which tb_translates to fetch.
     */
    where?: tb_translateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tb_translates to fetch.
     */
    orderBy?: tb_translateOrderByWithRelationInput | tb_translateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing tb_translates.
     */
    cursor?: tb_translateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tb_translates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tb_translates.
     */
    skip?: number
    distinct?: Tb_translateScalarFieldEnum | Tb_translateScalarFieldEnum[]
  }

  /**
   * tb_translate create
   */
  export type tb_translateCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_translate
     */
    select?: tb_translateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_translate
     */
    omit?: tb_translateOmit<ExtArgs> | null
    /**
     * The data needed to create a tb_translate.
     */
    data: XOR<tb_translateCreateInput, tb_translateUncheckedCreateInput>
  }

  /**
   * tb_translate createMany
   */
  export type tb_translateCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many tb_translates.
     */
    data: tb_translateCreateManyInput | tb_translateCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * tb_translate update
   */
  export type tb_translateUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_translate
     */
    select?: tb_translateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_translate
     */
    omit?: tb_translateOmit<ExtArgs> | null
    /**
     * The data needed to update a tb_translate.
     */
    data: XOR<tb_translateUpdateInput, tb_translateUncheckedUpdateInput>
    /**
     * Choose, which tb_translate to update.
     */
    where: tb_translateWhereUniqueInput
  }

  /**
   * tb_translate updateMany
   */
  export type tb_translateUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update tb_translates.
     */
    data: XOR<tb_translateUpdateManyMutationInput, tb_translateUncheckedUpdateManyInput>
    /**
     * Filter which tb_translates to update
     */
    where?: tb_translateWhereInput
    /**
     * Limit how many tb_translates to update.
     */
    limit?: number
  }

  /**
   * tb_translate upsert
   */
  export type tb_translateUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_translate
     */
    select?: tb_translateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_translate
     */
    omit?: tb_translateOmit<ExtArgs> | null
    /**
     * The filter to search for the tb_translate to update in case it exists.
     */
    where: tb_translateWhereUniqueInput
    /**
     * In case the tb_translate found by the `where` argument doesn't exist, create a new tb_translate with this data.
     */
    create: XOR<tb_translateCreateInput, tb_translateUncheckedCreateInput>
    /**
     * In case the tb_translate was found with the provided `where` argument, update it with this data.
     */
    update: XOR<tb_translateUpdateInput, tb_translateUncheckedUpdateInput>
  }

  /**
   * tb_translate delete
   */
  export type tb_translateDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_translate
     */
    select?: tb_translateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_translate
     */
    omit?: tb_translateOmit<ExtArgs> | null
    /**
     * Filter which tb_translate to delete.
     */
    where: tb_translateWhereUniqueInput
  }

  /**
   * tb_translate deleteMany
   */
  export type tb_translateDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tb_translates to delete
     */
    where?: tb_translateWhereInput
    /**
     * Limit how many tb_translates to delete.
     */
    limit?: number
  }

  /**
   * tb_translate without action
   */
  export type tb_translateDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_translate
     */
    select?: tb_translateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_translate
     */
    omit?: tb_translateOmit<ExtArgs> | null
  }


  /**
   * Model tb_translate_sign_statuses
   */

  export type AggregateTb_translate_sign_statuses = {
    _count: Tb_translate_sign_statusesCountAggregateOutputType | null
    _avg: Tb_translate_sign_statusesAvgAggregateOutputType | null
    _sum: Tb_translate_sign_statusesSumAggregateOutputType | null
    _min: Tb_translate_sign_statusesMinAggregateOutputType | null
    _max: Tb_translate_sign_statusesMaxAggregateOutputType | null
  }

  export type Tb_translate_sign_statusesAvgAggregateOutputType = {
    status_id: number | null
    sign_status: number | null
  }

  export type Tb_translate_sign_statusesSumAggregateOutputType = {
    status_id: number | null
    sign_status: number | null
  }

  export type Tb_translate_sign_statusesMinAggregateOutputType = {
    status_id: number | null
    sign_status: number | null
    sign_status_name: string | null
  }

  export type Tb_translate_sign_statusesMaxAggregateOutputType = {
    status_id: number | null
    sign_status: number | null
    sign_status_name: string | null
  }

  export type Tb_translate_sign_statusesCountAggregateOutputType = {
    status_id: number
    sign_status: number
    sign_status_name: number
    _all: number
  }


  export type Tb_translate_sign_statusesAvgAggregateInputType = {
    status_id?: true
    sign_status?: true
  }

  export type Tb_translate_sign_statusesSumAggregateInputType = {
    status_id?: true
    sign_status?: true
  }

  export type Tb_translate_sign_statusesMinAggregateInputType = {
    status_id?: true
    sign_status?: true
    sign_status_name?: true
  }

  export type Tb_translate_sign_statusesMaxAggregateInputType = {
    status_id?: true
    sign_status?: true
    sign_status_name?: true
  }

  export type Tb_translate_sign_statusesCountAggregateInputType = {
    status_id?: true
    sign_status?: true
    sign_status_name?: true
    _all?: true
  }

  export type Tb_translate_sign_statusesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tb_translate_sign_statuses to aggregate.
     */
    where?: tb_translate_sign_statusesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tb_translate_sign_statuses to fetch.
     */
    orderBy?: tb_translate_sign_statusesOrderByWithRelationInput | tb_translate_sign_statusesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: tb_translate_sign_statusesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tb_translate_sign_statuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tb_translate_sign_statuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned tb_translate_sign_statuses
    **/
    _count?: true | Tb_translate_sign_statusesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Tb_translate_sign_statusesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Tb_translate_sign_statusesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Tb_translate_sign_statusesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Tb_translate_sign_statusesMaxAggregateInputType
  }

  export type GetTb_translate_sign_statusesAggregateType<T extends Tb_translate_sign_statusesAggregateArgs> = {
        [P in keyof T & keyof AggregateTb_translate_sign_statuses]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTb_translate_sign_statuses[P]>
      : GetScalarType<T[P], AggregateTb_translate_sign_statuses[P]>
  }




  export type tb_translate_sign_statusesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: tb_translate_sign_statusesWhereInput
    orderBy?: tb_translate_sign_statusesOrderByWithAggregationInput | tb_translate_sign_statusesOrderByWithAggregationInput[]
    by: Tb_translate_sign_statusesScalarFieldEnum[] | Tb_translate_sign_statusesScalarFieldEnum
    having?: tb_translate_sign_statusesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Tb_translate_sign_statusesCountAggregateInputType | true
    _avg?: Tb_translate_sign_statusesAvgAggregateInputType
    _sum?: Tb_translate_sign_statusesSumAggregateInputType
    _min?: Tb_translate_sign_statusesMinAggregateInputType
    _max?: Tb_translate_sign_statusesMaxAggregateInputType
  }

  export type Tb_translate_sign_statusesGroupByOutputType = {
    status_id: number
    sign_status: number
    sign_status_name: string
    _count: Tb_translate_sign_statusesCountAggregateOutputType | null
    _avg: Tb_translate_sign_statusesAvgAggregateOutputType | null
    _sum: Tb_translate_sign_statusesSumAggregateOutputType | null
    _min: Tb_translate_sign_statusesMinAggregateOutputType | null
    _max: Tb_translate_sign_statusesMaxAggregateOutputType | null
  }

  type GetTb_translate_sign_statusesGroupByPayload<T extends tb_translate_sign_statusesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Tb_translate_sign_statusesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Tb_translate_sign_statusesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Tb_translate_sign_statusesGroupByOutputType[P]>
            : GetScalarType<T[P], Tb_translate_sign_statusesGroupByOutputType[P]>
        }
      >
    >


  export type tb_translate_sign_statusesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    status_id?: boolean
    sign_status?: boolean
    sign_status_name?: boolean
  }, ExtArgs["result"]["tb_translate_sign_statuses"]>



  export type tb_translate_sign_statusesSelectScalar = {
    status_id?: boolean
    sign_status?: boolean
    sign_status_name?: boolean
  }

  export type tb_translate_sign_statusesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"status_id" | "sign_status" | "sign_status_name", ExtArgs["result"]["tb_translate_sign_statuses"]>

  export type $tb_translate_sign_statusesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "tb_translate_sign_statuses"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      status_id: number
      sign_status: number
      sign_status_name: string
    }, ExtArgs["result"]["tb_translate_sign_statuses"]>
    composites: {}
  }

  type tb_translate_sign_statusesGetPayload<S extends boolean | null | undefined | tb_translate_sign_statusesDefaultArgs> = $Result.GetResult<Prisma.$tb_translate_sign_statusesPayload, S>

  type tb_translate_sign_statusesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<tb_translate_sign_statusesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Tb_translate_sign_statusesCountAggregateInputType | true
    }

  export interface tb_translate_sign_statusesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['tb_translate_sign_statuses'], meta: { name: 'tb_translate_sign_statuses' } }
    /**
     * Find zero or one Tb_translate_sign_statuses that matches the filter.
     * @param {tb_translate_sign_statusesFindUniqueArgs} args - Arguments to find a Tb_translate_sign_statuses
     * @example
     * // Get one Tb_translate_sign_statuses
     * const tb_translate_sign_statuses = await prisma.tb_translate_sign_statuses.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends tb_translate_sign_statusesFindUniqueArgs>(args: SelectSubset<T, tb_translate_sign_statusesFindUniqueArgs<ExtArgs>>): Prisma__tb_translate_sign_statusesClient<$Result.GetResult<Prisma.$tb_translate_sign_statusesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Tb_translate_sign_statuses that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {tb_translate_sign_statusesFindUniqueOrThrowArgs} args - Arguments to find a Tb_translate_sign_statuses
     * @example
     * // Get one Tb_translate_sign_statuses
     * const tb_translate_sign_statuses = await prisma.tb_translate_sign_statuses.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends tb_translate_sign_statusesFindUniqueOrThrowArgs>(args: SelectSubset<T, tb_translate_sign_statusesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__tb_translate_sign_statusesClient<$Result.GetResult<Prisma.$tb_translate_sign_statusesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tb_translate_sign_statuses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_translate_sign_statusesFindFirstArgs} args - Arguments to find a Tb_translate_sign_statuses
     * @example
     * // Get one Tb_translate_sign_statuses
     * const tb_translate_sign_statuses = await prisma.tb_translate_sign_statuses.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends tb_translate_sign_statusesFindFirstArgs>(args?: SelectSubset<T, tb_translate_sign_statusesFindFirstArgs<ExtArgs>>): Prisma__tb_translate_sign_statusesClient<$Result.GetResult<Prisma.$tb_translate_sign_statusesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tb_translate_sign_statuses that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_translate_sign_statusesFindFirstOrThrowArgs} args - Arguments to find a Tb_translate_sign_statuses
     * @example
     * // Get one Tb_translate_sign_statuses
     * const tb_translate_sign_statuses = await prisma.tb_translate_sign_statuses.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends tb_translate_sign_statusesFindFirstOrThrowArgs>(args?: SelectSubset<T, tb_translate_sign_statusesFindFirstOrThrowArgs<ExtArgs>>): Prisma__tb_translate_sign_statusesClient<$Result.GetResult<Prisma.$tb_translate_sign_statusesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Tb_translate_sign_statuses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_translate_sign_statusesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tb_translate_sign_statuses
     * const tb_translate_sign_statuses = await prisma.tb_translate_sign_statuses.findMany()
     * 
     * // Get first 10 Tb_translate_sign_statuses
     * const tb_translate_sign_statuses = await prisma.tb_translate_sign_statuses.findMany({ take: 10 })
     * 
     * // Only select the `status_id`
     * const tb_translate_sign_statusesWithStatus_idOnly = await prisma.tb_translate_sign_statuses.findMany({ select: { status_id: true } })
     * 
     */
    findMany<T extends tb_translate_sign_statusesFindManyArgs>(args?: SelectSubset<T, tb_translate_sign_statusesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tb_translate_sign_statusesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Tb_translate_sign_statuses.
     * @param {tb_translate_sign_statusesCreateArgs} args - Arguments to create a Tb_translate_sign_statuses.
     * @example
     * // Create one Tb_translate_sign_statuses
     * const Tb_translate_sign_statuses = await prisma.tb_translate_sign_statuses.create({
     *   data: {
     *     // ... data to create a Tb_translate_sign_statuses
     *   }
     * })
     * 
     */
    create<T extends tb_translate_sign_statusesCreateArgs>(args: SelectSubset<T, tb_translate_sign_statusesCreateArgs<ExtArgs>>): Prisma__tb_translate_sign_statusesClient<$Result.GetResult<Prisma.$tb_translate_sign_statusesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Tb_translate_sign_statuses.
     * @param {tb_translate_sign_statusesCreateManyArgs} args - Arguments to create many Tb_translate_sign_statuses.
     * @example
     * // Create many Tb_translate_sign_statuses
     * const tb_translate_sign_statuses = await prisma.tb_translate_sign_statuses.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends tb_translate_sign_statusesCreateManyArgs>(args?: SelectSubset<T, tb_translate_sign_statusesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Tb_translate_sign_statuses.
     * @param {tb_translate_sign_statusesDeleteArgs} args - Arguments to delete one Tb_translate_sign_statuses.
     * @example
     * // Delete one Tb_translate_sign_statuses
     * const Tb_translate_sign_statuses = await prisma.tb_translate_sign_statuses.delete({
     *   where: {
     *     // ... filter to delete one Tb_translate_sign_statuses
     *   }
     * })
     * 
     */
    delete<T extends tb_translate_sign_statusesDeleteArgs>(args: SelectSubset<T, tb_translate_sign_statusesDeleteArgs<ExtArgs>>): Prisma__tb_translate_sign_statusesClient<$Result.GetResult<Prisma.$tb_translate_sign_statusesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Tb_translate_sign_statuses.
     * @param {tb_translate_sign_statusesUpdateArgs} args - Arguments to update one Tb_translate_sign_statuses.
     * @example
     * // Update one Tb_translate_sign_statuses
     * const tb_translate_sign_statuses = await prisma.tb_translate_sign_statuses.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends tb_translate_sign_statusesUpdateArgs>(args: SelectSubset<T, tb_translate_sign_statusesUpdateArgs<ExtArgs>>): Prisma__tb_translate_sign_statusesClient<$Result.GetResult<Prisma.$tb_translate_sign_statusesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Tb_translate_sign_statuses.
     * @param {tb_translate_sign_statusesDeleteManyArgs} args - Arguments to filter Tb_translate_sign_statuses to delete.
     * @example
     * // Delete a few Tb_translate_sign_statuses
     * const { count } = await prisma.tb_translate_sign_statuses.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends tb_translate_sign_statusesDeleteManyArgs>(args?: SelectSubset<T, tb_translate_sign_statusesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tb_translate_sign_statuses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_translate_sign_statusesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tb_translate_sign_statuses
     * const tb_translate_sign_statuses = await prisma.tb_translate_sign_statuses.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends tb_translate_sign_statusesUpdateManyArgs>(args: SelectSubset<T, tb_translate_sign_statusesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Tb_translate_sign_statuses.
     * @param {tb_translate_sign_statusesUpsertArgs} args - Arguments to update or create a Tb_translate_sign_statuses.
     * @example
     * // Update or create a Tb_translate_sign_statuses
     * const tb_translate_sign_statuses = await prisma.tb_translate_sign_statuses.upsert({
     *   create: {
     *     // ... data to create a Tb_translate_sign_statuses
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tb_translate_sign_statuses we want to update
     *   }
     * })
     */
    upsert<T extends tb_translate_sign_statusesUpsertArgs>(args: SelectSubset<T, tb_translate_sign_statusesUpsertArgs<ExtArgs>>): Prisma__tb_translate_sign_statusesClient<$Result.GetResult<Prisma.$tb_translate_sign_statusesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Tb_translate_sign_statuses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_translate_sign_statusesCountArgs} args - Arguments to filter Tb_translate_sign_statuses to count.
     * @example
     * // Count the number of Tb_translate_sign_statuses
     * const count = await prisma.tb_translate_sign_statuses.count({
     *   where: {
     *     // ... the filter for the Tb_translate_sign_statuses we want to count
     *   }
     * })
    **/
    count<T extends tb_translate_sign_statusesCountArgs>(
      args?: Subset<T, tb_translate_sign_statusesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Tb_translate_sign_statusesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tb_translate_sign_statuses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Tb_translate_sign_statusesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Tb_translate_sign_statusesAggregateArgs>(args: Subset<T, Tb_translate_sign_statusesAggregateArgs>): Prisma.PrismaPromise<GetTb_translate_sign_statusesAggregateType<T>>

    /**
     * Group by Tb_translate_sign_statuses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_translate_sign_statusesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends tb_translate_sign_statusesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: tb_translate_sign_statusesGroupByArgs['orderBy'] }
        : { orderBy?: tb_translate_sign_statusesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, tb_translate_sign_statusesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTb_translate_sign_statusesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the tb_translate_sign_statuses model
   */
  readonly fields: tb_translate_sign_statusesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for tb_translate_sign_statuses.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__tb_translate_sign_statusesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the tb_translate_sign_statuses model
   */
  interface tb_translate_sign_statusesFieldRefs {
    readonly status_id: FieldRef<"tb_translate_sign_statuses", 'Int'>
    readonly sign_status: FieldRef<"tb_translate_sign_statuses", 'Int'>
    readonly sign_status_name: FieldRef<"tb_translate_sign_statuses", 'String'>
  }
    

  // Custom InputTypes
  /**
   * tb_translate_sign_statuses findUnique
   */
  export type tb_translate_sign_statusesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_translate_sign_statuses
     */
    select?: tb_translate_sign_statusesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_translate_sign_statuses
     */
    omit?: tb_translate_sign_statusesOmit<ExtArgs> | null
    /**
     * Filter, which tb_translate_sign_statuses to fetch.
     */
    where: tb_translate_sign_statusesWhereUniqueInput
  }

  /**
   * tb_translate_sign_statuses findUniqueOrThrow
   */
  export type tb_translate_sign_statusesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_translate_sign_statuses
     */
    select?: tb_translate_sign_statusesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_translate_sign_statuses
     */
    omit?: tb_translate_sign_statusesOmit<ExtArgs> | null
    /**
     * Filter, which tb_translate_sign_statuses to fetch.
     */
    where: tb_translate_sign_statusesWhereUniqueInput
  }

  /**
   * tb_translate_sign_statuses findFirst
   */
  export type tb_translate_sign_statusesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_translate_sign_statuses
     */
    select?: tb_translate_sign_statusesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_translate_sign_statuses
     */
    omit?: tb_translate_sign_statusesOmit<ExtArgs> | null
    /**
     * Filter, which tb_translate_sign_statuses to fetch.
     */
    where?: tb_translate_sign_statusesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tb_translate_sign_statuses to fetch.
     */
    orderBy?: tb_translate_sign_statusesOrderByWithRelationInput | tb_translate_sign_statusesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tb_translate_sign_statuses.
     */
    cursor?: tb_translate_sign_statusesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tb_translate_sign_statuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tb_translate_sign_statuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tb_translate_sign_statuses.
     */
    distinct?: Tb_translate_sign_statusesScalarFieldEnum | Tb_translate_sign_statusesScalarFieldEnum[]
  }

  /**
   * tb_translate_sign_statuses findFirstOrThrow
   */
  export type tb_translate_sign_statusesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_translate_sign_statuses
     */
    select?: tb_translate_sign_statusesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_translate_sign_statuses
     */
    omit?: tb_translate_sign_statusesOmit<ExtArgs> | null
    /**
     * Filter, which tb_translate_sign_statuses to fetch.
     */
    where?: tb_translate_sign_statusesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tb_translate_sign_statuses to fetch.
     */
    orderBy?: tb_translate_sign_statusesOrderByWithRelationInput | tb_translate_sign_statusesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tb_translate_sign_statuses.
     */
    cursor?: tb_translate_sign_statusesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tb_translate_sign_statuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tb_translate_sign_statuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tb_translate_sign_statuses.
     */
    distinct?: Tb_translate_sign_statusesScalarFieldEnum | Tb_translate_sign_statusesScalarFieldEnum[]
  }

  /**
   * tb_translate_sign_statuses findMany
   */
  export type tb_translate_sign_statusesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_translate_sign_statuses
     */
    select?: tb_translate_sign_statusesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_translate_sign_statuses
     */
    omit?: tb_translate_sign_statusesOmit<ExtArgs> | null
    /**
     * Filter, which tb_translate_sign_statuses to fetch.
     */
    where?: tb_translate_sign_statusesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tb_translate_sign_statuses to fetch.
     */
    orderBy?: tb_translate_sign_statusesOrderByWithRelationInput | tb_translate_sign_statusesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing tb_translate_sign_statuses.
     */
    cursor?: tb_translate_sign_statusesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tb_translate_sign_statuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tb_translate_sign_statuses.
     */
    skip?: number
    distinct?: Tb_translate_sign_statusesScalarFieldEnum | Tb_translate_sign_statusesScalarFieldEnum[]
  }

  /**
   * tb_translate_sign_statuses create
   */
  export type tb_translate_sign_statusesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_translate_sign_statuses
     */
    select?: tb_translate_sign_statusesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_translate_sign_statuses
     */
    omit?: tb_translate_sign_statusesOmit<ExtArgs> | null
    /**
     * The data needed to create a tb_translate_sign_statuses.
     */
    data: XOR<tb_translate_sign_statusesCreateInput, tb_translate_sign_statusesUncheckedCreateInput>
  }

  /**
   * tb_translate_sign_statuses createMany
   */
  export type tb_translate_sign_statusesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many tb_translate_sign_statuses.
     */
    data: tb_translate_sign_statusesCreateManyInput | tb_translate_sign_statusesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * tb_translate_sign_statuses update
   */
  export type tb_translate_sign_statusesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_translate_sign_statuses
     */
    select?: tb_translate_sign_statusesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_translate_sign_statuses
     */
    omit?: tb_translate_sign_statusesOmit<ExtArgs> | null
    /**
     * The data needed to update a tb_translate_sign_statuses.
     */
    data: XOR<tb_translate_sign_statusesUpdateInput, tb_translate_sign_statusesUncheckedUpdateInput>
    /**
     * Choose, which tb_translate_sign_statuses to update.
     */
    where: tb_translate_sign_statusesWhereUniqueInput
  }

  /**
   * tb_translate_sign_statuses updateMany
   */
  export type tb_translate_sign_statusesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update tb_translate_sign_statuses.
     */
    data: XOR<tb_translate_sign_statusesUpdateManyMutationInput, tb_translate_sign_statusesUncheckedUpdateManyInput>
    /**
     * Filter which tb_translate_sign_statuses to update
     */
    where?: tb_translate_sign_statusesWhereInput
    /**
     * Limit how many tb_translate_sign_statuses to update.
     */
    limit?: number
  }

  /**
   * tb_translate_sign_statuses upsert
   */
  export type tb_translate_sign_statusesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_translate_sign_statuses
     */
    select?: tb_translate_sign_statusesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_translate_sign_statuses
     */
    omit?: tb_translate_sign_statusesOmit<ExtArgs> | null
    /**
     * The filter to search for the tb_translate_sign_statuses to update in case it exists.
     */
    where: tb_translate_sign_statusesWhereUniqueInput
    /**
     * In case the tb_translate_sign_statuses found by the `where` argument doesn't exist, create a new tb_translate_sign_statuses with this data.
     */
    create: XOR<tb_translate_sign_statusesCreateInput, tb_translate_sign_statusesUncheckedCreateInput>
    /**
     * In case the tb_translate_sign_statuses was found with the provided `where` argument, update it with this data.
     */
    update: XOR<tb_translate_sign_statusesUpdateInput, tb_translate_sign_statusesUncheckedUpdateInput>
  }

  /**
   * tb_translate_sign_statuses delete
   */
  export type tb_translate_sign_statusesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_translate_sign_statuses
     */
    select?: tb_translate_sign_statusesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_translate_sign_statuses
     */
    omit?: tb_translate_sign_statusesOmit<ExtArgs> | null
    /**
     * Filter which tb_translate_sign_statuses to delete.
     */
    where: tb_translate_sign_statusesWhereUniqueInput
  }

  /**
   * tb_translate_sign_statuses deleteMany
   */
  export type tb_translate_sign_statusesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tb_translate_sign_statuses to delete
     */
    where?: tb_translate_sign_statusesWhereInput
    /**
     * Limit how many tb_translate_sign_statuses to delete.
     */
    limit?: number
  }

  /**
   * tb_translate_sign_statuses without action
   */
  export type tb_translate_sign_statusesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_translate_sign_statuses
     */
    select?: tb_translate_sign_statusesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_translate_sign_statuses
     */
    omit?: tb_translate_sign_statusesOmit<ExtArgs> | null
  }


  /**
   * Model tb_translation_type
   */

  export type AggregateTb_translation_type = {
    _count: Tb_translation_typeCountAggregateOutputType | null
    _avg: Tb_translation_typeAvgAggregateOutputType | null
    _sum: Tb_translation_typeSumAggregateOutputType | null
    _min: Tb_translation_typeMinAggregateOutputType | null
    _max: Tb_translation_typeMaxAggregateOutputType | null
  }

  export type Tb_translation_typeAvgAggregateOutputType = {
    ttype_id: number | null
  }

  export type Tb_translation_typeSumAggregateOutputType = {
    ttype_id: number | null
  }

  export type Tb_translation_typeMinAggregateOutputType = {
    ttype_id: number | null
    trans_type: string | null
  }

  export type Tb_translation_typeMaxAggregateOutputType = {
    ttype_id: number | null
    trans_type: string | null
  }

  export type Tb_translation_typeCountAggregateOutputType = {
    ttype_id: number
    trans_type: number
    _all: number
  }


  export type Tb_translation_typeAvgAggregateInputType = {
    ttype_id?: true
  }

  export type Tb_translation_typeSumAggregateInputType = {
    ttype_id?: true
  }

  export type Tb_translation_typeMinAggregateInputType = {
    ttype_id?: true
    trans_type?: true
  }

  export type Tb_translation_typeMaxAggregateInputType = {
    ttype_id?: true
    trans_type?: true
  }

  export type Tb_translation_typeCountAggregateInputType = {
    ttype_id?: true
    trans_type?: true
    _all?: true
  }

  export type Tb_translation_typeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tb_translation_type to aggregate.
     */
    where?: tb_translation_typeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tb_translation_types to fetch.
     */
    orderBy?: tb_translation_typeOrderByWithRelationInput | tb_translation_typeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: tb_translation_typeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tb_translation_types from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tb_translation_types.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned tb_translation_types
    **/
    _count?: true | Tb_translation_typeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Tb_translation_typeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Tb_translation_typeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Tb_translation_typeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Tb_translation_typeMaxAggregateInputType
  }

  export type GetTb_translation_typeAggregateType<T extends Tb_translation_typeAggregateArgs> = {
        [P in keyof T & keyof AggregateTb_translation_type]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTb_translation_type[P]>
      : GetScalarType<T[P], AggregateTb_translation_type[P]>
  }




  export type tb_translation_typeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: tb_translation_typeWhereInput
    orderBy?: tb_translation_typeOrderByWithAggregationInput | tb_translation_typeOrderByWithAggregationInput[]
    by: Tb_translation_typeScalarFieldEnum[] | Tb_translation_typeScalarFieldEnum
    having?: tb_translation_typeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Tb_translation_typeCountAggregateInputType | true
    _avg?: Tb_translation_typeAvgAggregateInputType
    _sum?: Tb_translation_typeSumAggregateInputType
    _min?: Tb_translation_typeMinAggregateInputType
    _max?: Tb_translation_typeMaxAggregateInputType
  }

  export type Tb_translation_typeGroupByOutputType = {
    ttype_id: number
    trans_type: string
    _count: Tb_translation_typeCountAggregateOutputType | null
    _avg: Tb_translation_typeAvgAggregateOutputType | null
    _sum: Tb_translation_typeSumAggregateOutputType | null
    _min: Tb_translation_typeMinAggregateOutputType | null
    _max: Tb_translation_typeMaxAggregateOutputType | null
  }

  type GetTb_translation_typeGroupByPayload<T extends tb_translation_typeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Tb_translation_typeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Tb_translation_typeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Tb_translation_typeGroupByOutputType[P]>
            : GetScalarType<T[P], Tb_translation_typeGroupByOutputType[P]>
        }
      >
    >


  export type tb_translation_typeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    ttype_id?: boolean
    trans_type?: boolean
  }, ExtArgs["result"]["tb_translation_type"]>



  export type tb_translation_typeSelectScalar = {
    ttype_id?: boolean
    trans_type?: boolean
  }

  export type tb_translation_typeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"ttype_id" | "trans_type", ExtArgs["result"]["tb_translation_type"]>

  export type $tb_translation_typePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "tb_translation_type"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      ttype_id: number
      trans_type: string
    }, ExtArgs["result"]["tb_translation_type"]>
    composites: {}
  }

  type tb_translation_typeGetPayload<S extends boolean | null | undefined | tb_translation_typeDefaultArgs> = $Result.GetResult<Prisma.$tb_translation_typePayload, S>

  type tb_translation_typeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<tb_translation_typeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Tb_translation_typeCountAggregateInputType | true
    }

  export interface tb_translation_typeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['tb_translation_type'], meta: { name: 'tb_translation_type' } }
    /**
     * Find zero or one Tb_translation_type that matches the filter.
     * @param {tb_translation_typeFindUniqueArgs} args - Arguments to find a Tb_translation_type
     * @example
     * // Get one Tb_translation_type
     * const tb_translation_type = await prisma.tb_translation_type.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends tb_translation_typeFindUniqueArgs>(args: SelectSubset<T, tb_translation_typeFindUniqueArgs<ExtArgs>>): Prisma__tb_translation_typeClient<$Result.GetResult<Prisma.$tb_translation_typePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Tb_translation_type that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {tb_translation_typeFindUniqueOrThrowArgs} args - Arguments to find a Tb_translation_type
     * @example
     * // Get one Tb_translation_type
     * const tb_translation_type = await prisma.tb_translation_type.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends tb_translation_typeFindUniqueOrThrowArgs>(args: SelectSubset<T, tb_translation_typeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__tb_translation_typeClient<$Result.GetResult<Prisma.$tb_translation_typePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tb_translation_type that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_translation_typeFindFirstArgs} args - Arguments to find a Tb_translation_type
     * @example
     * // Get one Tb_translation_type
     * const tb_translation_type = await prisma.tb_translation_type.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends tb_translation_typeFindFirstArgs>(args?: SelectSubset<T, tb_translation_typeFindFirstArgs<ExtArgs>>): Prisma__tb_translation_typeClient<$Result.GetResult<Prisma.$tb_translation_typePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tb_translation_type that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_translation_typeFindFirstOrThrowArgs} args - Arguments to find a Tb_translation_type
     * @example
     * // Get one Tb_translation_type
     * const tb_translation_type = await prisma.tb_translation_type.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends tb_translation_typeFindFirstOrThrowArgs>(args?: SelectSubset<T, tb_translation_typeFindFirstOrThrowArgs<ExtArgs>>): Prisma__tb_translation_typeClient<$Result.GetResult<Prisma.$tb_translation_typePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Tb_translation_types that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_translation_typeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tb_translation_types
     * const tb_translation_types = await prisma.tb_translation_type.findMany()
     * 
     * // Get first 10 Tb_translation_types
     * const tb_translation_types = await prisma.tb_translation_type.findMany({ take: 10 })
     * 
     * // Only select the `ttype_id`
     * const tb_translation_typeWithTtype_idOnly = await prisma.tb_translation_type.findMany({ select: { ttype_id: true } })
     * 
     */
    findMany<T extends tb_translation_typeFindManyArgs>(args?: SelectSubset<T, tb_translation_typeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tb_translation_typePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Tb_translation_type.
     * @param {tb_translation_typeCreateArgs} args - Arguments to create a Tb_translation_type.
     * @example
     * // Create one Tb_translation_type
     * const Tb_translation_type = await prisma.tb_translation_type.create({
     *   data: {
     *     // ... data to create a Tb_translation_type
     *   }
     * })
     * 
     */
    create<T extends tb_translation_typeCreateArgs>(args: SelectSubset<T, tb_translation_typeCreateArgs<ExtArgs>>): Prisma__tb_translation_typeClient<$Result.GetResult<Prisma.$tb_translation_typePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Tb_translation_types.
     * @param {tb_translation_typeCreateManyArgs} args - Arguments to create many Tb_translation_types.
     * @example
     * // Create many Tb_translation_types
     * const tb_translation_type = await prisma.tb_translation_type.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends tb_translation_typeCreateManyArgs>(args?: SelectSubset<T, tb_translation_typeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Tb_translation_type.
     * @param {tb_translation_typeDeleteArgs} args - Arguments to delete one Tb_translation_type.
     * @example
     * // Delete one Tb_translation_type
     * const Tb_translation_type = await prisma.tb_translation_type.delete({
     *   where: {
     *     // ... filter to delete one Tb_translation_type
     *   }
     * })
     * 
     */
    delete<T extends tb_translation_typeDeleteArgs>(args: SelectSubset<T, tb_translation_typeDeleteArgs<ExtArgs>>): Prisma__tb_translation_typeClient<$Result.GetResult<Prisma.$tb_translation_typePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Tb_translation_type.
     * @param {tb_translation_typeUpdateArgs} args - Arguments to update one Tb_translation_type.
     * @example
     * // Update one Tb_translation_type
     * const tb_translation_type = await prisma.tb_translation_type.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends tb_translation_typeUpdateArgs>(args: SelectSubset<T, tb_translation_typeUpdateArgs<ExtArgs>>): Prisma__tb_translation_typeClient<$Result.GetResult<Prisma.$tb_translation_typePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Tb_translation_types.
     * @param {tb_translation_typeDeleteManyArgs} args - Arguments to filter Tb_translation_types to delete.
     * @example
     * // Delete a few Tb_translation_types
     * const { count } = await prisma.tb_translation_type.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends tb_translation_typeDeleteManyArgs>(args?: SelectSubset<T, tb_translation_typeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tb_translation_types.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_translation_typeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tb_translation_types
     * const tb_translation_type = await prisma.tb_translation_type.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends tb_translation_typeUpdateManyArgs>(args: SelectSubset<T, tb_translation_typeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Tb_translation_type.
     * @param {tb_translation_typeUpsertArgs} args - Arguments to update or create a Tb_translation_type.
     * @example
     * // Update or create a Tb_translation_type
     * const tb_translation_type = await prisma.tb_translation_type.upsert({
     *   create: {
     *     // ... data to create a Tb_translation_type
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tb_translation_type we want to update
     *   }
     * })
     */
    upsert<T extends tb_translation_typeUpsertArgs>(args: SelectSubset<T, tb_translation_typeUpsertArgs<ExtArgs>>): Prisma__tb_translation_typeClient<$Result.GetResult<Prisma.$tb_translation_typePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Tb_translation_types.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_translation_typeCountArgs} args - Arguments to filter Tb_translation_types to count.
     * @example
     * // Count the number of Tb_translation_types
     * const count = await prisma.tb_translation_type.count({
     *   where: {
     *     // ... the filter for the Tb_translation_types we want to count
     *   }
     * })
    **/
    count<T extends tb_translation_typeCountArgs>(
      args?: Subset<T, tb_translation_typeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Tb_translation_typeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tb_translation_type.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Tb_translation_typeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Tb_translation_typeAggregateArgs>(args: Subset<T, Tb_translation_typeAggregateArgs>): Prisma.PrismaPromise<GetTb_translation_typeAggregateType<T>>

    /**
     * Group by Tb_translation_type.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_translation_typeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends tb_translation_typeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: tb_translation_typeGroupByArgs['orderBy'] }
        : { orderBy?: tb_translation_typeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, tb_translation_typeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTb_translation_typeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the tb_translation_type model
   */
  readonly fields: tb_translation_typeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for tb_translation_type.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__tb_translation_typeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the tb_translation_type model
   */
  interface tb_translation_typeFieldRefs {
    readonly ttype_id: FieldRef<"tb_translation_type", 'Int'>
    readonly trans_type: FieldRef<"tb_translation_type", 'String'>
  }
    

  // Custom InputTypes
  /**
   * tb_translation_type findUnique
   */
  export type tb_translation_typeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_translation_type
     */
    select?: tb_translation_typeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_translation_type
     */
    omit?: tb_translation_typeOmit<ExtArgs> | null
    /**
     * Filter, which tb_translation_type to fetch.
     */
    where: tb_translation_typeWhereUniqueInput
  }

  /**
   * tb_translation_type findUniqueOrThrow
   */
  export type tb_translation_typeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_translation_type
     */
    select?: tb_translation_typeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_translation_type
     */
    omit?: tb_translation_typeOmit<ExtArgs> | null
    /**
     * Filter, which tb_translation_type to fetch.
     */
    where: tb_translation_typeWhereUniqueInput
  }

  /**
   * tb_translation_type findFirst
   */
  export type tb_translation_typeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_translation_type
     */
    select?: tb_translation_typeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_translation_type
     */
    omit?: tb_translation_typeOmit<ExtArgs> | null
    /**
     * Filter, which tb_translation_type to fetch.
     */
    where?: tb_translation_typeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tb_translation_types to fetch.
     */
    orderBy?: tb_translation_typeOrderByWithRelationInput | tb_translation_typeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tb_translation_types.
     */
    cursor?: tb_translation_typeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tb_translation_types from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tb_translation_types.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tb_translation_types.
     */
    distinct?: Tb_translation_typeScalarFieldEnum | Tb_translation_typeScalarFieldEnum[]
  }

  /**
   * tb_translation_type findFirstOrThrow
   */
  export type tb_translation_typeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_translation_type
     */
    select?: tb_translation_typeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_translation_type
     */
    omit?: tb_translation_typeOmit<ExtArgs> | null
    /**
     * Filter, which tb_translation_type to fetch.
     */
    where?: tb_translation_typeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tb_translation_types to fetch.
     */
    orderBy?: tb_translation_typeOrderByWithRelationInput | tb_translation_typeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tb_translation_types.
     */
    cursor?: tb_translation_typeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tb_translation_types from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tb_translation_types.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tb_translation_types.
     */
    distinct?: Tb_translation_typeScalarFieldEnum | Tb_translation_typeScalarFieldEnum[]
  }

  /**
   * tb_translation_type findMany
   */
  export type tb_translation_typeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_translation_type
     */
    select?: tb_translation_typeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_translation_type
     */
    omit?: tb_translation_typeOmit<ExtArgs> | null
    /**
     * Filter, which tb_translation_types to fetch.
     */
    where?: tb_translation_typeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tb_translation_types to fetch.
     */
    orderBy?: tb_translation_typeOrderByWithRelationInput | tb_translation_typeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing tb_translation_types.
     */
    cursor?: tb_translation_typeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tb_translation_types from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tb_translation_types.
     */
    skip?: number
    distinct?: Tb_translation_typeScalarFieldEnum | Tb_translation_typeScalarFieldEnum[]
  }

  /**
   * tb_translation_type create
   */
  export type tb_translation_typeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_translation_type
     */
    select?: tb_translation_typeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_translation_type
     */
    omit?: tb_translation_typeOmit<ExtArgs> | null
    /**
     * The data needed to create a tb_translation_type.
     */
    data: XOR<tb_translation_typeCreateInput, tb_translation_typeUncheckedCreateInput>
  }

  /**
   * tb_translation_type createMany
   */
  export type tb_translation_typeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many tb_translation_types.
     */
    data: tb_translation_typeCreateManyInput | tb_translation_typeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * tb_translation_type update
   */
  export type tb_translation_typeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_translation_type
     */
    select?: tb_translation_typeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_translation_type
     */
    omit?: tb_translation_typeOmit<ExtArgs> | null
    /**
     * The data needed to update a tb_translation_type.
     */
    data: XOR<tb_translation_typeUpdateInput, tb_translation_typeUncheckedUpdateInput>
    /**
     * Choose, which tb_translation_type to update.
     */
    where: tb_translation_typeWhereUniqueInput
  }

  /**
   * tb_translation_type updateMany
   */
  export type tb_translation_typeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update tb_translation_types.
     */
    data: XOR<tb_translation_typeUpdateManyMutationInput, tb_translation_typeUncheckedUpdateManyInput>
    /**
     * Filter which tb_translation_types to update
     */
    where?: tb_translation_typeWhereInput
    /**
     * Limit how many tb_translation_types to update.
     */
    limit?: number
  }

  /**
   * tb_translation_type upsert
   */
  export type tb_translation_typeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_translation_type
     */
    select?: tb_translation_typeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_translation_type
     */
    omit?: tb_translation_typeOmit<ExtArgs> | null
    /**
     * The filter to search for the tb_translation_type to update in case it exists.
     */
    where: tb_translation_typeWhereUniqueInput
    /**
     * In case the tb_translation_type found by the `where` argument doesn't exist, create a new tb_translation_type with this data.
     */
    create: XOR<tb_translation_typeCreateInput, tb_translation_typeUncheckedCreateInput>
    /**
     * In case the tb_translation_type was found with the provided `where` argument, update it with this data.
     */
    update: XOR<tb_translation_typeUpdateInput, tb_translation_typeUncheckedUpdateInput>
  }

  /**
   * tb_translation_type delete
   */
  export type tb_translation_typeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_translation_type
     */
    select?: tb_translation_typeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_translation_type
     */
    omit?: tb_translation_typeOmit<ExtArgs> | null
    /**
     * Filter which tb_translation_type to delete.
     */
    where: tb_translation_typeWhereUniqueInput
  }

  /**
   * tb_translation_type deleteMany
   */
  export type tb_translation_typeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tb_translation_types to delete
     */
    where?: tb_translation_typeWhereInput
    /**
     * Limit how many tb_translation_types to delete.
     */
    limit?: number
  }

  /**
   * tb_translation_type without action
   */
  export type tb_translation_typeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_translation_type
     */
    select?: tb_translation_typeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_translation_type
     */
    omit?: tb_translation_typeOmit<ExtArgs> | null
  }


  /**
   * Model tb_translators
   */

  export type AggregateTb_translators = {
    _count: Tb_translatorsCountAggregateOutputType | null
    _avg: Tb_translatorsAvgAggregateOutputType | null
    _sum: Tb_translatorsSumAggregateOutputType | null
    _min: Tb_translatorsMinAggregateOutputType | null
    _max: Tb_translatorsMaxAggregateOutputType | null
  }

  export type Tb_translatorsAvgAggregateOutputType = {
    translator_id: number | null
    active_status: number | null
  }

  export type Tb_translatorsSumAggregateOutputType = {
    translator_id: number | null
    active_status: number | null
  }

  export type Tb_translatorsMinAggregateOutputType = {
    translator_id: number | null
    translator_name_arm: string | null
    translator_name_eng: string | null
    email: string | null
    test_mail: string | null
    logo_file: string | null
    active_status: number | null
  }

  export type Tb_translatorsMaxAggregateOutputType = {
    translator_id: number | null
    translator_name_arm: string | null
    translator_name_eng: string | null
    email: string | null
    test_mail: string | null
    logo_file: string | null
    active_status: number | null
  }

  export type Tb_translatorsCountAggregateOutputType = {
    translator_id: number
    translator_name_arm: number
    translator_name_eng: number
    email: number
    test_mail: number
    logo_file: number
    active_status: number
    _all: number
  }


  export type Tb_translatorsAvgAggregateInputType = {
    translator_id?: true
    active_status?: true
  }

  export type Tb_translatorsSumAggregateInputType = {
    translator_id?: true
    active_status?: true
  }

  export type Tb_translatorsMinAggregateInputType = {
    translator_id?: true
    translator_name_arm?: true
    translator_name_eng?: true
    email?: true
    test_mail?: true
    logo_file?: true
    active_status?: true
  }

  export type Tb_translatorsMaxAggregateInputType = {
    translator_id?: true
    translator_name_arm?: true
    translator_name_eng?: true
    email?: true
    test_mail?: true
    logo_file?: true
    active_status?: true
  }

  export type Tb_translatorsCountAggregateInputType = {
    translator_id?: true
    translator_name_arm?: true
    translator_name_eng?: true
    email?: true
    test_mail?: true
    logo_file?: true
    active_status?: true
    _all?: true
  }

  export type Tb_translatorsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tb_translators to aggregate.
     */
    where?: tb_translatorsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tb_translators to fetch.
     */
    orderBy?: tb_translatorsOrderByWithRelationInput | tb_translatorsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: tb_translatorsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tb_translators from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tb_translators.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned tb_translators
    **/
    _count?: true | Tb_translatorsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Tb_translatorsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Tb_translatorsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Tb_translatorsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Tb_translatorsMaxAggregateInputType
  }

  export type GetTb_translatorsAggregateType<T extends Tb_translatorsAggregateArgs> = {
        [P in keyof T & keyof AggregateTb_translators]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTb_translators[P]>
      : GetScalarType<T[P], AggregateTb_translators[P]>
  }




  export type tb_translatorsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: tb_translatorsWhereInput
    orderBy?: tb_translatorsOrderByWithAggregationInput | tb_translatorsOrderByWithAggregationInput[]
    by: Tb_translatorsScalarFieldEnum[] | Tb_translatorsScalarFieldEnum
    having?: tb_translatorsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Tb_translatorsCountAggregateInputType | true
    _avg?: Tb_translatorsAvgAggregateInputType
    _sum?: Tb_translatorsSumAggregateInputType
    _min?: Tb_translatorsMinAggregateInputType
    _max?: Tb_translatorsMaxAggregateInputType
  }

  export type Tb_translatorsGroupByOutputType = {
    translator_id: number
    translator_name_arm: string
    translator_name_eng: string
    email: string
    test_mail: string
    logo_file: string | null
    active_status: number | null
    _count: Tb_translatorsCountAggregateOutputType | null
    _avg: Tb_translatorsAvgAggregateOutputType | null
    _sum: Tb_translatorsSumAggregateOutputType | null
    _min: Tb_translatorsMinAggregateOutputType | null
    _max: Tb_translatorsMaxAggregateOutputType | null
  }

  type GetTb_translatorsGroupByPayload<T extends tb_translatorsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Tb_translatorsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Tb_translatorsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Tb_translatorsGroupByOutputType[P]>
            : GetScalarType<T[P], Tb_translatorsGroupByOutputType[P]>
        }
      >
    >


  export type tb_translatorsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    translator_id?: boolean
    translator_name_arm?: boolean
    translator_name_eng?: boolean
    email?: boolean
    test_mail?: boolean
    logo_file?: boolean
    active_status?: boolean
  }, ExtArgs["result"]["tb_translators"]>



  export type tb_translatorsSelectScalar = {
    translator_id?: boolean
    translator_name_arm?: boolean
    translator_name_eng?: boolean
    email?: boolean
    test_mail?: boolean
    logo_file?: boolean
    active_status?: boolean
  }

  export type tb_translatorsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"translator_id" | "translator_name_arm" | "translator_name_eng" | "email" | "test_mail" | "logo_file" | "active_status", ExtArgs["result"]["tb_translators"]>

  export type $tb_translatorsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "tb_translators"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      translator_id: number
      translator_name_arm: string
      translator_name_eng: string
      email: string
      test_mail: string
      logo_file: string | null
      active_status: number | null
    }, ExtArgs["result"]["tb_translators"]>
    composites: {}
  }

  type tb_translatorsGetPayload<S extends boolean | null | undefined | tb_translatorsDefaultArgs> = $Result.GetResult<Prisma.$tb_translatorsPayload, S>

  type tb_translatorsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<tb_translatorsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Tb_translatorsCountAggregateInputType | true
    }

  export interface tb_translatorsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['tb_translators'], meta: { name: 'tb_translators' } }
    /**
     * Find zero or one Tb_translators that matches the filter.
     * @param {tb_translatorsFindUniqueArgs} args - Arguments to find a Tb_translators
     * @example
     * // Get one Tb_translators
     * const tb_translators = await prisma.tb_translators.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends tb_translatorsFindUniqueArgs>(args: SelectSubset<T, tb_translatorsFindUniqueArgs<ExtArgs>>): Prisma__tb_translatorsClient<$Result.GetResult<Prisma.$tb_translatorsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Tb_translators that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {tb_translatorsFindUniqueOrThrowArgs} args - Arguments to find a Tb_translators
     * @example
     * // Get one Tb_translators
     * const tb_translators = await prisma.tb_translators.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends tb_translatorsFindUniqueOrThrowArgs>(args: SelectSubset<T, tb_translatorsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__tb_translatorsClient<$Result.GetResult<Prisma.$tb_translatorsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tb_translators that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_translatorsFindFirstArgs} args - Arguments to find a Tb_translators
     * @example
     * // Get one Tb_translators
     * const tb_translators = await prisma.tb_translators.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends tb_translatorsFindFirstArgs>(args?: SelectSubset<T, tb_translatorsFindFirstArgs<ExtArgs>>): Prisma__tb_translatorsClient<$Result.GetResult<Prisma.$tb_translatorsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tb_translators that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_translatorsFindFirstOrThrowArgs} args - Arguments to find a Tb_translators
     * @example
     * // Get one Tb_translators
     * const tb_translators = await prisma.tb_translators.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends tb_translatorsFindFirstOrThrowArgs>(args?: SelectSubset<T, tb_translatorsFindFirstOrThrowArgs<ExtArgs>>): Prisma__tb_translatorsClient<$Result.GetResult<Prisma.$tb_translatorsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Tb_translators that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_translatorsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tb_translators
     * const tb_translators = await prisma.tb_translators.findMany()
     * 
     * // Get first 10 Tb_translators
     * const tb_translators = await prisma.tb_translators.findMany({ take: 10 })
     * 
     * // Only select the `translator_id`
     * const tb_translatorsWithTranslator_idOnly = await prisma.tb_translators.findMany({ select: { translator_id: true } })
     * 
     */
    findMany<T extends tb_translatorsFindManyArgs>(args?: SelectSubset<T, tb_translatorsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tb_translatorsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Tb_translators.
     * @param {tb_translatorsCreateArgs} args - Arguments to create a Tb_translators.
     * @example
     * // Create one Tb_translators
     * const Tb_translators = await prisma.tb_translators.create({
     *   data: {
     *     // ... data to create a Tb_translators
     *   }
     * })
     * 
     */
    create<T extends tb_translatorsCreateArgs>(args: SelectSubset<T, tb_translatorsCreateArgs<ExtArgs>>): Prisma__tb_translatorsClient<$Result.GetResult<Prisma.$tb_translatorsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Tb_translators.
     * @param {tb_translatorsCreateManyArgs} args - Arguments to create many Tb_translators.
     * @example
     * // Create many Tb_translators
     * const tb_translators = await prisma.tb_translators.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends tb_translatorsCreateManyArgs>(args?: SelectSubset<T, tb_translatorsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Tb_translators.
     * @param {tb_translatorsDeleteArgs} args - Arguments to delete one Tb_translators.
     * @example
     * // Delete one Tb_translators
     * const Tb_translators = await prisma.tb_translators.delete({
     *   where: {
     *     // ... filter to delete one Tb_translators
     *   }
     * })
     * 
     */
    delete<T extends tb_translatorsDeleteArgs>(args: SelectSubset<T, tb_translatorsDeleteArgs<ExtArgs>>): Prisma__tb_translatorsClient<$Result.GetResult<Prisma.$tb_translatorsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Tb_translators.
     * @param {tb_translatorsUpdateArgs} args - Arguments to update one Tb_translators.
     * @example
     * // Update one Tb_translators
     * const tb_translators = await prisma.tb_translators.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends tb_translatorsUpdateArgs>(args: SelectSubset<T, tb_translatorsUpdateArgs<ExtArgs>>): Prisma__tb_translatorsClient<$Result.GetResult<Prisma.$tb_translatorsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Tb_translators.
     * @param {tb_translatorsDeleteManyArgs} args - Arguments to filter Tb_translators to delete.
     * @example
     * // Delete a few Tb_translators
     * const { count } = await prisma.tb_translators.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends tb_translatorsDeleteManyArgs>(args?: SelectSubset<T, tb_translatorsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tb_translators.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_translatorsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tb_translators
     * const tb_translators = await prisma.tb_translators.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends tb_translatorsUpdateManyArgs>(args: SelectSubset<T, tb_translatorsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Tb_translators.
     * @param {tb_translatorsUpsertArgs} args - Arguments to update or create a Tb_translators.
     * @example
     * // Update or create a Tb_translators
     * const tb_translators = await prisma.tb_translators.upsert({
     *   create: {
     *     // ... data to create a Tb_translators
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tb_translators we want to update
     *   }
     * })
     */
    upsert<T extends tb_translatorsUpsertArgs>(args: SelectSubset<T, tb_translatorsUpsertArgs<ExtArgs>>): Prisma__tb_translatorsClient<$Result.GetResult<Prisma.$tb_translatorsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Tb_translators.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_translatorsCountArgs} args - Arguments to filter Tb_translators to count.
     * @example
     * // Count the number of Tb_translators
     * const count = await prisma.tb_translators.count({
     *   where: {
     *     // ... the filter for the Tb_translators we want to count
     *   }
     * })
    **/
    count<T extends tb_translatorsCountArgs>(
      args?: Subset<T, tb_translatorsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Tb_translatorsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tb_translators.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Tb_translatorsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Tb_translatorsAggregateArgs>(args: Subset<T, Tb_translatorsAggregateArgs>): Prisma.PrismaPromise<GetTb_translatorsAggregateType<T>>

    /**
     * Group by Tb_translators.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tb_translatorsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends tb_translatorsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: tb_translatorsGroupByArgs['orderBy'] }
        : { orderBy?: tb_translatorsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, tb_translatorsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTb_translatorsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the tb_translators model
   */
  readonly fields: tb_translatorsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for tb_translators.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__tb_translatorsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the tb_translators model
   */
  interface tb_translatorsFieldRefs {
    readonly translator_id: FieldRef<"tb_translators", 'Int'>
    readonly translator_name_arm: FieldRef<"tb_translators", 'String'>
    readonly translator_name_eng: FieldRef<"tb_translators", 'String'>
    readonly email: FieldRef<"tb_translators", 'String'>
    readonly test_mail: FieldRef<"tb_translators", 'String'>
    readonly logo_file: FieldRef<"tb_translators", 'String'>
    readonly active_status: FieldRef<"tb_translators", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * tb_translators findUnique
   */
  export type tb_translatorsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_translators
     */
    select?: tb_translatorsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_translators
     */
    omit?: tb_translatorsOmit<ExtArgs> | null
    /**
     * Filter, which tb_translators to fetch.
     */
    where: tb_translatorsWhereUniqueInput
  }

  /**
   * tb_translators findUniqueOrThrow
   */
  export type tb_translatorsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_translators
     */
    select?: tb_translatorsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_translators
     */
    omit?: tb_translatorsOmit<ExtArgs> | null
    /**
     * Filter, which tb_translators to fetch.
     */
    where: tb_translatorsWhereUniqueInput
  }

  /**
   * tb_translators findFirst
   */
  export type tb_translatorsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_translators
     */
    select?: tb_translatorsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_translators
     */
    omit?: tb_translatorsOmit<ExtArgs> | null
    /**
     * Filter, which tb_translators to fetch.
     */
    where?: tb_translatorsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tb_translators to fetch.
     */
    orderBy?: tb_translatorsOrderByWithRelationInput | tb_translatorsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tb_translators.
     */
    cursor?: tb_translatorsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tb_translators from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tb_translators.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tb_translators.
     */
    distinct?: Tb_translatorsScalarFieldEnum | Tb_translatorsScalarFieldEnum[]
  }

  /**
   * tb_translators findFirstOrThrow
   */
  export type tb_translatorsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_translators
     */
    select?: tb_translatorsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_translators
     */
    omit?: tb_translatorsOmit<ExtArgs> | null
    /**
     * Filter, which tb_translators to fetch.
     */
    where?: tb_translatorsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tb_translators to fetch.
     */
    orderBy?: tb_translatorsOrderByWithRelationInput | tb_translatorsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tb_translators.
     */
    cursor?: tb_translatorsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tb_translators from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tb_translators.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tb_translators.
     */
    distinct?: Tb_translatorsScalarFieldEnum | Tb_translatorsScalarFieldEnum[]
  }

  /**
   * tb_translators findMany
   */
  export type tb_translatorsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_translators
     */
    select?: tb_translatorsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_translators
     */
    omit?: tb_translatorsOmit<ExtArgs> | null
    /**
     * Filter, which tb_translators to fetch.
     */
    where?: tb_translatorsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tb_translators to fetch.
     */
    orderBy?: tb_translatorsOrderByWithRelationInput | tb_translatorsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing tb_translators.
     */
    cursor?: tb_translatorsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tb_translators from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tb_translators.
     */
    skip?: number
    distinct?: Tb_translatorsScalarFieldEnum | Tb_translatorsScalarFieldEnum[]
  }

  /**
   * tb_translators create
   */
  export type tb_translatorsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_translators
     */
    select?: tb_translatorsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_translators
     */
    omit?: tb_translatorsOmit<ExtArgs> | null
    /**
     * The data needed to create a tb_translators.
     */
    data: XOR<tb_translatorsCreateInput, tb_translatorsUncheckedCreateInput>
  }

  /**
   * tb_translators createMany
   */
  export type tb_translatorsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many tb_translators.
     */
    data: tb_translatorsCreateManyInput | tb_translatorsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * tb_translators update
   */
  export type tb_translatorsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_translators
     */
    select?: tb_translatorsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_translators
     */
    omit?: tb_translatorsOmit<ExtArgs> | null
    /**
     * The data needed to update a tb_translators.
     */
    data: XOR<tb_translatorsUpdateInput, tb_translatorsUncheckedUpdateInput>
    /**
     * Choose, which tb_translators to update.
     */
    where: tb_translatorsWhereUniqueInput
  }

  /**
   * tb_translators updateMany
   */
  export type tb_translatorsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update tb_translators.
     */
    data: XOR<tb_translatorsUpdateManyMutationInput, tb_translatorsUncheckedUpdateManyInput>
    /**
     * Filter which tb_translators to update
     */
    where?: tb_translatorsWhereInput
    /**
     * Limit how many tb_translators to update.
     */
    limit?: number
  }

  /**
   * tb_translators upsert
   */
  export type tb_translatorsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_translators
     */
    select?: tb_translatorsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_translators
     */
    omit?: tb_translatorsOmit<ExtArgs> | null
    /**
     * The filter to search for the tb_translators to update in case it exists.
     */
    where: tb_translatorsWhereUniqueInput
    /**
     * In case the tb_translators found by the `where` argument doesn't exist, create a new tb_translators with this data.
     */
    create: XOR<tb_translatorsCreateInput, tb_translatorsUncheckedCreateInput>
    /**
     * In case the tb_translators was found with the provided `where` argument, update it with this data.
     */
    update: XOR<tb_translatorsUpdateInput, tb_translatorsUncheckedUpdateInput>
  }

  /**
   * tb_translators delete
   */
  export type tb_translatorsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_translators
     */
    select?: tb_translatorsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_translators
     */
    omit?: tb_translatorsOmit<ExtArgs> | null
    /**
     * Filter which tb_translators to delete.
     */
    where: tb_translatorsWhereUniqueInput
  }

  /**
   * tb_translators deleteMany
   */
  export type tb_translatorsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tb_translators to delete
     */
    where?: tb_translatorsWhereInput
    /**
     * Limit how many tb_translators to delete.
     */
    limit?: number
  }

  /**
   * tb_translators without action
   */
  export type tb_translatorsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tb_translators
     */
    select?: tb_translatorsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tb_translators
     */
    omit?: tb_translatorsOmit<ExtArgs> | null
  }


  /**
   * Model users
   */

  export type AggregateUsers = {
    _count: UsersCountAggregateOutputType | null
    _avg: UsersAvgAggregateOutputType | null
    _sum: UsersSumAggregateOutputType | null
    _min: UsersMinAggregateOutputType | null
    _max: UsersMaxAggregateOutputType | null
  }

  export type UsersAvgAggregateOutputType = {
    id: number | null
    user_status: number | null
    last_activity: number | null
  }

  export type UsersSumAggregateOutputType = {
    id: number | null
    user_status: number | null
    last_activity: bigint | null
  }

  export type UsersMinAggregateOutputType = {
    id: number | null
    username: string | null
    password: string | null
    f_name: string | null
    l_name: string | null
    user_type: string | null
    user_status: number | null
    last_activity: bigint | null
  }

  export type UsersMaxAggregateOutputType = {
    id: number | null
    username: string | null
    password: string | null
    f_name: string | null
    l_name: string | null
    user_type: string | null
    user_status: number | null
    last_activity: bigint | null
  }

  export type UsersCountAggregateOutputType = {
    id: number
    username: number
    password: number
    f_name: number
    l_name: number
    user_type: number
    user_status: number
    last_activity: number
    _all: number
  }


  export type UsersAvgAggregateInputType = {
    id?: true
    user_status?: true
    last_activity?: true
  }

  export type UsersSumAggregateInputType = {
    id?: true
    user_status?: true
    last_activity?: true
  }

  export type UsersMinAggregateInputType = {
    id?: true
    username?: true
    password?: true
    f_name?: true
    l_name?: true
    user_type?: true
    user_status?: true
    last_activity?: true
  }

  export type UsersMaxAggregateInputType = {
    id?: true
    username?: true
    password?: true
    f_name?: true
    l_name?: true
    user_type?: true
    user_status?: true
    last_activity?: true
  }

  export type UsersCountAggregateInputType = {
    id?: true
    username?: true
    password?: true
    f_name?: true
    l_name?: true
    user_type?: true
    user_status?: true
    last_activity?: true
    _all?: true
  }

  export type UsersAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which users to aggregate.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned users
    **/
    _count?: true | UsersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UsersAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UsersSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UsersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UsersMaxAggregateInputType
  }

  export type GetUsersAggregateType<T extends UsersAggregateArgs> = {
        [P in keyof T & keyof AggregateUsers]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUsers[P]>
      : GetScalarType<T[P], AggregateUsers[P]>
  }




  export type usersGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: usersWhereInput
    orderBy?: usersOrderByWithAggregationInput | usersOrderByWithAggregationInput[]
    by: UsersScalarFieldEnum[] | UsersScalarFieldEnum
    having?: usersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UsersCountAggregateInputType | true
    _avg?: UsersAvgAggregateInputType
    _sum?: UsersSumAggregateInputType
    _min?: UsersMinAggregateInputType
    _max?: UsersMaxAggregateInputType
  }

  export type UsersGroupByOutputType = {
    id: number
    username: string
    password: string
    f_name: string
    l_name: string
    user_type: string
    user_status: number
    last_activity: bigint | null
    _count: UsersCountAggregateOutputType | null
    _avg: UsersAvgAggregateOutputType | null
    _sum: UsersSumAggregateOutputType | null
    _min: UsersMinAggregateOutputType | null
    _max: UsersMaxAggregateOutputType | null
  }

  type GetUsersGroupByPayload<T extends usersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UsersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UsersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UsersGroupByOutputType[P]>
            : GetScalarType<T[P], UsersGroupByOutputType[P]>
        }
      >
    >


  export type usersSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    username?: boolean
    password?: boolean
    f_name?: boolean
    l_name?: boolean
    user_type?: boolean
    user_status?: boolean
    last_activity?: boolean
  }, ExtArgs["result"]["users"]>



  export type usersSelectScalar = {
    id?: boolean
    username?: boolean
    password?: boolean
    f_name?: boolean
    l_name?: boolean
    user_type?: boolean
    user_status?: boolean
    last_activity?: boolean
  }

  export type usersOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "username" | "password" | "f_name" | "l_name" | "user_type" | "user_status" | "last_activity", ExtArgs["result"]["users"]>

  export type $usersPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "users"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      username: string
      password: string
      f_name: string
      l_name: string
      user_type: string
      user_status: number
      last_activity: bigint | null
    }, ExtArgs["result"]["users"]>
    composites: {}
  }

  type usersGetPayload<S extends boolean | null | undefined | usersDefaultArgs> = $Result.GetResult<Prisma.$usersPayload, S>

  type usersCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<usersFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UsersCountAggregateInputType | true
    }

  export interface usersDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['users'], meta: { name: 'users' } }
    /**
     * Find zero or one Users that matches the filter.
     * @param {usersFindUniqueArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends usersFindUniqueArgs>(args: SelectSubset<T, usersFindUniqueArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Users that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {usersFindUniqueOrThrowArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends usersFindUniqueOrThrowArgs>(args: SelectSubset<T, usersFindUniqueOrThrowArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersFindFirstArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends usersFindFirstArgs>(args?: SelectSubset<T, usersFindFirstArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Users that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersFindFirstOrThrowArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends usersFindFirstOrThrowArgs>(args?: SelectSubset<T, usersFindFirstOrThrowArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.users.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.users.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const usersWithIdOnly = await prisma.users.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends usersFindManyArgs>(args?: SelectSubset<T, usersFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Users.
     * @param {usersCreateArgs} args - Arguments to create a Users.
     * @example
     * // Create one Users
     * const Users = await prisma.users.create({
     *   data: {
     *     // ... data to create a Users
     *   }
     * })
     * 
     */
    create<T extends usersCreateArgs>(args: SelectSubset<T, usersCreateArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {usersCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const users = await prisma.users.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends usersCreateManyArgs>(args?: SelectSubset<T, usersCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Users.
     * @param {usersDeleteArgs} args - Arguments to delete one Users.
     * @example
     * // Delete one Users
     * const Users = await prisma.users.delete({
     *   where: {
     *     // ... filter to delete one Users
     *   }
     * })
     * 
     */
    delete<T extends usersDeleteArgs>(args: SelectSubset<T, usersDeleteArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Users.
     * @param {usersUpdateArgs} args - Arguments to update one Users.
     * @example
     * // Update one Users
     * const users = await prisma.users.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends usersUpdateArgs>(args: SelectSubset<T, usersUpdateArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {usersDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.users.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends usersDeleteManyArgs>(args?: SelectSubset<T, usersDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const users = await prisma.users.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends usersUpdateManyArgs>(args: SelectSubset<T, usersUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Users.
     * @param {usersUpsertArgs} args - Arguments to update or create a Users.
     * @example
     * // Update or create a Users
     * const users = await prisma.users.upsert({
     *   create: {
     *     // ... data to create a Users
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Users we want to update
     *   }
     * })
     */
    upsert<T extends usersUpsertArgs>(args: SelectSubset<T, usersUpsertArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.users.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends usersCountArgs>(
      args?: Subset<T, usersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UsersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UsersAggregateArgs>(args: Subset<T, UsersAggregateArgs>): Prisma.PrismaPromise<GetUsersAggregateType<T>>

    /**
     * Group by Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends usersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: usersGroupByArgs['orderBy'] }
        : { orderBy?: usersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, usersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUsersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the users model
   */
  readonly fields: usersFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for users.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__usersClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the users model
   */
  interface usersFieldRefs {
    readonly id: FieldRef<"users", 'Int'>
    readonly username: FieldRef<"users", 'String'>
    readonly password: FieldRef<"users", 'String'>
    readonly f_name: FieldRef<"users", 'String'>
    readonly l_name: FieldRef<"users", 'String'>
    readonly user_type: FieldRef<"users", 'String'>
    readonly user_status: FieldRef<"users", 'Int'>
    readonly last_activity: FieldRef<"users", 'BigInt'>
  }
    

  // Custom InputTypes
  /**
   * users findUnique
   */
  export type usersFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where: usersWhereUniqueInput
  }

  /**
   * users findUniqueOrThrow
   */
  export type usersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where: usersWhereUniqueInput
  }

  /**
   * users findFirst
   */
  export type usersFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for users.
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of users.
     */
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * users findFirstOrThrow
   */
  export type usersFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for users.
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of users.
     */
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * users findMany
   */
  export type usersFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing users.
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * users create
   */
  export type usersCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * The data needed to create a users.
     */
    data: XOR<usersCreateInput, usersUncheckedCreateInput>
  }

  /**
   * users createMany
   */
  export type usersCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many users.
     */
    data: usersCreateManyInput | usersCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * users update
   */
  export type usersUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * The data needed to update a users.
     */
    data: XOR<usersUpdateInput, usersUncheckedUpdateInput>
    /**
     * Choose, which users to update.
     */
    where: usersWhereUniqueInput
  }

  /**
   * users updateMany
   */
  export type usersUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update users.
     */
    data: XOR<usersUpdateManyMutationInput, usersUncheckedUpdateManyInput>
    /**
     * Filter which users to update
     */
    where?: usersWhereInput
    /**
     * Limit how many users to update.
     */
    limit?: number
  }

  /**
   * users upsert
   */
  export type usersUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * The filter to search for the users to update in case it exists.
     */
    where: usersWhereUniqueInput
    /**
     * In case the users found by the `where` argument doesn't exist, create a new users with this data.
     */
    create: XOR<usersCreateInput, usersUncheckedCreateInput>
    /**
     * In case the users was found with the provided `where` argument, update it with this data.
     */
    update: XOR<usersUpdateInput, usersUncheckedUpdateInput>
  }

  /**
   * users delete
   */
  export type usersDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Filter which users to delete.
     */
    where: usersWhereUniqueInput
  }

  /**
   * users deleteMany
   */
  export type usersDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which users to delete
     */
    where?: usersWhereInput
    /**
     * Limit how many users to delete.
     */
    limit?: number
  }

  /**
   * users without action
   */
  export type usersDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const Court_appeal_typesScalarFieldEnum: {
    appeal_type_id: 'appeal_type_id',
    appeal_type: 'appeal_type'
  };

  export type Court_appeal_typesScalarFieldEnum = (typeof Court_appeal_typesScalarFieldEnum)[keyof typeof Court_appeal_typesScalarFieldEnum]


  export const Court_appealsScalarFieldEnum: {
    appeal_id: 'appeal_id',
    case_id: 'case_id',
    claim_id: 'claim_id',
    court_accept_date: 'court_accept_date',
    actual: 'actual',
    filled_in: 'filled_in',
    filled_by: 'filled_by',
    court_level: 'court_level',
    court_name: 'court_name'
  };

  export type Court_appealsScalarFieldEnum = (typeof Court_appealsScalarFieldEnum)[keyof typeof Court_appealsScalarFieldEnum]


  export const Court_claim_initiatorsScalarFieldEnum: {
    id: 'id',
    initiator_name: 'initiator_name'
  };

  export type Court_claim_initiatorsScalarFieldEnum = (typeof Court_claim_initiatorsScalarFieldEnum)[keyof typeof Court_claim_initiatorsScalarFieldEnum]


  export const Court_claim_membersScalarFieldEnum: {
    id: 'id',
    claim_id: 'claim_id',
    case_id: 'case_id',
    person_id: 'person_id',
    created_at: 'created_at',
    actual: 'actual'
  };

  export type Court_claim_membersScalarFieldEnum = (typeof Court_claim_membersScalarFieldEnum)[keyof typeof Court_claim_membersScalarFieldEnum]


  export const Court_claimsScalarFieldEnum: {
    claim_id: 'claim_id',
    claim_serial_number: 'claim_serial_number',
    claim_date: 'claim_date',
    appealable_ms_decision: 'appealable_ms_decision',
    appealable_court_decision: 'appealable_court_decision',
    appealable_claim: 'appealable_claim',
    filled_by: 'filled_by',
    filled_in_date: 'filled_in_date',
    ms_notified_date: 'ms_notified_date',
    ms_lawyer: 'ms_lawyer',
    case_id: 'case_id',
    court_level: 'court_level',
    actual: 'actual',
    initiator: 'initiator',
    claim_status: 'claim_status',
    appeal_type: 'appeal_type',
    status_change_date: 'status_change_date'
  };

  export type Court_claimsScalarFieldEnum = (typeof Court_claimsScalarFieldEnum)[keyof typeof Court_claimsScalarFieldEnum]


  export const Court_cliam_statusScalarFieldEnum: {
    id: 'id',
    court_level: 'court_level',
    name: 'name',
    button_value: 'button_value'
  };

  export type Court_cliam_statusScalarFieldEnum = (typeof Court_cliam_statusScalarFieldEnum)[keyof typeof Court_cliam_statusScalarFieldEnum]


  export const Court_decision_typesScalarFieldEnum: {
    court_decision_type_id: 'court_decision_type_id',
    court_type: 'court_type',
    court_decision: 'court_decision'
  };

  export type Court_decision_typesScalarFieldEnum = (typeof Court_decision_typesScalarFieldEnum)[keyof typeof Court_decision_typesScalarFieldEnum]


  export const Court_decisionsScalarFieldEnum: {
    court_decision_id: 'court_decision_id',
    appeal_id: 'appeal_id',
    decission_type: 'decission_type',
    decison_date: 'decison_date',
    decision_notification_date: 'decision_notification_date',
    input_date: 'input_date',
    input_by: 'input_by',
    actual: 'actual'
  };

  export type Court_decisionsScalarFieldEnum = (typeof Court_decisionsScalarFieldEnum)[keyof typeof Court_decisionsScalarFieldEnum]


  export const Court_levelsScalarFieldEnum: {
    court_id: 'court_id',
    court_title: 'court_title'
  };

  export type Court_levelsScalarFieldEnum = (typeof Court_levelsScalarFieldEnum)[keyof typeof Court_levelsScalarFieldEnum]


  export const Cover_sign_statusScalarFieldEnum: {
    sign_status_id: 'sign_status_id',
    sign_status_name: 'sign_status_name'
  };

  export type Cover_sign_statusScalarFieldEnum = (typeof Cover_sign_statusScalarFieldEnum)[keyof typeof Cover_sign_statusScalarFieldEnum]


  export const FilesScalarFieldEnum: {
    id: 'id',
    file_name: 'file_name',
    uploaded_on: 'uploaded_on',
    file_type: 'file_type',
    uploader: 'uploader',
    case_id: 'case_id',
    decision_id: 'decision_id',
    inter_id: 'inter_id',
    coi_id: 'coi_id',
    person_id: 'person_id',
    draft_id: 'draft_id',
    claim_id: 'claim_id',
    appeal_id: 'appeal_id',
    file_path: 'file_path',
    process_type_id: 'process_type_id',
    actual: 'actual'
  };

  export type FilesScalarFieldEnum = (typeof FilesScalarFieldEnum)[keyof typeof FilesScalarFieldEnum]


  export const IpsScalarFieldEnum: {
    id: 'id',
    ip: 'ip',
    created_at: 'created_at'
  };

  export type IpsScalarFieldEnum = (typeof IpsScalarFieldEnum)[keyof typeof IpsScalarFieldEnum]


  export const Old_case_decisionsScalarFieldEnum: {
    old_decision_id: 'old_decision_id',
    old_case_id: 'old_case_id',
    ms_decision: 'ms_decision',
    ms_decision_date: 'ms_decision_date',
    final_decision: 'final_decision',
    final_decision_date: 'final_decision_date'
  };

  export type Old_case_decisionsScalarFieldEnum = (typeof Old_case_decisionsScalarFieldEnum)[keyof typeof Old_case_decisionsScalarFieldEnum]


  export const Old_case_personScalarFieldEnum: {
    old_person_id: 'old_person_id',
    old_case_id: 'old_case_id',
    f_name_arm: 'f_name_arm',
    l_name_arm: 'l_name_arm',
    p_name_arm: 'p_name_arm',
    f_name_eng: 'f_name_eng',
    l_name_eng: 'l_name_eng',
    p_name_eng: 'p_name_eng',
    sex: 'sex',
    b_day: 'b_day',
    b_month: 'b_month',
    b_year: 'b_year',
    role: 'role',
    citizenship_id: 'citizenship_id',
    card_num: 'card_num',
    doc_num: 'doc_num',
    etnicity: 'etnicity',
    religion: 'religion',
    invalid: 'invalid',
    pregnant: 'pregnant',
    seriously_ill: 'seriously_ill',
    trafficking_victim: 'trafficking_victim',
    violence_victim: 'violence_victim',
    comment: 'comment',
    illegal_border: 'illegal_border',
    transfer_moj: 'transfer_moj',
    deport_prescurator: 'deport_prescurator',
    prison: 'prison',
    image: 'image',
    pnum: 'pnum',
    doc_type: 'doc_type',
    document_num: 'document_num',
    status: 'status'
  };

  export type Old_case_personScalarFieldEnum = (typeof Old_case_personScalarFieldEnum)[keyof typeof Old_case_personScalarFieldEnum]


  export const Old_casesScalarFieldEnum: {
    old_case_id: 'old_case_id',
    application_date: 'application_date',
    citizenship: 'citizenship',
    RA_address: 'RA_address',
    building: 'building',
    apartment: 'apartment',
    marz_id: 'marz_id',
    community_id: 'community_id',
    bnak_id: 'bnak_id',
    unaccompanied_child: 'unaccompanied_child',
    separated_child: 'separated_child',
    single_parent: 'single_parent',
    prefered_language: 'prefered_language',
    contact_tel: 'contact_tel',
    comment: 'comment'
  };

  export type Old_casesScalarFieldEnum = (typeof Old_casesScalarFieldEnum)[keyof typeof Old_casesScalarFieldEnum]


  export const Tb_arm_comScalarFieldEnum: {
    community_id: 'community_id',
    marz_id: 'marz_id',
    ADM3_PCODE: 'ADM3_PCODE',
    ADM3_ARM: 'ADM3_ARM',
    ADM3_EN: 'ADM3_EN',
    exist: 'exist',
    active: 'active'
  };

  export type Tb_arm_comScalarFieldEnum = (typeof Tb_arm_comScalarFieldEnum)[keyof typeof Tb_arm_comScalarFieldEnum]


  export const Tb_arm_com__ScalarFieldEnum: {
    community_id: 'community_id',
    marz_id: 'marz_id',
    ADM3_PCODE: 'ADM3_PCODE',
    ADM3_ARM: 'ADM3_ARM',
    ADM3_EN: 'ADM3_EN'
  };

  export type Tb_arm_com__ScalarFieldEnum = (typeof Tb_arm_com__ScalarFieldEnum)[keyof typeof Tb_arm_com__ScalarFieldEnum]


  export const Tb_calendarScalarFieldEnum: {
    interview_id: 'interview_id',
    case_id: 'case_id',
    user_id: 'user_id',
    inter_comment: 'inter_comment',
    inter_date_from: 'inter_date_from',
    inter_date_to: 'inter_date_to',
    text_color: 'text_color',
    border_color: 'border_color',
    actual_event: 'actual_event'
  };

  export type Tb_calendarScalarFieldEnum = (typeof Tb_calendarScalarFieldEnum)[keyof typeof Tb_calendarScalarFieldEnum]


  export const Tb_cancelScalarFieldEnum: {
    id: 'id',
    personal_id: 'personal_id',
    case_id: 'case_id',
    decision_date: 'decision_date',
    uploader: 'uploader',
    uploaded: 'uploaded',
    file_id: 'file_id'
  };

  export type Tb_cancelScalarFieldEnum = (typeof Tb_cancelScalarFieldEnum)[keyof typeof Tb_cancelScalarFieldEnum]


  export const Tb_cardsScalarFieldEnum: {
    card_id: 'card_id',
    serial: 'serial',
    card_number: 'card_number',
    personal_id: 'personal_id',
    issued: 'issued',
    full_address: 'full_address',
    valid: 'valid',
    bar: 'bar',
    printed: 'printed',
    actual_card: 'actual_card'
  };

  export type Tb_cardsScalarFieldEnum = (typeof Tb_cardsScalarFieldEnum)[keyof typeof Tb_cardsScalarFieldEnum]


  export const Tb_caseScalarFieldEnum: {
    case_id: 'case_id',
    application_date: 'application_date',
    input_date: 'input_date',
    reg_by: 'reg_by',
    officer: 'officer',
    preferred_lawyer: 'preferred_lawyer',
    unaccompanied_child: 'unaccompanied_child',
    separated_child: 'separated_child',
    single_parent: 'single_parent',
    prefered_language: 'prefered_language',
    RA_marz: 'RA_marz',
    RA_community: 'RA_community',
    RA_settlement: 'RA_settlement',
    RA_street: 'RA_street',
    RA_building: 'RA_building',
    RA_apartment: 'RA_apartment',
    contact_tel: 'contact_tel',
    contact_email: 'contact_email',
    comment: 'comment',
    case_status: 'case_status',
    mul_num: 'mul_num',
    mul_date: 'mul_date',
    MS_lawyer: 'MS_lawyer',
    special: 'special',
    reopened: 'reopened',
    attached_case: 'attached_case'
  };

  export type Tb_caseScalarFieldEnum = (typeof Tb_caseScalarFieldEnum)[keyof typeof Tb_caseScalarFieldEnum]


  export const Tb_case_statusScalarFieldEnum: {
    case_status_id: 'case_status_id',
    case_status: 'case_status',
    case_status_eng: 'case_status_eng'
  };

  export type Tb_case_statusScalarFieldEnum = (typeof Tb_case_statusScalarFieldEnum)[keyof typeof Tb_case_statusScalarFieldEnum]


  export const Tb_checkinScalarFieldEnum: {
    checkin_id: 'checkin_id',
    checkin_date: 'checkin_date',
    checkout_date: 'checkout_date',
    personal_id: 'personal_id',
    order_id: 'order_id',
    status: 'status',
    doss_id: 'doss_id'
  };

  export type Tb_checkinScalarFieldEnum = (typeof Tb_checkinScalarFieldEnum)[keyof typeof Tb_checkinScalarFieldEnum]


  export const Tb_coiScalarFieldEnum: {
    coi_id: 'coi_id',
    from_officer: 'from_officer',
    to_coispec: 'to_coispec',
    case_id: 'case_id',
    request_date: 'request_date',
    request_deadline: 'request_deadline',
    description: 'description',
    request_text: 'request_text',
    coi_state: 'coi_state',
    request_count: 'request_count',
    response_date: 'response_date',
    coi_status: 'coi_status'
  };

  export type Tb_coiScalarFieldEnum = (typeof Tb_coiScalarFieldEnum)[keyof typeof Tb_coiScalarFieldEnum]


  export const Tb_countryScalarFieldEnum: {
    country_id: 'country_id',
    country_eng: 'country_eng',
    country_arm: 'country_arm'
  };

  export type Tb_countryScalarFieldEnum = (typeof Tb_countryScalarFieldEnum)[keyof typeof Tb_countryScalarFieldEnum]


  export const Tb_cover_filesScalarFieldEnum: {
    cover_file_id: 'cover_file_id',
    type: 'type',
    file_name: 'file_name',
    cover_status: 'cover_status',
    case_id: 'case_id',
    translation_id: 'translation_id',
    cover_actual: 'cover_actual'
  };

  export type Tb_cover_filesScalarFieldEnum = (typeof Tb_cover_filesScalarFieldEnum)[keyof typeof Tb_cover_filesScalarFieldEnum]


  export const Tb_deadlineScalarFieldEnum: {
    id: 'id',
    case_id: 'case_id',
    deadline_type: 'deadline_type',
    deadline: 'deadline',
    actual_dead: 'actual_dead',
    process_type_id: 'process_type_id'
  };

  export type Tb_deadlineScalarFieldEnum = (typeof Tb_deadlineScalarFieldEnum)[keyof typeof Tb_deadlineScalarFieldEnum]


  export const Tb_deadline_typesScalarFieldEnum: {
    deadline_type_id: 'deadline_type_id',
    deadline_type: 'deadline_type'
  };

  export type Tb_deadline_typesScalarFieldEnum = (typeof Tb_deadline_typesScalarFieldEnum)[keyof typeof Tb_deadline_typesScalarFieldEnum]


  export const Tb_decision_statusScalarFieldEnum: {
    decision_status_id: 'decision_status_id',
    decision_status: 'decision_status',
    decision_status_eng: 'decision_status_eng'
  };

  export type Tb_decision_statusScalarFieldEnum = (typeof Tb_decision_statusScalarFieldEnum)[keyof typeof Tb_decision_statusScalarFieldEnum]


  export const Tb_decision_typesScalarFieldEnum: {
    decision_type_id: 'decision_type_id',
    decision_type: 'decision_type',
    decision_type_eng: 'decision_type_eng'
  };

  export type Tb_decision_typesScalarFieldEnum = (typeof Tb_decision_typesScalarFieldEnum)[keyof typeof Tb_decision_typesScalarFieldEnum]


  export const Tb_decisionsScalarFieldEnum: {
    decision_id: 'decision_id',
    case_id: 'case_id',
    decision_type: 'decision_type',
    decison_date: 'decison_date',
    decision_status: 'decision_status',
    actual: 'actual',
    decision_out_num: 'decision_out_num'
  };

  export type Tb_decisionsScalarFieldEnum = (typeof Tb_decisionsScalarFieldEnum)[keyof typeof Tb_decisionsScalarFieldEnum]


  export const Tb_dossScalarFieldEnum: {
    doss_id: 'doss_id',
    room_num: 'room_num',
    doss: 'doss',
    doss_status: 'doss_status',
    doss_type: 'doss_type',
    doss_sex: 'doss_sex'
  };

  export type Tb_dossScalarFieldEnum = (typeof Tb_dossScalarFieldEnum)[keyof typeof Tb_dossScalarFieldEnum]


  export const Tb_draftScalarFieldEnum: {
    draft_id: 'draft_id',
    case_id: 'case_id',
    autor: 'autor',
    uploaded: 'uploaded',
    receiver: 'receiver',
    actual: 'actual'
  };

  export type Tb_draftScalarFieldEnum = (typeof Tb_draftScalarFieldEnum)[keyof typeof Tb_draftScalarFieldEnum]


  export const Tb_droomsScalarFieldEnum: {
    room_id: 'room_id',
    room_num: 'room_num',
    floor: 'floor',
    type: 'type',
    capacity: 'capacity',
    room_sex: 'room_sex'
  };

  export type Tb_droomsScalarFieldEnum = (typeof Tb_droomsScalarFieldEnum)[keyof typeof Tb_droomsScalarFieldEnum]


  export const Tb_edu_lvlScalarFieldEnum: {
    lvl_id: 'lvl_id',
    edu_lvl: 'edu_lvl'
  };

  export type Tb_edu_lvlScalarFieldEnum = (typeof Tb_edu_lvlScalarFieldEnum)[keyof typeof Tb_edu_lvlScalarFieldEnum]


  export const Tb_educationScalarFieldEnum: {
    edu_id: 'edu_id',
    specialization: 'specialization',
    institution: 'institution',
    edu_lvl: 'edu_lvl',
    start_year: 'start_year',
    end_year: 'end_year',
    personal_id: 'personal_id'
  };

  export type Tb_educationScalarFieldEnum = (typeof Tb_educationScalarFieldEnum)[keyof typeof Tb_educationScalarFieldEnum]


  export const Tb_employmentScalarFieldEnum: {
    employment_id: 'employment_id',
    start_date: 'start_date',
    end_date: 'end_date',
    occupation: 'occupation',
    organization: 'organization',
    personal_id: 'personal_id'
  };

  export type Tb_employmentScalarFieldEnum = (typeof Tb_employmentScalarFieldEnum)[keyof typeof Tb_employmentScalarFieldEnum]


  export const Tb_etnicsScalarFieldEnum: {
    etnic_id: 'etnic_id',
    etnic_arm: 'etnic_arm',
    etnic_eng: 'etnic_eng'
  };

  export type Tb_etnicsScalarFieldEnum = (typeof Tb_etnicsScalarFieldEnum)[keyof typeof Tb_etnicsScalarFieldEnum]


  export const Tb_file_typeScalarFieldEnum: {
    file_type_id: 'file_type_id',
    file_type: 'file_type',
    file_filter: 'file_filter'
  };

  export type Tb_file_typeScalarFieldEnum = (typeof Tb_file_typeScalarFieldEnum)[keyof typeof Tb_file_typeScalarFieldEnum]


  export const Tb_handedScalarFieldEnum: {
    handed_id: 'handed_id',
    case_id: 'case_id',
    decision_id: 'decision_id',
    created: 'created',
    hended_by: 'hended_by',
    signed_page: 'signed_page'
  };

  export type Tb_handedScalarFieldEnum = (typeof Tb_handedScalarFieldEnum)[keyof typeof Tb_handedScalarFieldEnum]


  export const Tb_interScalarFieldEnum: {
    inter_id: 'inter_id',
    case_id: 'case_id',
    author_id: 'author_id',
    inter_status: 'inter_status',
    inter_reciever: 'inter_reciever',
    inter_type: 'inter_type',
    send_type: 'send_type',
    out_num: 'out_num'
  };

  export type Tb_interScalarFieldEnum = (typeof Tb_interScalarFieldEnum)[keyof typeof Tb_interScalarFieldEnum]


  export const Tb_inter_notifiedScalarFieldEnum: {
    inter_notified_id: 'inter_notified_id',
    notified_date: 'notified_date',
    actioned: 'actioned',
    file_name: 'file_name',
    inter_id: 'inter_id',
    notification_status: 'notification_status'
  };

  export type Tb_inter_notifiedScalarFieldEnum = (typeof Tb_inter_notifiedScalarFieldEnum)[keyof typeof Tb_inter_notifiedScalarFieldEnum]


  export const Tb_inter_reciversScalarFieldEnum: {
    inter_reciever_id: 'inter_reciever_id',
    inter_reciever_text: 'inter_reciever_text'
  };

  export type Tb_inter_reciversScalarFieldEnum = (typeof Tb_inter_reciversScalarFieldEnum)[keyof typeof Tb_inter_reciversScalarFieldEnum]


  export const Tb_inter_send_typeScalarFieldEnum: {
    inter_send_type_id: 'inter_send_type_id',
    inter_send_type: 'inter_send_type'
  };

  export type Tb_inter_send_typeScalarFieldEnum = (typeof Tb_inter_send_typeScalarFieldEnum)[keyof typeof Tb_inter_send_typeScalarFieldEnum]


  export const Tb_inter_status_typesScalarFieldEnum: {
    id: 'id',
    inter_status_type: 'inter_status_type'
  };

  export type Tb_inter_status_typesScalarFieldEnum = (typeof Tb_inter_status_typesScalarFieldEnum)[keyof typeof Tb_inter_status_typesScalarFieldEnum]


  export const Tb_inter_typeScalarFieldEnum: {
    inter_type_id: 'inter_type_id',
    inter_type: 'inter_type'
  };

  export type Tb_inter_typeScalarFieldEnum = (typeof Tb_inter_typeScalarFieldEnum)[keyof typeof Tb_inter_typeScalarFieldEnum]


  export const Tb_lawyerScalarFieldEnum: {
    lawyer_id: 'lawyer_id',
    lawyer_name: 'lawyer_name',
    lawyer_surname: 'lawyer_surname',
    lawyer_organization: 'lawyer_organization',
    lawyer_tel: 'lawyer_tel',
    lawyer_address: 'lawyer_address',
    lawyer_email: 'lawyer_email',
    case_id: 'case_id',
    actual: 'actual'
  };

  export type Tb_lawyerScalarFieldEnum = (typeof Tb_lawyerScalarFieldEnum)[keyof typeof Tb_lawyerScalarFieldEnum]


  export const Tb_marzScalarFieldEnum: {
    marz_id: 'marz_id',
    ADM1_ARM: 'ADM1_ARM',
    ADM1_EN: 'ADM1_EN',
    ADM1_PCODE: 'ADM1_PCODE'
  };

  export type Tb_marzScalarFieldEnum = (typeof Tb_marzScalarFieldEnum)[keyof typeof Tb_marzScalarFieldEnum]


  export const Tb_membersScalarFieldEnum: {
    member_id: 'member_id',
    case_id: 'case_id',
    f_name_arm: 'f_name_arm',
    f_name_eng: 'f_name_eng',
    l_name_arm: 'l_name_arm',
    l_name_eng: 'l_name_eng',
    m_name_arm: 'm_name_arm',
    m_name_eng: 'm_name_eng',
    b_day: 'b_day',
    b_month: 'b_month',
    b_year: 'b_year',
    sex: 'sex',
    citizenship: 'citizenship',
    residence: 'residence',
    role: 'role'
  };

  export type Tb_membersScalarFieldEnum = (typeof Tb_membersScalarFieldEnum)[keyof typeof Tb_membersScalarFieldEnum]


  export const Tb_notificationsScalarFieldEnum: {
    comment_id: 'comment_id',
    comment_subject: 'comment_subject',
    comment_text: 'comment_text',
    comment_status: 'comment_status',
    comment_from: 'comment_from',
    comment_to: 'comment_to',
    case_id: 'case_id',
    coi_id: 'coi_id',
    request_id: 'request_id',
    note_type: 'note_type',
    draft_id: 'draft_id',
    order_id: 'order_id',
    readed: 'readed',
    note_date: 'note_date',
    msg_read: 'msg_read'
  };

  export type Tb_notificationsScalarFieldEnum = (typeof Tb_notificationsScalarFieldEnum)[keyof typeof Tb_notificationsScalarFieldEnum]


  export const Tb_ordersScalarFieldEnum: {
    order_id: 'order_id',
    case_id: 'case_id',
    order_status: 'order_status',
    date: 'date'
  };

  export type Tb_ordersScalarFieldEnum = (typeof Tb_ordersScalarFieldEnum)[keyof typeof Tb_ordersScalarFieldEnum]


  export const Tb_personScalarFieldEnum: {
    personal_id: 'personal_id',
    case_id: 'case_id',
    f_name_arm: 'f_name_arm',
    f_name_eng: 'f_name_eng',
    l_name_arm: 'l_name_arm',
    l_name_eng: 'l_name_eng',
    m_name_arm: 'm_name_arm',
    m_name_eng: 'm_name_eng',
    b_day: 'b_day',
    b_month: 'b_month',
    b_year: 'b_year',
    sex: 'sex',
    citizenship: 'citizenship',
    previous_residence: 'previous_residence',
    citizen_adr: 'citizen_adr',
    residence_adr: 'residence_adr',
    departure_from_citizen: 'departure_from_citizen',
    departure_from_residence: 'departure_from_residence',
    arrival_date: 'arrival_date',
    doc_num: 'doc_num',
    etnicity: 'etnicity',
    religion: 'religion',
    preferred_traslator_sex: 'preferred_traslator_sex',
    preferred_interviewer_sex: 'preferred_interviewer_sex',
    invalid: 'invalid',
    pregnant: 'pregnant',
    seriously_ill: 'seriously_ill',
    trafficking_victim: 'trafficking_victim',
    violence_victim: 'violence_victim',
    comment: 'comment',
    illegal_border: 'illegal_border',
    transfer_moj: 'transfer_moj',
    deport_prescurator: 'deport_prescurator',
    prison: 'prison',
    role: 'role',
    image: 'image',
    person_status: 'person_status',
    ident: 'ident',
    pnum: 'pnum',
    doc_type: 'doc_type',
    document_num: 'document_num',
    doc_issued_date: 'doc_issued_date',
    doc_valid: 'doc_valid',
    doc_issued_by: 'doc_issued_by',
    bpr_community: 'bpr_community',
    bpr_bnakavayr: 'bpr_bnakavayr',
    bpr_street: 'bpr_street',
    bpr_house: 'bpr_house',
    bpr_aprt: 'bpr_aprt',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type Tb_personScalarFieldEnum = (typeof Tb_personScalarFieldEnum)[keyof typeof Tb_personScalarFieldEnum]


  export const Tb_person_statusScalarFieldEnum: {
    person_status_id: 'person_status_id',
    person_status: 'person_status',
    person_status_eng: 'person_status_eng'
  };

  export type Tb_person_statusScalarFieldEnum = (typeof Tb_person_statusScalarFieldEnum)[keyof typeof Tb_person_statusScalarFieldEnum]


  export const Tb_processScalarFieldEnum: {
    process_id: 'process_id',
    process_type_id: 'process_type_id',
    case_id: 'case_id',
    draft_id: 'draft_id',
    coi_id: 'coi_id',
    request_id: 'request_id',
    order_id: 'order_id',
    decision_id: 'decision_id',
    notification_id: 'notification_id',
    sign_status: 'sign_status',
    sign_date: 'sign_date',
    sign_by: 'sign_by',
    processor: 'processor',
    comment_to: 'comment_to',
    actual: 'actual',
    comment_status: 'comment_status',
    out_num: 'out_num'
  };

  export type Tb_processScalarFieldEnum = (typeof Tb_processScalarFieldEnum)[keyof typeof Tb_processScalarFieldEnum]


  export const Tb_process_typeScalarFieldEnum: {
    process_type_id: 'process_type_id',
    process_type: 'process_type'
  };

  export type Tb_process_typeScalarFieldEnum = (typeof Tb_process_typeScalarFieldEnum)[keyof typeof Tb_process_typeScalarFieldEnum]


  export const Tb_religionsScalarFieldEnum: {
    religion_id: 'religion_id',
    religion_arm: 'religion_arm',
    religion_eng: 'religion_eng'
  };

  export type Tb_religionsScalarFieldEnum = (typeof Tb_religionsScalarFieldEnum)[keyof typeof Tb_religionsScalarFieldEnum]


  export const Tb_request_bodiesScalarFieldEnum: {
    body_id: 'body_id',
    body: 'body'
  };

  export type Tb_request_bodiesScalarFieldEnum = (typeof Tb_request_bodiesScalarFieldEnum)[keyof typeof Tb_request_bodiesScalarFieldEnum]


  export const Tb_request_outScalarFieldEnum: {
    request_id: 'request_id',
    case_id: 'case_id',
    author: 'author',
    body: 'body',
    request_date: 'request_date',
    request_status: 'request_status'
  };

  export type Tb_request_outScalarFieldEnum = (typeof Tb_request_outScalarFieldEnum)[keyof typeof Tb_request_outScalarFieldEnum]


  export const Tb_roleScalarFieldEnum: {
    role_id: 'role_id',
    der: 'der'
  };

  export type Tb_roleScalarFieldEnum = (typeof Tb_roleScalarFieldEnum)[keyof typeof Tb_roleScalarFieldEnum]


  export const Tb_settlementScalarFieldEnum: {
    settlement_id: 'settlement_id',
    com_id: 'com_id',
    ADM3_CODE: 'ADM3_CODE',
    ADM4_PCODE: 'ADM4_PCODE',
    ADM4_ARM: 'ADM4_ARM',
    ADM4_ENG: 'ADM4_ENG'
  };

  export type Tb_settlementScalarFieldEnum = (typeof Tb_settlementScalarFieldEnum)[keyof typeof Tb_settlementScalarFieldEnum]


  export const Tb_settlement_ScalarFieldEnum: {
    settlement_id: 'settlement_id',
    com_id: 'com_id',
    ADM3_CODE: 'ADM3_CODE',
    ADM4_PCODE: 'ADM4_PCODE',
    ADM4_ARM: 'ADM4_ARM',
    ADM4_ENG: 'ADM4_ENG',
    active: 'active'
  };

  export type Tb_settlement_ScalarFieldEnum = (typeof Tb_settlement_ScalarFieldEnum)[keyof typeof Tb_settlement_ScalarFieldEnum]


  export const Tb_sign_statusScalarFieldEnum: {
    status_id: 'status_id',
    status: 'status'
  };

  export type Tb_sign_statusScalarFieldEnum = (typeof Tb_sign_statusScalarFieldEnum)[keyof typeof Tb_sign_statusScalarFieldEnum]


  export const Tb_translateScalarFieldEnum: {
    translate_id: 'translate_id',
    case_id: 'case_id',
    translate_type: 'translate_type',
    user_from: 'user_from',
    user_to: 'user_to',
    filled_in_date: 'filled_in_date',
    translator_company: 'translator_company',
    file_path: 'file_path',
    file_ids: 'file_ids',
    translate_date: 'translate_date',
    translate_time_from: 'translate_time_from',
    translate_time_to: 'translate_time_to',
    sign_status: 'sign_status',
    mailed_to_translators: 'mailed_to_translators'
  };

  export type Tb_translateScalarFieldEnum = (typeof Tb_translateScalarFieldEnum)[keyof typeof Tb_translateScalarFieldEnum]


  export const Tb_translate_sign_statusesScalarFieldEnum: {
    status_id: 'status_id',
    sign_status: 'sign_status',
    sign_status_name: 'sign_status_name'
  };

  export type Tb_translate_sign_statusesScalarFieldEnum = (typeof Tb_translate_sign_statusesScalarFieldEnum)[keyof typeof Tb_translate_sign_statusesScalarFieldEnum]


  export const Tb_translation_typeScalarFieldEnum: {
    ttype_id: 'ttype_id',
    trans_type: 'trans_type'
  };

  export type Tb_translation_typeScalarFieldEnum = (typeof Tb_translation_typeScalarFieldEnum)[keyof typeof Tb_translation_typeScalarFieldEnum]


  export const Tb_translatorsScalarFieldEnum: {
    translator_id: 'translator_id',
    translator_name_arm: 'translator_name_arm',
    translator_name_eng: 'translator_name_eng',
    email: 'email',
    test_mail: 'test_mail',
    logo_file: 'logo_file',
    active_status: 'active_status'
  };

  export type Tb_translatorsScalarFieldEnum = (typeof Tb_translatorsScalarFieldEnum)[keyof typeof Tb_translatorsScalarFieldEnum]


  export const UsersScalarFieldEnum: {
    id: 'id',
    username: 'username',
    password: 'password',
    f_name: 'f_name',
    l_name: 'l_name',
    user_type: 'user_type',
    user_status: 'user_status',
    last_activity: 'last_activity'
  };

  export type UsersScalarFieldEnum = (typeof UsersScalarFieldEnum)[keyof typeof UsersScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const court_appeal_typesOrderByRelevanceFieldEnum: {
    appeal_type: 'appeal_type'
  };

  export type court_appeal_typesOrderByRelevanceFieldEnum = (typeof court_appeal_typesOrderByRelevanceFieldEnum)[keyof typeof court_appeal_typesOrderByRelevanceFieldEnum]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const court_appealsOrderByRelevanceFieldEnum: {
    court_name: 'court_name'
  };

  export type court_appealsOrderByRelevanceFieldEnum = (typeof court_appealsOrderByRelevanceFieldEnum)[keyof typeof court_appealsOrderByRelevanceFieldEnum]


  export const court_claim_initiatorsOrderByRelevanceFieldEnum: {
    initiator_name: 'initiator_name'
  };

  export type court_claim_initiatorsOrderByRelevanceFieldEnum = (typeof court_claim_initiatorsOrderByRelevanceFieldEnum)[keyof typeof court_claim_initiatorsOrderByRelevanceFieldEnum]


  export const court_claimsOrderByRelevanceFieldEnum: {
    claim_serial_number: 'claim_serial_number'
  };

  export type court_claimsOrderByRelevanceFieldEnum = (typeof court_claimsOrderByRelevanceFieldEnum)[keyof typeof court_claimsOrderByRelevanceFieldEnum]


  export const court_cliam_statusOrderByRelevanceFieldEnum: {
    name: 'name',
    button_value: 'button_value'
  };

  export type court_cliam_statusOrderByRelevanceFieldEnum = (typeof court_cliam_statusOrderByRelevanceFieldEnum)[keyof typeof court_cliam_statusOrderByRelevanceFieldEnum]


  export const court_decision_typesOrderByRelevanceFieldEnum: {
    court_decision: 'court_decision'
  };

  export type court_decision_typesOrderByRelevanceFieldEnum = (typeof court_decision_typesOrderByRelevanceFieldEnum)[keyof typeof court_decision_typesOrderByRelevanceFieldEnum]


  export const court_levelsOrderByRelevanceFieldEnum: {
    court_title: 'court_title'
  };

  export type court_levelsOrderByRelevanceFieldEnum = (typeof court_levelsOrderByRelevanceFieldEnum)[keyof typeof court_levelsOrderByRelevanceFieldEnum]


  export const cover_sign_statusOrderByRelevanceFieldEnum: {
    sign_status_name: 'sign_status_name'
  };

  export type cover_sign_statusOrderByRelevanceFieldEnum = (typeof cover_sign_statusOrderByRelevanceFieldEnum)[keyof typeof cover_sign_statusOrderByRelevanceFieldEnum]


  export const filesOrderByRelevanceFieldEnum: {
    file_name: 'file_name',
    file_path: 'file_path'
  };

  export type filesOrderByRelevanceFieldEnum = (typeof filesOrderByRelevanceFieldEnum)[keyof typeof filesOrderByRelevanceFieldEnum]


  export const ipsOrderByRelevanceFieldEnum: {
    ip: 'ip'
  };

  export type ipsOrderByRelevanceFieldEnum = (typeof ipsOrderByRelevanceFieldEnum)[keyof typeof ipsOrderByRelevanceFieldEnum]


  export const old_case_personOrderByRelevanceFieldEnum: {
    f_name_arm: 'f_name_arm',
    l_name_arm: 'l_name_arm',
    p_name_arm: 'p_name_arm',
    f_name_eng: 'f_name_eng',
    l_name_eng: 'l_name_eng',
    p_name_eng: 'p_name_eng',
    b_day: 'b_day',
    b_month: 'b_month',
    b_year: 'b_year',
    card_num: 'card_num',
    doc_num: 'doc_num',
    comment: 'comment',
    image: 'image',
    pnum: 'pnum',
    document_num: 'document_num'
  };

  export type old_case_personOrderByRelevanceFieldEnum = (typeof old_case_personOrderByRelevanceFieldEnum)[keyof typeof old_case_personOrderByRelevanceFieldEnum]


  export const old_casesOrderByRelevanceFieldEnum: {
    RA_address: 'RA_address',
    building: 'building',
    apartment: 'apartment',
    prefered_language: 'prefered_language',
    contact_tel: 'contact_tel',
    comment: 'comment'
  };

  export type old_casesOrderByRelevanceFieldEnum = (typeof old_casesOrderByRelevanceFieldEnum)[keyof typeof old_casesOrderByRelevanceFieldEnum]


  export const tb_arm_comOrderByRelevanceFieldEnum: {
    ADM3_PCODE: 'ADM3_PCODE',
    ADM3_ARM: 'ADM3_ARM',
    ADM3_EN: 'ADM3_EN'
  };

  export type tb_arm_comOrderByRelevanceFieldEnum = (typeof tb_arm_comOrderByRelevanceFieldEnum)[keyof typeof tb_arm_comOrderByRelevanceFieldEnum]


  export const tb_arm_com__OrderByRelevanceFieldEnum: {
    ADM3_PCODE: 'ADM3_PCODE',
    ADM3_ARM: 'ADM3_ARM',
    ADM3_EN: 'ADM3_EN'
  };

  export type tb_arm_com__OrderByRelevanceFieldEnum = (typeof tb_arm_com__OrderByRelevanceFieldEnum)[keyof typeof tb_arm_com__OrderByRelevanceFieldEnum]


  export const tb_calendarOrderByRelevanceFieldEnum: {
    inter_comment: 'inter_comment',
    text_color: 'text_color',
    border_color: 'border_color'
  };

  export type tb_calendarOrderByRelevanceFieldEnum = (typeof tb_calendarOrderByRelevanceFieldEnum)[keyof typeof tb_calendarOrderByRelevanceFieldEnum]


  export const tb_cardsOrderByRelevanceFieldEnum: {
    serial: 'serial',
    full_address: 'full_address',
    bar: 'bar'
  };

  export type tb_cardsOrderByRelevanceFieldEnum = (typeof tb_cardsOrderByRelevanceFieldEnum)[keyof typeof tb_cardsOrderByRelevanceFieldEnum]


  export const tb_caseOrderByRelevanceFieldEnum: {
    prefered_language: 'prefered_language',
    RA_street: 'RA_street',
    RA_building: 'RA_building',
    RA_apartment: 'RA_apartment',
    contact_tel: 'contact_tel',
    contact_email: 'contact_email',
    comment: 'comment',
    mul_num: 'mul_num'
  };

  export type tb_caseOrderByRelevanceFieldEnum = (typeof tb_caseOrderByRelevanceFieldEnum)[keyof typeof tb_caseOrderByRelevanceFieldEnum]


  export const tb_case_statusOrderByRelevanceFieldEnum: {
    case_status: 'case_status',
    case_status_eng: 'case_status_eng'
  };

  export type tb_case_statusOrderByRelevanceFieldEnum = (typeof tb_case_statusOrderByRelevanceFieldEnum)[keyof typeof tb_case_statusOrderByRelevanceFieldEnum]


  export const tb_coiOrderByRelevanceFieldEnum: {
    description: 'description',
    request_text: 'request_text'
  };

  export type tb_coiOrderByRelevanceFieldEnum = (typeof tb_coiOrderByRelevanceFieldEnum)[keyof typeof tb_coiOrderByRelevanceFieldEnum]


  export const tb_countryOrderByRelevanceFieldEnum: {
    country_eng: 'country_eng',
    country_arm: 'country_arm'
  };

  export type tb_countryOrderByRelevanceFieldEnum = (typeof tb_countryOrderByRelevanceFieldEnum)[keyof typeof tb_countryOrderByRelevanceFieldEnum]


  export const tb_cover_filesOrderByRelevanceFieldEnum: {
    file_name: 'file_name'
  };

  export type tb_cover_filesOrderByRelevanceFieldEnum = (typeof tb_cover_filesOrderByRelevanceFieldEnum)[keyof typeof tb_cover_filesOrderByRelevanceFieldEnum]


  export const tb_deadline_typesOrderByRelevanceFieldEnum: {
    deadline_type: 'deadline_type'
  };

  export type tb_deadline_typesOrderByRelevanceFieldEnum = (typeof tb_deadline_typesOrderByRelevanceFieldEnum)[keyof typeof tb_deadline_typesOrderByRelevanceFieldEnum]


  export const tb_decision_statusOrderByRelevanceFieldEnum: {
    decision_status: 'decision_status',
    decision_status_eng: 'decision_status_eng'
  };

  export type tb_decision_statusOrderByRelevanceFieldEnum = (typeof tb_decision_statusOrderByRelevanceFieldEnum)[keyof typeof tb_decision_statusOrderByRelevanceFieldEnum]


  export const tb_decision_typesOrderByRelevanceFieldEnum: {
    decision_type: 'decision_type',
    decision_type_eng: 'decision_type_eng'
  };

  export type tb_decision_typesOrderByRelevanceFieldEnum = (typeof tb_decision_typesOrderByRelevanceFieldEnum)[keyof typeof tb_decision_typesOrderByRelevanceFieldEnum]


  export const tb_decisionsOrderByRelevanceFieldEnum: {
    decision_out_num: 'decision_out_num'
  };

  export type tb_decisionsOrderByRelevanceFieldEnum = (typeof tb_decisionsOrderByRelevanceFieldEnum)[keyof typeof tb_decisionsOrderByRelevanceFieldEnum]


  export const tb_dossOrderByRelevanceFieldEnum: {
    doss: 'doss',
    doss_type: 'doss_type'
  };

  export type tb_dossOrderByRelevanceFieldEnum = (typeof tb_dossOrderByRelevanceFieldEnum)[keyof typeof tb_dossOrderByRelevanceFieldEnum]


  export const tb_droomsOrderByRelevanceFieldEnum: {
    type: 'type'
  };

  export type tb_droomsOrderByRelevanceFieldEnum = (typeof tb_droomsOrderByRelevanceFieldEnum)[keyof typeof tb_droomsOrderByRelevanceFieldEnum]


  export const tb_edu_lvlOrderByRelevanceFieldEnum: {
    edu_lvl: 'edu_lvl'
  };

  export type tb_edu_lvlOrderByRelevanceFieldEnum = (typeof tb_edu_lvlOrderByRelevanceFieldEnum)[keyof typeof tb_edu_lvlOrderByRelevanceFieldEnum]


  export const tb_educationOrderByRelevanceFieldEnum: {
    specialization: 'specialization',
    institution: 'institution',
    start_year: 'start_year',
    end_year: 'end_year'
  };

  export type tb_educationOrderByRelevanceFieldEnum = (typeof tb_educationOrderByRelevanceFieldEnum)[keyof typeof tb_educationOrderByRelevanceFieldEnum]


  export const tb_employmentOrderByRelevanceFieldEnum: {
    start_date: 'start_date',
    end_date: 'end_date',
    occupation: 'occupation',
    organization: 'organization'
  };

  export type tb_employmentOrderByRelevanceFieldEnum = (typeof tb_employmentOrderByRelevanceFieldEnum)[keyof typeof tb_employmentOrderByRelevanceFieldEnum]


  export const tb_etnicsOrderByRelevanceFieldEnum: {
    etnic_arm: 'etnic_arm',
    etnic_eng: 'etnic_eng'
  };

  export type tb_etnicsOrderByRelevanceFieldEnum = (typeof tb_etnicsOrderByRelevanceFieldEnum)[keyof typeof tb_etnicsOrderByRelevanceFieldEnum]


  export const tb_file_typeOrderByRelevanceFieldEnum: {
    file_type: 'file_type'
  };

  export type tb_file_typeOrderByRelevanceFieldEnum = (typeof tb_file_typeOrderByRelevanceFieldEnum)[keyof typeof tb_file_typeOrderByRelevanceFieldEnum]


  export const tb_handedOrderByRelevanceFieldEnum: {
    signed_page: 'signed_page'
  };

  export type tb_handedOrderByRelevanceFieldEnum = (typeof tb_handedOrderByRelevanceFieldEnum)[keyof typeof tb_handedOrderByRelevanceFieldEnum]


  export const tb_interOrderByRelevanceFieldEnum: {
    out_num: 'out_num'
  };

  export type tb_interOrderByRelevanceFieldEnum = (typeof tb_interOrderByRelevanceFieldEnum)[keyof typeof tb_interOrderByRelevanceFieldEnum]


  export const tb_inter_notifiedOrderByRelevanceFieldEnum: {
    file_name: 'file_name'
  };

  export type tb_inter_notifiedOrderByRelevanceFieldEnum = (typeof tb_inter_notifiedOrderByRelevanceFieldEnum)[keyof typeof tb_inter_notifiedOrderByRelevanceFieldEnum]


  export const tb_inter_reciversOrderByRelevanceFieldEnum: {
    inter_reciever_text: 'inter_reciever_text'
  };

  export type tb_inter_reciversOrderByRelevanceFieldEnum = (typeof tb_inter_reciversOrderByRelevanceFieldEnum)[keyof typeof tb_inter_reciversOrderByRelevanceFieldEnum]


  export const tb_inter_send_typeOrderByRelevanceFieldEnum: {
    inter_send_type: 'inter_send_type'
  };

  export type tb_inter_send_typeOrderByRelevanceFieldEnum = (typeof tb_inter_send_typeOrderByRelevanceFieldEnum)[keyof typeof tb_inter_send_typeOrderByRelevanceFieldEnum]


  export const tb_inter_status_typesOrderByRelevanceFieldEnum: {
    inter_status_type: 'inter_status_type'
  };

  export type tb_inter_status_typesOrderByRelevanceFieldEnum = (typeof tb_inter_status_typesOrderByRelevanceFieldEnum)[keyof typeof tb_inter_status_typesOrderByRelevanceFieldEnum]


  export const tb_inter_typeOrderByRelevanceFieldEnum: {
    inter_type: 'inter_type'
  };

  export type tb_inter_typeOrderByRelevanceFieldEnum = (typeof tb_inter_typeOrderByRelevanceFieldEnum)[keyof typeof tb_inter_typeOrderByRelevanceFieldEnum]


  export const tb_lawyerOrderByRelevanceFieldEnum: {
    lawyer_name: 'lawyer_name',
    lawyer_surname: 'lawyer_surname',
    lawyer_organization: 'lawyer_organization',
    lawyer_tel: 'lawyer_tel',
    lawyer_address: 'lawyer_address',
    lawyer_email: 'lawyer_email'
  };

  export type tb_lawyerOrderByRelevanceFieldEnum = (typeof tb_lawyerOrderByRelevanceFieldEnum)[keyof typeof tb_lawyerOrderByRelevanceFieldEnum]


  export const tb_marzOrderByRelevanceFieldEnum: {
    ADM1_ARM: 'ADM1_ARM',
    ADM1_EN: 'ADM1_EN',
    ADM1_PCODE: 'ADM1_PCODE'
  };

  export type tb_marzOrderByRelevanceFieldEnum = (typeof tb_marzOrderByRelevanceFieldEnum)[keyof typeof tb_marzOrderByRelevanceFieldEnum]


  export const tb_membersOrderByRelevanceFieldEnum: {
    f_name_arm: 'f_name_arm',
    f_name_eng: 'f_name_eng',
    l_name_arm: 'l_name_arm',
    l_name_eng: 'l_name_eng',
    m_name_arm: 'm_name_arm',
    m_name_eng: 'm_name_eng',
    b_day: 'b_day',
    b_month: 'b_month',
    b_year: 'b_year'
  };

  export type tb_membersOrderByRelevanceFieldEnum = (typeof tb_membersOrderByRelevanceFieldEnum)[keyof typeof tb_membersOrderByRelevanceFieldEnum]


  export const tb_notificationsOrderByRelevanceFieldEnum: {
    comment_subject: 'comment_subject',
    comment_text: 'comment_text'
  };

  export type tb_notificationsOrderByRelevanceFieldEnum = (typeof tb_notificationsOrderByRelevanceFieldEnum)[keyof typeof tb_notificationsOrderByRelevanceFieldEnum]


  export const tb_personOrderByRelevanceFieldEnum: {
    f_name_arm: 'f_name_arm',
    f_name_eng: 'f_name_eng',
    l_name_arm: 'l_name_arm',
    l_name_eng: 'l_name_eng',
    m_name_arm: 'm_name_arm',
    m_name_eng: 'm_name_eng',
    b_day: 'b_day',
    b_month: 'b_month',
    b_year: 'b_year',
    citizen_adr: 'citizen_adr',
    residence_adr: 'residence_adr',
    departure_from_citizen: 'departure_from_citizen',
    departure_from_residence: 'departure_from_residence',
    doc_num: 'doc_num',
    comment: 'comment',
    image: 'image',
    pnum: 'pnum',
    doc_type: 'doc_type',
    document_num: 'document_num',
    doc_issued_by: 'doc_issued_by',
    bpr_community: 'bpr_community',
    bpr_bnakavayr: 'bpr_bnakavayr',
    bpr_street: 'bpr_street',
    bpr_house: 'bpr_house',
    bpr_aprt: 'bpr_aprt'
  };

  export type tb_personOrderByRelevanceFieldEnum = (typeof tb_personOrderByRelevanceFieldEnum)[keyof typeof tb_personOrderByRelevanceFieldEnum]


  export const tb_person_statusOrderByRelevanceFieldEnum: {
    person_status: 'person_status',
    person_status_eng: 'person_status_eng'
  };

  export type tb_person_statusOrderByRelevanceFieldEnum = (typeof tb_person_statusOrderByRelevanceFieldEnum)[keyof typeof tb_person_statusOrderByRelevanceFieldEnum]


  export const tb_processOrderByRelevanceFieldEnum: {
    comment_to: 'comment_to',
    out_num: 'out_num'
  };

  export type tb_processOrderByRelevanceFieldEnum = (typeof tb_processOrderByRelevanceFieldEnum)[keyof typeof tb_processOrderByRelevanceFieldEnum]


  export const tb_process_typeOrderByRelevanceFieldEnum: {
    process_type: 'process_type'
  };

  export type tb_process_typeOrderByRelevanceFieldEnum = (typeof tb_process_typeOrderByRelevanceFieldEnum)[keyof typeof tb_process_typeOrderByRelevanceFieldEnum]


  export const tb_religionsOrderByRelevanceFieldEnum: {
    religion_arm: 'religion_arm',
    religion_eng: 'religion_eng'
  };

  export type tb_religionsOrderByRelevanceFieldEnum = (typeof tb_religionsOrderByRelevanceFieldEnum)[keyof typeof tb_religionsOrderByRelevanceFieldEnum]


  export const tb_request_bodiesOrderByRelevanceFieldEnum: {
    body: 'body'
  };

  export type tb_request_bodiesOrderByRelevanceFieldEnum = (typeof tb_request_bodiesOrderByRelevanceFieldEnum)[keyof typeof tb_request_bodiesOrderByRelevanceFieldEnum]


  export const tb_roleOrderByRelevanceFieldEnum: {
    der: 'der'
  };

  export type tb_roleOrderByRelevanceFieldEnum = (typeof tb_roleOrderByRelevanceFieldEnum)[keyof typeof tb_roleOrderByRelevanceFieldEnum]


  export const tb_settlementOrderByRelevanceFieldEnum: {
    ADM3_CODE: 'ADM3_CODE',
    ADM4_PCODE: 'ADM4_PCODE',
    ADM4_ARM: 'ADM4_ARM',
    ADM4_ENG: 'ADM4_ENG'
  };

  export type tb_settlementOrderByRelevanceFieldEnum = (typeof tb_settlementOrderByRelevanceFieldEnum)[keyof typeof tb_settlementOrderByRelevanceFieldEnum]


  export const tb_settlement_OrderByRelevanceFieldEnum: {
    ADM3_CODE: 'ADM3_CODE',
    ADM4_PCODE: 'ADM4_PCODE',
    ADM4_ARM: 'ADM4_ARM',
    ADM4_ENG: 'ADM4_ENG'
  };

  export type tb_settlement_OrderByRelevanceFieldEnum = (typeof tb_settlement_OrderByRelevanceFieldEnum)[keyof typeof tb_settlement_OrderByRelevanceFieldEnum]


  export const tb_sign_statusOrderByRelevanceFieldEnum: {
    status: 'status'
  };

  export type tb_sign_statusOrderByRelevanceFieldEnum = (typeof tb_sign_statusOrderByRelevanceFieldEnum)[keyof typeof tb_sign_statusOrderByRelevanceFieldEnum]


  export const tb_translateOrderByRelevanceFieldEnum: {
    file_path: 'file_path',
    file_ids: 'file_ids',
    translate_time_from: 'translate_time_from',
    translate_time_to: 'translate_time_to'
  };

  export type tb_translateOrderByRelevanceFieldEnum = (typeof tb_translateOrderByRelevanceFieldEnum)[keyof typeof tb_translateOrderByRelevanceFieldEnum]


  export const tb_translate_sign_statusesOrderByRelevanceFieldEnum: {
    sign_status_name: 'sign_status_name'
  };

  export type tb_translate_sign_statusesOrderByRelevanceFieldEnum = (typeof tb_translate_sign_statusesOrderByRelevanceFieldEnum)[keyof typeof tb_translate_sign_statusesOrderByRelevanceFieldEnum]


  export const tb_translation_typeOrderByRelevanceFieldEnum: {
    trans_type: 'trans_type'
  };

  export type tb_translation_typeOrderByRelevanceFieldEnum = (typeof tb_translation_typeOrderByRelevanceFieldEnum)[keyof typeof tb_translation_typeOrderByRelevanceFieldEnum]


  export const tb_translatorsOrderByRelevanceFieldEnum: {
    translator_name_arm: 'translator_name_arm',
    translator_name_eng: 'translator_name_eng',
    email: 'email',
    test_mail: 'test_mail',
    logo_file: 'logo_file'
  };

  export type tb_translatorsOrderByRelevanceFieldEnum = (typeof tb_translatorsOrderByRelevanceFieldEnum)[keyof typeof tb_translatorsOrderByRelevanceFieldEnum]


  export const usersOrderByRelevanceFieldEnum: {
    username: 'username',
    password: 'password',
    f_name: 'f_name',
    l_name: 'l_name',
    user_type: 'user_type'
  };

  export type usersOrderByRelevanceFieldEnum = (typeof usersOrderByRelevanceFieldEnum)[keyof typeof usersOrderByRelevanceFieldEnum]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'tb_inter_notified_notification_status'
   */
  export type Enumtb_inter_notified_notification_statusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'tb_inter_notified_notification_status'>
    


  /**
   * Reference to a field of type 'BigInt'
   */
  export type BigIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BigInt'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    
  /**
   * Deep Input Types
   */


  export type court_appeal_typesWhereInput = {
    AND?: court_appeal_typesWhereInput | court_appeal_typesWhereInput[]
    OR?: court_appeal_typesWhereInput[]
    NOT?: court_appeal_typesWhereInput | court_appeal_typesWhereInput[]
    appeal_type_id?: IntFilter<"court_appeal_types"> | number
    appeal_type?: StringFilter<"court_appeal_types"> | string
  }

  export type court_appeal_typesOrderByWithRelationInput = {
    appeal_type_id?: SortOrder
    appeal_type?: SortOrder
    _relevance?: court_appeal_typesOrderByRelevanceInput
  }

  export type court_appeal_typesWhereUniqueInput = Prisma.AtLeast<{
    appeal_type_id?: number
    AND?: court_appeal_typesWhereInput | court_appeal_typesWhereInput[]
    OR?: court_appeal_typesWhereInput[]
    NOT?: court_appeal_typesWhereInput | court_appeal_typesWhereInput[]
    appeal_type?: StringFilter<"court_appeal_types"> | string
  }, "appeal_type_id">

  export type court_appeal_typesOrderByWithAggregationInput = {
    appeal_type_id?: SortOrder
    appeal_type?: SortOrder
    _count?: court_appeal_typesCountOrderByAggregateInput
    _avg?: court_appeal_typesAvgOrderByAggregateInput
    _max?: court_appeal_typesMaxOrderByAggregateInput
    _min?: court_appeal_typesMinOrderByAggregateInput
    _sum?: court_appeal_typesSumOrderByAggregateInput
  }

  export type court_appeal_typesScalarWhereWithAggregatesInput = {
    AND?: court_appeal_typesScalarWhereWithAggregatesInput | court_appeal_typesScalarWhereWithAggregatesInput[]
    OR?: court_appeal_typesScalarWhereWithAggregatesInput[]
    NOT?: court_appeal_typesScalarWhereWithAggregatesInput | court_appeal_typesScalarWhereWithAggregatesInput[]
    appeal_type_id?: IntWithAggregatesFilter<"court_appeal_types"> | number
    appeal_type?: StringWithAggregatesFilter<"court_appeal_types"> | string
  }

  export type court_appealsWhereInput = {
    AND?: court_appealsWhereInput | court_appealsWhereInput[]
    OR?: court_appealsWhereInput[]
    NOT?: court_appealsWhereInput | court_appealsWhereInput[]
    appeal_id?: IntFilter<"court_appeals"> | number
    case_id?: IntFilter<"court_appeals"> | number
    claim_id?: IntFilter<"court_appeals"> | number
    court_accept_date?: DateTimeFilter<"court_appeals"> | Date | string
    actual?: IntFilter<"court_appeals"> | number
    filled_in?: DateTimeFilter<"court_appeals"> | Date | string
    filled_by?: IntFilter<"court_appeals"> | number
    court_level?: IntFilter<"court_appeals"> | number
    court_name?: StringNullableFilter<"court_appeals"> | string | null
  }

  export type court_appealsOrderByWithRelationInput = {
    appeal_id?: SortOrder
    case_id?: SortOrder
    claim_id?: SortOrder
    court_accept_date?: SortOrder
    actual?: SortOrder
    filled_in?: SortOrder
    filled_by?: SortOrder
    court_level?: SortOrder
    court_name?: SortOrderInput | SortOrder
    _relevance?: court_appealsOrderByRelevanceInput
  }

  export type court_appealsWhereUniqueInput = Prisma.AtLeast<{
    appeal_id?: number
    AND?: court_appealsWhereInput | court_appealsWhereInput[]
    OR?: court_appealsWhereInput[]
    NOT?: court_appealsWhereInput | court_appealsWhereInput[]
    case_id?: IntFilter<"court_appeals"> | number
    claim_id?: IntFilter<"court_appeals"> | number
    court_accept_date?: DateTimeFilter<"court_appeals"> | Date | string
    actual?: IntFilter<"court_appeals"> | number
    filled_in?: DateTimeFilter<"court_appeals"> | Date | string
    filled_by?: IntFilter<"court_appeals"> | number
    court_level?: IntFilter<"court_appeals"> | number
    court_name?: StringNullableFilter<"court_appeals"> | string | null
  }, "appeal_id">

  export type court_appealsOrderByWithAggregationInput = {
    appeal_id?: SortOrder
    case_id?: SortOrder
    claim_id?: SortOrder
    court_accept_date?: SortOrder
    actual?: SortOrder
    filled_in?: SortOrder
    filled_by?: SortOrder
    court_level?: SortOrder
    court_name?: SortOrderInput | SortOrder
    _count?: court_appealsCountOrderByAggregateInput
    _avg?: court_appealsAvgOrderByAggregateInput
    _max?: court_appealsMaxOrderByAggregateInput
    _min?: court_appealsMinOrderByAggregateInput
    _sum?: court_appealsSumOrderByAggregateInput
  }

  export type court_appealsScalarWhereWithAggregatesInput = {
    AND?: court_appealsScalarWhereWithAggregatesInput | court_appealsScalarWhereWithAggregatesInput[]
    OR?: court_appealsScalarWhereWithAggregatesInput[]
    NOT?: court_appealsScalarWhereWithAggregatesInput | court_appealsScalarWhereWithAggregatesInput[]
    appeal_id?: IntWithAggregatesFilter<"court_appeals"> | number
    case_id?: IntWithAggregatesFilter<"court_appeals"> | number
    claim_id?: IntWithAggregatesFilter<"court_appeals"> | number
    court_accept_date?: DateTimeWithAggregatesFilter<"court_appeals"> | Date | string
    actual?: IntWithAggregatesFilter<"court_appeals"> | number
    filled_in?: DateTimeWithAggregatesFilter<"court_appeals"> | Date | string
    filled_by?: IntWithAggregatesFilter<"court_appeals"> | number
    court_level?: IntWithAggregatesFilter<"court_appeals"> | number
    court_name?: StringNullableWithAggregatesFilter<"court_appeals"> | string | null
  }

  export type court_claim_initiatorsWhereInput = {
    AND?: court_claim_initiatorsWhereInput | court_claim_initiatorsWhereInput[]
    OR?: court_claim_initiatorsWhereInput[]
    NOT?: court_claim_initiatorsWhereInput | court_claim_initiatorsWhereInput[]
    id?: IntFilter<"court_claim_initiators"> | number
    initiator_name?: StringFilter<"court_claim_initiators"> | string
  }

  export type court_claim_initiatorsOrderByWithRelationInput = {
    id?: SortOrder
    initiator_name?: SortOrder
    _relevance?: court_claim_initiatorsOrderByRelevanceInput
  }

  export type court_claim_initiatorsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: court_claim_initiatorsWhereInput | court_claim_initiatorsWhereInput[]
    OR?: court_claim_initiatorsWhereInput[]
    NOT?: court_claim_initiatorsWhereInput | court_claim_initiatorsWhereInput[]
    initiator_name?: StringFilter<"court_claim_initiators"> | string
  }, "id">

  export type court_claim_initiatorsOrderByWithAggregationInput = {
    id?: SortOrder
    initiator_name?: SortOrder
    _count?: court_claim_initiatorsCountOrderByAggregateInput
    _avg?: court_claim_initiatorsAvgOrderByAggregateInput
    _max?: court_claim_initiatorsMaxOrderByAggregateInput
    _min?: court_claim_initiatorsMinOrderByAggregateInput
    _sum?: court_claim_initiatorsSumOrderByAggregateInput
  }

  export type court_claim_initiatorsScalarWhereWithAggregatesInput = {
    AND?: court_claim_initiatorsScalarWhereWithAggregatesInput | court_claim_initiatorsScalarWhereWithAggregatesInput[]
    OR?: court_claim_initiatorsScalarWhereWithAggregatesInput[]
    NOT?: court_claim_initiatorsScalarWhereWithAggregatesInput | court_claim_initiatorsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"court_claim_initiators"> | number
    initiator_name?: StringWithAggregatesFilter<"court_claim_initiators"> | string
  }

  export type court_claim_membersWhereInput = {
    AND?: court_claim_membersWhereInput | court_claim_membersWhereInput[]
    OR?: court_claim_membersWhereInput[]
    NOT?: court_claim_membersWhereInput | court_claim_membersWhereInput[]
    id?: IntFilter<"court_claim_members"> | number
    claim_id?: IntFilter<"court_claim_members"> | number
    case_id?: IntFilter<"court_claim_members"> | number
    person_id?: IntFilter<"court_claim_members"> | number
    created_at?: DateTimeFilter<"court_claim_members"> | Date | string
    actual?: IntFilter<"court_claim_members"> | number
  }

  export type court_claim_membersOrderByWithRelationInput = {
    id?: SortOrder
    claim_id?: SortOrder
    case_id?: SortOrder
    person_id?: SortOrder
    created_at?: SortOrder
    actual?: SortOrder
  }

  export type court_claim_membersWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: court_claim_membersWhereInput | court_claim_membersWhereInput[]
    OR?: court_claim_membersWhereInput[]
    NOT?: court_claim_membersWhereInput | court_claim_membersWhereInput[]
    claim_id?: IntFilter<"court_claim_members"> | number
    case_id?: IntFilter<"court_claim_members"> | number
    person_id?: IntFilter<"court_claim_members"> | number
    created_at?: DateTimeFilter<"court_claim_members"> | Date | string
    actual?: IntFilter<"court_claim_members"> | number
  }, "id">

  export type court_claim_membersOrderByWithAggregationInput = {
    id?: SortOrder
    claim_id?: SortOrder
    case_id?: SortOrder
    person_id?: SortOrder
    created_at?: SortOrder
    actual?: SortOrder
    _count?: court_claim_membersCountOrderByAggregateInput
    _avg?: court_claim_membersAvgOrderByAggregateInput
    _max?: court_claim_membersMaxOrderByAggregateInput
    _min?: court_claim_membersMinOrderByAggregateInput
    _sum?: court_claim_membersSumOrderByAggregateInput
  }

  export type court_claim_membersScalarWhereWithAggregatesInput = {
    AND?: court_claim_membersScalarWhereWithAggregatesInput | court_claim_membersScalarWhereWithAggregatesInput[]
    OR?: court_claim_membersScalarWhereWithAggregatesInput[]
    NOT?: court_claim_membersScalarWhereWithAggregatesInput | court_claim_membersScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"court_claim_members"> | number
    claim_id?: IntWithAggregatesFilter<"court_claim_members"> | number
    case_id?: IntWithAggregatesFilter<"court_claim_members"> | number
    person_id?: IntWithAggregatesFilter<"court_claim_members"> | number
    created_at?: DateTimeWithAggregatesFilter<"court_claim_members"> | Date | string
    actual?: IntWithAggregatesFilter<"court_claim_members"> | number
  }

  export type court_claimsWhereInput = {
    AND?: court_claimsWhereInput | court_claimsWhereInput[]
    OR?: court_claimsWhereInput[]
    NOT?: court_claimsWhereInput | court_claimsWhereInput[]
    claim_id?: IntFilter<"court_claims"> | number
    claim_serial_number?: StringFilter<"court_claims"> | string
    claim_date?: DateTimeFilter<"court_claims"> | Date | string
    appealable_ms_decision?: IntNullableFilter<"court_claims"> | number | null
    appealable_court_decision?: IntNullableFilter<"court_claims"> | number | null
    appealable_claim?: IntNullableFilter<"court_claims"> | number | null
    filled_by?: IntFilter<"court_claims"> | number
    filled_in_date?: DateTimeFilter<"court_claims"> | Date | string
    ms_notified_date?: DateTimeFilter<"court_claims"> | Date | string
    ms_lawyer?: IntFilter<"court_claims"> | number
    case_id?: IntFilter<"court_claims"> | number
    court_level?: IntFilter<"court_claims"> | number
    actual?: IntFilter<"court_claims"> | number
    initiator?: IntFilter<"court_claims"> | number
    claim_status?: IntFilter<"court_claims"> | number
    appeal_type?: IntFilter<"court_claims"> | number
    status_change_date?: DateTimeFilter<"court_claims"> | Date | string
  }

  export type court_claimsOrderByWithRelationInput = {
    claim_id?: SortOrder
    claim_serial_number?: SortOrder
    claim_date?: SortOrder
    appealable_ms_decision?: SortOrderInput | SortOrder
    appealable_court_decision?: SortOrderInput | SortOrder
    appealable_claim?: SortOrderInput | SortOrder
    filled_by?: SortOrder
    filled_in_date?: SortOrder
    ms_notified_date?: SortOrder
    ms_lawyer?: SortOrder
    case_id?: SortOrder
    court_level?: SortOrder
    actual?: SortOrder
    initiator?: SortOrder
    claim_status?: SortOrder
    appeal_type?: SortOrder
    status_change_date?: SortOrder
    _relevance?: court_claimsOrderByRelevanceInput
  }

  export type court_claimsWhereUniqueInput = Prisma.AtLeast<{
    claim_id?: number
    AND?: court_claimsWhereInput | court_claimsWhereInput[]
    OR?: court_claimsWhereInput[]
    NOT?: court_claimsWhereInput | court_claimsWhereInput[]
    claim_serial_number?: StringFilter<"court_claims"> | string
    claim_date?: DateTimeFilter<"court_claims"> | Date | string
    appealable_ms_decision?: IntNullableFilter<"court_claims"> | number | null
    appealable_court_decision?: IntNullableFilter<"court_claims"> | number | null
    appealable_claim?: IntNullableFilter<"court_claims"> | number | null
    filled_by?: IntFilter<"court_claims"> | number
    filled_in_date?: DateTimeFilter<"court_claims"> | Date | string
    ms_notified_date?: DateTimeFilter<"court_claims"> | Date | string
    ms_lawyer?: IntFilter<"court_claims"> | number
    case_id?: IntFilter<"court_claims"> | number
    court_level?: IntFilter<"court_claims"> | number
    actual?: IntFilter<"court_claims"> | number
    initiator?: IntFilter<"court_claims"> | number
    claim_status?: IntFilter<"court_claims"> | number
    appeal_type?: IntFilter<"court_claims"> | number
    status_change_date?: DateTimeFilter<"court_claims"> | Date | string
  }, "claim_id">

  export type court_claimsOrderByWithAggregationInput = {
    claim_id?: SortOrder
    claim_serial_number?: SortOrder
    claim_date?: SortOrder
    appealable_ms_decision?: SortOrderInput | SortOrder
    appealable_court_decision?: SortOrderInput | SortOrder
    appealable_claim?: SortOrderInput | SortOrder
    filled_by?: SortOrder
    filled_in_date?: SortOrder
    ms_notified_date?: SortOrder
    ms_lawyer?: SortOrder
    case_id?: SortOrder
    court_level?: SortOrder
    actual?: SortOrder
    initiator?: SortOrder
    claim_status?: SortOrder
    appeal_type?: SortOrder
    status_change_date?: SortOrder
    _count?: court_claimsCountOrderByAggregateInput
    _avg?: court_claimsAvgOrderByAggregateInput
    _max?: court_claimsMaxOrderByAggregateInput
    _min?: court_claimsMinOrderByAggregateInput
    _sum?: court_claimsSumOrderByAggregateInput
  }

  export type court_claimsScalarWhereWithAggregatesInput = {
    AND?: court_claimsScalarWhereWithAggregatesInput | court_claimsScalarWhereWithAggregatesInput[]
    OR?: court_claimsScalarWhereWithAggregatesInput[]
    NOT?: court_claimsScalarWhereWithAggregatesInput | court_claimsScalarWhereWithAggregatesInput[]
    claim_id?: IntWithAggregatesFilter<"court_claims"> | number
    claim_serial_number?: StringWithAggregatesFilter<"court_claims"> | string
    claim_date?: DateTimeWithAggregatesFilter<"court_claims"> | Date | string
    appealable_ms_decision?: IntNullableWithAggregatesFilter<"court_claims"> | number | null
    appealable_court_decision?: IntNullableWithAggregatesFilter<"court_claims"> | number | null
    appealable_claim?: IntNullableWithAggregatesFilter<"court_claims"> | number | null
    filled_by?: IntWithAggregatesFilter<"court_claims"> | number
    filled_in_date?: DateTimeWithAggregatesFilter<"court_claims"> | Date | string
    ms_notified_date?: DateTimeWithAggregatesFilter<"court_claims"> | Date | string
    ms_lawyer?: IntWithAggregatesFilter<"court_claims"> | number
    case_id?: IntWithAggregatesFilter<"court_claims"> | number
    court_level?: IntWithAggregatesFilter<"court_claims"> | number
    actual?: IntWithAggregatesFilter<"court_claims"> | number
    initiator?: IntWithAggregatesFilter<"court_claims"> | number
    claim_status?: IntWithAggregatesFilter<"court_claims"> | number
    appeal_type?: IntWithAggregatesFilter<"court_claims"> | number
    status_change_date?: DateTimeWithAggregatesFilter<"court_claims"> | Date | string
  }

  export type court_cliam_statusWhereInput = {
    AND?: court_cliam_statusWhereInput | court_cliam_statusWhereInput[]
    OR?: court_cliam_statusWhereInput[]
    NOT?: court_cliam_statusWhereInput | court_cliam_statusWhereInput[]
    id?: IntFilter<"court_cliam_status"> | number
    court_level?: IntFilter<"court_cliam_status"> | number
    name?: StringFilter<"court_cliam_status"> | string
    button_value?: StringNullableFilter<"court_cliam_status"> | string | null
  }

  export type court_cliam_statusOrderByWithRelationInput = {
    id?: SortOrder
    court_level?: SortOrder
    name?: SortOrder
    button_value?: SortOrderInput | SortOrder
    _relevance?: court_cliam_statusOrderByRelevanceInput
  }

  export type court_cliam_statusWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: court_cliam_statusWhereInput | court_cliam_statusWhereInput[]
    OR?: court_cliam_statusWhereInput[]
    NOT?: court_cliam_statusWhereInput | court_cliam_statusWhereInput[]
    court_level?: IntFilter<"court_cliam_status"> | number
    name?: StringFilter<"court_cliam_status"> | string
    button_value?: StringNullableFilter<"court_cliam_status"> | string | null
  }, "id">

  export type court_cliam_statusOrderByWithAggregationInput = {
    id?: SortOrder
    court_level?: SortOrder
    name?: SortOrder
    button_value?: SortOrderInput | SortOrder
    _count?: court_cliam_statusCountOrderByAggregateInput
    _avg?: court_cliam_statusAvgOrderByAggregateInput
    _max?: court_cliam_statusMaxOrderByAggregateInput
    _min?: court_cliam_statusMinOrderByAggregateInput
    _sum?: court_cliam_statusSumOrderByAggregateInput
  }

  export type court_cliam_statusScalarWhereWithAggregatesInput = {
    AND?: court_cliam_statusScalarWhereWithAggregatesInput | court_cliam_statusScalarWhereWithAggregatesInput[]
    OR?: court_cliam_statusScalarWhereWithAggregatesInput[]
    NOT?: court_cliam_statusScalarWhereWithAggregatesInput | court_cliam_statusScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"court_cliam_status"> | number
    court_level?: IntWithAggregatesFilter<"court_cliam_status"> | number
    name?: StringWithAggregatesFilter<"court_cliam_status"> | string
    button_value?: StringNullableWithAggregatesFilter<"court_cliam_status"> | string | null
  }

  export type court_decision_typesWhereInput = {
    AND?: court_decision_typesWhereInput | court_decision_typesWhereInput[]
    OR?: court_decision_typesWhereInput[]
    NOT?: court_decision_typesWhereInput | court_decision_typesWhereInput[]
    court_decision_type_id?: IntFilter<"court_decision_types"> | number
    court_type?: IntFilter<"court_decision_types"> | number
    court_decision?: StringFilter<"court_decision_types"> | string
  }

  export type court_decision_typesOrderByWithRelationInput = {
    court_decision_type_id?: SortOrder
    court_type?: SortOrder
    court_decision?: SortOrder
    _relevance?: court_decision_typesOrderByRelevanceInput
  }

  export type court_decision_typesWhereUniqueInput = Prisma.AtLeast<{
    court_decision_type_id?: number
    AND?: court_decision_typesWhereInput | court_decision_typesWhereInput[]
    OR?: court_decision_typesWhereInput[]
    NOT?: court_decision_typesWhereInput | court_decision_typesWhereInput[]
    court_type?: IntFilter<"court_decision_types"> | number
    court_decision?: StringFilter<"court_decision_types"> | string
  }, "court_decision_type_id">

  export type court_decision_typesOrderByWithAggregationInput = {
    court_decision_type_id?: SortOrder
    court_type?: SortOrder
    court_decision?: SortOrder
    _count?: court_decision_typesCountOrderByAggregateInput
    _avg?: court_decision_typesAvgOrderByAggregateInput
    _max?: court_decision_typesMaxOrderByAggregateInput
    _min?: court_decision_typesMinOrderByAggregateInput
    _sum?: court_decision_typesSumOrderByAggregateInput
  }

  export type court_decision_typesScalarWhereWithAggregatesInput = {
    AND?: court_decision_typesScalarWhereWithAggregatesInput | court_decision_typesScalarWhereWithAggregatesInput[]
    OR?: court_decision_typesScalarWhereWithAggregatesInput[]
    NOT?: court_decision_typesScalarWhereWithAggregatesInput | court_decision_typesScalarWhereWithAggregatesInput[]
    court_decision_type_id?: IntWithAggregatesFilter<"court_decision_types"> | number
    court_type?: IntWithAggregatesFilter<"court_decision_types"> | number
    court_decision?: StringWithAggregatesFilter<"court_decision_types"> | string
  }

  export type court_decisionsWhereInput = {
    AND?: court_decisionsWhereInput | court_decisionsWhereInput[]
    OR?: court_decisionsWhereInput[]
    NOT?: court_decisionsWhereInput | court_decisionsWhereInput[]
    court_decision_id?: IntFilter<"court_decisions"> | number
    appeal_id?: IntFilter<"court_decisions"> | number
    decission_type?: IntFilter<"court_decisions"> | number
    decison_date?: DateTimeFilter<"court_decisions"> | Date | string
    decision_notification_date?: DateTimeFilter<"court_decisions"> | Date | string
    input_date?: DateTimeFilter<"court_decisions"> | Date | string
    input_by?: IntFilter<"court_decisions"> | number
    actual?: IntFilter<"court_decisions"> | number
  }

  export type court_decisionsOrderByWithRelationInput = {
    court_decision_id?: SortOrder
    appeal_id?: SortOrder
    decission_type?: SortOrder
    decison_date?: SortOrder
    decision_notification_date?: SortOrder
    input_date?: SortOrder
    input_by?: SortOrder
    actual?: SortOrder
  }

  export type court_decisionsWhereUniqueInput = Prisma.AtLeast<{
    court_decision_id?: number
    AND?: court_decisionsWhereInput | court_decisionsWhereInput[]
    OR?: court_decisionsWhereInput[]
    NOT?: court_decisionsWhereInput | court_decisionsWhereInput[]
    appeal_id?: IntFilter<"court_decisions"> | number
    decission_type?: IntFilter<"court_decisions"> | number
    decison_date?: DateTimeFilter<"court_decisions"> | Date | string
    decision_notification_date?: DateTimeFilter<"court_decisions"> | Date | string
    input_date?: DateTimeFilter<"court_decisions"> | Date | string
    input_by?: IntFilter<"court_decisions"> | number
    actual?: IntFilter<"court_decisions"> | number
  }, "court_decision_id">

  export type court_decisionsOrderByWithAggregationInput = {
    court_decision_id?: SortOrder
    appeal_id?: SortOrder
    decission_type?: SortOrder
    decison_date?: SortOrder
    decision_notification_date?: SortOrder
    input_date?: SortOrder
    input_by?: SortOrder
    actual?: SortOrder
    _count?: court_decisionsCountOrderByAggregateInput
    _avg?: court_decisionsAvgOrderByAggregateInput
    _max?: court_decisionsMaxOrderByAggregateInput
    _min?: court_decisionsMinOrderByAggregateInput
    _sum?: court_decisionsSumOrderByAggregateInput
  }

  export type court_decisionsScalarWhereWithAggregatesInput = {
    AND?: court_decisionsScalarWhereWithAggregatesInput | court_decisionsScalarWhereWithAggregatesInput[]
    OR?: court_decisionsScalarWhereWithAggregatesInput[]
    NOT?: court_decisionsScalarWhereWithAggregatesInput | court_decisionsScalarWhereWithAggregatesInput[]
    court_decision_id?: IntWithAggregatesFilter<"court_decisions"> | number
    appeal_id?: IntWithAggregatesFilter<"court_decisions"> | number
    decission_type?: IntWithAggregatesFilter<"court_decisions"> | number
    decison_date?: DateTimeWithAggregatesFilter<"court_decisions"> | Date | string
    decision_notification_date?: DateTimeWithAggregatesFilter<"court_decisions"> | Date | string
    input_date?: DateTimeWithAggregatesFilter<"court_decisions"> | Date | string
    input_by?: IntWithAggregatesFilter<"court_decisions"> | number
    actual?: IntWithAggregatesFilter<"court_decisions"> | number
  }

  export type court_levelsWhereInput = {
    AND?: court_levelsWhereInput | court_levelsWhereInput[]
    OR?: court_levelsWhereInput[]
    NOT?: court_levelsWhereInput | court_levelsWhereInput[]
    court_id?: IntFilter<"court_levels"> | number
    court_title?: StringFilter<"court_levels"> | string
  }

  export type court_levelsOrderByWithRelationInput = {
    court_id?: SortOrder
    court_title?: SortOrder
    _relevance?: court_levelsOrderByRelevanceInput
  }

  export type court_levelsWhereUniqueInput = Prisma.AtLeast<{
    court_id?: number
    AND?: court_levelsWhereInput | court_levelsWhereInput[]
    OR?: court_levelsWhereInput[]
    NOT?: court_levelsWhereInput | court_levelsWhereInput[]
    court_title?: StringFilter<"court_levels"> | string
  }, "court_id">

  export type court_levelsOrderByWithAggregationInput = {
    court_id?: SortOrder
    court_title?: SortOrder
    _count?: court_levelsCountOrderByAggregateInput
    _avg?: court_levelsAvgOrderByAggregateInput
    _max?: court_levelsMaxOrderByAggregateInput
    _min?: court_levelsMinOrderByAggregateInput
    _sum?: court_levelsSumOrderByAggregateInput
  }

  export type court_levelsScalarWhereWithAggregatesInput = {
    AND?: court_levelsScalarWhereWithAggregatesInput | court_levelsScalarWhereWithAggregatesInput[]
    OR?: court_levelsScalarWhereWithAggregatesInput[]
    NOT?: court_levelsScalarWhereWithAggregatesInput | court_levelsScalarWhereWithAggregatesInput[]
    court_id?: IntWithAggregatesFilter<"court_levels"> | number
    court_title?: StringWithAggregatesFilter<"court_levels"> | string
  }

  export type cover_sign_statusWhereInput = {
    AND?: cover_sign_statusWhereInput | cover_sign_statusWhereInput[]
    OR?: cover_sign_statusWhereInput[]
    NOT?: cover_sign_statusWhereInput | cover_sign_statusWhereInput[]
    sign_status_id?: IntFilter<"cover_sign_status"> | number
    sign_status_name?: StringFilter<"cover_sign_status"> | string
  }

  export type cover_sign_statusOrderByWithRelationInput = {
    sign_status_id?: SortOrder
    sign_status_name?: SortOrder
    _relevance?: cover_sign_statusOrderByRelevanceInput
  }

  export type cover_sign_statusWhereUniqueInput = Prisma.AtLeast<{
    sign_status_id?: number
    AND?: cover_sign_statusWhereInput | cover_sign_statusWhereInput[]
    OR?: cover_sign_statusWhereInput[]
    NOT?: cover_sign_statusWhereInput | cover_sign_statusWhereInput[]
    sign_status_name?: StringFilter<"cover_sign_status"> | string
  }, "sign_status_id">

  export type cover_sign_statusOrderByWithAggregationInput = {
    sign_status_id?: SortOrder
    sign_status_name?: SortOrder
    _count?: cover_sign_statusCountOrderByAggregateInput
    _avg?: cover_sign_statusAvgOrderByAggregateInput
    _max?: cover_sign_statusMaxOrderByAggregateInput
    _min?: cover_sign_statusMinOrderByAggregateInput
    _sum?: cover_sign_statusSumOrderByAggregateInput
  }

  export type cover_sign_statusScalarWhereWithAggregatesInput = {
    AND?: cover_sign_statusScalarWhereWithAggregatesInput | cover_sign_statusScalarWhereWithAggregatesInput[]
    OR?: cover_sign_statusScalarWhereWithAggregatesInput[]
    NOT?: cover_sign_statusScalarWhereWithAggregatesInput | cover_sign_statusScalarWhereWithAggregatesInput[]
    sign_status_id?: IntWithAggregatesFilter<"cover_sign_status"> | number
    sign_status_name?: StringWithAggregatesFilter<"cover_sign_status"> | string
  }

  export type filesWhereInput = {
    AND?: filesWhereInput | filesWhereInput[]
    OR?: filesWhereInput[]
    NOT?: filesWhereInput | filesWhereInput[]
    id?: IntFilter<"files"> | number
    file_name?: StringFilter<"files"> | string
    uploaded_on?: DateTimeFilter<"files"> | Date | string
    file_type?: IntNullableFilter<"files"> | number | null
    uploader?: IntFilter<"files"> | number
    case_id?: IntFilter<"files"> | number
    decision_id?: IntNullableFilter<"files"> | number | null
    inter_id?: IntNullableFilter<"files"> | number | null
    coi_id?: IntNullableFilter<"files"> | number | null
    person_id?: IntNullableFilter<"files"> | number | null
    draft_id?: IntNullableFilter<"files"> | number | null
    claim_id?: IntNullableFilter<"files"> | number | null
    appeal_id?: IntNullableFilter<"files"> | number | null
    file_path?: StringNullableFilter<"files"> | string | null
    process_type_id?: IntNullableFilter<"files"> | number | null
    actual?: IntFilter<"files"> | number
  }

  export type filesOrderByWithRelationInput = {
    id?: SortOrder
    file_name?: SortOrder
    uploaded_on?: SortOrder
    file_type?: SortOrderInput | SortOrder
    uploader?: SortOrder
    case_id?: SortOrder
    decision_id?: SortOrderInput | SortOrder
    inter_id?: SortOrderInput | SortOrder
    coi_id?: SortOrderInput | SortOrder
    person_id?: SortOrderInput | SortOrder
    draft_id?: SortOrderInput | SortOrder
    claim_id?: SortOrderInput | SortOrder
    appeal_id?: SortOrderInput | SortOrder
    file_path?: SortOrderInput | SortOrder
    process_type_id?: SortOrderInput | SortOrder
    actual?: SortOrder
    _relevance?: filesOrderByRelevanceInput
  }

  export type filesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: filesWhereInput | filesWhereInput[]
    OR?: filesWhereInput[]
    NOT?: filesWhereInput | filesWhereInput[]
    file_name?: StringFilter<"files"> | string
    uploaded_on?: DateTimeFilter<"files"> | Date | string
    file_type?: IntNullableFilter<"files"> | number | null
    uploader?: IntFilter<"files"> | number
    case_id?: IntFilter<"files"> | number
    decision_id?: IntNullableFilter<"files"> | number | null
    inter_id?: IntNullableFilter<"files"> | number | null
    coi_id?: IntNullableFilter<"files"> | number | null
    person_id?: IntNullableFilter<"files"> | number | null
    draft_id?: IntNullableFilter<"files"> | number | null
    claim_id?: IntNullableFilter<"files"> | number | null
    appeal_id?: IntNullableFilter<"files"> | number | null
    file_path?: StringNullableFilter<"files"> | string | null
    process_type_id?: IntNullableFilter<"files"> | number | null
    actual?: IntFilter<"files"> | number
  }, "id">

  export type filesOrderByWithAggregationInput = {
    id?: SortOrder
    file_name?: SortOrder
    uploaded_on?: SortOrder
    file_type?: SortOrderInput | SortOrder
    uploader?: SortOrder
    case_id?: SortOrder
    decision_id?: SortOrderInput | SortOrder
    inter_id?: SortOrderInput | SortOrder
    coi_id?: SortOrderInput | SortOrder
    person_id?: SortOrderInput | SortOrder
    draft_id?: SortOrderInput | SortOrder
    claim_id?: SortOrderInput | SortOrder
    appeal_id?: SortOrderInput | SortOrder
    file_path?: SortOrderInput | SortOrder
    process_type_id?: SortOrderInput | SortOrder
    actual?: SortOrder
    _count?: filesCountOrderByAggregateInput
    _avg?: filesAvgOrderByAggregateInput
    _max?: filesMaxOrderByAggregateInput
    _min?: filesMinOrderByAggregateInput
    _sum?: filesSumOrderByAggregateInput
  }

  export type filesScalarWhereWithAggregatesInput = {
    AND?: filesScalarWhereWithAggregatesInput | filesScalarWhereWithAggregatesInput[]
    OR?: filesScalarWhereWithAggregatesInput[]
    NOT?: filesScalarWhereWithAggregatesInput | filesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"files"> | number
    file_name?: StringWithAggregatesFilter<"files"> | string
    uploaded_on?: DateTimeWithAggregatesFilter<"files"> | Date | string
    file_type?: IntNullableWithAggregatesFilter<"files"> | number | null
    uploader?: IntWithAggregatesFilter<"files"> | number
    case_id?: IntWithAggregatesFilter<"files"> | number
    decision_id?: IntNullableWithAggregatesFilter<"files"> | number | null
    inter_id?: IntNullableWithAggregatesFilter<"files"> | number | null
    coi_id?: IntNullableWithAggregatesFilter<"files"> | number | null
    person_id?: IntNullableWithAggregatesFilter<"files"> | number | null
    draft_id?: IntNullableWithAggregatesFilter<"files"> | number | null
    claim_id?: IntNullableWithAggregatesFilter<"files"> | number | null
    appeal_id?: IntNullableWithAggregatesFilter<"files"> | number | null
    file_path?: StringNullableWithAggregatesFilter<"files"> | string | null
    process_type_id?: IntNullableWithAggregatesFilter<"files"> | number | null
    actual?: IntWithAggregatesFilter<"files"> | number
  }

  export type ipsWhereInput = {
    AND?: ipsWhereInput | ipsWhereInput[]
    OR?: ipsWhereInput[]
    NOT?: ipsWhereInput | ipsWhereInput[]
    id?: IntFilter<"ips"> | number
    ip?: StringFilter<"ips"> | string
    created_at?: DateTimeFilter<"ips"> | Date | string
  }

  export type ipsOrderByWithRelationInput = {
    id?: SortOrder
    ip?: SortOrder
    created_at?: SortOrder
    _relevance?: ipsOrderByRelevanceInput
  }

  export type ipsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ipsWhereInput | ipsWhereInput[]
    OR?: ipsWhereInput[]
    NOT?: ipsWhereInput | ipsWhereInput[]
    ip?: StringFilter<"ips"> | string
    created_at?: DateTimeFilter<"ips"> | Date | string
  }, "id">

  export type ipsOrderByWithAggregationInput = {
    id?: SortOrder
    ip?: SortOrder
    created_at?: SortOrder
    _count?: ipsCountOrderByAggregateInput
    _avg?: ipsAvgOrderByAggregateInput
    _max?: ipsMaxOrderByAggregateInput
    _min?: ipsMinOrderByAggregateInput
    _sum?: ipsSumOrderByAggregateInput
  }

  export type ipsScalarWhereWithAggregatesInput = {
    AND?: ipsScalarWhereWithAggregatesInput | ipsScalarWhereWithAggregatesInput[]
    OR?: ipsScalarWhereWithAggregatesInput[]
    NOT?: ipsScalarWhereWithAggregatesInput | ipsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ips"> | number
    ip?: StringWithAggregatesFilter<"ips"> | string
    created_at?: DateTimeWithAggregatesFilter<"ips"> | Date | string
  }

  export type old_case_decisionsWhereInput = {
    AND?: old_case_decisionsWhereInput | old_case_decisionsWhereInput[]
    OR?: old_case_decisionsWhereInput[]
    NOT?: old_case_decisionsWhereInput | old_case_decisionsWhereInput[]
    old_decision_id?: IntFilter<"old_case_decisions"> | number
    old_case_id?: IntFilter<"old_case_decisions"> | number
    ms_decision?: IntFilter<"old_case_decisions"> | number
    ms_decision_date?: DateTimeNullableFilter<"old_case_decisions"> | Date | string | null
    final_decision?: IntNullableFilter<"old_case_decisions"> | number | null
    final_decision_date?: DateTimeNullableFilter<"old_case_decisions"> | Date | string | null
  }

  export type old_case_decisionsOrderByWithRelationInput = {
    old_decision_id?: SortOrder
    old_case_id?: SortOrder
    ms_decision?: SortOrder
    ms_decision_date?: SortOrderInput | SortOrder
    final_decision?: SortOrderInput | SortOrder
    final_decision_date?: SortOrderInput | SortOrder
  }

  export type old_case_decisionsWhereUniqueInput = Prisma.AtLeast<{
    old_decision_id?: number
    AND?: old_case_decisionsWhereInput | old_case_decisionsWhereInput[]
    OR?: old_case_decisionsWhereInput[]
    NOT?: old_case_decisionsWhereInput | old_case_decisionsWhereInput[]
    old_case_id?: IntFilter<"old_case_decisions"> | number
    ms_decision?: IntFilter<"old_case_decisions"> | number
    ms_decision_date?: DateTimeNullableFilter<"old_case_decisions"> | Date | string | null
    final_decision?: IntNullableFilter<"old_case_decisions"> | number | null
    final_decision_date?: DateTimeNullableFilter<"old_case_decisions"> | Date | string | null
  }, "old_decision_id">

  export type old_case_decisionsOrderByWithAggregationInput = {
    old_decision_id?: SortOrder
    old_case_id?: SortOrder
    ms_decision?: SortOrder
    ms_decision_date?: SortOrderInput | SortOrder
    final_decision?: SortOrderInput | SortOrder
    final_decision_date?: SortOrderInput | SortOrder
    _count?: old_case_decisionsCountOrderByAggregateInput
    _avg?: old_case_decisionsAvgOrderByAggregateInput
    _max?: old_case_decisionsMaxOrderByAggregateInput
    _min?: old_case_decisionsMinOrderByAggregateInput
    _sum?: old_case_decisionsSumOrderByAggregateInput
  }

  export type old_case_decisionsScalarWhereWithAggregatesInput = {
    AND?: old_case_decisionsScalarWhereWithAggregatesInput | old_case_decisionsScalarWhereWithAggregatesInput[]
    OR?: old_case_decisionsScalarWhereWithAggregatesInput[]
    NOT?: old_case_decisionsScalarWhereWithAggregatesInput | old_case_decisionsScalarWhereWithAggregatesInput[]
    old_decision_id?: IntWithAggregatesFilter<"old_case_decisions"> | number
    old_case_id?: IntWithAggregatesFilter<"old_case_decisions"> | number
    ms_decision?: IntWithAggregatesFilter<"old_case_decisions"> | number
    ms_decision_date?: DateTimeNullableWithAggregatesFilter<"old_case_decisions"> | Date | string | null
    final_decision?: IntNullableWithAggregatesFilter<"old_case_decisions"> | number | null
    final_decision_date?: DateTimeNullableWithAggregatesFilter<"old_case_decisions"> | Date | string | null
  }

  export type old_case_personWhereInput = {
    AND?: old_case_personWhereInput | old_case_personWhereInput[]
    OR?: old_case_personWhereInput[]
    NOT?: old_case_personWhereInput | old_case_personWhereInput[]
    old_person_id?: IntFilter<"old_case_person"> | number
    old_case_id?: IntFilter<"old_case_person"> | number
    f_name_arm?: StringNullableFilter<"old_case_person"> | string | null
    l_name_arm?: StringNullableFilter<"old_case_person"> | string | null
    p_name_arm?: StringNullableFilter<"old_case_person"> | string | null
    f_name_eng?: StringNullableFilter<"old_case_person"> | string | null
    l_name_eng?: StringNullableFilter<"old_case_person"> | string | null
    p_name_eng?: StringNullableFilter<"old_case_person"> | string | null
    sex?: IntFilter<"old_case_person"> | number
    b_day?: StringNullableFilter<"old_case_person"> | string | null
    b_month?: StringNullableFilter<"old_case_person"> | string | null
    b_year?: StringNullableFilter<"old_case_person"> | string | null
    role?: IntFilter<"old_case_person"> | number
    citizenship_id?: IntNullableFilter<"old_case_person"> | number | null
    card_num?: StringNullableFilter<"old_case_person"> | string | null
    doc_num?: StringNullableFilter<"old_case_person"> | string | null
    etnicity?: IntNullableFilter<"old_case_person"> | number | null
    religion?: IntNullableFilter<"old_case_person"> | number | null
    invalid?: IntFilter<"old_case_person"> | number
    pregnant?: IntFilter<"old_case_person"> | number
    seriously_ill?: IntFilter<"old_case_person"> | number
    trafficking_victim?: IntFilter<"old_case_person"> | number
    violence_victim?: IntFilter<"old_case_person"> | number
    comment?: StringNullableFilter<"old_case_person"> | string | null
    illegal_border?: IntFilter<"old_case_person"> | number
    transfer_moj?: IntNullableFilter<"old_case_person"> | number | null
    deport_prescurator?: IntFilter<"old_case_person"> | number
    prison?: IntFilter<"old_case_person"> | number
    image?: StringNullableFilter<"old_case_person"> | string | null
    pnum?: StringNullableFilter<"old_case_person"> | string | null
    doc_type?: IntNullableFilter<"old_case_person"> | number | null
    document_num?: StringNullableFilter<"old_case_person"> | string | null
    status?: IntNullableFilter<"old_case_person"> | number | null
  }

  export type old_case_personOrderByWithRelationInput = {
    old_person_id?: SortOrder
    old_case_id?: SortOrder
    f_name_arm?: SortOrderInput | SortOrder
    l_name_arm?: SortOrderInput | SortOrder
    p_name_arm?: SortOrderInput | SortOrder
    f_name_eng?: SortOrderInput | SortOrder
    l_name_eng?: SortOrderInput | SortOrder
    p_name_eng?: SortOrderInput | SortOrder
    sex?: SortOrder
    b_day?: SortOrderInput | SortOrder
    b_month?: SortOrderInput | SortOrder
    b_year?: SortOrderInput | SortOrder
    role?: SortOrder
    citizenship_id?: SortOrderInput | SortOrder
    card_num?: SortOrderInput | SortOrder
    doc_num?: SortOrderInput | SortOrder
    etnicity?: SortOrderInput | SortOrder
    religion?: SortOrderInput | SortOrder
    invalid?: SortOrder
    pregnant?: SortOrder
    seriously_ill?: SortOrder
    trafficking_victim?: SortOrder
    violence_victim?: SortOrder
    comment?: SortOrderInput | SortOrder
    illegal_border?: SortOrder
    transfer_moj?: SortOrderInput | SortOrder
    deport_prescurator?: SortOrder
    prison?: SortOrder
    image?: SortOrderInput | SortOrder
    pnum?: SortOrderInput | SortOrder
    doc_type?: SortOrderInput | SortOrder
    document_num?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    _relevance?: old_case_personOrderByRelevanceInput
  }

  export type old_case_personWhereUniqueInput = Prisma.AtLeast<{
    old_person_id?: number
    AND?: old_case_personWhereInput | old_case_personWhereInput[]
    OR?: old_case_personWhereInput[]
    NOT?: old_case_personWhereInput | old_case_personWhereInput[]
    old_case_id?: IntFilter<"old_case_person"> | number
    f_name_arm?: StringNullableFilter<"old_case_person"> | string | null
    l_name_arm?: StringNullableFilter<"old_case_person"> | string | null
    p_name_arm?: StringNullableFilter<"old_case_person"> | string | null
    f_name_eng?: StringNullableFilter<"old_case_person"> | string | null
    l_name_eng?: StringNullableFilter<"old_case_person"> | string | null
    p_name_eng?: StringNullableFilter<"old_case_person"> | string | null
    sex?: IntFilter<"old_case_person"> | number
    b_day?: StringNullableFilter<"old_case_person"> | string | null
    b_month?: StringNullableFilter<"old_case_person"> | string | null
    b_year?: StringNullableFilter<"old_case_person"> | string | null
    role?: IntFilter<"old_case_person"> | number
    citizenship_id?: IntNullableFilter<"old_case_person"> | number | null
    card_num?: StringNullableFilter<"old_case_person"> | string | null
    doc_num?: StringNullableFilter<"old_case_person"> | string | null
    etnicity?: IntNullableFilter<"old_case_person"> | number | null
    religion?: IntNullableFilter<"old_case_person"> | number | null
    invalid?: IntFilter<"old_case_person"> | number
    pregnant?: IntFilter<"old_case_person"> | number
    seriously_ill?: IntFilter<"old_case_person"> | number
    trafficking_victim?: IntFilter<"old_case_person"> | number
    violence_victim?: IntFilter<"old_case_person"> | number
    comment?: StringNullableFilter<"old_case_person"> | string | null
    illegal_border?: IntFilter<"old_case_person"> | number
    transfer_moj?: IntNullableFilter<"old_case_person"> | number | null
    deport_prescurator?: IntFilter<"old_case_person"> | number
    prison?: IntFilter<"old_case_person"> | number
    image?: StringNullableFilter<"old_case_person"> | string | null
    pnum?: StringNullableFilter<"old_case_person"> | string | null
    doc_type?: IntNullableFilter<"old_case_person"> | number | null
    document_num?: StringNullableFilter<"old_case_person"> | string | null
    status?: IntNullableFilter<"old_case_person"> | number | null
  }, "old_person_id">

  export type old_case_personOrderByWithAggregationInput = {
    old_person_id?: SortOrder
    old_case_id?: SortOrder
    f_name_arm?: SortOrderInput | SortOrder
    l_name_arm?: SortOrderInput | SortOrder
    p_name_arm?: SortOrderInput | SortOrder
    f_name_eng?: SortOrderInput | SortOrder
    l_name_eng?: SortOrderInput | SortOrder
    p_name_eng?: SortOrderInput | SortOrder
    sex?: SortOrder
    b_day?: SortOrderInput | SortOrder
    b_month?: SortOrderInput | SortOrder
    b_year?: SortOrderInput | SortOrder
    role?: SortOrder
    citizenship_id?: SortOrderInput | SortOrder
    card_num?: SortOrderInput | SortOrder
    doc_num?: SortOrderInput | SortOrder
    etnicity?: SortOrderInput | SortOrder
    religion?: SortOrderInput | SortOrder
    invalid?: SortOrder
    pregnant?: SortOrder
    seriously_ill?: SortOrder
    trafficking_victim?: SortOrder
    violence_victim?: SortOrder
    comment?: SortOrderInput | SortOrder
    illegal_border?: SortOrder
    transfer_moj?: SortOrderInput | SortOrder
    deport_prescurator?: SortOrder
    prison?: SortOrder
    image?: SortOrderInput | SortOrder
    pnum?: SortOrderInput | SortOrder
    doc_type?: SortOrderInput | SortOrder
    document_num?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    _count?: old_case_personCountOrderByAggregateInput
    _avg?: old_case_personAvgOrderByAggregateInput
    _max?: old_case_personMaxOrderByAggregateInput
    _min?: old_case_personMinOrderByAggregateInput
    _sum?: old_case_personSumOrderByAggregateInput
  }

  export type old_case_personScalarWhereWithAggregatesInput = {
    AND?: old_case_personScalarWhereWithAggregatesInput | old_case_personScalarWhereWithAggregatesInput[]
    OR?: old_case_personScalarWhereWithAggregatesInput[]
    NOT?: old_case_personScalarWhereWithAggregatesInput | old_case_personScalarWhereWithAggregatesInput[]
    old_person_id?: IntWithAggregatesFilter<"old_case_person"> | number
    old_case_id?: IntWithAggregatesFilter<"old_case_person"> | number
    f_name_arm?: StringNullableWithAggregatesFilter<"old_case_person"> | string | null
    l_name_arm?: StringNullableWithAggregatesFilter<"old_case_person"> | string | null
    p_name_arm?: StringNullableWithAggregatesFilter<"old_case_person"> | string | null
    f_name_eng?: StringNullableWithAggregatesFilter<"old_case_person"> | string | null
    l_name_eng?: StringNullableWithAggregatesFilter<"old_case_person"> | string | null
    p_name_eng?: StringNullableWithAggregatesFilter<"old_case_person"> | string | null
    sex?: IntWithAggregatesFilter<"old_case_person"> | number
    b_day?: StringNullableWithAggregatesFilter<"old_case_person"> | string | null
    b_month?: StringNullableWithAggregatesFilter<"old_case_person"> | string | null
    b_year?: StringNullableWithAggregatesFilter<"old_case_person"> | string | null
    role?: IntWithAggregatesFilter<"old_case_person"> | number
    citizenship_id?: IntNullableWithAggregatesFilter<"old_case_person"> | number | null
    card_num?: StringNullableWithAggregatesFilter<"old_case_person"> | string | null
    doc_num?: StringNullableWithAggregatesFilter<"old_case_person"> | string | null
    etnicity?: IntNullableWithAggregatesFilter<"old_case_person"> | number | null
    religion?: IntNullableWithAggregatesFilter<"old_case_person"> | number | null
    invalid?: IntWithAggregatesFilter<"old_case_person"> | number
    pregnant?: IntWithAggregatesFilter<"old_case_person"> | number
    seriously_ill?: IntWithAggregatesFilter<"old_case_person"> | number
    trafficking_victim?: IntWithAggregatesFilter<"old_case_person"> | number
    violence_victim?: IntWithAggregatesFilter<"old_case_person"> | number
    comment?: StringNullableWithAggregatesFilter<"old_case_person"> | string | null
    illegal_border?: IntWithAggregatesFilter<"old_case_person"> | number
    transfer_moj?: IntNullableWithAggregatesFilter<"old_case_person"> | number | null
    deport_prescurator?: IntWithAggregatesFilter<"old_case_person"> | number
    prison?: IntWithAggregatesFilter<"old_case_person"> | number
    image?: StringNullableWithAggregatesFilter<"old_case_person"> | string | null
    pnum?: StringNullableWithAggregatesFilter<"old_case_person"> | string | null
    doc_type?: IntNullableWithAggregatesFilter<"old_case_person"> | number | null
    document_num?: StringNullableWithAggregatesFilter<"old_case_person"> | string | null
    status?: IntNullableWithAggregatesFilter<"old_case_person"> | number | null
  }

  export type old_casesWhereInput = {
    AND?: old_casesWhereInput | old_casesWhereInput[]
    OR?: old_casesWhereInput[]
    NOT?: old_casesWhereInput | old_casesWhereInput[]
    old_case_id?: IntFilter<"old_cases"> | number
    application_date?: DateTimeFilter<"old_cases"> | Date | string
    citizenship?: IntFilter<"old_cases"> | number
    RA_address?: StringNullableFilter<"old_cases"> | string | null
    building?: StringNullableFilter<"old_cases"> | string | null
    apartment?: StringNullableFilter<"old_cases"> | string | null
    marz_id?: IntNullableFilter<"old_cases"> | number | null
    community_id?: IntNullableFilter<"old_cases"> | number | null
    bnak_id?: IntNullableFilter<"old_cases"> | number | null
    unaccompanied_child?: IntFilter<"old_cases"> | number
    separated_child?: IntFilter<"old_cases"> | number
    single_parent?: IntFilter<"old_cases"> | number
    prefered_language?: StringNullableFilter<"old_cases"> | string | null
    contact_tel?: StringNullableFilter<"old_cases"> | string | null
    comment?: StringNullableFilter<"old_cases"> | string | null
  }

  export type old_casesOrderByWithRelationInput = {
    old_case_id?: SortOrder
    application_date?: SortOrder
    citizenship?: SortOrder
    RA_address?: SortOrderInput | SortOrder
    building?: SortOrderInput | SortOrder
    apartment?: SortOrderInput | SortOrder
    marz_id?: SortOrderInput | SortOrder
    community_id?: SortOrderInput | SortOrder
    bnak_id?: SortOrderInput | SortOrder
    unaccompanied_child?: SortOrder
    separated_child?: SortOrder
    single_parent?: SortOrder
    prefered_language?: SortOrderInput | SortOrder
    contact_tel?: SortOrderInput | SortOrder
    comment?: SortOrderInput | SortOrder
    _relevance?: old_casesOrderByRelevanceInput
  }

  export type old_casesWhereUniqueInput = Prisma.AtLeast<{
    old_case_id?: number
    AND?: old_casesWhereInput | old_casesWhereInput[]
    OR?: old_casesWhereInput[]
    NOT?: old_casesWhereInput | old_casesWhereInput[]
    application_date?: DateTimeFilter<"old_cases"> | Date | string
    citizenship?: IntFilter<"old_cases"> | number
    RA_address?: StringNullableFilter<"old_cases"> | string | null
    building?: StringNullableFilter<"old_cases"> | string | null
    apartment?: StringNullableFilter<"old_cases"> | string | null
    marz_id?: IntNullableFilter<"old_cases"> | number | null
    community_id?: IntNullableFilter<"old_cases"> | number | null
    bnak_id?: IntNullableFilter<"old_cases"> | number | null
    unaccompanied_child?: IntFilter<"old_cases"> | number
    separated_child?: IntFilter<"old_cases"> | number
    single_parent?: IntFilter<"old_cases"> | number
    prefered_language?: StringNullableFilter<"old_cases"> | string | null
    contact_tel?: StringNullableFilter<"old_cases"> | string | null
    comment?: StringNullableFilter<"old_cases"> | string | null
  }, "old_case_id">

  export type old_casesOrderByWithAggregationInput = {
    old_case_id?: SortOrder
    application_date?: SortOrder
    citizenship?: SortOrder
    RA_address?: SortOrderInput | SortOrder
    building?: SortOrderInput | SortOrder
    apartment?: SortOrderInput | SortOrder
    marz_id?: SortOrderInput | SortOrder
    community_id?: SortOrderInput | SortOrder
    bnak_id?: SortOrderInput | SortOrder
    unaccompanied_child?: SortOrder
    separated_child?: SortOrder
    single_parent?: SortOrder
    prefered_language?: SortOrderInput | SortOrder
    contact_tel?: SortOrderInput | SortOrder
    comment?: SortOrderInput | SortOrder
    _count?: old_casesCountOrderByAggregateInput
    _avg?: old_casesAvgOrderByAggregateInput
    _max?: old_casesMaxOrderByAggregateInput
    _min?: old_casesMinOrderByAggregateInput
    _sum?: old_casesSumOrderByAggregateInput
  }

  export type old_casesScalarWhereWithAggregatesInput = {
    AND?: old_casesScalarWhereWithAggregatesInput | old_casesScalarWhereWithAggregatesInput[]
    OR?: old_casesScalarWhereWithAggregatesInput[]
    NOT?: old_casesScalarWhereWithAggregatesInput | old_casesScalarWhereWithAggregatesInput[]
    old_case_id?: IntWithAggregatesFilter<"old_cases"> | number
    application_date?: DateTimeWithAggregatesFilter<"old_cases"> | Date | string
    citizenship?: IntWithAggregatesFilter<"old_cases"> | number
    RA_address?: StringNullableWithAggregatesFilter<"old_cases"> | string | null
    building?: StringNullableWithAggregatesFilter<"old_cases"> | string | null
    apartment?: StringNullableWithAggregatesFilter<"old_cases"> | string | null
    marz_id?: IntNullableWithAggregatesFilter<"old_cases"> | number | null
    community_id?: IntNullableWithAggregatesFilter<"old_cases"> | number | null
    bnak_id?: IntNullableWithAggregatesFilter<"old_cases"> | number | null
    unaccompanied_child?: IntWithAggregatesFilter<"old_cases"> | number
    separated_child?: IntWithAggregatesFilter<"old_cases"> | number
    single_parent?: IntWithAggregatesFilter<"old_cases"> | number
    prefered_language?: StringNullableWithAggregatesFilter<"old_cases"> | string | null
    contact_tel?: StringNullableWithAggregatesFilter<"old_cases"> | string | null
    comment?: StringNullableWithAggregatesFilter<"old_cases"> | string | null
  }

  export type tb_arm_comWhereInput = {
    AND?: tb_arm_comWhereInput | tb_arm_comWhereInput[]
    OR?: tb_arm_comWhereInput[]
    NOT?: tb_arm_comWhereInput | tb_arm_comWhereInput[]
    community_id?: IntFilter<"tb_arm_com"> | number
    marz_id?: IntFilter<"tb_arm_com"> | number
    ADM3_PCODE?: StringFilter<"tb_arm_com"> | string
    ADM3_ARM?: StringFilter<"tb_arm_com"> | string
    ADM3_EN?: StringFilter<"tb_arm_com"> | string
    exist?: IntFilter<"tb_arm_com"> | number
    active?: IntFilter<"tb_arm_com"> | number
  }

  export type tb_arm_comOrderByWithRelationInput = {
    community_id?: SortOrder
    marz_id?: SortOrder
    ADM3_PCODE?: SortOrder
    ADM3_ARM?: SortOrder
    ADM3_EN?: SortOrder
    exist?: SortOrder
    active?: SortOrder
    _relevance?: tb_arm_comOrderByRelevanceInput
  }

  export type tb_arm_comWhereUniqueInput = Prisma.AtLeast<{
    community_id?: number
    AND?: tb_arm_comWhereInput | tb_arm_comWhereInput[]
    OR?: tb_arm_comWhereInput[]
    NOT?: tb_arm_comWhereInput | tb_arm_comWhereInput[]
    marz_id?: IntFilter<"tb_arm_com"> | number
    ADM3_PCODE?: StringFilter<"tb_arm_com"> | string
    ADM3_ARM?: StringFilter<"tb_arm_com"> | string
    ADM3_EN?: StringFilter<"tb_arm_com"> | string
    exist?: IntFilter<"tb_arm_com"> | number
    active?: IntFilter<"tb_arm_com"> | number
  }, "community_id">

  export type tb_arm_comOrderByWithAggregationInput = {
    community_id?: SortOrder
    marz_id?: SortOrder
    ADM3_PCODE?: SortOrder
    ADM3_ARM?: SortOrder
    ADM3_EN?: SortOrder
    exist?: SortOrder
    active?: SortOrder
    _count?: tb_arm_comCountOrderByAggregateInput
    _avg?: tb_arm_comAvgOrderByAggregateInput
    _max?: tb_arm_comMaxOrderByAggregateInput
    _min?: tb_arm_comMinOrderByAggregateInput
    _sum?: tb_arm_comSumOrderByAggregateInput
  }

  export type tb_arm_comScalarWhereWithAggregatesInput = {
    AND?: tb_arm_comScalarWhereWithAggregatesInput | tb_arm_comScalarWhereWithAggregatesInput[]
    OR?: tb_arm_comScalarWhereWithAggregatesInput[]
    NOT?: tb_arm_comScalarWhereWithAggregatesInput | tb_arm_comScalarWhereWithAggregatesInput[]
    community_id?: IntWithAggregatesFilter<"tb_arm_com"> | number
    marz_id?: IntWithAggregatesFilter<"tb_arm_com"> | number
    ADM3_PCODE?: StringWithAggregatesFilter<"tb_arm_com"> | string
    ADM3_ARM?: StringWithAggregatesFilter<"tb_arm_com"> | string
    ADM3_EN?: StringWithAggregatesFilter<"tb_arm_com"> | string
    exist?: IntWithAggregatesFilter<"tb_arm_com"> | number
    active?: IntWithAggregatesFilter<"tb_arm_com"> | number
  }

  export type tb_arm_com__WhereInput = {
    AND?: tb_arm_com__WhereInput | tb_arm_com__WhereInput[]
    OR?: tb_arm_com__WhereInput[]
    NOT?: tb_arm_com__WhereInput | tb_arm_com__WhereInput[]
    community_id?: IntFilter<"tb_arm_com__"> | number
    marz_id?: IntFilter<"tb_arm_com__"> | number
    ADM3_PCODE?: StringFilter<"tb_arm_com__"> | string
    ADM3_ARM?: StringFilter<"tb_arm_com__"> | string
    ADM3_EN?: StringFilter<"tb_arm_com__"> | string
  }

  export type tb_arm_com__OrderByWithRelationInput = {
    community_id?: SortOrder
    marz_id?: SortOrder
    ADM3_PCODE?: SortOrder
    ADM3_ARM?: SortOrder
    ADM3_EN?: SortOrder
    _relevance?: tb_arm_com__OrderByRelevanceInput
  }

  export type tb_arm_com__WhereUniqueInput = Prisma.AtLeast<{
    community_id?: number
    AND?: tb_arm_com__WhereInput | tb_arm_com__WhereInput[]
    OR?: tb_arm_com__WhereInput[]
    NOT?: tb_arm_com__WhereInput | tb_arm_com__WhereInput[]
    marz_id?: IntFilter<"tb_arm_com__"> | number
    ADM3_PCODE?: StringFilter<"tb_arm_com__"> | string
    ADM3_ARM?: StringFilter<"tb_arm_com__"> | string
    ADM3_EN?: StringFilter<"tb_arm_com__"> | string
  }, "community_id">

  export type tb_arm_com__OrderByWithAggregationInput = {
    community_id?: SortOrder
    marz_id?: SortOrder
    ADM3_PCODE?: SortOrder
    ADM3_ARM?: SortOrder
    ADM3_EN?: SortOrder
    _count?: tb_arm_com__CountOrderByAggregateInput
    _avg?: tb_arm_com__AvgOrderByAggregateInput
    _max?: tb_arm_com__MaxOrderByAggregateInput
    _min?: tb_arm_com__MinOrderByAggregateInput
    _sum?: tb_arm_com__SumOrderByAggregateInput
  }

  export type tb_arm_com__ScalarWhereWithAggregatesInput = {
    AND?: tb_arm_com__ScalarWhereWithAggregatesInput | tb_arm_com__ScalarWhereWithAggregatesInput[]
    OR?: tb_arm_com__ScalarWhereWithAggregatesInput[]
    NOT?: tb_arm_com__ScalarWhereWithAggregatesInput | tb_arm_com__ScalarWhereWithAggregatesInput[]
    community_id?: IntWithAggregatesFilter<"tb_arm_com__"> | number
    marz_id?: IntWithAggregatesFilter<"tb_arm_com__"> | number
    ADM3_PCODE?: StringWithAggregatesFilter<"tb_arm_com__"> | string
    ADM3_ARM?: StringWithAggregatesFilter<"tb_arm_com__"> | string
    ADM3_EN?: StringWithAggregatesFilter<"tb_arm_com__"> | string
  }

  export type tb_calendarWhereInput = {
    AND?: tb_calendarWhereInput | tb_calendarWhereInput[]
    OR?: tb_calendarWhereInput[]
    NOT?: tb_calendarWhereInput | tb_calendarWhereInput[]
    interview_id?: IntFilter<"tb_calendar"> | number
    case_id?: IntFilter<"tb_calendar"> | number
    user_id?: IntFilter<"tb_calendar"> | number
    inter_comment?: StringFilter<"tb_calendar"> | string
    inter_date_from?: DateTimeNullableFilter<"tb_calendar"> | Date | string | null
    inter_date_to?: DateTimeNullableFilter<"tb_calendar"> | Date | string | null
    text_color?: StringFilter<"tb_calendar"> | string
    border_color?: StringFilter<"tb_calendar"> | string
    actual_event?: IntFilter<"tb_calendar"> | number
  }

  export type tb_calendarOrderByWithRelationInput = {
    interview_id?: SortOrder
    case_id?: SortOrder
    user_id?: SortOrder
    inter_comment?: SortOrder
    inter_date_from?: SortOrderInput | SortOrder
    inter_date_to?: SortOrderInput | SortOrder
    text_color?: SortOrder
    border_color?: SortOrder
    actual_event?: SortOrder
    _relevance?: tb_calendarOrderByRelevanceInput
  }

  export type tb_calendarWhereUniqueInput = Prisma.AtLeast<{
    interview_id?: number
    AND?: tb_calendarWhereInput | tb_calendarWhereInput[]
    OR?: tb_calendarWhereInput[]
    NOT?: tb_calendarWhereInput | tb_calendarWhereInput[]
    case_id?: IntFilter<"tb_calendar"> | number
    user_id?: IntFilter<"tb_calendar"> | number
    inter_comment?: StringFilter<"tb_calendar"> | string
    inter_date_from?: DateTimeNullableFilter<"tb_calendar"> | Date | string | null
    inter_date_to?: DateTimeNullableFilter<"tb_calendar"> | Date | string | null
    text_color?: StringFilter<"tb_calendar"> | string
    border_color?: StringFilter<"tb_calendar"> | string
    actual_event?: IntFilter<"tb_calendar"> | number
  }, "interview_id">

  export type tb_calendarOrderByWithAggregationInput = {
    interview_id?: SortOrder
    case_id?: SortOrder
    user_id?: SortOrder
    inter_comment?: SortOrder
    inter_date_from?: SortOrderInput | SortOrder
    inter_date_to?: SortOrderInput | SortOrder
    text_color?: SortOrder
    border_color?: SortOrder
    actual_event?: SortOrder
    _count?: tb_calendarCountOrderByAggregateInput
    _avg?: tb_calendarAvgOrderByAggregateInput
    _max?: tb_calendarMaxOrderByAggregateInput
    _min?: tb_calendarMinOrderByAggregateInput
    _sum?: tb_calendarSumOrderByAggregateInput
  }

  export type tb_calendarScalarWhereWithAggregatesInput = {
    AND?: tb_calendarScalarWhereWithAggregatesInput | tb_calendarScalarWhereWithAggregatesInput[]
    OR?: tb_calendarScalarWhereWithAggregatesInput[]
    NOT?: tb_calendarScalarWhereWithAggregatesInput | tb_calendarScalarWhereWithAggregatesInput[]
    interview_id?: IntWithAggregatesFilter<"tb_calendar"> | number
    case_id?: IntWithAggregatesFilter<"tb_calendar"> | number
    user_id?: IntWithAggregatesFilter<"tb_calendar"> | number
    inter_comment?: StringWithAggregatesFilter<"tb_calendar"> | string
    inter_date_from?: DateTimeNullableWithAggregatesFilter<"tb_calendar"> | Date | string | null
    inter_date_to?: DateTimeNullableWithAggregatesFilter<"tb_calendar"> | Date | string | null
    text_color?: StringWithAggregatesFilter<"tb_calendar"> | string
    border_color?: StringWithAggregatesFilter<"tb_calendar"> | string
    actual_event?: IntWithAggregatesFilter<"tb_calendar"> | number
  }

  export type tb_cancelWhereInput = {
    AND?: tb_cancelWhereInput | tb_cancelWhereInput[]
    OR?: tb_cancelWhereInput[]
    NOT?: tb_cancelWhereInput | tb_cancelWhereInput[]
    id?: IntFilter<"tb_cancel"> | number
    personal_id?: IntFilter<"tb_cancel"> | number
    case_id?: IntFilter<"tb_cancel"> | number
    decision_date?: DateTimeFilter<"tb_cancel"> | Date | string
    uploader?: IntFilter<"tb_cancel"> | number
    uploaded?: DateTimeFilter<"tb_cancel"> | Date | string
    file_id?: IntFilter<"tb_cancel"> | number
  }

  export type tb_cancelOrderByWithRelationInput = {
    id?: SortOrder
    personal_id?: SortOrder
    case_id?: SortOrder
    decision_date?: SortOrder
    uploader?: SortOrder
    uploaded?: SortOrder
    file_id?: SortOrder
  }

  export type tb_cancelWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: tb_cancelWhereInput | tb_cancelWhereInput[]
    OR?: tb_cancelWhereInput[]
    NOT?: tb_cancelWhereInput | tb_cancelWhereInput[]
    personal_id?: IntFilter<"tb_cancel"> | number
    case_id?: IntFilter<"tb_cancel"> | number
    decision_date?: DateTimeFilter<"tb_cancel"> | Date | string
    uploader?: IntFilter<"tb_cancel"> | number
    uploaded?: DateTimeFilter<"tb_cancel"> | Date | string
    file_id?: IntFilter<"tb_cancel"> | number
  }, "id">

  export type tb_cancelOrderByWithAggregationInput = {
    id?: SortOrder
    personal_id?: SortOrder
    case_id?: SortOrder
    decision_date?: SortOrder
    uploader?: SortOrder
    uploaded?: SortOrder
    file_id?: SortOrder
    _count?: tb_cancelCountOrderByAggregateInput
    _avg?: tb_cancelAvgOrderByAggregateInput
    _max?: tb_cancelMaxOrderByAggregateInput
    _min?: tb_cancelMinOrderByAggregateInput
    _sum?: tb_cancelSumOrderByAggregateInput
  }

  export type tb_cancelScalarWhereWithAggregatesInput = {
    AND?: tb_cancelScalarWhereWithAggregatesInput | tb_cancelScalarWhereWithAggregatesInput[]
    OR?: tb_cancelScalarWhereWithAggregatesInput[]
    NOT?: tb_cancelScalarWhereWithAggregatesInput | tb_cancelScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"tb_cancel"> | number
    personal_id?: IntWithAggregatesFilter<"tb_cancel"> | number
    case_id?: IntWithAggregatesFilter<"tb_cancel"> | number
    decision_date?: DateTimeWithAggregatesFilter<"tb_cancel"> | Date | string
    uploader?: IntWithAggregatesFilter<"tb_cancel"> | number
    uploaded?: DateTimeWithAggregatesFilter<"tb_cancel"> | Date | string
    file_id?: IntWithAggregatesFilter<"tb_cancel"> | number
  }

  export type tb_cardsWhereInput = {
    AND?: tb_cardsWhereInput | tb_cardsWhereInput[]
    OR?: tb_cardsWhereInput[]
    NOT?: tb_cardsWhereInput | tb_cardsWhereInput[]
    card_id?: IntFilter<"tb_cards"> | number
    serial?: StringFilter<"tb_cards"> | string
    card_number?: IntFilter<"tb_cards"> | number
    personal_id?: IntFilter<"tb_cards"> | number
    issued?: DateTimeFilter<"tb_cards"> | Date | string
    full_address?: StringNullableFilter<"tb_cards"> | string | null
    valid?: DateTimeFilter<"tb_cards"> | Date | string
    bar?: StringFilter<"tb_cards"> | string
    printed?: DateTimeFilter<"tb_cards"> | Date | string
    actual_card?: IntFilter<"tb_cards"> | number
  }

  export type tb_cardsOrderByWithRelationInput = {
    card_id?: SortOrder
    serial?: SortOrder
    card_number?: SortOrder
    personal_id?: SortOrder
    issued?: SortOrder
    full_address?: SortOrderInput | SortOrder
    valid?: SortOrder
    bar?: SortOrder
    printed?: SortOrder
    actual_card?: SortOrder
    _relevance?: tb_cardsOrderByRelevanceInput
  }

  export type tb_cardsWhereUniqueInput = Prisma.AtLeast<{
    card_id?: number
    AND?: tb_cardsWhereInput | tb_cardsWhereInput[]
    OR?: tb_cardsWhereInput[]
    NOT?: tb_cardsWhereInput | tb_cardsWhereInput[]
    serial?: StringFilter<"tb_cards"> | string
    card_number?: IntFilter<"tb_cards"> | number
    personal_id?: IntFilter<"tb_cards"> | number
    issued?: DateTimeFilter<"tb_cards"> | Date | string
    full_address?: StringNullableFilter<"tb_cards"> | string | null
    valid?: DateTimeFilter<"tb_cards"> | Date | string
    bar?: StringFilter<"tb_cards"> | string
    printed?: DateTimeFilter<"tb_cards"> | Date | string
    actual_card?: IntFilter<"tb_cards"> | number
  }, "card_id">

  export type tb_cardsOrderByWithAggregationInput = {
    card_id?: SortOrder
    serial?: SortOrder
    card_number?: SortOrder
    personal_id?: SortOrder
    issued?: SortOrder
    full_address?: SortOrderInput | SortOrder
    valid?: SortOrder
    bar?: SortOrder
    printed?: SortOrder
    actual_card?: SortOrder
    _count?: tb_cardsCountOrderByAggregateInput
    _avg?: tb_cardsAvgOrderByAggregateInput
    _max?: tb_cardsMaxOrderByAggregateInput
    _min?: tb_cardsMinOrderByAggregateInput
    _sum?: tb_cardsSumOrderByAggregateInput
  }

  export type tb_cardsScalarWhereWithAggregatesInput = {
    AND?: tb_cardsScalarWhereWithAggregatesInput | tb_cardsScalarWhereWithAggregatesInput[]
    OR?: tb_cardsScalarWhereWithAggregatesInput[]
    NOT?: tb_cardsScalarWhereWithAggregatesInput | tb_cardsScalarWhereWithAggregatesInput[]
    card_id?: IntWithAggregatesFilter<"tb_cards"> | number
    serial?: StringWithAggregatesFilter<"tb_cards"> | string
    card_number?: IntWithAggregatesFilter<"tb_cards"> | number
    personal_id?: IntWithAggregatesFilter<"tb_cards"> | number
    issued?: DateTimeWithAggregatesFilter<"tb_cards"> | Date | string
    full_address?: StringNullableWithAggregatesFilter<"tb_cards"> | string | null
    valid?: DateTimeWithAggregatesFilter<"tb_cards"> | Date | string
    bar?: StringWithAggregatesFilter<"tb_cards"> | string
    printed?: DateTimeWithAggregatesFilter<"tb_cards"> | Date | string
    actual_card?: IntWithAggregatesFilter<"tb_cards"> | number
  }

  export type tb_caseWhereInput = {
    AND?: tb_caseWhereInput | tb_caseWhereInput[]
    OR?: tb_caseWhereInput[]
    NOT?: tb_caseWhereInput | tb_caseWhereInput[]
    case_id?: IntFilter<"tb_case"> | number
    application_date?: DateTimeFilter<"tb_case"> | Date | string
    input_date?: DateTimeFilter<"tb_case"> | Date | string
    reg_by?: IntFilter<"tb_case"> | number
    officer?: IntNullableFilter<"tb_case"> | number | null
    preferred_lawyer?: IntFilter<"tb_case"> | number
    unaccompanied_child?: IntFilter<"tb_case"> | number
    separated_child?: IntFilter<"tb_case"> | number
    single_parent?: IntFilter<"tb_case"> | number
    prefered_language?: StringNullableFilter<"tb_case"> | string | null
    RA_marz?: IntNullableFilter<"tb_case"> | number | null
    RA_community?: IntNullableFilter<"tb_case"> | number | null
    RA_settlement?: IntNullableFilter<"tb_case"> | number | null
    RA_street?: StringNullableFilter<"tb_case"> | string | null
    RA_building?: StringNullableFilter<"tb_case"> | string | null
    RA_apartment?: StringNullableFilter<"tb_case"> | string | null
    contact_tel?: StringNullableFilter<"tb_case"> | string | null
    contact_email?: StringNullableFilter<"tb_case"> | string | null
    comment?: StringNullableFilter<"tb_case"> | string | null
    case_status?: IntNullableFilter<"tb_case"> | number | null
    mul_num?: StringNullableFilter<"tb_case"> | string | null
    mul_date?: DateTimeNullableFilter<"tb_case"> | Date | string | null
    MS_lawyer?: IntNullableFilter<"tb_case"> | number | null
    special?: IntFilter<"tb_case"> | number
    reopened?: IntFilter<"tb_case"> | number
    attached_case?: IntNullableFilter<"tb_case"> | number | null
  }

  export type tb_caseOrderByWithRelationInput = {
    case_id?: SortOrder
    application_date?: SortOrder
    input_date?: SortOrder
    reg_by?: SortOrder
    officer?: SortOrderInput | SortOrder
    preferred_lawyer?: SortOrder
    unaccompanied_child?: SortOrder
    separated_child?: SortOrder
    single_parent?: SortOrder
    prefered_language?: SortOrderInput | SortOrder
    RA_marz?: SortOrderInput | SortOrder
    RA_community?: SortOrderInput | SortOrder
    RA_settlement?: SortOrderInput | SortOrder
    RA_street?: SortOrderInput | SortOrder
    RA_building?: SortOrderInput | SortOrder
    RA_apartment?: SortOrderInput | SortOrder
    contact_tel?: SortOrderInput | SortOrder
    contact_email?: SortOrderInput | SortOrder
    comment?: SortOrderInput | SortOrder
    case_status?: SortOrderInput | SortOrder
    mul_num?: SortOrderInput | SortOrder
    mul_date?: SortOrderInput | SortOrder
    MS_lawyer?: SortOrderInput | SortOrder
    special?: SortOrder
    reopened?: SortOrder
    attached_case?: SortOrderInput | SortOrder
    _relevance?: tb_caseOrderByRelevanceInput
  }

  export type tb_caseWhereUniqueInput = Prisma.AtLeast<{
    case_id?: number
    AND?: tb_caseWhereInput | tb_caseWhereInput[]
    OR?: tb_caseWhereInput[]
    NOT?: tb_caseWhereInput | tb_caseWhereInput[]
    application_date?: DateTimeFilter<"tb_case"> | Date | string
    input_date?: DateTimeFilter<"tb_case"> | Date | string
    reg_by?: IntFilter<"tb_case"> | number
    officer?: IntNullableFilter<"tb_case"> | number | null
    preferred_lawyer?: IntFilter<"tb_case"> | number
    unaccompanied_child?: IntFilter<"tb_case"> | number
    separated_child?: IntFilter<"tb_case"> | number
    single_parent?: IntFilter<"tb_case"> | number
    prefered_language?: StringNullableFilter<"tb_case"> | string | null
    RA_marz?: IntNullableFilter<"tb_case"> | number | null
    RA_community?: IntNullableFilter<"tb_case"> | number | null
    RA_settlement?: IntNullableFilter<"tb_case"> | number | null
    RA_street?: StringNullableFilter<"tb_case"> | string | null
    RA_building?: StringNullableFilter<"tb_case"> | string | null
    RA_apartment?: StringNullableFilter<"tb_case"> | string | null
    contact_tel?: StringNullableFilter<"tb_case"> | string | null
    contact_email?: StringNullableFilter<"tb_case"> | string | null
    comment?: StringNullableFilter<"tb_case"> | string | null
    case_status?: IntNullableFilter<"tb_case"> | number | null
    mul_num?: StringNullableFilter<"tb_case"> | string | null
    mul_date?: DateTimeNullableFilter<"tb_case"> | Date | string | null
    MS_lawyer?: IntNullableFilter<"tb_case"> | number | null
    special?: IntFilter<"tb_case"> | number
    reopened?: IntFilter<"tb_case"> | number
    attached_case?: IntNullableFilter<"tb_case"> | number | null
  }, "case_id">

  export type tb_caseOrderByWithAggregationInput = {
    case_id?: SortOrder
    application_date?: SortOrder
    input_date?: SortOrder
    reg_by?: SortOrder
    officer?: SortOrderInput | SortOrder
    preferred_lawyer?: SortOrder
    unaccompanied_child?: SortOrder
    separated_child?: SortOrder
    single_parent?: SortOrder
    prefered_language?: SortOrderInput | SortOrder
    RA_marz?: SortOrderInput | SortOrder
    RA_community?: SortOrderInput | SortOrder
    RA_settlement?: SortOrderInput | SortOrder
    RA_street?: SortOrderInput | SortOrder
    RA_building?: SortOrderInput | SortOrder
    RA_apartment?: SortOrderInput | SortOrder
    contact_tel?: SortOrderInput | SortOrder
    contact_email?: SortOrderInput | SortOrder
    comment?: SortOrderInput | SortOrder
    case_status?: SortOrderInput | SortOrder
    mul_num?: SortOrderInput | SortOrder
    mul_date?: SortOrderInput | SortOrder
    MS_lawyer?: SortOrderInput | SortOrder
    special?: SortOrder
    reopened?: SortOrder
    attached_case?: SortOrderInput | SortOrder
    _count?: tb_caseCountOrderByAggregateInput
    _avg?: tb_caseAvgOrderByAggregateInput
    _max?: tb_caseMaxOrderByAggregateInput
    _min?: tb_caseMinOrderByAggregateInput
    _sum?: tb_caseSumOrderByAggregateInput
  }

  export type tb_caseScalarWhereWithAggregatesInput = {
    AND?: tb_caseScalarWhereWithAggregatesInput | tb_caseScalarWhereWithAggregatesInput[]
    OR?: tb_caseScalarWhereWithAggregatesInput[]
    NOT?: tb_caseScalarWhereWithAggregatesInput | tb_caseScalarWhereWithAggregatesInput[]
    case_id?: IntWithAggregatesFilter<"tb_case"> | number
    application_date?: DateTimeWithAggregatesFilter<"tb_case"> | Date | string
    input_date?: DateTimeWithAggregatesFilter<"tb_case"> | Date | string
    reg_by?: IntWithAggregatesFilter<"tb_case"> | number
    officer?: IntNullableWithAggregatesFilter<"tb_case"> | number | null
    preferred_lawyer?: IntWithAggregatesFilter<"tb_case"> | number
    unaccompanied_child?: IntWithAggregatesFilter<"tb_case"> | number
    separated_child?: IntWithAggregatesFilter<"tb_case"> | number
    single_parent?: IntWithAggregatesFilter<"tb_case"> | number
    prefered_language?: StringNullableWithAggregatesFilter<"tb_case"> | string | null
    RA_marz?: IntNullableWithAggregatesFilter<"tb_case"> | number | null
    RA_community?: IntNullableWithAggregatesFilter<"tb_case"> | number | null
    RA_settlement?: IntNullableWithAggregatesFilter<"tb_case"> | number | null
    RA_street?: StringNullableWithAggregatesFilter<"tb_case"> | string | null
    RA_building?: StringNullableWithAggregatesFilter<"tb_case"> | string | null
    RA_apartment?: StringNullableWithAggregatesFilter<"tb_case"> | string | null
    contact_tel?: StringNullableWithAggregatesFilter<"tb_case"> | string | null
    contact_email?: StringNullableWithAggregatesFilter<"tb_case"> | string | null
    comment?: StringNullableWithAggregatesFilter<"tb_case"> | string | null
    case_status?: IntNullableWithAggregatesFilter<"tb_case"> | number | null
    mul_num?: StringNullableWithAggregatesFilter<"tb_case"> | string | null
    mul_date?: DateTimeNullableWithAggregatesFilter<"tb_case"> | Date | string | null
    MS_lawyer?: IntNullableWithAggregatesFilter<"tb_case"> | number | null
    special?: IntWithAggregatesFilter<"tb_case"> | number
    reopened?: IntWithAggregatesFilter<"tb_case"> | number
    attached_case?: IntNullableWithAggregatesFilter<"tb_case"> | number | null
  }

  export type tb_case_statusWhereInput = {
    AND?: tb_case_statusWhereInput | tb_case_statusWhereInput[]
    OR?: tb_case_statusWhereInput[]
    NOT?: tb_case_statusWhereInput | tb_case_statusWhereInput[]
    case_status_id?: IntFilter<"tb_case_status"> | number
    case_status?: StringFilter<"tb_case_status"> | string
    case_status_eng?: StringNullableFilter<"tb_case_status"> | string | null
  }

  export type tb_case_statusOrderByWithRelationInput = {
    case_status_id?: SortOrder
    case_status?: SortOrder
    case_status_eng?: SortOrderInput | SortOrder
    _relevance?: tb_case_statusOrderByRelevanceInput
  }

  export type tb_case_statusWhereUniqueInput = Prisma.AtLeast<{
    case_status_id?: number
    AND?: tb_case_statusWhereInput | tb_case_statusWhereInput[]
    OR?: tb_case_statusWhereInput[]
    NOT?: tb_case_statusWhereInput | tb_case_statusWhereInput[]
    case_status?: StringFilter<"tb_case_status"> | string
    case_status_eng?: StringNullableFilter<"tb_case_status"> | string | null
  }, "case_status_id">

  export type tb_case_statusOrderByWithAggregationInput = {
    case_status_id?: SortOrder
    case_status?: SortOrder
    case_status_eng?: SortOrderInput | SortOrder
    _count?: tb_case_statusCountOrderByAggregateInput
    _avg?: tb_case_statusAvgOrderByAggregateInput
    _max?: tb_case_statusMaxOrderByAggregateInput
    _min?: tb_case_statusMinOrderByAggregateInput
    _sum?: tb_case_statusSumOrderByAggregateInput
  }

  export type tb_case_statusScalarWhereWithAggregatesInput = {
    AND?: tb_case_statusScalarWhereWithAggregatesInput | tb_case_statusScalarWhereWithAggregatesInput[]
    OR?: tb_case_statusScalarWhereWithAggregatesInput[]
    NOT?: tb_case_statusScalarWhereWithAggregatesInput | tb_case_statusScalarWhereWithAggregatesInput[]
    case_status_id?: IntWithAggregatesFilter<"tb_case_status"> | number
    case_status?: StringWithAggregatesFilter<"tb_case_status"> | string
    case_status_eng?: StringNullableWithAggregatesFilter<"tb_case_status"> | string | null
  }

  export type tb_checkinWhereInput = {
    AND?: tb_checkinWhereInput | tb_checkinWhereInput[]
    OR?: tb_checkinWhereInput[]
    NOT?: tb_checkinWhereInput | tb_checkinWhereInput[]
    checkin_id?: IntFilter<"tb_checkin"> | number
    checkin_date?: DateTimeNullableFilter<"tb_checkin"> | Date | string | null
    checkout_date?: DateTimeNullableFilter<"tb_checkin"> | Date | string | null
    personal_id?: IntFilter<"tb_checkin"> | number
    order_id?: IntFilter<"tb_checkin"> | number
    status?: IntFilter<"tb_checkin"> | number
    doss_id?: IntFilter<"tb_checkin"> | number
  }

  export type tb_checkinOrderByWithRelationInput = {
    checkin_id?: SortOrder
    checkin_date?: SortOrderInput | SortOrder
    checkout_date?: SortOrderInput | SortOrder
    personal_id?: SortOrder
    order_id?: SortOrder
    status?: SortOrder
    doss_id?: SortOrder
  }

  export type tb_checkinWhereUniqueInput = Prisma.AtLeast<{
    checkin_id?: number
    AND?: tb_checkinWhereInput | tb_checkinWhereInput[]
    OR?: tb_checkinWhereInput[]
    NOT?: tb_checkinWhereInput | tb_checkinWhereInput[]
    checkin_date?: DateTimeNullableFilter<"tb_checkin"> | Date | string | null
    checkout_date?: DateTimeNullableFilter<"tb_checkin"> | Date | string | null
    personal_id?: IntFilter<"tb_checkin"> | number
    order_id?: IntFilter<"tb_checkin"> | number
    status?: IntFilter<"tb_checkin"> | number
    doss_id?: IntFilter<"tb_checkin"> | number
  }, "checkin_id">

  export type tb_checkinOrderByWithAggregationInput = {
    checkin_id?: SortOrder
    checkin_date?: SortOrderInput | SortOrder
    checkout_date?: SortOrderInput | SortOrder
    personal_id?: SortOrder
    order_id?: SortOrder
    status?: SortOrder
    doss_id?: SortOrder
    _count?: tb_checkinCountOrderByAggregateInput
    _avg?: tb_checkinAvgOrderByAggregateInput
    _max?: tb_checkinMaxOrderByAggregateInput
    _min?: tb_checkinMinOrderByAggregateInput
    _sum?: tb_checkinSumOrderByAggregateInput
  }

  export type tb_checkinScalarWhereWithAggregatesInput = {
    AND?: tb_checkinScalarWhereWithAggregatesInput | tb_checkinScalarWhereWithAggregatesInput[]
    OR?: tb_checkinScalarWhereWithAggregatesInput[]
    NOT?: tb_checkinScalarWhereWithAggregatesInput | tb_checkinScalarWhereWithAggregatesInput[]
    checkin_id?: IntWithAggregatesFilter<"tb_checkin"> | number
    checkin_date?: DateTimeNullableWithAggregatesFilter<"tb_checkin"> | Date | string | null
    checkout_date?: DateTimeNullableWithAggregatesFilter<"tb_checkin"> | Date | string | null
    personal_id?: IntWithAggregatesFilter<"tb_checkin"> | number
    order_id?: IntWithAggregatesFilter<"tb_checkin"> | number
    status?: IntWithAggregatesFilter<"tb_checkin"> | number
    doss_id?: IntWithAggregatesFilter<"tb_checkin"> | number
  }

  export type tb_coiWhereInput = {
    AND?: tb_coiWhereInput | tb_coiWhereInput[]
    OR?: tb_coiWhereInput[]
    NOT?: tb_coiWhereInput | tb_coiWhereInput[]
    coi_id?: IntFilter<"tb_coi"> | number
    from_officer?: IntFilter<"tb_coi"> | number
    to_coispec?: IntFilter<"tb_coi"> | number
    case_id?: IntFilter<"tb_coi"> | number
    request_date?: DateTimeFilter<"tb_coi"> | Date | string
    request_deadline?: DateTimeFilter<"tb_coi"> | Date | string
    description?: StringNullableFilter<"tb_coi"> | string | null
    request_text?: StringFilter<"tb_coi"> | string
    coi_state?: IntFilter<"tb_coi"> | number
    request_count?: IntNullableFilter<"tb_coi"> | number | null
    response_date?: DateTimeNullableFilter<"tb_coi"> | Date | string | null
    coi_status?: IntFilter<"tb_coi"> | number
  }

  export type tb_coiOrderByWithRelationInput = {
    coi_id?: SortOrder
    from_officer?: SortOrder
    to_coispec?: SortOrder
    case_id?: SortOrder
    request_date?: SortOrder
    request_deadline?: SortOrder
    description?: SortOrderInput | SortOrder
    request_text?: SortOrder
    coi_state?: SortOrder
    request_count?: SortOrderInput | SortOrder
    response_date?: SortOrderInput | SortOrder
    coi_status?: SortOrder
    _relevance?: tb_coiOrderByRelevanceInput
  }

  export type tb_coiWhereUniqueInput = Prisma.AtLeast<{
    coi_id?: number
    AND?: tb_coiWhereInput | tb_coiWhereInput[]
    OR?: tb_coiWhereInput[]
    NOT?: tb_coiWhereInput | tb_coiWhereInput[]
    from_officer?: IntFilter<"tb_coi"> | number
    to_coispec?: IntFilter<"tb_coi"> | number
    case_id?: IntFilter<"tb_coi"> | number
    request_date?: DateTimeFilter<"tb_coi"> | Date | string
    request_deadline?: DateTimeFilter<"tb_coi"> | Date | string
    description?: StringNullableFilter<"tb_coi"> | string | null
    request_text?: StringFilter<"tb_coi"> | string
    coi_state?: IntFilter<"tb_coi"> | number
    request_count?: IntNullableFilter<"tb_coi"> | number | null
    response_date?: DateTimeNullableFilter<"tb_coi"> | Date | string | null
    coi_status?: IntFilter<"tb_coi"> | number
  }, "coi_id">

  export type tb_coiOrderByWithAggregationInput = {
    coi_id?: SortOrder
    from_officer?: SortOrder
    to_coispec?: SortOrder
    case_id?: SortOrder
    request_date?: SortOrder
    request_deadline?: SortOrder
    description?: SortOrderInput | SortOrder
    request_text?: SortOrder
    coi_state?: SortOrder
    request_count?: SortOrderInput | SortOrder
    response_date?: SortOrderInput | SortOrder
    coi_status?: SortOrder
    _count?: tb_coiCountOrderByAggregateInput
    _avg?: tb_coiAvgOrderByAggregateInput
    _max?: tb_coiMaxOrderByAggregateInput
    _min?: tb_coiMinOrderByAggregateInput
    _sum?: tb_coiSumOrderByAggregateInput
  }

  export type tb_coiScalarWhereWithAggregatesInput = {
    AND?: tb_coiScalarWhereWithAggregatesInput | tb_coiScalarWhereWithAggregatesInput[]
    OR?: tb_coiScalarWhereWithAggregatesInput[]
    NOT?: tb_coiScalarWhereWithAggregatesInput | tb_coiScalarWhereWithAggregatesInput[]
    coi_id?: IntWithAggregatesFilter<"tb_coi"> | number
    from_officer?: IntWithAggregatesFilter<"tb_coi"> | number
    to_coispec?: IntWithAggregatesFilter<"tb_coi"> | number
    case_id?: IntWithAggregatesFilter<"tb_coi"> | number
    request_date?: DateTimeWithAggregatesFilter<"tb_coi"> | Date | string
    request_deadline?: DateTimeWithAggregatesFilter<"tb_coi"> | Date | string
    description?: StringNullableWithAggregatesFilter<"tb_coi"> | string | null
    request_text?: StringWithAggregatesFilter<"tb_coi"> | string
    coi_state?: IntWithAggregatesFilter<"tb_coi"> | number
    request_count?: IntNullableWithAggregatesFilter<"tb_coi"> | number | null
    response_date?: DateTimeNullableWithAggregatesFilter<"tb_coi"> | Date | string | null
    coi_status?: IntWithAggregatesFilter<"tb_coi"> | number
  }

  export type tb_countryWhereInput = {
    AND?: tb_countryWhereInput | tb_countryWhereInput[]
    OR?: tb_countryWhereInput[]
    NOT?: tb_countryWhereInput | tb_countryWhereInput[]
    country_id?: IntFilter<"tb_country"> | number
    country_eng?: StringFilter<"tb_country"> | string
    country_arm?: StringFilter<"tb_country"> | string
  }

  export type tb_countryOrderByWithRelationInput = {
    country_id?: SortOrder
    country_eng?: SortOrder
    country_arm?: SortOrder
    _relevance?: tb_countryOrderByRelevanceInput
  }

  export type tb_countryWhereUniqueInput = Prisma.AtLeast<{
    country_id?: number
    AND?: tb_countryWhereInput | tb_countryWhereInput[]
    OR?: tb_countryWhereInput[]
    NOT?: tb_countryWhereInput | tb_countryWhereInput[]
    country_eng?: StringFilter<"tb_country"> | string
    country_arm?: StringFilter<"tb_country"> | string
  }, "country_id">

  export type tb_countryOrderByWithAggregationInput = {
    country_id?: SortOrder
    country_eng?: SortOrder
    country_arm?: SortOrder
    _count?: tb_countryCountOrderByAggregateInput
    _avg?: tb_countryAvgOrderByAggregateInput
    _max?: tb_countryMaxOrderByAggregateInput
    _min?: tb_countryMinOrderByAggregateInput
    _sum?: tb_countrySumOrderByAggregateInput
  }

  export type tb_countryScalarWhereWithAggregatesInput = {
    AND?: tb_countryScalarWhereWithAggregatesInput | tb_countryScalarWhereWithAggregatesInput[]
    OR?: tb_countryScalarWhereWithAggregatesInput[]
    NOT?: tb_countryScalarWhereWithAggregatesInput | tb_countryScalarWhereWithAggregatesInput[]
    country_id?: IntWithAggregatesFilter<"tb_country"> | number
    country_eng?: StringWithAggregatesFilter<"tb_country"> | string
    country_arm?: StringWithAggregatesFilter<"tb_country"> | string
  }

  export type tb_cover_filesWhereInput = {
    AND?: tb_cover_filesWhereInput | tb_cover_filesWhereInput[]
    OR?: tb_cover_filesWhereInput[]
    NOT?: tb_cover_filesWhereInput | tb_cover_filesWhereInput[]
    cover_file_id?: IntFilter<"tb_cover_files"> | number
    type?: IntFilter<"tb_cover_files"> | number
    file_name?: StringFilter<"tb_cover_files"> | string
    cover_status?: IntFilter<"tb_cover_files"> | number
    case_id?: IntFilter<"tb_cover_files"> | number
    translation_id?: IntFilter<"tb_cover_files"> | number
    cover_actual?: IntNullableFilter<"tb_cover_files"> | number | null
  }

  export type tb_cover_filesOrderByWithRelationInput = {
    cover_file_id?: SortOrder
    type?: SortOrder
    file_name?: SortOrder
    cover_status?: SortOrder
    case_id?: SortOrder
    translation_id?: SortOrder
    cover_actual?: SortOrderInput | SortOrder
    _relevance?: tb_cover_filesOrderByRelevanceInput
  }

  export type tb_cover_filesWhereUniqueInput = Prisma.AtLeast<{
    cover_file_id?: number
    AND?: tb_cover_filesWhereInput | tb_cover_filesWhereInput[]
    OR?: tb_cover_filesWhereInput[]
    NOT?: tb_cover_filesWhereInput | tb_cover_filesWhereInput[]
    type?: IntFilter<"tb_cover_files"> | number
    file_name?: StringFilter<"tb_cover_files"> | string
    cover_status?: IntFilter<"tb_cover_files"> | number
    case_id?: IntFilter<"tb_cover_files"> | number
    translation_id?: IntFilter<"tb_cover_files"> | number
    cover_actual?: IntNullableFilter<"tb_cover_files"> | number | null
  }, "cover_file_id">

  export type tb_cover_filesOrderByWithAggregationInput = {
    cover_file_id?: SortOrder
    type?: SortOrder
    file_name?: SortOrder
    cover_status?: SortOrder
    case_id?: SortOrder
    translation_id?: SortOrder
    cover_actual?: SortOrderInput | SortOrder
    _count?: tb_cover_filesCountOrderByAggregateInput
    _avg?: tb_cover_filesAvgOrderByAggregateInput
    _max?: tb_cover_filesMaxOrderByAggregateInput
    _min?: tb_cover_filesMinOrderByAggregateInput
    _sum?: tb_cover_filesSumOrderByAggregateInput
  }

  export type tb_cover_filesScalarWhereWithAggregatesInput = {
    AND?: tb_cover_filesScalarWhereWithAggregatesInput | tb_cover_filesScalarWhereWithAggregatesInput[]
    OR?: tb_cover_filesScalarWhereWithAggregatesInput[]
    NOT?: tb_cover_filesScalarWhereWithAggregatesInput | tb_cover_filesScalarWhereWithAggregatesInput[]
    cover_file_id?: IntWithAggregatesFilter<"tb_cover_files"> | number
    type?: IntWithAggregatesFilter<"tb_cover_files"> | number
    file_name?: StringWithAggregatesFilter<"tb_cover_files"> | string
    cover_status?: IntWithAggregatesFilter<"tb_cover_files"> | number
    case_id?: IntWithAggregatesFilter<"tb_cover_files"> | number
    translation_id?: IntWithAggregatesFilter<"tb_cover_files"> | number
    cover_actual?: IntNullableWithAggregatesFilter<"tb_cover_files"> | number | null
  }

  export type tb_deadlineWhereInput = {
    AND?: tb_deadlineWhereInput | tb_deadlineWhereInput[]
    OR?: tb_deadlineWhereInput[]
    NOT?: tb_deadlineWhereInput | tb_deadlineWhereInput[]
    id?: IntFilter<"tb_deadline"> | number
    case_id?: IntFilter<"tb_deadline"> | number
    deadline_type?: IntFilter<"tb_deadline"> | number
    deadline?: DateTimeFilter<"tb_deadline"> | Date | string
    actual_dead?: IntFilter<"tb_deadline"> | number
    process_type_id?: IntFilter<"tb_deadline"> | number
  }

  export type tb_deadlineOrderByWithRelationInput = {
    id?: SortOrder
    case_id?: SortOrder
    deadline_type?: SortOrder
    deadline?: SortOrder
    actual_dead?: SortOrder
    process_type_id?: SortOrder
  }

  export type tb_deadlineWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: tb_deadlineWhereInput | tb_deadlineWhereInput[]
    OR?: tb_deadlineWhereInput[]
    NOT?: tb_deadlineWhereInput | tb_deadlineWhereInput[]
    case_id?: IntFilter<"tb_deadline"> | number
    deadline_type?: IntFilter<"tb_deadline"> | number
    deadline?: DateTimeFilter<"tb_deadline"> | Date | string
    actual_dead?: IntFilter<"tb_deadline"> | number
    process_type_id?: IntFilter<"tb_deadline"> | number
  }, "id">

  export type tb_deadlineOrderByWithAggregationInput = {
    id?: SortOrder
    case_id?: SortOrder
    deadline_type?: SortOrder
    deadline?: SortOrder
    actual_dead?: SortOrder
    process_type_id?: SortOrder
    _count?: tb_deadlineCountOrderByAggregateInput
    _avg?: tb_deadlineAvgOrderByAggregateInput
    _max?: tb_deadlineMaxOrderByAggregateInput
    _min?: tb_deadlineMinOrderByAggregateInput
    _sum?: tb_deadlineSumOrderByAggregateInput
  }

  export type tb_deadlineScalarWhereWithAggregatesInput = {
    AND?: tb_deadlineScalarWhereWithAggregatesInput | tb_deadlineScalarWhereWithAggregatesInput[]
    OR?: tb_deadlineScalarWhereWithAggregatesInput[]
    NOT?: tb_deadlineScalarWhereWithAggregatesInput | tb_deadlineScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"tb_deadline"> | number
    case_id?: IntWithAggregatesFilter<"tb_deadline"> | number
    deadline_type?: IntWithAggregatesFilter<"tb_deadline"> | number
    deadline?: DateTimeWithAggregatesFilter<"tb_deadline"> | Date | string
    actual_dead?: IntWithAggregatesFilter<"tb_deadline"> | number
    process_type_id?: IntWithAggregatesFilter<"tb_deadline"> | number
  }

  export type tb_deadline_typesWhereInput = {
    AND?: tb_deadline_typesWhereInput | tb_deadline_typesWhereInput[]
    OR?: tb_deadline_typesWhereInput[]
    NOT?: tb_deadline_typesWhereInput | tb_deadline_typesWhereInput[]
    deadline_type_id?: IntFilter<"tb_deadline_types"> | number
    deadline_type?: StringFilter<"tb_deadline_types"> | string
  }

  export type tb_deadline_typesOrderByWithRelationInput = {
    deadline_type_id?: SortOrder
    deadline_type?: SortOrder
    _relevance?: tb_deadline_typesOrderByRelevanceInput
  }

  export type tb_deadline_typesWhereUniqueInput = Prisma.AtLeast<{
    deadline_type_id?: number
    AND?: tb_deadline_typesWhereInput | tb_deadline_typesWhereInput[]
    OR?: tb_deadline_typesWhereInput[]
    NOT?: tb_deadline_typesWhereInput | tb_deadline_typesWhereInput[]
    deadline_type?: StringFilter<"tb_deadline_types"> | string
  }, "deadline_type_id">

  export type tb_deadline_typesOrderByWithAggregationInput = {
    deadline_type_id?: SortOrder
    deadline_type?: SortOrder
    _count?: tb_deadline_typesCountOrderByAggregateInput
    _avg?: tb_deadline_typesAvgOrderByAggregateInput
    _max?: tb_deadline_typesMaxOrderByAggregateInput
    _min?: tb_deadline_typesMinOrderByAggregateInput
    _sum?: tb_deadline_typesSumOrderByAggregateInput
  }

  export type tb_deadline_typesScalarWhereWithAggregatesInput = {
    AND?: tb_deadline_typesScalarWhereWithAggregatesInput | tb_deadline_typesScalarWhereWithAggregatesInput[]
    OR?: tb_deadline_typesScalarWhereWithAggregatesInput[]
    NOT?: tb_deadline_typesScalarWhereWithAggregatesInput | tb_deadline_typesScalarWhereWithAggregatesInput[]
    deadline_type_id?: IntWithAggregatesFilter<"tb_deadline_types"> | number
    deadline_type?: StringWithAggregatesFilter<"tb_deadline_types"> | string
  }

  export type tb_decision_statusWhereInput = {
    AND?: tb_decision_statusWhereInput | tb_decision_statusWhereInput[]
    OR?: tb_decision_statusWhereInput[]
    NOT?: tb_decision_statusWhereInput | tb_decision_statusWhereInput[]
    decision_status_id?: IntFilter<"tb_decision_status"> | number
    decision_status?: StringFilter<"tb_decision_status"> | string
    decision_status_eng?: StringNullableFilter<"tb_decision_status"> | string | null
  }

  export type tb_decision_statusOrderByWithRelationInput = {
    decision_status_id?: SortOrder
    decision_status?: SortOrder
    decision_status_eng?: SortOrderInput | SortOrder
    _relevance?: tb_decision_statusOrderByRelevanceInput
  }

  export type tb_decision_statusWhereUniqueInput = Prisma.AtLeast<{
    decision_status_id?: number
    AND?: tb_decision_statusWhereInput | tb_decision_statusWhereInput[]
    OR?: tb_decision_statusWhereInput[]
    NOT?: tb_decision_statusWhereInput | tb_decision_statusWhereInput[]
    decision_status?: StringFilter<"tb_decision_status"> | string
    decision_status_eng?: StringNullableFilter<"tb_decision_status"> | string | null
  }, "decision_status_id">

  export type tb_decision_statusOrderByWithAggregationInput = {
    decision_status_id?: SortOrder
    decision_status?: SortOrder
    decision_status_eng?: SortOrderInput | SortOrder
    _count?: tb_decision_statusCountOrderByAggregateInput
    _avg?: tb_decision_statusAvgOrderByAggregateInput
    _max?: tb_decision_statusMaxOrderByAggregateInput
    _min?: tb_decision_statusMinOrderByAggregateInput
    _sum?: tb_decision_statusSumOrderByAggregateInput
  }

  export type tb_decision_statusScalarWhereWithAggregatesInput = {
    AND?: tb_decision_statusScalarWhereWithAggregatesInput | tb_decision_statusScalarWhereWithAggregatesInput[]
    OR?: tb_decision_statusScalarWhereWithAggregatesInput[]
    NOT?: tb_decision_statusScalarWhereWithAggregatesInput | tb_decision_statusScalarWhereWithAggregatesInput[]
    decision_status_id?: IntWithAggregatesFilter<"tb_decision_status"> | number
    decision_status?: StringWithAggregatesFilter<"tb_decision_status"> | string
    decision_status_eng?: StringNullableWithAggregatesFilter<"tb_decision_status"> | string | null
  }

  export type tb_decision_typesWhereInput = {
    AND?: tb_decision_typesWhereInput | tb_decision_typesWhereInput[]
    OR?: tb_decision_typesWhereInput[]
    NOT?: tb_decision_typesWhereInput | tb_decision_typesWhereInput[]
    decision_type_id?: IntFilter<"tb_decision_types"> | number
    decision_type?: StringFilter<"tb_decision_types"> | string
    decision_type_eng?: StringFilter<"tb_decision_types"> | string
  }

  export type tb_decision_typesOrderByWithRelationInput = {
    decision_type_id?: SortOrder
    decision_type?: SortOrder
    decision_type_eng?: SortOrder
    _relevance?: tb_decision_typesOrderByRelevanceInput
  }

  export type tb_decision_typesWhereUniqueInput = Prisma.AtLeast<{
    decision_type_id?: number
    AND?: tb_decision_typesWhereInput | tb_decision_typesWhereInput[]
    OR?: tb_decision_typesWhereInput[]
    NOT?: tb_decision_typesWhereInput | tb_decision_typesWhereInput[]
    decision_type?: StringFilter<"tb_decision_types"> | string
    decision_type_eng?: StringFilter<"tb_decision_types"> | string
  }, "decision_type_id">

  export type tb_decision_typesOrderByWithAggregationInput = {
    decision_type_id?: SortOrder
    decision_type?: SortOrder
    decision_type_eng?: SortOrder
    _count?: tb_decision_typesCountOrderByAggregateInput
    _avg?: tb_decision_typesAvgOrderByAggregateInput
    _max?: tb_decision_typesMaxOrderByAggregateInput
    _min?: tb_decision_typesMinOrderByAggregateInput
    _sum?: tb_decision_typesSumOrderByAggregateInput
  }

  export type tb_decision_typesScalarWhereWithAggregatesInput = {
    AND?: tb_decision_typesScalarWhereWithAggregatesInput | tb_decision_typesScalarWhereWithAggregatesInput[]
    OR?: tb_decision_typesScalarWhereWithAggregatesInput[]
    NOT?: tb_decision_typesScalarWhereWithAggregatesInput | tb_decision_typesScalarWhereWithAggregatesInput[]
    decision_type_id?: IntWithAggregatesFilter<"tb_decision_types"> | number
    decision_type?: StringWithAggregatesFilter<"tb_decision_types"> | string
    decision_type_eng?: StringWithAggregatesFilter<"tb_decision_types"> | string
  }

  export type tb_decisionsWhereInput = {
    AND?: tb_decisionsWhereInput | tb_decisionsWhereInput[]
    OR?: tb_decisionsWhereInput[]
    NOT?: tb_decisionsWhereInput | tb_decisionsWhereInput[]
    decision_id?: IntFilter<"tb_decisions"> | number
    case_id?: IntFilter<"tb_decisions"> | number
    decision_type?: IntFilter<"tb_decisions"> | number
    decison_date?: DateTimeFilter<"tb_decisions"> | Date | string
    decision_status?: IntFilter<"tb_decisions"> | number
    actual?: IntFilter<"tb_decisions"> | number
    decision_out_num?: StringNullableFilter<"tb_decisions"> | string | null
  }

  export type tb_decisionsOrderByWithRelationInput = {
    decision_id?: SortOrder
    case_id?: SortOrder
    decision_type?: SortOrder
    decison_date?: SortOrder
    decision_status?: SortOrder
    actual?: SortOrder
    decision_out_num?: SortOrderInput | SortOrder
    _relevance?: tb_decisionsOrderByRelevanceInput
  }

  export type tb_decisionsWhereUniqueInput = Prisma.AtLeast<{
    decision_id?: number
    AND?: tb_decisionsWhereInput | tb_decisionsWhereInput[]
    OR?: tb_decisionsWhereInput[]
    NOT?: tb_decisionsWhereInput | tb_decisionsWhereInput[]
    case_id?: IntFilter<"tb_decisions"> | number
    decision_type?: IntFilter<"tb_decisions"> | number
    decison_date?: DateTimeFilter<"tb_decisions"> | Date | string
    decision_status?: IntFilter<"tb_decisions"> | number
    actual?: IntFilter<"tb_decisions"> | number
    decision_out_num?: StringNullableFilter<"tb_decisions"> | string | null
  }, "decision_id">

  export type tb_decisionsOrderByWithAggregationInput = {
    decision_id?: SortOrder
    case_id?: SortOrder
    decision_type?: SortOrder
    decison_date?: SortOrder
    decision_status?: SortOrder
    actual?: SortOrder
    decision_out_num?: SortOrderInput | SortOrder
    _count?: tb_decisionsCountOrderByAggregateInput
    _avg?: tb_decisionsAvgOrderByAggregateInput
    _max?: tb_decisionsMaxOrderByAggregateInput
    _min?: tb_decisionsMinOrderByAggregateInput
    _sum?: tb_decisionsSumOrderByAggregateInput
  }

  export type tb_decisionsScalarWhereWithAggregatesInput = {
    AND?: tb_decisionsScalarWhereWithAggregatesInput | tb_decisionsScalarWhereWithAggregatesInput[]
    OR?: tb_decisionsScalarWhereWithAggregatesInput[]
    NOT?: tb_decisionsScalarWhereWithAggregatesInput | tb_decisionsScalarWhereWithAggregatesInput[]
    decision_id?: IntWithAggregatesFilter<"tb_decisions"> | number
    case_id?: IntWithAggregatesFilter<"tb_decisions"> | number
    decision_type?: IntWithAggregatesFilter<"tb_decisions"> | number
    decison_date?: DateTimeWithAggregatesFilter<"tb_decisions"> | Date | string
    decision_status?: IntWithAggregatesFilter<"tb_decisions"> | number
    actual?: IntWithAggregatesFilter<"tb_decisions"> | number
    decision_out_num?: StringNullableWithAggregatesFilter<"tb_decisions"> | string | null
  }

  export type tb_dossWhereInput = {
    AND?: tb_dossWhereInput | tb_dossWhereInput[]
    OR?: tb_dossWhereInput[]
    NOT?: tb_dossWhereInput | tb_dossWhereInput[]
    doss_id?: IntFilter<"tb_doss"> | number
    room_num?: IntFilter<"tb_doss"> | number
    doss?: StringFilter<"tb_doss"> | string
    doss_status?: IntFilter<"tb_doss"> | number
    doss_type?: StringFilter<"tb_doss"> | string
    doss_sex?: IntFilter<"tb_doss"> | number
  }

  export type tb_dossOrderByWithRelationInput = {
    doss_id?: SortOrder
    room_num?: SortOrder
    doss?: SortOrder
    doss_status?: SortOrder
    doss_type?: SortOrder
    doss_sex?: SortOrder
    _relevance?: tb_dossOrderByRelevanceInput
  }

  export type tb_dossWhereUniqueInput = Prisma.AtLeast<{
    doss_id?: number
    doss?: string
    AND?: tb_dossWhereInput | tb_dossWhereInput[]
    OR?: tb_dossWhereInput[]
    NOT?: tb_dossWhereInput | tb_dossWhereInput[]
    room_num?: IntFilter<"tb_doss"> | number
    doss_status?: IntFilter<"tb_doss"> | number
    doss_type?: StringFilter<"tb_doss"> | string
    doss_sex?: IntFilter<"tb_doss"> | number
  }, "doss_id" | "doss">

  export type tb_dossOrderByWithAggregationInput = {
    doss_id?: SortOrder
    room_num?: SortOrder
    doss?: SortOrder
    doss_status?: SortOrder
    doss_type?: SortOrder
    doss_sex?: SortOrder
    _count?: tb_dossCountOrderByAggregateInput
    _avg?: tb_dossAvgOrderByAggregateInput
    _max?: tb_dossMaxOrderByAggregateInput
    _min?: tb_dossMinOrderByAggregateInput
    _sum?: tb_dossSumOrderByAggregateInput
  }

  export type tb_dossScalarWhereWithAggregatesInput = {
    AND?: tb_dossScalarWhereWithAggregatesInput | tb_dossScalarWhereWithAggregatesInput[]
    OR?: tb_dossScalarWhereWithAggregatesInput[]
    NOT?: tb_dossScalarWhereWithAggregatesInput | tb_dossScalarWhereWithAggregatesInput[]
    doss_id?: IntWithAggregatesFilter<"tb_doss"> | number
    room_num?: IntWithAggregatesFilter<"tb_doss"> | number
    doss?: StringWithAggregatesFilter<"tb_doss"> | string
    doss_status?: IntWithAggregatesFilter<"tb_doss"> | number
    doss_type?: StringWithAggregatesFilter<"tb_doss"> | string
    doss_sex?: IntWithAggregatesFilter<"tb_doss"> | number
  }

  export type tb_draftWhereInput = {
    AND?: tb_draftWhereInput | tb_draftWhereInput[]
    OR?: tb_draftWhereInput[]
    NOT?: tb_draftWhereInput | tb_draftWhereInput[]
    draft_id?: IntFilter<"tb_draft"> | number
    case_id?: IntFilter<"tb_draft"> | number
    autor?: IntFilter<"tb_draft"> | number
    uploaded?: DateTimeFilter<"tb_draft"> | Date | string
    receiver?: IntFilter<"tb_draft"> | number
    actual?: IntFilter<"tb_draft"> | number
  }

  export type tb_draftOrderByWithRelationInput = {
    draft_id?: SortOrder
    case_id?: SortOrder
    autor?: SortOrder
    uploaded?: SortOrder
    receiver?: SortOrder
    actual?: SortOrder
  }

  export type tb_draftWhereUniqueInput = Prisma.AtLeast<{
    draft_id?: number
    AND?: tb_draftWhereInput | tb_draftWhereInput[]
    OR?: tb_draftWhereInput[]
    NOT?: tb_draftWhereInput | tb_draftWhereInput[]
    case_id?: IntFilter<"tb_draft"> | number
    autor?: IntFilter<"tb_draft"> | number
    uploaded?: DateTimeFilter<"tb_draft"> | Date | string
    receiver?: IntFilter<"tb_draft"> | number
    actual?: IntFilter<"tb_draft"> | number
  }, "draft_id">

  export type tb_draftOrderByWithAggregationInput = {
    draft_id?: SortOrder
    case_id?: SortOrder
    autor?: SortOrder
    uploaded?: SortOrder
    receiver?: SortOrder
    actual?: SortOrder
    _count?: tb_draftCountOrderByAggregateInput
    _avg?: tb_draftAvgOrderByAggregateInput
    _max?: tb_draftMaxOrderByAggregateInput
    _min?: tb_draftMinOrderByAggregateInput
    _sum?: tb_draftSumOrderByAggregateInput
  }

  export type tb_draftScalarWhereWithAggregatesInput = {
    AND?: tb_draftScalarWhereWithAggregatesInput | tb_draftScalarWhereWithAggregatesInput[]
    OR?: tb_draftScalarWhereWithAggregatesInput[]
    NOT?: tb_draftScalarWhereWithAggregatesInput | tb_draftScalarWhereWithAggregatesInput[]
    draft_id?: IntWithAggregatesFilter<"tb_draft"> | number
    case_id?: IntWithAggregatesFilter<"tb_draft"> | number
    autor?: IntWithAggregatesFilter<"tb_draft"> | number
    uploaded?: DateTimeWithAggregatesFilter<"tb_draft"> | Date | string
    receiver?: IntWithAggregatesFilter<"tb_draft"> | number
    actual?: IntWithAggregatesFilter<"tb_draft"> | number
  }

  export type tb_droomsWhereInput = {
    AND?: tb_droomsWhereInput | tb_droomsWhereInput[]
    OR?: tb_droomsWhereInput[]
    NOT?: tb_droomsWhereInput | tb_droomsWhereInput[]
    room_id?: IntFilter<"tb_drooms"> | number
    room_num?: IntNullableFilter<"tb_drooms"> | number | null
    floor?: IntNullableFilter<"tb_drooms"> | number | null
    type?: StringNullableFilter<"tb_drooms"> | string | null
    capacity?: IntNullableFilter<"tb_drooms"> | number | null
    room_sex?: IntFilter<"tb_drooms"> | number
  }

  export type tb_droomsOrderByWithRelationInput = {
    room_id?: SortOrder
    room_num?: SortOrderInput | SortOrder
    floor?: SortOrderInput | SortOrder
    type?: SortOrderInput | SortOrder
    capacity?: SortOrderInput | SortOrder
    room_sex?: SortOrder
    _relevance?: tb_droomsOrderByRelevanceInput
  }

  export type tb_droomsWhereUniqueInput = Prisma.AtLeast<{
    room_id?: number
    AND?: tb_droomsWhereInput | tb_droomsWhereInput[]
    OR?: tb_droomsWhereInput[]
    NOT?: tb_droomsWhereInput | tb_droomsWhereInput[]
    room_num?: IntNullableFilter<"tb_drooms"> | number | null
    floor?: IntNullableFilter<"tb_drooms"> | number | null
    type?: StringNullableFilter<"tb_drooms"> | string | null
    capacity?: IntNullableFilter<"tb_drooms"> | number | null
    room_sex?: IntFilter<"tb_drooms"> | number
  }, "room_id">

  export type tb_droomsOrderByWithAggregationInput = {
    room_id?: SortOrder
    room_num?: SortOrderInput | SortOrder
    floor?: SortOrderInput | SortOrder
    type?: SortOrderInput | SortOrder
    capacity?: SortOrderInput | SortOrder
    room_sex?: SortOrder
    _count?: tb_droomsCountOrderByAggregateInput
    _avg?: tb_droomsAvgOrderByAggregateInput
    _max?: tb_droomsMaxOrderByAggregateInput
    _min?: tb_droomsMinOrderByAggregateInput
    _sum?: tb_droomsSumOrderByAggregateInput
  }

  export type tb_droomsScalarWhereWithAggregatesInput = {
    AND?: tb_droomsScalarWhereWithAggregatesInput | tb_droomsScalarWhereWithAggregatesInput[]
    OR?: tb_droomsScalarWhereWithAggregatesInput[]
    NOT?: tb_droomsScalarWhereWithAggregatesInput | tb_droomsScalarWhereWithAggregatesInput[]
    room_id?: IntWithAggregatesFilter<"tb_drooms"> | number
    room_num?: IntNullableWithAggregatesFilter<"tb_drooms"> | number | null
    floor?: IntNullableWithAggregatesFilter<"tb_drooms"> | number | null
    type?: StringNullableWithAggregatesFilter<"tb_drooms"> | string | null
    capacity?: IntNullableWithAggregatesFilter<"tb_drooms"> | number | null
    room_sex?: IntWithAggregatesFilter<"tb_drooms"> | number
  }

  export type tb_edu_lvlWhereInput = {
    AND?: tb_edu_lvlWhereInput | tb_edu_lvlWhereInput[]
    OR?: tb_edu_lvlWhereInput[]
    NOT?: tb_edu_lvlWhereInput | tb_edu_lvlWhereInput[]
    lvl_id?: IntFilter<"tb_edu_lvl"> | number
    edu_lvl?: StringFilter<"tb_edu_lvl"> | string
  }

  export type tb_edu_lvlOrderByWithRelationInput = {
    lvl_id?: SortOrder
    edu_lvl?: SortOrder
    _relevance?: tb_edu_lvlOrderByRelevanceInput
  }

  export type tb_edu_lvlWhereUniqueInput = Prisma.AtLeast<{
    lvl_id?: number
    AND?: tb_edu_lvlWhereInput | tb_edu_lvlWhereInput[]
    OR?: tb_edu_lvlWhereInput[]
    NOT?: tb_edu_lvlWhereInput | tb_edu_lvlWhereInput[]
    edu_lvl?: StringFilter<"tb_edu_lvl"> | string
  }, "lvl_id">

  export type tb_edu_lvlOrderByWithAggregationInput = {
    lvl_id?: SortOrder
    edu_lvl?: SortOrder
    _count?: tb_edu_lvlCountOrderByAggregateInput
    _avg?: tb_edu_lvlAvgOrderByAggregateInput
    _max?: tb_edu_lvlMaxOrderByAggregateInput
    _min?: tb_edu_lvlMinOrderByAggregateInput
    _sum?: tb_edu_lvlSumOrderByAggregateInput
  }

  export type tb_edu_lvlScalarWhereWithAggregatesInput = {
    AND?: tb_edu_lvlScalarWhereWithAggregatesInput | tb_edu_lvlScalarWhereWithAggregatesInput[]
    OR?: tb_edu_lvlScalarWhereWithAggregatesInput[]
    NOT?: tb_edu_lvlScalarWhereWithAggregatesInput | tb_edu_lvlScalarWhereWithAggregatesInput[]
    lvl_id?: IntWithAggregatesFilter<"tb_edu_lvl"> | number
    edu_lvl?: StringWithAggregatesFilter<"tb_edu_lvl"> | string
  }

  export type tb_educationWhereInput = {
    AND?: tb_educationWhereInput | tb_educationWhereInput[]
    OR?: tb_educationWhereInput[]
    NOT?: tb_educationWhereInput | tb_educationWhereInput[]
    edu_id?: IntFilter<"tb_education"> | number
    specialization?: StringNullableFilter<"tb_education"> | string | null
    institution?: StringNullableFilter<"tb_education"> | string | null
    edu_lvl?: IntFilter<"tb_education"> | number
    start_year?: StringNullableFilter<"tb_education"> | string | null
    end_year?: StringNullableFilter<"tb_education"> | string | null
    personal_id?: IntFilter<"tb_education"> | number
  }

  export type tb_educationOrderByWithRelationInput = {
    edu_id?: SortOrder
    specialization?: SortOrderInput | SortOrder
    institution?: SortOrderInput | SortOrder
    edu_lvl?: SortOrder
    start_year?: SortOrderInput | SortOrder
    end_year?: SortOrderInput | SortOrder
    personal_id?: SortOrder
    _relevance?: tb_educationOrderByRelevanceInput
  }

  export type tb_educationWhereUniqueInput = Prisma.AtLeast<{
    edu_id?: number
    AND?: tb_educationWhereInput | tb_educationWhereInput[]
    OR?: tb_educationWhereInput[]
    NOT?: tb_educationWhereInput | tb_educationWhereInput[]
    specialization?: StringNullableFilter<"tb_education"> | string | null
    institution?: StringNullableFilter<"tb_education"> | string | null
    edu_lvl?: IntFilter<"tb_education"> | number
    start_year?: StringNullableFilter<"tb_education"> | string | null
    end_year?: StringNullableFilter<"tb_education"> | string | null
    personal_id?: IntFilter<"tb_education"> | number
  }, "edu_id">

  export type tb_educationOrderByWithAggregationInput = {
    edu_id?: SortOrder
    specialization?: SortOrderInput | SortOrder
    institution?: SortOrderInput | SortOrder
    edu_lvl?: SortOrder
    start_year?: SortOrderInput | SortOrder
    end_year?: SortOrderInput | SortOrder
    personal_id?: SortOrder
    _count?: tb_educationCountOrderByAggregateInput
    _avg?: tb_educationAvgOrderByAggregateInput
    _max?: tb_educationMaxOrderByAggregateInput
    _min?: tb_educationMinOrderByAggregateInput
    _sum?: tb_educationSumOrderByAggregateInput
  }

  export type tb_educationScalarWhereWithAggregatesInput = {
    AND?: tb_educationScalarWhereWithAggregatesInput | tb_educationScalarWhereWithAggregatesInput[]
    OR?: tb_educationScalarWhereWithAggregatesInput[]
    NOT?: tb_educationScalarWhereWithAggregatesInput | tb_educationScalarWhereWithAggregatesInput[]
    edu_id?: IntWithAggregatesFilter<"tb_education"> | number
    specialization?: StringNullableWithAggregatesFilter<"tb_education"> | string | null
    institution?: StringNullableWithAggregatesFilter<"tb_education"> | string | null
    edu_lvl?: IntWithAggregatesFilter<"tb_education"> | number
    start_year?: StringNullableWithAggregatesFilter<"tb_education"> | string | null
    end_year?: StringNullableWithAggregatesFilter<"tb_education"> | string | null
    personal_id?: IntWithAggregatesFilter<"tb_education"> | number
  }

  export type tb_employmentWhereInput = {
    AND?: tb_employmentWhereInput | tb_employmentWhereInput[]
    OR?: tb_employmentWhereInput[]
    NOT?: tb_employmentWhereInput | tb_employmentWhereInput[]
    employment_id?: IntFilter<"tb_employment"> | number
    start_date?: StringNullableFilter<"tb_employment"> | string | null
    end_date?: StringNullableFilter<"tb_employment"> | string | null
    occupation?: StringNullableFilter<"tb_employment"> | string | null
    organization?: StringNullableFilter<"tb_employment"> | string | null
    personal_id?: IntFilter<"tb_employment"> | number
  }

  export type tb_employmentOrderByWithRelationInput = {
    employment_id?: SortOrder
    start_date?: SortOrderInput | SortOrder
    end_date?: SortOrderInput | SortOrder
    occupation?: SortOrderInput | SortOrder
    organization?: SortOrderInput | SortOrder
    personal_id?: SortOrder
    _relevance?: tb_employmentOrderByRelevanceInput
  }

  export type tb_employmentWhereUniqueInput = Prisma.AtLeast<{
    employment_id?: number
    AND?: tb_employmentWhereInput | tb_employmentWhereInput[]
    OR?: tb_employmentWhereInput[]
    NOT?: tb_employmentWhereInput | tb_employmentWhereInput[]
    start_date?: StringNullableFilter<"tb_employment"> | string | null
    end_date?: StringNullableFilter<"tb_employment"> | string | null
    occupation?: StringNullableFilter<"tb_employment"> | string | null
    organization?: StringNullableFilter<"tb_employment"> | string | null
    personal_id?: IntFilter<"tb_employment"> | number
  }, "employment_id">

  export type tb_employmentOrderByWithAggregationInput = {
    employment_id?: SortOrder
    start_date?: SortOrderInput | SortOrder
    end_date?: SortOrderInput | SortOrder
    occupation?: SortOrderInput | SortOrder
    organization?: SortOrderInput | SortOrder
    personal_id?: SortOrder
    _count?: tb_employmentCountOrderByAggregateInput
    _avg?: tb_employmentAvgOrderByAggregateInput
    _max?: tb_employmentMaxOrderByAggregateInput
    _min?: tb_employmentMinOrderByAggregateInput
    _sum?: tb_employmentSumOrderByAggregateInput
  }

  export type tb_employmentScalarWhereWithAggregatesInput = {
    AND?: tb_employmentScalarWhereWithAggregatesInput | tb_employmentScalarWhereWithAggregatesInput[]
    OR?: tb_employmentScalarWhereWithAggregatesInput[]
    NOT?: tb_employmentScalarWhereWithAggregatesInput | tb_employmentScalarWhereWithAggregatesInput[]
    employment_id?: IntWithAggregatesFilter<"tb_employment"> | number
    start_date?: StringNullableWithAggregatesFilter<"tb_employment"> | string | null
    end_date?: StringNullableWithAggregatesFilter<"tb_employment"> | string | null
    occupation?: StringNullableWithAggregatesFilter<"tb_employment"> | string | null
    organization?: StringNullableWithAggregatesFilter<"tb_employment"> | string | null
    personal_id?: IntWithAggregatesFilter<"tb_employment"> | number
  }

  export type tb_etnicsWhereInput = {
    AND?: tb_etnicsWhereInput | tb_etnicsWhereInput[]
    OR?: tb_etnicsWhereInput[]
    NOT?: tb_etnicsWhereInput | tb_etnicsWhereInput[]
    etnic_id?: IntFilter<"tb_etnics"> | number
    etnic_arm?: StringFilter<"tb_etnics"> | string
    etnic_eng?: StringFilter<"tb_etnics"> | string
  }

  export type tb_etnicsOrderByWithRelationInput = {
    etnic_id?: SortOrder
    etnic_arm?: SortOrder
    etnic_eng?: SortOrder
    _relevance?: tb_etnicsOrderByRelevanceInput
  }

  export type tb_etnicsWhereUniqueInput = Prisma.AtLeast<{
    etnic_id?: number
    AND?: tb_etnicsWhereInput | tb_etnicsWhereInput[]
    OR?: tb_etnicsWhereInput[]
    NOT?: tb_etnicsWhereInput | tb_etnicsWhereInput[]
    etnic_arm?: StringFilter<"tb_etnics"> | string
    etnic_eng?: StringFilter<"tb_etnics"> | string
  }, "etnic_id">

  export type tb_etnicsOrderByWithAggregationInput = {
    etnic_id?: SortOrder
    etnic_arm?: SortOrder
    etnic_eng?: SortOrder
    _count?: tb_etnicsCountOrderByAggregateInput
    _avg?: tb_etnicsAvgOrderByAggregateInput
    _max?: tb_etnicsMaxOrderByAggregateInput
    _min?: tb_etnicsMinOrderByAggregateInput
    _sum?: tb_etnicsSumOrderByAggregateInput
  }

  export type tb_etnicsScalarWhereWithAggregatesInput = {
    AND?: tb_etnicsScalarWhereWithAggregatesInput | tb_etnicsScalarWhereWithAggregatesInput[]
    OR?: tb_etnicsScalarWhereWithAggregatesInput[]
    NOT?: tb_etnicsScalarWhereWithAggregatesInput | tb_etnicsScalarWhereWithAggregatesInput[]
    etnic_id?: IntWithAggregatesFilter<"tb_etnics"> | number
    etnic_arm?: StringWithAggregatesFilter<"tb_etnics"> | string
    etnic_eng?: StringWithAggregatesFilter<"tb_etnics"> | string
  }

  export type tb_file_typeWhereInput = {
    AND?: tb_file_typeWhereInput | tb_file_typeWhereInput[]
    OR?: tb_file_typeWhereInput[]
    NOT?: tb_file_typeWhereInput | tb_file_typeWhereInput[]
    file_type_id?: IntFilter<"tb_file_type"> | number
    file_type?: StringFilter<"tb_file_type"> | string
    file_filter?: IntFilter<"tb_file_type"> | number
  }

  export type tb_file_typeOrderByWithRelationInput = {
    file_type_id?: SortOrder
    file_type?: SortOrder
    file_filter?: SortOrder
    _relevance?: tb_file_typeOrderByRelevanceInput
  }

  export type tb_file_typeWhereUniqueInput = Prisma.AtLeast<{
    file_type_id?: number
    AND?: tb_file_typeWhereInput | tb_file_typeWhereInput[]
    OR?: tb_file_typeWhereInput[]
    NOT?: tb_file_typeWhereInput | tb_file_typeWhereInput[]
    file_type?: StringFilter<"tb_file_type"> | string
    file_filter?: IntFilter<"tb_file_type"> | number
  }, "file_type_id">

  export type tb_file_typeOrderByWithAggregationInput = {
    file_type_id?: SortOrder
    file_type?: SortOrder
    file_filter?: SortOrder
    _count?: tb_file_typeCountOrderByAggregateInput
    _avg?: tb_file_typeAvgOrderByAggregateInput
    _max?: tb_file_typeMaxOrderByAggregateInput
    _min?: tb_file_typeMinOrderByAggregateInput
    _sum?: tb_file_typeSumOrderByAggregateInput
  }

  export type tb_file_typeScalarWhereWithAggregatesInput = {
    AND?: tb_file_typeScalarWhereWithAggregatesInput | tb_file_typeScalarWhereWithAggregatesInput[]
    OR?: tb_file_typeScalarWhereWithAggregatesInput[]
    NOT?: tb_file_typeScalarWhereWithAggregatesInput | tb_file_typeScalarWhereWithAggregatesInput[]
    file_type_id?: IntWithAggregatesFilter<"tb_file_type"> | number
    file_type?: StringWithAggregatesFilter<"tb_file_type"> | string
    file_filter?: IntWithAggregatesFilter<"tb_file_type"> | number
  }

  export type tb_handedWhereInput = {
    AND?: tb_handedWhereInput | tb_handedWhereInput[]
    OR?: tb_handedWhereInput[]
    NOT?: tb_handedWhereInput | tb_handedWhereInput[]
    handed_id?: IntFilter<"tb_handed"> | number
    case_id?: IntFilter<"tb_handed"> | number
    decision_id?: IntFilter<"tb_handed"> | number
    created?: DateTimeFilter<"tb_handed"> | Date | string
    hended_by?: IntFilter<"tb_handed"> | number
    signed_page?: StringNullableFilter<"tb_handed"> | string | null
  }

  export type tb_handedOrderByWithRelationInput = {
    handed_id?: SortOrder
    case_id?: SortOrder
    decision_id?: SortOrder
    created?: SortOrder
    hended_by?: SortOrder
    signed_page?: SortOrderInput | SortOrder
    _relevance?: tb_handedOrderByRelevanceInput
  }

  export type tb_handedWhereUniqueInput = Prisma.AtLeast<{
    handed_id?: number
    AND?: tb_handedWhereInput | tb_handedWhereInput[]
    OR?: tb_handedWhereInput[]
    NOT?: tb_handedWhereInput | tb_handedWhereInput[]
    case_id?: IntFilter<"tb_handed"> | number
    decision_id?: IntFilter<"tb_handed"> | number
    created?: DateTimeFilter<"tb_handed"> | Date | string
    hended_by?: IntFilter<"tb_handed"> | number
    signed_page?: StringNullableFilter<"tb_handed"> | string | null
  }, "handed_id">

  export type tb_handedOrderByWithAggregationInput = {
    handed_id?: SortOrder
    case_id?: SortOrder
    decision_id?: SortOrder
    created?: SortOrder
    hended_by?: SortOrder
    signed_page?: SortOrderInput | SortOrder
    _count?: tb_handedCountOrderByAggregateInput
    _avg?: tb_handedAvgOrderByAggregateInput
    _max?: tb_handedMaxOrderByAggregateInput
    _min?: tb_handedMinOrderByAggregateInput
    _sum?: tb_handedSumOrderByAggregateInput
  }

  export type tb_handedScalarWhereWithAggregatesInput = {
    AND?: tb_handedScalarWhereWithAggregatesInput | tb_handedScalarWhereWithAggregatesInput[]
    OR?: tb_handedScalarWhereWithAggregatesInput[]
    NOT?: tb_handedScalarWhereWithAggregatesInput | tb_handedScalarWhereWithAggregatesInput[]
    handed_id?: IntWithAggregatesFilter<"tb_handed"> | number
    case_id?: IntWithAggregatesFilter<"tb_handed"> | number
    decision_id?: IntWithAggregatesFilter<"tb_handed"> | number
    created?: DateTimeWithAggregatesFilter<"tb_handed"> | Date | string
    hended_by?: IntWithAggregatesFilter<"tb_handed"> | number
    signed_page?: StringNullableWithAggregatesFilter<"tb_handed"> | string | null
  }

  export type tb_interWhereInput = {
    AND?: tb_interWhereInput | tb_interWhereInput[]
    OR?: tb_interWhereInput[]
    NOT?: tb_interWhereInput | tb_interWhereInput[]
    inter_id?: IntFilter<"tb_inter"> | number
    case_id?: IntFilter<"tb_inter"> | number
    author_id?: IntFilter<"tb_inter"> | number
    inter_status?: IntFilter<"tb_inter"> | number
    inter_reciever?: IntFilter<"tb_inter"> | number
    inter_type?: IntFilter<"tb_inter"> | number
    send_type?: IntFilter<"tb_inter"> | number
    out_num?: StringNullableFilter<"tb_inter"> | string | null
  }

  export type tb_interOrderByWithRelationInput = {
    inter_id?: SortOrder
    case_id?: SortOrder
    author_id?: SortOrder
    inter_status?: SortOrder
    inter_reciever?: SortOrder
    inter_type?: SortOrder
    send_type?: SortOrder
    out_num?: SortOrderInput | SortOrder
    _relevance?: tb_interOrderByRelevanceInput
  }

  export type tb_interWhereUniqueInput = Prisma.AtLeast<{
    inter_id?: number
    AND?: tb_interWhereInput | tb_interWhereInput[]
    OR?: tb_interWhereInput[]
    NOT?: tb_interWhereInput | tb_interWhereInput[]
    case_id?: IntFilter<"tb_inter"> | number
    author_id?: IntFilter<"tb_inter"> | number
    inter_status?: IntFilter<"tb_inter"> | number
    inter_reciever?: IntFilter<"tb_inter"> | number
    inter_type?: IntFilter<"tb_inter"> | number
    send_type?: IntFilter<"tb_inter"> | number
    out_num?: StringNullableFilter<"tb_inter"> | string | null
  }, "inter_id">

  export type tb_interOrderByWithAggregationInput = {
    inter_id?: SortOrder
    case_id?: SortOrder
    author_id?: SortOrder
    inter_status?: SortOrder
    inter_reciever?: SortOrder
    inter_type?: SortOrder
    send_type?: SortOrder
    out_num?: SortOrderInput | SortOrder
    _count?: tb_interCountOrderByAggregateInput
    _avg?: tb_interAvgOrderByAggregateInput
    _max?: tb_interMaxOrderByAggregateInput
    _min?: tb_interMinOrderByAggregateInput
    _sum?: tb_interSumOrderByAggregateInput
  }

  export type tb_interScalarWhereWithAggregatesInput = {
    AND?: tb_interScalarWhereWithAggregatesInput | tb_interScalarWhereWithAggregatesInput[]
    OR?: tb_interScalarWhereWithAggregatesInput[]
    NOT?: tb_interScalarWhereWithAggregatesInput | tb_interScalarWhereWithAggregatesInput[]
    inter_id?: IntWithAggregatesFilter<"tb_inter"> | number
    case_id?: IntWithAggregatesFilter<"tb_inter"> | number
    author_id?: IntWithAggregatesFilter<"tb_inter"> | number
    inter_status?: IntWithAggregatesFilter<"tb_inter"> | number
    inter_reciever?: IntWithAggregatesFilter<"tb_inter"> | number
    inter_type?: IntWithAggregatesFilter<"tb_inter"> | number
    send_type?: IntWithAggregatesFilter<"tb_inter"> | number
    out_num?: StringNullableWithAggregatesFilter<"tb_inter"> | string | null
  }

  export type tb_inter_notifiedWhereInput = {
    AND?: tb_inter_notifiedWhereInput | tb_inter_notifiedWhereInput[]
    OR?: tb_inter_notifiedWhereInput[]
    NOT?: tb_inter_notifiedWhereInput | tb_inter_notifiedWhereInput[]
    inter_notified_id?: IntFilter<"tb_inter_notified"> | number
    notified_date?: DateTimeNullableFilter<"tb_inter_notified"> | Date | string | null
    actioned?: DateTimeFilter<"tb_inter_notified"> | Date | string
    file_name?: StringNullableFilter<"tb_inter_notified"> | string | null
    inter_id?: IntFilter<"tb_inter_notified"> | number
    notification_status?: Enumtb_inter_notified_notification_statusNullableFilter<"tb_inter_notified"> | $Enums.tb_inter_notified_notification_status | null
  }

  export type tb_inter_notifiedOrderByWithRelationInput = {
    inter_notified_id?: SortOrder
    notified_date?: SortOrderInput | SortOrder
    actioned?: SortOrder
    file_name?: SortOrderInput | SortOrder
    inter_id?: SortOrder
    notification_status?: SortOrderInput | SortOrder
    _relevance?: tb_inter_notifiedOrderByRelevanceInput
  }

  export type tb_inter_notifiedWhereUniqueInput = Prisma.AtLeast<{
    inter_notified_id?: number
    AND?: tb_inter_notifiedWhereInput | tb_inter_notifiedWhereInput[]
    OR?: tb_inter_notifiedWhereInput[]
    NOT?: tb_inter_notifiedWhereInput | tb_inter_notifiedWhereInput[]
    notified_date?: DateTimeNullableFilter<"tb_inter_notified"> | Date | string | null
    actioned?: DateTimeFilter<"tb_inter_notified"> | Date | string
    file_name?: StringNullableFilter<"tb_inter_notified"> | string | null
    inter_id?: IntFilter<"tb_inter_notified"> | number
    notification_status?: Enumtb_inter_notified_notification_statusNullableFilter<"tb_inter_notified"> | $Enums.tb_inter_notified_notification_status | null
  }, "inter_notified_id">

  export type tb_inter_notifiedOrderByWithAggregationInput = {
    inter_notified_id?: SortOrder
    notified_date?: SortOrderInput | SortOrder
    actioned?: SortOrder
    file_name?: SortOrderInput | SortOrder
    inter_id?: SortOrder
    notification_status?: SortOrderInput | SortOrder
    _count?: tb_inter_notifiedCountOrderByAggregateInput
    _avg?: tb_inter_notifiedAvgOrderByAggregateInput
    _max?: tb_inter_notifiedMaxOrderByAggregateInput
    _min?: tb_inter_notifiedMinOrderByAggregateInput
    _sum?: tb_inter_notifiedSumOrderByAggregateInput
  }

  export type tb_inter_notifiedScalarWhereWithAggregatesInput = {
    AND?: tb_inter_notifiedScalarWhereWithAggregatesInput | tb_inter_notifiedScalarWhereWithAggregatesInput[]
    OR?: tb_inter_notifiedScalarWhereWithAggregatesInput[]
    NOT?: tb_inter_notifiedScalarWhereWithAggregatesInput | tb_inter_notifiedScalarWhereWithAggregatesInput[]
    inter_notified_id?: IntWithAggregatesFilter<"tb_inter_notified"> | number
    notified_date?: DateTimeNullableWithAggregatesFilter<"tb_inter_notified"> | Date | string | null
    actioned?: DateTimeWithAggregatesFilter<"tb_inter_notified"> | Date | string
    file_name?: StringNullableWithAggregatesFilter<"tb_inter_notified"> | string | null
    inter_id?: IntWithAggregatesFilter<"tb_inter_notified"> | number
    notification_status?: Enumtb_inter_notified_notification_statusNullableWithAggregatesFilter<"tb_inter_notified"> | $Enums.tb_inter_notified_notification_status | null
  }

  export type tb_inter_reciversWhereInput = {
    AND?: tb_inter_reciversWhereInput | tb_inter_reciversWhereInput[]
    OR?: tb_inter_reciversWhereInput[]
    NOT?: tb_inter_reciversWhereInput | tb_inter_reciversWhereInput[]
    inter_reciever_id?: IntFilter<"tb_inter_recivers"> | number
    inter_reciever_text?: StringFilter<"tb_inter_recivers"> | string
  }

  export type tb_inter_reciversOrderByWithRelationInput = {
    inter_reciever_id?: SortOrder
    inter_reciever_text?: SortOrder
    _relevance?: tb_inter_reciversOrderByRelevanceInput
  }

  export type tb_inter_reciversWhereUniqueInput = Prisma.AtLeast<{
    inter_reciever_id?: number
    AND?: tb_inter_reciversWhereInput | tb_inter_reciversWhereInput[]
    OR?: tb_inter_reciversWhereInput[]
    NOT?: tb_inter_reciversWhereInput | tb_inter_reciversWhereInput[]
    inter_reciever_text?: StringFilter<"tb_inter_recivers"> | string
  }, "inter_reciever_id">

  export type tb_inter_reciversOrderByWithAggregationInput = {
    inter_reciever_id?: SortOrder
    inter_reciever_text?: SortOrder
    _count?: tb_inter_reciversCountOrderByAggregateInput
    _avg?: tb_inter_reciversAvgOrderByAggregateInput
    _max?: tb_inter_reciversMaxOrderByAggregateInput
    _min?: tb_inter_reciversMinOrderByAggregateInput
    _sum?: tb_inter_reciversSumOrderByAggregateInput
  }

  export type tb_inter_reciversScalarWhereWithAggregatesInput = {
    AND?: tb_inter_reciversScalarWhereWithAggregatesInput | tb_inter_reciversScalarWhereWithAggregatesInput[]
    OR?: tb_inter_reciversScalarWhereWithAggregatesInput[]
    NOT?: tb_inter_reciversScalarWhereWithAggregatesInput | tb_inter_reciversScalarWhereWithAggregatesInput[]
    inter_reciever_id?: IntWithAggregatesFilter<"tb_inter_recivers"> | number
    inter_reciever_text?: StringWithAggregatesFilter<"tb_inter_recivers"> | string
  }

  export type tb_inter_send_typeWhereInput = {
    AND?: tb_inter_send_typeWhereInput | tb_inter_send_typeWhereInput[]
    OR?: tb_inter_send_typeWhereInput[]
    NOT?: tb_inter_send_typeWhereInput | tb_inter_send_typeWhereInput[]
    inter_send_type_id?: IntFilter<"tb_inter_send_type"> | number
    inter_send_type?: StringFilter<"tb_inter_send_type"> | string
  }

  export type tb_inter_send_typeOrderByWithRelationInput = {
    inter_send_type_id?: SortOrder
    inter_send_type?: SortOrder
    _relevance?: tb_inter_send_typeOrderByRelevanceInput
  }

  export type tb_inter_send_typeWhereUniqueInput = Prisma.AtLeast<{
    inter_send_type_id?: number
    AND?: tb_inter_send_typeWhereInput | tb_inter_send_typeWhereInput[]
    OR?: tb_inter_send_typeWhereInput[]
    NOT?: tb_inter_send_typeWhereInput | tb_inter_send_typeWhereInput[]
    inter_send_type?: StringFilter<"tb_inter_send_type"> | string
  }, "inter_send_type_id">

  export type tb_inter_send_typeOrderByWithAggregationInput = {
    inter_send_type_id?: SortOrder
    inter_send_type?: SortOrder
    _count?: tb_inter_send_typeCountOrderByAggregateInput
    _avg?: tb_inter_send_typeAvgOrderByAggregateInput
    _max?: tb_inter_send_typeMaxOrderByAggregateInput
    _min?: tb_inter_send_typeMinOrderByAggregateInput
    _sum?: tb_inter_send_typeSumOrderByAggregateInput
  }

  export type tb_inter_send_typeScalarWhereWithAggregatesInput = {
    AND?: tb_inter_send_typeScalarWhereWithAggregatesInput | tb_inter_send_typeScalarWhereWithAggregatesInput[]
    OR?: tb_inter_send_typeScalarWhereWithAggregatesInput[]
    NOT?: tb_inter_send_typeScalarWhereWithAggregatesInput | tb_inter_send_typeScalarWhereWithAggregatesInput[]
    inter_send_type_id?: IntWithAggregatesFilter<"tb_inter_send_type"> | number
    inter_send_type?: StringWithAggregatesFilter<"tb_inter_send_type"> | string
  }

  export type tb_inter_status_typesWhereInput = {
    AND?: tb_inter_status_typesWhereInput | tb_inter_status_typesWhereInput[]
    OR?: tb_inter_status_typesWhereInput[]
    NOT?: tb_inter_status_typesWhereInput | tb_inter_status_typesWhereInput[]
    id?: IntFilter<"tb_inter_status_types"> | number
    inter_status_type?: StringFilter<"tb_inter_status_types"> | string
  }

  export type tb_inter_status_typesOrderByWithRelationInput = {
    id?: SortOrder
    inter_status_type?: SortOrder
    _relevance?: tb_inter_status_typesOrderByRelevanceInput
  }

  export type tb_inter_status_typesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: tb_inter_status_typesWhereInput | tb_inter_status_typesWhereInput[]
    OR?: tb_inter_status_typesWhereInput[]
    NOT?: tb_inter_status_typesWhereInput | tb_inter_status_typesWhereInput[]
    inter_status_type?: StringFilter<"tb_inter_status_types"> | string
  }, "id">

  export type tb_inter_status_typesOrderByWithAggregationInput = {
    id?: SortOrder
    inter_status_type?: SortOrder
    _count?: tb_inter_status_typesCountOrderByAggregateInput
    _avg?: tb_inter_status_typesAvgOrderByAggregateInput
    _max?: tb_inter_status_typesMaxOrderByAggregateInput
    _min?: tb_inter_status_typesMinOrderByAggregateInput
    _sum?: tb_inter_status_typesSumOrderByAggregateInput
  }

  export type tb_inter_status_typesScalarWhereWithAggregatesInput = {
    AND?: tb_inter_status_typesScalarWhereWithAggregatesInput | tb_inter_status_typesScalarWhereWithAggregatesInput[]
    OR?: tb_inter_status_typesScalarWhereWithAggregatesInput[]
    NOT?: tb_inter_status_typesScalarWhereWithAggregatesInput | tb_inter_status_typesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"tb_inter_status_types"> | number
    inter_status_type?: StringWithAggregatesFilter<"tb_inter_status_types"> | string
  }

  export type tb_inter_typeWhereInput = {
    AND?: tb_inter_typeWhereInput | tb_inter_typeWhereInput[]
    OR?: tb_inter_typeWhereInput[]
    NOT?: tb_inter_typeWhereInput | tb_inter_typeWhereInput[]
    inter_type_id?: IntFilter<"tb_inter_type"> | number
    inter_type?: StringFilter<"tb_inter_type"> | string
  }

  export type tb_inter_typeOrderByWithRelationInput = {
    inter_type_id?: SortOrder
    inter_type?: SortOrder
    _relevance?: tb_inter_typeOrderByRelevanceInput
  }

  export type tb_inter_typeWhereUniqueInput = Prisma.AtLeast<{
    inter_type_id?: number
    AND?: tb_inter_typeWhereInput | tb_inter_typeWhereInput[]
    OR?: tb_inter_typeWhereInput[]
    NOT?: tb_inter_typeWhereInput | tb_inter_typeWhereInput[]
    inter_type?: StringFilter<"tb_inter_type"> | string
  }, "inter_type_id">

  export type tb_inter_typeOrderByWithAggregationInput = {
    inter_type_id?: SortOrder
    inter_type?: SortOrder
    _count?: tb_inter_typeCountOrderByAggregateInput
    _avg?: tb_inter_typeAvgOrderByAggregateInput
    _max?: tb_inter_typeMaxOrderByAggregateInput
    _min?: tb_inter_typeMinOrderByAggregateInput
    _sum?: tb_inter_typeSumOrderByAggregateInput
  }

  export type tb_inter_typeScalarWhereWithAggregatesInput = {
    AND?: tb_inter_typeScalarWhereWithAggregatesInput | tb_inter_typeScalarWhereWithAggregatesInput[]
    OR?: tb_inter_typeScalarWhereWithAggregatesInput[]
    NOT?: tb_inter_typeScalarWhereWithAggregatesInput | tb_inter_typeScalarWhereWithAggregatesInput[]
    inter_type_id?: IntWithAggregatesFilter<"tb_inter_type"> | number
    inter_type?: StringWithAggregatesFilter<"tb_inter_type"> | string
  }

  export type tb_lawyerWhereInput = {
    AND?: tb_lawyerWhereInput | tb_lawyerWhereInput[]
    OR?: tb_lawyerWhereInput[]
    NOT?: tb_lawyerWhereInput | tb_lawyerWhereInput[]
    lawyer_id?: IntFilter<"tb_lawyer"> | number
    lawyer_name?: StringFilter<"tb_lawyer"> | string
    lawyer_surname?: StringFilter<"tb_lawyer"> | string
    lawyer_organization?: StringNullableFilter<"tb_lawyer"> | string | null
    lawyer_tel?: StringNullableFilter<"tb_lawyer"> | string | null
    lawyer_address?: StringNullableFilter<"tb_lawyer"> | string | null
    lawyer_email?: StringNullableFilter<"tb_lawyer"> | string | null
    case_id?: IntFilter<"tb_lawyer"> | number
    actual?: IntNullableFilter<"tb_lawyer"> | number | null
  }

  export type tb_lawyerOrderByWithRelationInput = {
    lawyer_id?: SortOrder
    lawyer_name?: SortOrder
    lawyer_surname?: SortOrder
    lawyer_organization?: SortOrderInput | SortOrder
    lawyer_tel?: SortOrderInput | SortOrder
    lawyer_address?: SortOrderInput | SortOrder
    lawyer_email?: SortOrderInput | SortOrder
    case_id?: SortOrder
    actual?: SortOrderInput | SortOrder
    _relevance?: tb_lawyerOrderByRelevanceInput
  }

  export type tb_lawyerWhereUniqueInput = Prisma.AtLeast<{
    lawyer_id?: number
    AND?: tb_lawyerWhereInput | tb_lawyerWhereInput[]
    OR?: tb_lawyerWhereInput[]
    NOT?: tb_lawyerWhereInput | tb_lawyerWhereInput[]
    lawyer_name?: StringFilter<"tb_lawyer"> | string
    lawyer_surname?: StringFilter<"tb_lawyer"> | string
    lawyer_organization?: StringNullableFilter<"tb_lawyer"> | string | null
    lawyer_tel?: StringNullableFilter<"tb_lawyer"> | string | null
    lawyer_address?: StringNullableFilter<"tb_lawyer"> | string | null
    lawyer_email?: StringNullableFilter<"tb_lawyer"> | string | null
    case_id?: IntFilter<"tb_lawyer"> | number
    actual?: IntNullableFilter<"tb_lawyer"> | number | null
  }, "lawyer_id">

  export type tb_lawyerOrderByWithAggregationInput = {
    lawyer_id?: SortOrder
    lawyer_name?: SortOrder
    lawyer_surname?: SortOrder
    lawyer_organization?: SortOrderInput | SortOrder
    lawyer_tel?: SortOrderInput | SortOrder
    lawyer_address?: SortOrderInput | SortOrder
    lawyer_email?: SortOrderInput | SortOrder
    case_id?: SortOrder
    actual?: SortOrderInput | SortOrder
    _count?: tb_lawyerCountOrderByAggregateInput
    _avg?: tb_lawyerAvgOrderByAggregateInput
    _max?: tb_lawyerMaxOrderByAggregateInput
    _min?: tb_lawyerMinOrderByAggregateInput
    _sum?: tb_lawyerSumOrderByAggregateInput
  }

  export type tb_lawyerScalarWhereWithAggregatesInput = {
    AND?: tb_lawyerScalarWhereWithAggregatesInput | tb_lawyerScalarWhereWithAggregatesInput[]
    OR?: tb_lawyerScalarWhereWithAggregatesInput[]
    NOT?: tb_lawyerScalarWhereWithAggregatesInput | tb_lawyerScalarWhereWithAggregatesInput[]
    lawyer_id?: IntWithAggregatesFilter<"tb_lawyer"> | number
    lawyer_name?: StringWithAggregatesFilter<"tb_lawyer"> | string
    lawyer_surname?: StringWithAggregatesFilter<"tb_lawyer"> | string
    lawyer_organization?: StringNullableWithAggregatesFilter<"tb_lawyer"> | string | null
    lawyer_tel?: StringNullableWithAggregatesFilter<"tb_lawyer"> | string | null
    lawyer_address?: StringNullableWithAggregatesFilter<"tb_lawyer"> | string | null
    lawyer_email?: StringNullableWithAggregatesFilter<"tb_lawyer"> | string | null
    case_id?: IntWithAggregatesFilter<"tb_lawyer"> | number
    actual?: IntNullableWithAggregatesFilter<"tb_lawyer"> | number | null
  }

  export type tb_marzWhereInput = {
    AND?: tb_marzWhereInput | tb_marzWhereInput[]
    OR?: tb_marzWhereInput[]
    NOT?: tb_marzWhereInput | tb_marzWhereInput[]
    marz_id?: IntFilter<"tb_marz"> | number
    ADM1_ARM?: StringFilter<"tb_marz"> | string
    ADM1_EN?: StringFilter<"tb_marz"> | string
    ADM1_PCODE?: StringFilter<"tb_marz"> | string
  }

  export type tb_marzOrderByWithRelationInput = {
    marz_id?: SortOrder
    ADM1_ARM?: SortOrder
    ADM1_EN?: SortOrder
    ADM1_PCODE?: SortOrder
    _relevance?: tb_marzOrderByRelevanceInput
  }

  export type tb_marzWhereUniqueInput = Prisma.AtLeast<{
    marz_id?: number
    AND?: tb_marzWhereInput | tb_marzWhereInput[]
    OR?: tb_marzWhereInput[]
    NOT?: tb_marzWhereInput | tb_marzWhereInput[]
    ADM1_ARM?: StringFilter<"tb_marz"> | string
    ADM1_EN?: StringFilter<"tb_marz"> | string
    ADM1_PCODE?: StringFilter<"tb_marz"> | string
  }, "marz_id">

  export type tb_marzOrderByWithAggregationInput = {
    marz_id?: SortOrder
    ADM1_ARM?: SortOrder
    ADM1_EN?: SortOrder
    ADM1_PCODE?: SortOrder
    _count?: tb_marzCountOrderByAggregateInput
    _avg?: tb_marzAvgOrderByAggregateInput
    _max?: tb_marzMaxOrderByAggregateInput
    _min?: tb_marzMinOrderByAggregateInput
    _sum?: tb_marzSumOrderByAggregateInput
  }

  export type tb_marzScalarWhereWithAggregatesInput = {
    AND?: tb_marzScalarWhereWithAggregatesInput | tb_marzScalarWhereWithAggregatesInput[]
    OR?: tb_marzScalarWhereWithAggregatesInput[]
    NOT?: tb_marzScalarWhereWithAggregatesInput | tb_marzScalarWhereWithAggregatesInput[]
    marz_id?: IntWithAggregatesFilter<"tb_marz"> | number
    ADM1_ARM?: StringWithAggregatesFilter<"tb_marz"> | string
    ADM1_EN?: StringWithAggregatesFilter<"tb_marz"> | string
    ADM1_PCODE?: StringWithAggregatesFilter<"tb_marz"> | string
  }

  export type tb_membersWhereInput = {
    AND?: tb_membersWhereInput | tb_membersWhereInput[]
    OR?: tb_membersWhereInput[]
    NOT?: tb_membersWhereInput | tb_membersWhereInput[]
    member_id?: IntFilter<"tb_members"> | number
    case_id?: IntFilter<"tb_members"> | number
    f_name_arm?: StringFilter<"tb_members"> | string
    f_name_eng?: StringFilter<"tb_members"> | string
    l_name_arm?: StringFilter<"tb_members"> | string
    l_name_eng?: StringFilter<"tb_members"> | string
    m_name_arm?: StringNullableFilter<"tb_members"> | string | null
    m_name_eng?: StringNullableFilter<"tb_members"> | string | null
    b_day?: StringFilter<"tb_members"> | string
    b_month?: StringFilter<"tb_members"> | string
    b_year?: StringFilter<"tb_members"> | string
    sex?: IntFilter<"tb_members"> | number
    citizenship?: IntNullableFilter<"tb_members"> | number | null
    residence?: IntNullableFilter<"tb_members"> | number | null
    role?: IntFilter<"tb_members"> | number
  }

  export type tb_membersOrderByWithRelationInput = {
    member_id?: SortOrder
    case_id?: SortOrder
    f_name_arm?: SortOrder
    f_name_eng?: SortOrder
    l_name_arm?: SortOrder
    l_name_eng?: SortOrder
    m_name_arm?: SortOrderInput | SortOrder
    m_name_eng?: SortOrderInput | SortOrder
    b_day?: SortOrder
    b_month?: SortOrder
    b_year?: SortOrder
    sex?: SortOrder
    citizenship?: SortOrderInput | SortOrder
    residence?: SortOrderInput | SortOrder
    role?: SortOrder
    _relevance?: tb_membersOrderByRelevanceInput
  }

  export type tb_membersWhereUniqueInput = Prisma.AtLeast<{
    member_id?: number
    AND?: tb_membersWhereInput | tb_membersWhereInput[]
    OR?: tb_membersWhereInput[]
    NOT?: tb_membersWhereInput | tb_membersWhereInput[]
    case_id?: IntFilter<"tb_members"> | number
    f_name_arm?: StringFilter<"tb_members"> | string
    f_name_eng?: StringFilter<"tb_members"> | string
    l_name_arm?: StringFilter<"tb_members"> | string
    l_name_eng?: StringFilter<"tb_members"> | string
    m_name_arm?: StringNullableFilter<"tb_members"> | string | null
    m_name_eng?: StringNullableFilter<"tb_members"> | string | null
    b_day?: StringFilter<"tb_members"> | string
    b_month?: StringFilter<"tb_members"> | string
    b_year?: StringFilter<"tb_members"> | string
    sex?: IntFilter<"tb_members"> | number
    citizenship?: IntNullableFilter<"tb_members"> | number | null
    residence?: IntNullableFilter<"tb_members"> | number | null
    role?: IntFilter<"tb_members"> | number
  }, "member_id">

  export type tb_membersOrderByWithAggregationInput = {
    member_id?: SortOrder
    case_id?: SortOrder
    f_name_arm?: SortOrder
    f_name_eng?: SortOrder
    l_name_arm?: SortOrder
    l_name_eng?: SortOrder
    m_name_arm?: SortOrderInput | SortOrder
    m_name_eng?: SortOrderInput | SortOrder
    b_day?: SortOrder
    b_month?: SortOrder
    b_year?: SortOrder
    sex?: SortOrder
    citizenship?: SortOrderInput | SortOrder
    residence?: SortOrderInput | SortOrder
    role?: SortOrder
    _count?: tb_membersCountOrderByAggregateInput
    _avg?: tb_membersAvgOrderByAggregateInput
    _max?: tb_membersMaxOrderByAggregateInput
    _min?: tb_membersMinOrderByAggregateInput
    _sum?: tb_membersSumOrderByAggregateInput
  }

  export type tb_membersScalarWhereWithAggregatesInput = {
    AND?: tb_membersScalarWhereWithAggregatesInput | tb_membersScalarWhereWithAggregatesInput[]
    OR?: tb_membersScalarWhereWithAggregatesInput[]
    NOT?: tb_membersScalarWhereWithAggregatesInput | tb_membersScalarWhereWithAggregatesInput[]
    member_id?: IntWithAggregatesFilter<"tb_members"> | number
    case_id?: IntWithAggregatesFilter<"tb_members"> | number
    f_name_arm?: StringWithAggregatesFilter<"tb_members"> | string
    f_name_eng?: StringWithAggregatesFilter<"tb_members"> | string
    l_name_arm?: StringWithAggregatesFilter<"tb_members"> | string
    l_name_eng?: StringWithAggregatesFilter<"tb_members"> | string
    m_name_arm?: StringNullableWithAggregatesFilter<"tb_members"> | string | null
    m_name_eng?: StringNullableWithAggregatesFilter<"tb_members"> | string | null
    b_day?: StringWithAggregatesFilter<"tb_members"> | string
    b_month?: StringWithAggregatesFilter<"tb_members"> | string
    b_year?: StringWithAggregatesFilter<"tb_members"> | string
    sex?: IntWithAggregatesFilter<"tb_members"> | number
    citizenship?: IntNullableWithAggregatesFilter<"tb_members"> | number | null
    residence?: IntNullableWithAggregatesFilter<"tb_members"> | number | null
    role?: IntWithAggregatesFilter<"tb_members"> | number
  }

  export type tb_notificationsWhereInput = {
    AND?: tb_notificationsWhereInput | tb_notificationsWhereInput[]
    OR?: tb_notificationsWhereInput[]
    NOT?: tb_notificationsWhereInput | tb_notificationsWhereInput[]
    comment_id?: IntFilter<"tb_notifications"> | number
    comment_subject?: StringFilter<"tb_notifications"> | string
    comment_text?: StringNullableFilter<"tb_notifications"> | string | null
    comment_status?: IntFilter<"tb_notifications"> | number
    comment_from?: IntFilter<"tb_notifications"> | number
    comment_to?: IntFilter<"tb_notifications"> | number
    case_id?: IntNullableFilter<"tb_notifications"> | number | null
    coi_id?: IntNullableFilter<"tb_notifications"> | number | null
    request_id?: IntNullableFilter<"tb_notifications"> | number | null
    note_type?: IntNullableFilter<"tb_notifications"> | number | null
    draft_id?: IntNullableFilter<"tb_notifications"> | number | null
    order_id?: IntNullableFilter<"tb_notifications"> | number | null
    readed?: IntNullableFilter<"tb_notifications"> | number | null
    note_date?: DateTimeFilter<"tb_notifications"> | Date | string
    msg_read?: IntFilter<"tb_notifications"> | number
  }

  export type tb_notificationsOrderByWithRelationInput = {
    comment_id?: SortOrder
    comment_subject?: SortOrder
    comment_text?: SortOrderInput | SortOrder
    comment_status?: SortOrder
    comment_from?: SortOrder
    comment_to?: SortOrder
    case_id?: SortOrderInput | SortOrder
    coi_id?: SortOrderInput | SortOrder
    request_id?: SortOrderInput | SortOrder
    note_type?: SortOrderInput | SortOrder
    draft_id?: SortOrderInput | SortOrder
    order_id?: SortOrderInput | SortOrder
    readed?: SortOrderInput | SortOrder
    note_date?: SortOrder
    msg_read?: SortOrder
    _relevance?: tb_notificationsOrderByRelevanceInput
  }

  export type tb_notificationsWhereUniqueInput = Prisma.AtLeast<{
    comment_id?: number
    AND?: tb_notificationsWhereInput | tb_notificationsWhereInput[]
    OR?: tb_notificationsWhereInput[]
    NOT?: tb_notificationsWhereInput | tb_notificationsWhereInput[]
    comment_subject?: StringFilter<"tb_notifications"> | string
    comment_text?: StringNullableFilter<"tb_notifications"> | string | null
    comment_status?: IntFilter<"tb_notifications"> | number
    comment_from?: IntFilter<"tb_notifications"> | number
    comment_to?: IntFilter<"tb_notifications"> | number
    case_id?: IntNullableFilter<"tb_notifications"> | number | null
    coi_id?: IntNullableFilter<"tb_notifications"> | number | null
    request_id?: IntNullableFilter<"tb_notifications"> | number | null
    note_type?: IntNullableFilter<"tb_notifications"> | number | null
    draft_id?: IntNullableFilter<"tb_notifications"> | number | null
    order_id?: IntNullableFilter<"tb_notifications"> | number | null
    readed?: IntNullableFilter<"tb_notifications"> | number | null
    note_date?: DateTimeFilter<"tb_notifications"> | Date | string
    msg_read?: IntFilter<"tb_notifications"> | number
  }, "comment_id">

  export type tb_notificationsOrderByWithAggregationInput = {
    comment_id?: SortOrder
    comment_subject?: SortOrder
    comment_text?: SortOrderInput | SortOrder
    comment_status?: SortOrder
    comment_from?: SortOrder
    comment_to?: SortOrder
    case_id?: SortOrderInput | SortOrder
    coi_id?: SortOrderInput | SortOrder
    request_id?: SortOrderInput | SortOrder
    note_type?: SortOrderInput | SortOrder
    draft_id?: SortOrderInput | SortOrder
    order_id?: SortOrderInput | SortOrder
    readed?: SortOrderInput | SortOrder
    note_date?: SortOrder
    msg_read?: SortOrder
    _count?: tb_notificationsCountOrderByAggregateInput
    _avg?: tb_notificationsAvgOrderByAggregateInput
    _max?: tb_notificationsMaxOrderByAggregateInput
    _min?: tb_notificationsMinOrderByAggregateInput
    _sum?: tb_notificationsSumOrderByAggregateInput
  }

  export type tb_notificationsScalarWhereWithAggregatesInput = {
    AND?: tb_notificationsScalarWhereWithAggregatesInput | tb_notificationsScalarWhereWithAggregatesInput[]
    OR?: tb_notificationsScalarWhereWithAggregatesInput[]
    NOT?: tb_notificationsScalarWhereWithAggregatesInput | tb_notificationsScalarWhereWithAggregatesInput[]
    comment_id?: IntWithAggregatesFilter<"tb_notifications"> | number
    comment_subject?: StringWithAggregatesFilter<"tb_notifications"> | string
    comment_text?: StringNullableWithAggregatesFilter<"tb_notifications"> | string | null
    comment_status?: IntWithAggregatesFilter<"tb_notifications"> | number
    comment_from?: IntWithAggregatesFilter<"tb_notifications"> | number
    comment_to?: IntWithAggregatesFilter<"tb_notifications"> | number
    case_id?: IntNullableWithAggregatesFilter<"tb_notifications"> | number | null
    coi_id?: IntNullableWithAggregatesFilter<"tb_notifications"> | number | null
    request_id?: IntNullableWithAggregatesFilter<"tb_notifications"> | number | null
    note_type?: IntNullableWithAggregatesFilter<"tb_notifications"> | number | null
    draft_id?: IntNullableWithAggregatesFilter<"tb_notifications"> | number | null
    order_id?: IntNullableWithAggregatesFilter<"tb_notifications"> | number | null
    readed?: IntNullableWithAggregatesFilter<"tb_notifications"> | number | null
    note_date?: DateTimeWithAggregatesFilter<"tb_notifications"> | Date | string
    msg_read?: IntWithAggregatesFilter<"tb_notifications"> | number
  }

  export type tb_ordersWhereInput = {
    AND?: tb_ordersWhereInput | tb_ordersWhereInput[]
    OR?: tb_ordersWhereInput[]
    NOT?: tb_ordersWhereInput | tb_ordersWhereInput[]
    order_id?: IntFilter<"tb_orders"> | number
    case_id?: IntFilter<"tb_orders"> | number
    order_status?: IntFilter<"tb_orders"> | number
    date?: DateTimeFilter<"tb_orders"> | Date | string
  }

  export type tb_ordersOrderByWithRelationInput = {
    order_id?: SortOrder
    case_id?: SortOrder
    order_status?: SortOrder
    date?: SortOrder
  }

  export type tb_ordersWhereUniqueInput = Prisma.AtLeast<{
    order_id?: number
    AND?: tb_ordersWhereInput | tb_ordersWhereInput[]
    OR?: tb_ordersWhereInput[]
    NOT?: tb_ordersWhereInput | tb_ordersWhereInput[]
    case_id?: IntFilter<"tb_orders"> | number
    order_status?: IntFilter<"tb_orders"> | number
    date?: DateTimeFilter<"tb_orders"> | Date | string
  }, "order_id">

  export type tb_ordersOrderByWithAggregationInput = {
    order_id?: SortOrder
    case_id?: SortOrder
    order_status?: SortOrder
    date?: SortOrder
    _count?: tb_ordersCountOrderByAggregateInput
    _avg?: tb_ordersAvgOrderByAggregateInput
    _max?: tb_ordersMaxOrderByAggregateInput
    _min?: tb_ordersMinOrderByAggregateInput
    _sum?: tb_ordersSumOrderByAggregateInput
  }

  export type tb_ordersScalarWhereWithAggregatesInput = {
    AND?: tb_ordersScalarWhereWithAggregatesInput | tb_ordersScalarWhereWithAggregatesInput[]
    OR?: tb_ordersScalarWhereWithAggregatesInput[]
    NOT?: tb_ordersScalarWhereWithAggregatesInput | tb_ordersScalarWhereWithAggregatesInput[]
    order_id?: IntWithAggregatesFilter<"tb_orders"> | number
    case_id?: IntWithAggregatesFilter<"tb_orders"> | number
    order_status?: IntWithAggregatesFilter<"tb_orders"> | number
    date?: DateTimeWithAggregatesFilter<"tb_orders"> | Date | string
  }

  export type tb_personWhereInput = {
    AND?: tb_personWhereInput | tb_personWhereInput[]
    OR?: tb_personWhereInput[]
    NOT?: tb_personWhereInput | tb_personWhereInput[]
    personal_id?: IntFilter<"tb_person"> | number
    case_id?: IntFilter<"tb_person"> | number
    f_name_arm?: StringFilter<"tb_person"> | string
    f_name_eng?: StringFilter<"tb_person"> | string
    l_name_arm?: StringFilter<"tb_person"> | string
    l_name_eng?: StringFilter<"tb_person"> | string
    m_name_arm?: StringNullableFilter<"tb_person"> | string | null
    m_name_eng?: StringNullableFilter<"tb_person"> | string | null
    b_day?: StringFilter<"tb_person"> | string
    b_month?: StringFilter<"tb_person"> | string
    b_year?: StringFilter<"tb_person"> | string
    sex?: IntFilter<"tb_person"> | number
    citizenship?: IntFilter<"tb_person"> | number
    previous_residence?: IntNullableFilter<"tb_person"> | number | null
    citizen_adr?: StringNullableFilter<"tb_person"> | string | null
    residence_adr?: StringNullableFilter<"tb_person"> | string | null
    departure_from_citizen?: StringNullableFilter<"tb_person"> | string | null
    departure_from_residence?: StringNullableFilter<"tb_person"> | string | null
    arrival_date?: DateTimeNullableFilter<"tb_person"> | Date | string | null
    doc_num?: StringNullableFilter<"tb_person"> | string | null
    etnicity?: IntNullableFilter<"tb_person"> | number | null
    religion?: IntNullableFilter<"tb_person"> | number | null
    preferred_traslator_sex?: IntFilter<"tb_person"> | number
    preferred_interviewer_sex?: IntFilter<"tb_person"> | number
    invalid?: IntFilter<"tb_person"> | number
    pregnant?: IntFilter<"tb_person"> | number
    seriously_ill?: IntFilter<"tb_person"> | number
    trafficking_victim?: IntFilter<"tb_person"> | number
    violence_victim?: IntFilter<"tb_person"> | number
    comment?: StringNullableFilter<"tb_person"> | string | null
    illegal_border?: IntFilter<"tb_person"> | number
    transfer_moj?: IntFilter<"tb_person"> | number
    deport_prescurator?: IntFilter<"tb_person"> | number
    prison?: IntNullableFilter<"tb_person"> | number | null
    role?: IntFilter<"tb_person"> | number
    image?: StringNullableFilter<"tb_person"> | string | null
    person_status?: IntFilter<"tb_person"> | number
    ident?: IntFilter<"tb_person"> | number
    pnum?: StringNullableFilter<"tb_person"> | string | null
    doc_type?: StringNullableFilter<"tb_person"> | string | null
    document_num?: StringNullableFilter<"tb_person"> | string | null
    doc_issued_date?: DateTimeNullableFilter<"tb_person"> | Date | string | null
    doc_valid?: DateTimeNullableFilter<"tb_person"> | Date | string | null
    doc_issued_by?: StringNullableFilter<"tb_person"> | string | null
    bpr_community?: StringNullableFilter<"tb_person"> | string | null
    bpr_bnakavayr?: StringNullableFilter<"tb_person"> | string | null
    bpr_street?: StringNullableFilter<"tb_person"> | string | null
    bpr_house?: StringNullableFilter<"tb_person"> | string | null
    bpr_aprt?: StringNullableFilter<"tb_person"> | string | null
    created_at?: DateTimeFilter<"tb_person"> | Date | string
    updated_at?: DateTimeFilter<"tb_person"> | Date | string
  }

  export type tb_personOrderByWithRelationInput = {
    personal_id?: SortOrder
    case_id?: SortOrder
    f_name_arm?: SortOrder
    f_name_eng?: SortOrder
    l_name_arm?: SortOrder
    l_name_eng?: SortOrder
    m_name_arm?: SortOrderInput | SortOrder
    m_name_eng?: SortOrderInput | SortOrder
    b_day?: SortOrder
    b_month?: SortOrder
    b_year?: SortOrder
    sex?: SortOrder
    citizenship?: SortOrder
    previous_residence?: SortOrderInput | SortOrder
    citizen_adr?: SortOrderInput | SortOrder
    residence_adr?: SortOrderInput | SortOrder
    departure_from_citizen?: SortOrderInput | SortOrder
    departure_from_residence?: SortOrderInput | SortOrder
    arrival_date?: SortOrderInput | SortOrder
    doc_num?: SortOrderInput | SortOrder
    etnicity?: SortOrderInput | SortOrder
    religion?: SortOrderInput | SortOrder
    preferred_traslator_sex?: SortOrder
    preferred_interviewer_sex?: SortOrder
    invalid?: SortOrder
    pregnant?: SortOrder
    seriously_ill?: SortOrder
    trafficking_victim?: SortOrder
    violence_victim?: SortOrder
    comment?: SortOrderInput | SortOrder
    illegal_border?: SortOrder
    transfer_moj?: SortOrder
    deport_prescurator?: SortOrder
    prison?: SortOrderInput | SortOrder
    role?: SortOrder
    image?: SortOrderInput | SortOrder
    person_status?: SortOrder
    ident?: SortOrder
    pnum?: SortOrderInput | SortOrder
    doc_type?: SortOrderInput | SortOrder
    document_num?: SortOrderInput | SortOrder
    doc_issued_date?: SortOrderInput | SortOrder
    doc_valid?: SortOrderInput | SortOrder
    doc_issued_by?: SortOrderInput | SortOrder
    bpr_community?: SortOrderInput | SortOrder
    bpr_bnakavayr?: SortOrderInput | SortOrder
    bpr_street?: SortOrderInput | SortOrder
    bpr_house?: SortOrderInput | SortOrder
    bpr_aprt?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _relevance?: tb_personOrderByRelevanceInput
  }

  export type tb_personWhereUniqueInput = Prisma.AtLeast<{
    personal_id?: number
    AND?: tb_personWhereInput | tb_personWhereInput[]
    OR?: tb_personWhereInput[]
    NOT?: tb_personWhereInput | tb_personWhereInput[]
    case_id?: IntFilter<"tb_person"> | number
    f_name_arm?: StringFilter<"tb_person"> | string
    f_name_eng?: StringFilter<"tb_person"> | string
    l_name_arm?: StringFilter<"tb_person"> | string
    l_name_eng?: StringFilter<"tb_person"> | string
    m_name_arm?: StringNullableFilter<"tb_person"> | string | null
    m_name_eng?: StringNullableFilter<"tb_person"> | string | null
    b_day?: StringFilter<"tb_person"> | string
    b_month?: StringFilter<"tb_person"> | string
    b_year?: StringFilter<"tb_person"> | string
    sex?: IntFilter<"tb_person"> | number
    citizenship?: IntFilter<"tb_person"> | number
    previous_residence?: IntNullableFilter<"tb_person"> | number | null
    citizen_adr?: StringNullableFilter<"tb_person"> | string | null
    residence_adr?: StringNullableFilter<"tb_person"> | string | null
    departure_from_citizen?: StringNullableFilter<"tb_person"> | string | null
    departure_from_residence?: StringNullableFilter<"tb_person"> | string | null
    arrival_date?: DateTimeNullableFilter<"tb_person"> | Date | string | null
    doc_num?: StringNullableFilter<"tb_person"> | string | null
    etnicity?: IntNullableFilter<"tb_person"> | number | null
    religion?: IntNullableFilter<"tb_person"> | number | null
    preferred_traslator_sex?: IntFilter<"tb_person"> | number
    preferred_interviewer_sex?: IntFilter<"tb_person"> | number
    invalid?: IntFilter<"tb_person"> | number
    pregnant?: IntFilter<"tb_person"> | number
    seriously_ill?: IntFilter<"tb_person"> | number
    trafficking_victim?: IntFilter<"tb_person"> | number
    violence_victim?: IntFilter<"tb_person"> | number
    comment?: StringNullableFilter<"tb_person"> | string | null
    illegal_border?: IntFilter<"tb_person"> | number
    transfer_moj?: IntFilter<"tb_person"> | number
    deport_prescurator?: IntFilter<"tb_person"> | number
    prison?: IntNullableFilter<"tb_person"> | number | null
    role?: IntFilter<"tb_person"> | number
    image?: StringNullableFilter<"tb_person"> | string | null
    person_status?: IntFilter<"tb_person"> | number
    ident?: IntFilter<"tb_person"> | number
    pnum?: StringNullableFilter<"tb_person"> | string | null
    doc_type?: StringNullableFilter<"tb_person"> | string | null
    document_num?: StringNullableFilter<"tb_person"> | string | null
    doc_issued_date?: DateTimeNullableFilter<"tb_person"> | Date | string | null
    doc_valid?: DateTimeNullableFilter<"tb_person"> | Date | string | null
    doc_issued_by?: StringNullableFilter<"tb_person"> | string | null
    bpr_community?: StringNullableFilter<"tb_person"> | string | null
    bpr_bnakavayr?: StringNullableFilter<"tb_person"> | string | null
    bpr_street?: StringNullableFilter<"tb_person"> | string | null
    bpr_house?: StringNullableFilter<"tb_person"> | string | null
    bpr_aprt?: StringNullableFilter<"tb_person"> | string | null
    created_at?: DateTimeFilter<"tb_person"> | Date | string
    updated_at?: DateTimeFilter<"tb_person"> | Date | string
  }, "personal_id">

  export type tb_personOrderByWithAggregationInput = {
    personal_id?: SortOrder
    case_id?: SortOrder
    f_name_arm?: SortOrder
    f_name_eng?: SortOrder
    l_name_arm?: SortOrder
    l_name_eng?: SortOrder
    m_name_arm?: SortOrderInput | SortOrder
    m_name_eng?: SortOrderInput | SortOrder
    b_day?: SortOrder
    b_month?: SortOrder
    b_year?: SortOrder
    sex?: SortOrder
    citizenship?: SortOrder
    previous_residence?: SortOrderInput | SortOrder
    citizen_adr?: SortOrderInput | SortOrder
    residence_adr?: SortOrderInput | SortOrder
    departure_from_citizen?: SortOrderInput | SortOrder
    departure_from_residence?: SortOrderInput | SortOrder
    arrival_date?: SortOrderInput | SortOrder
    doc_num?: SortOrderInput | SortOrder
    etnicity?: SortOrderInput | SortOrder
    religion?: SortOrderInput | SortOrder
    preferred_traslator_sex?: SortOrder
    preferred_interviewer_sex?: SortOrder
    invalid?: SortOrder
    pregnant?: SortOrder
    seriously_ill?: SortOrder
    trafficking_victim?: SortOrder
    violence_victim?: SortOrder
    comment?: SortOrderInput | SortOrder
    illegal_border?: SortOrder
    transfer_moj?: SortOrder
    deport_prescurator?: SortOrder
    prison?: SortOrderInput | SortOrder
    role?: SortOrder
    image?: SortOrderInput | SortOrder
    person_status?: SortOrder
    ident?: SortOrder
    pnum?: SortOrderInput | SortOrder
    doc_type?: SortOrderInput | SortOrder
    document_num?: SortOrderInput | SortOrder
    doc_issued_date?: SortOrderInput | SortOrder
    doc_valid?: SortOrderInput | SortOrder
    doc_issued_by?: SortOrderInput | SortOrder
    bpr_community?: SortOrderInput | SortOrder
    bpr_bnakavayr?: SortOrderInput | SortOrder
    bpr_street?: SortOrderInput | SortOrder
    bpr_house?: SortOrderInput | SortOrder
    bpr_aprt?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: tb_personCountOrderByAggregateInput
    _avg?: tb_personAvgOrderByAggregateInput
    _max?: tb_personMaxOrderByAggregateInput
    _min?: tb_personMinOrderByAggregateInput
    _sum?: tb_personSumOrderByAggregateInput
  }

  export type tb_personScalarWhereWithAggregatesInput = {
    AND?: tb_personScalarWhereWithAggregatesInput | tb_personScalarWhereWithAggregatesInput[]
    OR?: tb_personScalarWhereWithAggregatesInput[]
    NOT?: tb_personScalarWhereWithAggregatesInput | tb_personScalarWhereWithAggregatesInput[]
    personal_id?: IntWithAggregatesFilter<"tb_person"> | number
    case_id?: IntWithAggregatesFilter<"tb_person"> | number
    f_name_arm?: StringWithAggregatesFilter<"tb_person"> | string
    f_name_eng?: StringWithAggregatesFilter<"tb_person"> | string
    l_name_arm?: StringWithAggregatesFilter<"tb_person"> | string
    l_name_eng?: StringWithAggregatesFilter<"tb_person"> | string
    m_name_arm?: StringNullableWithAggregatesFilter<"tb_person"> | string | null
    m_name_eng?: StringNullableWithAggregatesFilter<"tb_person"> | string | null
    b_day?: StringWithAggregatesFilter<"tb_person"> | string
    b_month?: StringWithAggregatesFilter<"tb_person"> | string
    b_year?: StringWithAggregatesFilter<"tb_person"> | string
    sex?: IntWithAggregatesFilter<"tb_person"> | number
    citizenship?: IntWithAggregatesFilter<"tb_person"> | number
    previous_residence?: IntNullableWithAggregatesFilter<"tb_person"> | number | null
    citizen_adr?: StringNullableWithAggregatesFilter<"tb_person"> | string | null
    residence_adr?: StringNullableWithAggregatesFilter<"tb_person"> | string | null
    departure_from_citizen?: StringNullableWithAggregatesFilter<"tb_person"> | string | null
    departure_from_residence?: StringNullableWithAggregatesFilter<"tb_person"> | string | null
    arrival_date?: DateTimeNullableWithAggregatesFilter<"tb_person"> | Date | string | null
    doc_num?: StringNullableWithAggregatesFilter<"tb_person"> | string | null
    etnicity?: IntNullableWithAggregatesFilter<"tb_person"> | number | null
    religion?: IntNullableWithAggregatesFilter<"tb_person"> | number | null
    preferred_traslator_sex?: IntWithAggregatesFilter<"tb_person"> | number
    preferred_interviewer_sex?: IntWithAggregatesFilter<"tb_person"> | number
    invalid?: IntWithAggregatesFilter<"tb_person"> | number
    pregnant?: IntWithAggregatesFilter<"tb_person"> | number
    seriously_ill?: IntWithAggregatesFilter<"tb_person"> | number
    trafficking_victim?: IntWithAggregatesFilter<"tb_person"> | number
    violence_victim?: IntWithAggregatesFilter<"tb_person"> | number
    comment?: StringNullableWithAggregatesFilter<"tb_person"> | string | null
    illegal_border?: IntWithAggregatesFilter<"tb_person"> | number
    transfer_moj?: IntWithAggregatesFilter<"tb_person"> | number
    deport_prescurator?: IntWithAggregatesFilter<"tb_person"> | number
    prison?: IntNullableWithAggregatesFilter<"tb_person"> | number | null
    role?: IntWithAggregatesFilter<"tb_person"> | number
    image?: StringNullableWithAggregatesFilter<"tb_person"> | string | null
    person_status?: IntWithAggregatesFilter<"tb_person"> | number
    ident?: IntWithAggregatesFilter<"tb_person"> | number
    pnum?: StringNullableWithAggregatesFilter<"tb_person"> | string | null
    doc_type?: StringNullableWithAggregatesFilter<"tb_person"> | string | null
    document_num?: StringNullableWithAggregatesFilter<"tb_person"> | string | null
    doc_issued_date?: DateTimeNullableWithAggregatesFilter<"tb_person"> | Date | string | null
    doc_valid?: DateTimeNullableWithAggregatesFilter<"tb_person"> | Date | string | null
    doc_issued_by?: StringNullableWithAggregatesFilter<"tb_person"> | string | null
    bpr_community?: StringNullableWithAggregatesFilter<"tb_person"> | string | null
    bpr_bnakavayr?: StringNullableWithAggregatesFilter<"tb_person"> | string | null
    bpr_street?: StringNullableWithAggregatesFilter<"tb_person"> | string | null
    bpr_house?: StringNullableWithAggregatesFilter<"tb_person"> | string | null
    bpr_aprt?: StringNullableWithAggregatesFilter<"tb_person"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"tb_person"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"tb_person"> | Date | string
  }

  export type tb_person_statusWhereInput = {
    AND?: tb_person_statusWhereInput | tb_person_statusWhereInput[]
    OR?: tb_person_statusWhereInput[]
    NOT?: tb_person_statusWhereInput | tb_person_statusWhereInput[]
    person_status_id?: IntFilter<"tb_person_status"> | number
    person_status?: StringFilter<"tb_person_status"> | string
    person_status_eng?: StringNullableFilter<"tb_person_status"> | string | null
  }

  export type tb_person_statusOrderByWithRelationInput = {
    person_status_id?: SortOrder
    person_status?: SortOrder
    person_status_eng?: SortOrderInput | SortOrder
    _relevance?: tb_person_statusOrderByRelevanceInput
  }

  export type tb_person_statusWhereUniqueInput = Prisma.AtLeast<{
    person_status_id?: number
    AND?: tb_person_statusWhereInput | tb_person_statusWhereInput[]
    OR?: tb_person_statusWhereInput[]
    NOT?: tb_person_statusWhereInput | tb_person_statusWhereInput[]
    person_status?: StringFilter<"tb_person_status"> | string
    person_status_eng?: StringNullableFilter<"tb_person_status"> | string | null
  }, "person_status_id">

  export type tb_person_statusOrderByWithAggregationInput = {
    person_status_id?: SortOrder
    person_status?: SortOrder
    person_status_eng?: SortOrderInput | SortOrder
    _count?: tb_person_statusCountOrderByAggregateInput
    _avg?: tb_person_statusAvgOrderByAggregateInput
    _max?: tb_person_statusMaxOrderByAggregateInput
    _min?: tb_person_statusMinOrderByAggregateInput
    _sum?: tb_person_statusSumOrderByAggregateInput
  }

  export type tb_person_statusScalarWhereWithAggregatesInput = {
    AND?: tb_person_statusScalarWhereWithAggregatesInput | tb_person_statusScalarWhereWithAggregatesInput[]
    OR?: tb_person_statusScalarWhereWithAggregatesInput[]
    NOT?: tb_person_statusScalarWhereWithAggregatesInput | tb_person_statusScalarWhereWithAggregatesInput[]
    person_status_id?: IntWithAggregatesFilter<"tb_person_status"> | number
    person_status?: StringWithAggregatesFilter<"tb_person_status"> | string
    person_status_eng?: StringNullableWithAggregatesFilter<"tb_person_status"> | string | null
  }

  export type tb_processWhereInput = {
    AND?: tb_processWhereInput | tb_processWhereInput[]
    OR?: tb_processWhereInput[]
    NOT?: tb_processWhereInput | tb_processWhereInput[]
    process_id?: IntFilter<"tb_process"> | number
    process_type_id?: IntFilter<"tb_process"> | number
    case_id?: IntFilter<"tb_process"> | number
    draft_id?: IntNullableFilter<"tb_process"> | number | null
    coi_id?: IntNullableFilter<"tb_process"> | number | null
    request_id?: IntNullableFilter<"tb_process"> | number | null
    order_id?: IntNullableFilter<"tb_process"> | number | null
    decision_id?: IntNullableFilter<"tb_process"> | number | null
    notification_id?: IntNullableFilter<"tb_process"> | number | null
    sign_status?: IntFilter<"tb_process"> | number
    sign_date?: DateTimeFilter<"tb_process"> | Date | string
    sign_by?: IntFilter<"tb_process"> | number
    processor?: IntFilter<"tb_process"> | number
    comment_to?: StringNullableFilter<"tb_process"> | string | null
    actual?: IntFilter<"tb_process"> | number
    comment_status?: IntFilter<"tb_process"> | number
    out_num?: StringNullableFilter<"tb_process"> | string | null
  }

  export type tb_processOrderByWithRelationInput = {
    process_id?: SortOrder
    process_type_id?: SortOrder
    case_id?: SortOrder
    draft_id?: SortOrderInput | SortOrder
    coi_id?: SortOrderInput | SortOrder
    request_id?: SortOrderInput | SortOrder
    order_id?: SortOrderInput | SortOrder
    decision_id?: SortOrderInput | SortOrder
    notification_id?: SortOrderInput | SortOrder
    sign_status?: SortOrder
    sign_date?: SortOrder
    sign_by?: SortOrder
    processor?: SortOrder
    comment_to?: SortOrderInput | SortOrder
    actual?: SortOrder
    comment_status?: SortOrder
    out_num?: SortOrderInput | SortOrder
    _relevance?: tb_processOrderByRelevanceInput
  }

  export type tb_processWhereUniqueInput = Prisma.AtLeast<{
    process_id?: number
    AND?: tb_processWhereInput | tb_processWhereInput[]
    OR?: tb_processWhereInput[]
    NOT?: tb_processWhereInput | tb_processWhereInput[]
    process_type_id?: IntFilter<"tb_process"> | number
    case_id?: IntFilter<"tb_process"> | number
    draft_id?: IntNullableFilter<"tb_process"> | number | null
    coi_id?: IntNullableFilter<"tb_process"> | number | null
    request_id?: IntNullableFilter<"tb_process"> | number | null
    order_id?: IntNullableFilter<"tb_process"> | number | null
    decision_id?: IntNullableFilter<"tb_process"> | number | null
    notification_id?: IntNullableFilter<"tb_process"> | number | null
    sign_status?: IntFilter<"tb_process"> | number
    sign_date?: DateTimeFilter<"tb_process"> | Date | string
    sign_by?: IntFilter<"tb_process"> | number
    processor?: IntFilter<"tb_process"> | number
    comment_to?: StringNullableFilter<"tb_process"> | string | null
    actual?: IntFilter<"tb_process"> | number
    comment_status?: IntFilter<"tb_process"> | number
    out_num?: StringNullableFilter<"tb_process"> | string | null
  }, "process_id">

  export type tb_processOrderByWithAggregationInput = {
    process_id?: SortOrder
    process_type_id?: SortOrder
    case_id?: SortOrder
    draft_id?: SortOrderInput | SortOrder
    coi_id?: SortOrderInput | SortOrder
    request_id?: SortOrderInput | SortOrder
    order_id?: SortOrderInput | SortOrder
    decision_id?: SortOrderInput | SortOrder
    notification_id?: SortOrderInput | SortOrder
    sign_status?: SortOrder
    sign_date?: SortOrder
    sign_by?: SortOrder
    processor?: SortOrder
    comment_to?: SortOrderInput | SortOrder
    actual?: SortOrder
    comment_status?: SortOrder
    out_num?: SortOrderInput | SortOrder
    _count?: tb_processCountOrderByAggregateInput
    _avg?: tb_processAvgOrderByAggregateInput
    _max?: tb_processMaxOrderByAggregateInput
    _min?: tb_processMinOrderByAggregateInput
    _sum?: tb_processSumOrderByAggregateInput
  }

  export type tb_processScalarWhereWithAggregatesInput = {
    AND?: tb_processScalarWhereWithAggregatesInput | tb_processScalarWhereWithAggregatesInput[]
    OR?: tb_processScalarWhereWithAggregatesInput[]
    NOT?: tb_processScalarWhereWithAggregatesInput | tb_processScalarWhereWithAggregatesInput[]
    process_id?: IntWithAggregatesFilter<"tb_process"> | number
    process_type_id?: IntWithAggregatesFilter<"tb_process"> | number
    case_id?: IntWithAggregatesFilter<"tb_process"> | number
    draft_id?: IntNullableWithAggregatesFilter<"tb_process"> | number | null
    coi_id?: IntNullableWithAggregatesFilter<"tb_process"> | number | null
    request_id?: IntNullableWithAggregatesFilter<"tb_process"> | number | null
    order_id?: IntNullableWithAggregatesFilter<"tb_process"> | number | null
    decision_id?: IntNullableWithAggregatesFilter<"tb_process"> | number | null
    notification_id?: IntNullableWithAggregatesFilter<"tb_process"> | number | null
    sign_status?: IntWithAggregatesFilter<"tb_process"> | number
    sign_date?: DateTimeWithAggregatesFilter<"tb_process"> | Date | string
    sign_by?: IntWithAggregatesFilter<"tb_process"> | number
    processor?: IntWithAggregatesFilter<"tb_process"> | number
    comment_to?: StringNullableWithAggregatesFilter<"tb_process"> | string | null
    actual?: IntWithAggregatesFilter<"tb_process"> | number
    comment_status?: IntWithAggregatesFilter<"tb_process"> | number
    out_num?: StringNullableWithAggregatesFilter<"tb_process"> | string | null
  }

  export type tb_process_typeWhereInput = {
    AND?: tb_process_typeWhereInput | tb_process_typeWhereInput[]
    OR?: tb_process_typeWhereInput[]
    NOT?: tb_process_typeWhereInput | tb_process_typeWhereInput[]
    process_type_id?: IntFilter<"tb_process_type"> | number
    process_type?: StringFilter<"tb_process_type"> | string
  }

  export type tb_process_typeOrderByWithRelationInput = {
    process_type_id?: SortOrder
    process_type?: SortOrder
    _relevance?: tb_process_typeOrderByRelevanceInput
  }

  export type tb_process_typeWhereUniqueInput = Prisma.AtLeast<{
    process_type_id?: number
    AND?: tb_process_typeWhereInput | tb_process_typeWhereInput[]
    OR?: tb_process_typeWhereInput[]
    NOT?: tb_process_typeWhereInput | tb_process_typeWhereInput[]
    process_type?: StringFilter<"tb_process_type"> | string
  }, "process_type_id">

  export type tb_process_typeOrderByWithAggregationInput = {
    process_type_id?: SortOrder
    process_type?: SortOrder
    _count?: tb_process_typeCountOrderByAggregateInput
    _avg?: tb_process_typeAvgOrderByAggregateInput
    _max?: tb_process_typeMaxOrderByAggregateInput
    _min?: tb_process_typeMinOrderByAggregateInput
    _sum?: tb_process_typeSumOrderByAggregateInput
  }

  export type tb_process_typeScalarWhereWithAggregatesInput = {
    AND?: tb_process_typeScalarWhereWithAggregatesInput | tb_process_typeScalarWhereWithAggregatesInput[]
    OR?: tb_process_typeScalarWhereWithAggregatesInput[]
    NOT?: tb_process_typeScalarWhereWithAggregatesInput | tb_process_typeScalarWhereWithAggregatesInput[]
    process_type_id?: IntWithAggregatesFilter<"tb_process_type"> | number
    process_type?: StringWithAggregatesFilter<"tb_process_type"> | string
  }

  export type tb_religionsWhereInput = {
    AND?: tb_religionsWhereInput | tb_religionsWhereInput[]
    OR?: tb_religionsWhereInput[]
    NOT?: tb_religionsWhereInput | tb_religionsWhereInput[]
    religion_id?: IntFilter<"tb_religions"> | number
    religion_arm?: StringFilter<"tb_religions"> | string
    religion_eng?: StringFilter<"tb_religions"> | string
  }

  export type tb_religionsOrderByWithRelationInput = {
    religion_id?: SortOrder
    religion_arm?: SortOrder
    religion_eng?: SortOrder
    _relevance?: tb_religionsOrderByRelevanceInput
  }

  export type tb_religionsWhereUniqueInput = Prisma.AtLeast<{
    religion_id?: number
    AND?: tb_religionsWhereInput | tb_religionsWhereInput[]
    OR?: tb_religionsWhereInput[]
    NOT?: tb_religionsWhereInput | tb_religionsWhereInput[]
    religion_arm?: StringFilter<"tb_religions"> | string
    religion_eng?: StringFilter<"tb_religions"> | string
  }, "religion_id">

  export type tb_religionsOrderByWithAggregationInput = {
    religion_id?: SortOrder
    religion_arm?: SortOrder
    religion_eng?: SortOrder
    _count?: tb_religionsCountOrderByAggregateInput
    _avg?: tb_religionsAvgOrderByAggregateInput
    _max?: tb_religionsMaxOrderByAggregateInput
    _min?: tb_religionsMinOrderByAggregateInput
    _sum?: tb_religionsSumOrderByAggregateInput
  }

  export type tb_religionsScalarWhereWithAggregatesInput = {
    AND?: tb_religionsScalarWhereWithAggregatesInput | tb_religionsScalarWhereWithAggregatesInput[]
    OR?: tb_religionsScalarWhereWithAggregatesInput[]
    NOT?: tb_religionsScalarWhereWithAggregatesInput | tb_religionsScalarWhereWithAggregatesInput[]
    religion_id?: IntWithAggregatesFilter<"tb_religions"> | number
    religion_arm?: StringWithAggregatesFilter<"tb_religions"> | string
    religion_eng?: StringWithAggregatesFilter<"tb_religions"> | string
  }

  export type tb_request_bodiesWhereInput = {
    AND?: tb_request_bodiesWhereInput | tb_request_bodiesWhereInput[]
    OR?: tb_request_bodiesWhereInput[]
    NOT?: tb_request_bodiesWhereInput | tb_request_bodiesWhereInput[]
    body_id?: IntFilter<"tb_request_bodies"> | number
    body?: StringFilter<"tb_request_bodies"> | string
  }

  export type tb_request_bodiesOrderByWithRelationInput = {
    body_id?: SortOrder
    body?: SortOrder
    _relevance?: tb_request_bodiesOrderByRelevanceInput
  }

  export type tb_request_bodiesWhereUniqueInput = Prisma.AtLeast<{
    body_id?: number
    AND?: tb_request_bodiesWhereInput | tb_request_bodiesWhereInput[]
    OR?: tb_request_bodiesWhereInput[]
    NOT?: tb_request_bodiesWhereInput | tb_request_bodiesWhereInput[]
    body?: StringFilter<"tb_request_bodies"> | string
  }, "body_id">

  export type tb_request_bodiesOrderByWithAggregationInput = {
    body_id?: SortOrder
    body?: SortOrder
    _count?: tb_request_bodiesCountOrderByAggregateInput
    _avg?: tb_request_bodiesAvgOrderByAggregateInput
    _max?: tb_request_bodiesMaxOrderByAggregateInput
    _min?: tb_request_bodiesMinOrderByAggregateInput
    _sum?: tb_request_bodiesSumOrderByAggregateInput
  }

  export type tb_request_bodiesScalarWhereWithAggregatesInput = {
    AND?: tb_request_bodiesScalarWhereWithAggregatesInput | tb_request_bodiesScalarWhereWithAggregatesInput[]
    OR?: tb_request_bodiesScalarWhereWithAggregatesInput[]
    NOT?: tb_request_bodiesScalarWhereWithAggregatesInput | tb_request_bodiesScalarWhereWithAggregatesInput[]
    body_id?: IntWithAggregatesFilter<"tb_request_bodies"> | number
    body?: StringWithAggregatesFilter<"tb_request_bodies"> | string
  }

  export type tb_request_outWhereInput = {
    AND?: tb_request_outWhereInput | tb_request_outWhereInput[]
    OR?: tb_request_outWhereInput[]
    NOT?: tb_request_outWhereInput | tb_request_outWhereInput[]
    request_id?: IntFilter<"tb_request_out"> | number
    case_id?: IntFilter<"tb_request_out"> | number
    author?: IntFilter<"tb_request_out"> | number
    body?: IntFilter<"tb_request_out"> | number
    request_date?: DateTimeFilter<"tb_request_out"> | Date | string
    request_status?: IntFilter<"tb_request_out"> | number
  }

  export type tb_request_outOrderByWithRelationInput = {
    request_id?: SortOrder
    case_id?: SortOrder
    author?: SortOrder
    body?: SortOrder
    request_date?: SortOrder
    request_status?: SortOrder
  }

  export type tb_request_outWhereUniqueInput = Prisma.AtLeast<{
    request_id?: number
    AND?: tb_request_outWhereInput | tb_request_outWhereInput[]
    OR?: tb_request_outWhereInput[]
    NOT?: tb_request_outWhereInput | tb_request_outWhereInput[]
    case_id?: IntFilter<"tb_request_out"> | number
    author?: IntFilter<"tb_request_out"> | number
    body?: IntFilter<"tb_request_out"> | number
    request_date?: DateTimeFilter<"tb_request_out"> | Date | string
    request_status?: IntFilter<"tb_request_out"> | number
  }, "request_id">

  export type tb_request_outOrderByWithAggregationInput = {
    request_id?: SortOrder
    case_id?: SortOrder
    author?: SortOrder
    body?: SortOrder
    request_date?: SortOrder
    request_status?: SortOrder
    _count?: tb_request_outCountOrderByAggregateInput
    _avg?: tb_request_outAvgOrderByAggregateInput
    _max?: tb_request_outMaxOrderByAggregateInput
    _min?: tb_request_outMinOrderByAggregateInput
    _sum?: tb_request_outSumOrderByAggregateInput
  }

  export type tb_request_outScalarWhereWithAggregatesInput = {
    AND?: tb_request_outScalarWhereWithAggregatesInput | tb_request_outScalarWhereWithAggregatesInput[]
    OR?: tb_request_outScalarWhereWithAggregatesInput[]
    NOT?: tb_request_outScalarWhereWithAggregatesInput | tb_request_outScalarWhereWithAggregatesInput[]
    request_id?: IntWithAggregatesFilter<"tb_request_out"> | number
    case_id?: IntWithAggregatesFilter<"tb_request_out"> | number
    author?: IntWithAggregatesFilter<"tb_request_out"> | number
    body?: IntWithAggregatesFilter<"tb_request_out"> | number
    request_date?: DateTimeWithAggregatesFilter<"tb_request_out"> | Date | string
    request_status?: IntWithAggregatesFilter<"tb_request_out"> | number
  }

  export type tb_roleWhereInput = {
    AND?: tb_roleWhereInput | tb_roleWhereInput[]
    OR?: tb_roleWhereInput[]
    NOT?: tb_roleWhereInput | tb_roleWhereInput[]
    role_id?: IntFilter<"tb_role"> | number
    der?: StringFilter<"tb_role"> | string
  }

  export type tb_roleOrderByWithRelationInput = {
    role_id?: SortOrder
    der?: SortOrder
    _relevance?: tb_roleOrderByRelevanceInput
  }

  export type tb_roleWhereUniqueInput = Prisma.AtLeast<{
    role_id?: number
    AND?: tb_roleWhereInput | tb_roleWhereInput[]
    OR?: tb_roleWhereInput[]
    NOT?: tb_roleWhereInput | tb_roleWhereInput[]
    der?: StringFilter<"tb_role"> | string
  }, "role_id">

  export type tb_roleOrderByWithAggregationInput = {
    role_id?: SortOrder
    der?: SortOrder
    _count?: tb_roleCountOrderByAggregateInput
    _avg?: tb_roleAvgOrderByAggregateInput
    _max?: tb_roleMaxOrderByAggregateInput
    _min?: tb_roleMinOrderByAggregateInput
    _sum?: tb_roleSumOrderByAggregateInput
  }

  export type tb_roleScalarWhereWithAggregatesInput = {
    AND?: tb_roleScalarWhereWithAggregatesInput | tb_roleScalarWhereWithAggregatesInput[]
    OR?: tb_roleScalarWhereWithAggregatesInput[]
    NOT?: tb_roleScalarWhereWithAggregatesInput | tb_roleScalarWhereWithAggregatesInput[]
    role_id?: IntWithAggregatesFilter<"tb_role"> | number
    der?: StringWithAggregatesFilter<"tb_role"> | string
  }

  export type tb_settlementWhereInput = {
    AND?: tb_settlementWhereInput | tb_settlementWhereInput[]
    OR?: tb_settlementWhereInput[]
    NOT?: tb_settlementWhereInput | tb_settlementWhereInput[]
    settlement_id?: IntFilter<"tb_settlement"> | number
    com_id?: IntFilter<"tb_settlement"> | number
    ADM3_CODE?: StringFilter<"tb_settlement"> | string
    ADM4_PCODE?: StringFilter<"tb_settlement"> | string
    ADM4_ARM?: StringFilter<"tb_settlement"> | string
    ADM4_ENG?: StringFilter<"tb_settlement"> | string
  }

  export type tb_settlementOrderByWithRelationInput = {
    settlement_id?: SortOrder
    com_id?: SortOrder
    ADM3_CODE?: SortOrder
    ADM4_PCODE?: SortOrder
    ADM4_ARM?: SortOrder
    ADM4_ENG?: SortOrder
    _relevance?: tb_settlementOrderByRelevanceInput
  }

  export type tb_settlementWhereUniqueInput = Prisma.AtLeast<{
    settlement_id?: number
    AND?: tb_settlementWhereInput | tb_settlementWhereInput[]
    OR?: tb_settlementWhereInput[]
    NOT?: tb_settlementWhereInput | tb_settlementWhereInput[]
    com_id?: IntFilter<"tb_settlement"> | number
    ADM3_CODE?: StringFilter<"tb_settlement"> | string
    ADM4_PCODE?: StringFilter<"tb_settlement"> | string
    ADM4_ARM?: StringFilter<"tb_settlement"> | string
    ADM4_ENG?: StringFilter<"tb_settlement"> | string
  }, "settlement_id">

  export type tb_settlementOrderByWithAggregationInput = {
    settlement_id?: SortOrder
    com_id?: SortOrder
    ADM3_CODE?: SortOrder
    ADM4_PCODE?: SortOrder
    ADM4_ARM?: SortOrder
    ADM4_ENG?: SortOrder
    _count?: tb_settlementCountOrderByAggregateInput
    _avg?: tb_settlementAvgOrderByAggregateInput
    _max?: tb_settlementMaxOrderByAggregateInput
    _min?: tb_settlementMinOrderByAggregateInput
    _sum?: tb_settlementSumOrderByAggregateInput
  }

  export type tb_settlementScalarWhereWithAggregatesInput = {
    AND?: tb_settlementScalarWhereWithAggregatesInput | tb_settlementScalarWhereWithAggregatesInput[]
    OR?: tb_settlementScalarWhereWithAggregatesInput[]
    NOT?: tb_settlementScalarWhereWithAggregatesInput | tb_settlementScalarWhereWithAggregatesInput[]
    settlement_id?: IntWithAggregatesFilter<"tb_settlement"> | number
    com_id?: IntWithAggregatesFilter<"tb_settlement"> | number
    ADM3_CODE?: StringWithAggregatesFilter<"tb_settlement"> | string
    ADM4_PCODE?: StringWithAggregatesFilter<"tb_settlement"> | string
    ADM4_ARM?: StringWithAggregatesFilter<"tb_settlement"> | string
    ADM4_ENG?: StringWithAggregatesFilter<"tb_settlement"> | string
  }

  export type tb_settlement_WhereInput = {
    AND?: tb_settlement_WhereInput | tb_settlement_WhereInput[]
    OR?: tb_settlement_WhereInput[]
    NOT?: tb_settlement_WhereInput | tb_settlement_WhereInput[]
    settlement_id?: IntFilter<"tb_settlement_"> | number
    com_id?: IntFilter<"tb_settlement_"> | number
    ADM3_CODE?: StringFilter<"tb_settlement_"> | string
    ADM4_PCODE?: StringFilter<"tb_settlement_"> | string
    ADM4_ARM?: StringFilter<"tb_settlement_"> | string
    ADM4_ENG?: StringFilter<"tb_settlement_"> | string
    active?: IntFilter<"tb_settlement_"> | number
  }

  export type tb_settlement_OrderByWithRelationInput = {
    settlement_id?: SortOrder
    com_id?: SortOrder
    ADM3_CODE?: SortOrder
    ADM4_PCODE?: SortOrder
    ADM4_ARM?: SortOrder
    ADM4_ENG?: SortOrder
    active?: SortOrder
    _relevance?: tb_settlement_OrderByRelevanceInput
  }

  export type tb_settlement_WhereUniqueInput = Prisma.AtLeast<{
    settlement_id?: number
    AND?: tb_settlement_WhereInput | tb_settlement_WhereInput[]
    OR?: tb_settlement_WhereInput[]
    NOT?: tb_settlement_WhereInput | tb_settlement_WhereInput[]
    com_id?: IntFilter<"tb_settlement_"> | number
    ADM3_CODE?: StringFilter<"tb_settlement_"> | string
    ADM4_PCODE?: StringFilter<"tb_settlement_"> | string
    ADM4_ARM?: StringFilter<"tb_settlement_"> | string
    ADM4_ENG?: StringFilter<"tb_settlement_"> | string
    active?: IntFilter<"tb_settlement_"> | number
  }, "settlement_id">

  export type tb_settlement_OrderByWithAggregationInput = {
    settlement_id?: SortOrder
    com_id?: SortOrder
    ADM3_CODE?: SortOrder
    ADM4_PCODE?: SortOrder
    ADM4_ARM?: SortOrder
    ADM4_ENG?: SortOrder
    active?: SortOrder
    _count?: tb_settlement_CountOrderByAggregateInput
    _avg?: tb_settlement_AvgOrderByAggregateInput
    _max?: tb_settlement_MaxOrderByAggregateInput
    _min?: tb_settlement_MinOrderByAggregateInput
    _sum?: tb_settlement_SumOrderByAggregateInput
  }

  export type tb_settlement_ScalarWhereWithAggregatesInput = {
    AND?: tb_settlement_ScalarWhereWithAggregatesInput | tb_settlement_ScalarWhereWithAggregatesInput[]
    OR?: tb_settlement_ScalarWhereWithAggregatesInput[]
    NOT?: tb_settlement_ScalarWhereWithAggregatesInput | tb_settlement_ScalarWhereWithAggregatesInput[]
    settlement_id?: IntWithAggregatesFilter<"tb_settlement_"> | number
    com_id?: IntWithAggregatesFilter<"tb_settlement_"> | number
    ADM3_CODE?: StringWithAggregatesFilter<"tb_settlement_"> | string
    ADM4_PCODE?: StringWithAggregatesFilter<"tb_settlement_"> | string
    ADM4_ARM?: StringWithAggregatesFilter<"tb_settlement_"> | string
    ADM4_ENG?: StringWithAggregatesFilter<"tb_settlement_"> | string
    active?: IntWithAggregatesFilter<"tb_settlement_"> | number
  }

  export type tb_sign_statusWhereInput = {
    AND?: tb_sign_statusWhereInput | tb_sign_statusWhereInput[]
    OR?: tb_sign_statusWhereInput[]
    NOT?: tb_sign_statusWhereInput | tb_sign_statusWhereInput[]
    status_id?: IntFilter<"tb_sign_status"> | number
    status?: StringFilter<"tb_sign_status"> | string
  }

  export type tb_sign_statusOrderByWithRelationInput = {
    status_id?: SortOrder
    status?: SortOrder
    _relevance?: tb_sign_statusOrderByRelevanceInput
  }

  export type tb_sign_statusWhereUniqueInput = Prisma.AtLeast<{
    status_id?: number
    AND?: tb_sign_statusWhereInput | tb_sign_statusWhereInput[]
    OR?: tb_sign_statusWhereInput[]
    NOT?: tb_sign_statusWhereInput | tb_sign_statusWhereInput[]
    status?: StringFilter<"tb_sign_status"> | string
  }, "status_id">

  export type tb_sign_statusOrderByWithAggregationInput = {
    status_id?: SortOrder
    status?: SortOrder
    _count?: tb_sign_statusCountOrderByAggregateInput
    _avg?: tb_sign_statusAvgOrderByAggregateInput
    _max?: tb_sign_statusMaxOrderByAggregateInput
    _min?: tb_sign_statusMinOrderByAggregateInput
    _sum?: tb_sign_statusSumOrderByAggregateInput
  }

  export type tb_sign_statusScalarWhereWithAggregatesInput = {
    AND?: tb_sign_statusScalarWhereWithAggregatesInput | tb_sign_statusScalarWhereWithAggregatesInput[]
    OR?: tb_sign_statusScalarWhereWithAggregatesInput[]
    NOT?: tb_sign_statusScalarWhereWithAggregatesInput | tb_sign_statusScalarWhereWithAggregatesInput[]
    status_id?: IntWithAggregatesFilter<"tb_sign_status"> | number
    status?: StringWithAggregatesFilter<"tb_sign_status"> | string
  }

  export type tb_translateWhereInput = {
    AND?: tb_translateWhereInput | tb_translateWhereInput[]
    OR?: tb_translateWhereInput[]
    NOT?: tb_translateWhereInput | tb_translateWhereInput[]
    translate_id?: IntFilter<"tb_translate"> | number
    case_id?: IntFilter<"tb_translate"> | number
    translate_type?: IntFilter<"tb_translate"> | number
    user_from?: IntFilter<"tb_translate"> | number
    user_to?: IntFilter<"tb_translate"> | number
    filled_in_date?: DateTimeFilter<"tb_translate"> | Date | string
    translator_company?: IntFilter<"tb_translate"> | number
    file_path?: StringNullableFilter<"tb_translate"> | string | null
    file_ids?: StringNullableFilter<"tb_translate"> | string | null
    translate_date?: DateTimeNullableFilter<"tb_translate"> | Date | string | null
    translate_time_from?: StringNullableFilter<"tb_translate"> | string | null
    translate_time_to?: StringNullableFilter<"tb_translate"> | string | null
    sign_status?: IntNullableFilter<"tb_translate"> | number | null
    mailed_to_translators?: DateTimeNullableFilter<"tb_translate"> | Date | string | null
  }

  export type tb_translateOrderByWithRelationInput = {
    translate_id?: SortOrder
    case_id?: SortOrder
    translate_type?: SortOrder
    user_from?: SortOrder
    user_to?: SortOrder
    filled_in_date?: SortOrder
    translator_company?: SortOrder
    file_path?: SortOrderInput | SortOrder
    file_ids?: SortOrderInput | SortOrder
    translate_date?: SortOrderInput | SortOrder
    translate_time_from?: SortOrderInput | SortOrder
    translate_time_to?: SortOrderInput | SortOrder
    sign_status?: SortOrderInput | SortOrder
    mailed_to_translators?: SortOrderInput | SortOrder
    _relevance?: tb_translateOrderByRelevanceInput
  }

  export type tb_translateWhereUniqueInput = Prisma.AtLeast<{
    translate_id?: number
    AND?: tb_translateWhereInput | tb_translateWhereInput[]
    OR?: tb_translateWhereInput[]
    NOT?: tb_translateWhereInput | tb_translateWhereInput[]
    case_id?: IntFilter<"tb_translate"> | number
    translate_type?: IntFilter<"tb_translate"> | number
    user_from?: IntFilter<"tb_translate"> | number
    user_to?: IntFilter<"tb_translate"> | number
    filled_in_date?: DateTimeFilter<"tb_translate"> | Date | string
    translator_company?: IntFilter<"tb_translate"> | number
    file_path?: StringNullableFilter<"tb_translate"> | string | null
    file_ids?: StringNullableFilter<"tb_translate"> | string | null
    translate_date?: DateTimeNullableFilter<"tb_translate"> | Date | string | null
    translate_time_from?: StringNullableFilter<"tb_translate"> | string | null
    translate_time_to?: StringNullableFilter<"tb_translate"> | string | null
    sign_status?: IntNullableFilter<"tb_translate"> | number | null
    mailed_to_translators?: DateTimeNullableFilter<"tb_translate"> | Date | string | null
  }, "translate_id">

  export type tb_translateOrderByWithAggregationInput = {
    translate_id?: SortOrder
    case_id?: SortOrder
    translate_type?: SortOrder
    user_from?: SortOrder
    user_to?: SortOrder
    filled_in_date?: SortOrder
    translator_company?: SortOrder
    file_path?: SortOrderInput | SortOrder
    file_ids?: SortOrderInput | SortOrder
    translate_date?: SortOrderInput | SortOrder
    translate_time_from?: SortOrderInput | SortOrder
    translate_time_to?: SortOrderInput | SortOrder
    sign_status?: SortOrderInput | SortOrder
    mailed_to_translators?: SortOrderInput | SortOrder
    _count?: tb_translateCountOrderByAggregateInput
    _avg?: tb_translateAvgOrderByAggregateInput
    _max?: tb_translateMaxOrderByAggregateInput
    _min?: tb_translateMinOrderByAggregateInput
    _sum?: tb_translateSumOrderByAggregateInput
  }

  export type tb_translateScalarWhereWithAggregatesInput = {
    AND?: tb_translateScalarWhereWithAggregatesInput | tb_translateScalarWhereWithAggregatesInput[]
    OR?: tb_translateScalarWhereWithAggregatesInput[]
    NOT?: tb_translateScalarWhereWithAggregatesInput | tb_translateScalarWhereWithAggregatesInput[]
    translate_id?: IntWithAggregatesFilter<"tb_translate"> | number
    case_id?: IntWithAggregatesFilter<"tb_translate"> | number
    translate_type?: IntWithAggregatesFilter<"tb_translate"> | number
    user_from?: IntWithAggregatesFilter<"tb_translate"> | number
    user_to?: IntWithAggregatesFilter<"tb_translate"> | number
    filled_in_date?: DateTimeWithAggregatesFilter<"tb_translate"> | Date | string
    translator_company?: IntWithAggregatesFilter<"tb_translate"> | number
    file_path?: StringNullableWithAggregatesFilter<"tb_translate"> | string | null
    file_ids?: StringNullableWithAggregatesFilter<"tb_translate"> | string | null
    translate_date?: DateTimeNullableWithAggregatesFilter<"tb_translate"> | Date | string | null
    translate_time_from?: StringNullableWithAggregatesFilter<"tb_translate"> | string | null
    translate_time_to?: StringNullableWithAggregatesFilter<"tb_translate"> | string | null
    sign_status?: IntNullableWithAggregatesFilter<"tb_translate"> | number | null
    mailed_to_translators?: DateTimeNullableWithAggregatesFilter<"tb_translate"> | Date | string | null
  }

  export type tb_translate_sign_statusesWhereInput = {
    AND?: tb_translate_sign_statusesWhereInput | tb_translate_sign_statusesWhereInput[]
    OR?: tb_translate_sign_statusesWhereInput[]
    NOT?: tb_translate_sign_statusesWhereInput | tb_translate_sign_statusesWhereInput[]
    status_id?: IntFilter<"tb_translate_sign_statuses"> | number
    sign_status?: IntFilter<"tb_translate_sign_statuses"> | number
    sign_status_name?: StringFilter<"tb_translate_sign_statuses"> | string
  }

  export type tb_translate_sign_statusesOrderByWithRelationInput = {
    status_id?: SortOrder
    sign_status?: SortOrder
    sign_status_name?: SortOrder
    _relevance?: tb_translate_sign_statusesOrderByRelevanceInput
  }

  export type tb_translate_sign_statusesWhereUniqueInput = Prisma.AtLeast<{
    status_id?: number
    AND?: tb_translate_sign_statusesWhereInput | tb_translate_sign_statusesWhereInput[]
    OR?: tb_translate_sign_statusesWhereInput[]
    NOT?: tb_translate_sign_statusesWhereInput | tb_translate_sign_statusesWhereInput[]
    sign_status?: IntFilter<"tb_translate_sign_statuses"> | number
    sign_status_name?: StringFilter<"tb_translate_sign_statuses"> | string
  }, "status_id">

  export type tb_translate_sign_statusesOrderByWithAggregationInput = {
    status_id?: SortOrder
    sign_status?: SortOrder
    sign_status_name?: SortOrder
    _count?: tb_translate_sign_statusesCountOrderByAggregateInput
    _avg?: tb_translate_sign_statusesAvgOrderByAggregateInput
    _max?: tb_translate_sign_statusesMaxOrderByAggregateInput
    _min?: tb_translate_sign_statusesMinOrderByAggregateInput
    _sum?: tb_translate_sign_statusesSumOrderByAggregateInput
  }

  export type tb_translate_sign_statusesScalarWhereWithAggregatesInput = {
    AND?: tb_translate_sign_statusesScalarWhereWithAggregatesInput | tb_translate_sign_statusesScalarWhereWithAggregatesInput[]
    OR?: tb_translate_sign_statusesScalarWhereWithAggregatesInput[]
    NOT?: tb_translate_sign_statusesScalarWhereWithAggregatesInput | tb_translate_sign_statusesScalarWhereWithAggregatesInput[]
    status_id?: IntWithAggregatesFilter<"tb_translate_sign_statuses"> | number
    sign_status?: IntWithAggregatesFilter<"tb_translate_sign_statuses"> | number
    sign_status_name?: StringWithAggregatesFilter<"tb_translate_sign_statuses"> | string
  }

  export type tb_translation_typeWhereInput = {
    AND?: tb_translation_typeWhereInput | tb_translation_typeWhereInput[]
    OR?: tb_translation_typeWhereInput[]
    NOT?: tb_translation_typeWhereInput | tb_translation_typeWhereInput[]
    ttype_id?: IntFilter<"tb_translation_type"> | number
    trans_type?: StringFilter<"tb_translation_type"> | string
  }

  export type tb_translation_typeOrderByWithRelationInput = {
    ttype_id?: SortOrder
    trans_type?: SortOrder
    _relevance?: tb_translation_typeOrderByRelevanceInput
  }

  export type tb_translation_typeWhereUniqueInput = Prisma.AtLeast<{
    ttype_id?: number
    AND?: tb_translation_typeWhereInput | tb_translation_typeWhereInput[]
    OR?: tb_translation_typeWhereInput[]
    NOT?: tb_translation_typeWhereInput | tb_translation_typeWhereInput[]
    trans_type?: StringFilter<"tb_translation_type"> | string
  }, "ttype_id">

  export type tb_translation_typeOrderByWithAggregationInput = {
    ttype_id?: SortOrder
    trans_type?: SortOrder
    _count?: tb_translation_typeCountOrderByAggregateInput
    _avg?: tb_translation_typeAvgOrderByAggregateInput
    _max?: tb_translation_typeMaxOrderByAggregateInput
    _min?: tb_translation_typeMinOrderByAggregateInput
    _sum?: tb_translation_typeSumOrderByAggregateInput
  }

  export type tb_translation_typeScalarWhereWithAggregatesInput = {
    AND?: tb_translation_typeScalarWhereWithAggregatesInput | tb_translation_typeScalarWhereWithAggregatesInput[]
    OR?: tb_translation_typeScalarWhereWithAggregatesInput[]
    NOT?: tb_translation_typeScalarWhereWithAggregatesInput | tb_translation_typeScalarWhereWithAggregatesInput[]
    ttype_id?: IntWithAggregatesFilter<"tb_translation_type"> | number
    trans_type?: StringWithAggregatesFilter<"tb_translation_type"> | string
  }

  export type tb_translatorsWhereInput = {
    AND?: tb_translatorsWhereInput | tb_translatorsWhereInput[]
    OR?: tb_translatorsWhereInput[]
    NOT?: tb_translatorsWhereInput | tb_translatorsWhereInput[]
    translator_id?: IntFilter<"tb_translators"> | number
    translator_name_arm?: StringFilter<"tb_translators"> | string
    translator_name_eng?: StringFilter<"tb_translators"> | string
    email?: StringFilter<"tb_translators"> | string
    test_mail?: StringFilter<"tb_translators"> | string
    logo_file?: StringNullableFilter<"tb_translators"> | string | null
    active_status?: IntNullableFilter<"tb_translators"> | number | null
  }

  export type tb_translatorsOrderByWithRelationInput = {
    translator_id?: SortOrder
    translator_name_arm?: SortOrder
    translator_name_eng?: SortOrder
    email?: SortOrder
    test_mail?: SortOrder
    logo_file?: SortOrderInput | SortOrder
    active_status?: SortOrderInput | SortOrder
    _relevance?: tb_translatorsOrderByRelevanceInput
  }

  export type tb_translatorsWhereUniqueInput = Prisma.AtLeast<{
    translator_id?: number
    AND?: tb_translatorsWhereInput | tb_translatorsWhereInput[]
    OR?: tb_translatorsWhereInput[]
    NOT?: tb_translatorsWhereInput | tb_translatorsWhereInput[]
    translator_name_arm?: StringFilter<"tb_translators"> | string
    translator_name_eng?: StringFilter<"tb_translators"> | string
    email?: StringFilter<"tb_translators"> | string
    test_mail?: StringFilter<"tb_translators"> | string
    logo_file?: StringNullableFilter<"tb_translators"> | string | null
    active_status?: IntNullableFilter<"tb_translators"> | number | null
  }, "translator_id">

  export type tb_translatorsOrderByWithAggregationInput = {
    translator_id?: SortOrder
    translator_name_arm?: SortOrder
    translator_name_eng?: SortOrder
    email?: SortOrder
    test_mail?: SortOrder
    logo_file?: SortOrderInput | SortOrder
    active_status?: SortOrderInput | SortOrder
    _count?: tb_translatorsCountOrderByAggregateInput
    _avg?: tb_translatorsAvgOrderByAggregateInput
    _max?: tb_translatorsMaxOrderByAggregateInput
    _min?: tb_translatorsMinOrderByAggregateInput
    _sum?: tb_translatorsSumOrderByAggregateInput
  }

  export type tb_translatorsScalarWhereWithAggregatesInput = {
    AND?: tb_translatorsScalarWhereWithAggregatesInput | tb_translatorsScalarWhereWithAggregatesInput[]
    OR?: tb_translatorsScalarWhereWithAggregatesInput[]
    NOT?: tb_translatorsScalarWhereWithAggregatesInput | tb_translatorsScalarWhereWithAggregatesInput[]
    translator_id?: IntWithAggregatesFilter<"tb_translators"> | number
    translator_name_arm?: StringWithAggregatesFilter<"tb_translators"> | string
    translator_name_eng?: StringWithAggregatesFilter<"tb_translators"> | string
    email?: StringWithAggregatesFilter<"tb_translators"> | string
    test_mail?: StringWithAggregatesFilter<"tb_translators"> | string
    logo_file?: StringNullableWithAggregatesFilter<"tb_translators"> | string | null
    active_status?: IntNullableWithAggregatesFilter<"tb_translators"> | number | null
  }

  export type usersWhereInput = {
    AND?: usersWhereInput | usersWhereInput[]
    OR?: usersWhereInput[]
    NOT?: usersWhereInput | usersWhereInput[]
    id?: IntFilter<"users"> | number
    username?: StringFilter<"users"> | string
    password?: StringFilter<"users"> | string
    f_name?: StringFilter<"users"> | string
    l_name?: StringFilter<"users"> | string
    user_type?: StringFilter<"users"> | string
    user_status?: IntFilter<"users"> | number
    last_activity?: BigIntNullableFilter<"users"> | bigint | number | null
  }

  export type usersOrderByWithRelationInput = {
    id?: SortOrder
    username?: SortOrder
    password?: SortOrder
    f_name?: SortOrder
    l_name?: SortOrder
    user_type?: SortOrder
    user_status?: SortOrder
    last_activity?: SortOrderInput | SortOrder
    _relevance?: usersOrderByRelevanceInput
  }

  export type usersWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: usersWhereInput | usersWhereInput[]
    OR?: usersWhereInput[]
    NOT?: usersWhereInput | usersWhereInput[]
    username?: StringFilter<"users"> | string
    password?: StringFilter<"users"> | string
    f_name?: StringFilter<"users"> | string
    l_name?: StringFilter<"users"> | string
    user_type?: StringFilter<"users"> | string
    user_status?: IntFilter<"users"> | number
    last_activity?: BigIntNullableFilter<"users"> | bigint | number | null
  }, "id">

  export type usersOrderByWithAggregationInput = {
    id?: SortOrder
    username?: SortOrder
    password?: SortOrder
    f_name?: SortOrder
    l_name?: SortOrder
    user_type?: SortOrder
    user_status?: SortOrder
    last_activity?: SortOrderInput | SortOrder
    _count?: usersCountOrderByAggregateInput
    _avg?: usersAvgOrderByAggregateInput
    _max?: usersMaxOrderByAggregateInput
    _min?: usersMinOrderByAggregateInput
    _sum?: usersSumOrderByAggregateInput
  }

  export type usersScalarWhereWithAggregatesInput = {
    AND?: usersScalarWhereWithAggregatesInput | usersScalarWhereWithAggregatesInput[]
    OR?: usersScalarWhereWithAggregatesInput[]
    NOT?: usersScalarWhereWithAggregatesInput | usersScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"users"> | number
    username?: StringWithAggregatesFilter<"users"> | string
    password?: StringWithAggregatesFilter<"users"> | string
    f_name?: StringWithAggregatesFilter<"users"> | string
    l_name?: StringWithAggregatesFilter<"users"> | string
    user_type?: StringWithAggregatesFilter<"users"> | string
    user_status?: IntWithAggregatesFilter<"users"> | number
    last_activity?: BigIntNullableWithAggregatesFilter<"users"> | bigint | number | null
  }

  export type court_appeal_typesCreateInput = {
    appeal_type: string
  }

  export type court_appeal_typesUncheckedCreateInput = {
    appeal_type_id?: number
    appeal_type: string
  }

  export type court_appeal_typesUpdateInput = {
    appeal_type?: StringFieldUpdateOperationsInput | string
  }

  export type court_appeal_typesUncheckedUpdateInput = {
    appeal_type_id?: IntFieldUpdateOperationsInput | number
    appeal_type?: StringFieldUpdateOperationsInput | string
  }

  export type court_appeal_typesCreateManyInput = {
    appeal_type_id?: number
    appeal_type: string
  }

  export type court_appeal_typesUpdateManyMutationInput = {
    appeal_type?: StringFieldUpdateOperationsInput | string
  }

  export type court_appeal_typesUncheckedUpdateManyInput = {
    appeal_type_id?: IntFieldUpdateOperationsInput | number
    appeal_type?: StringFieldUpdateOperationsInput | string
  }

  export type court_appealsCreateInput = {
    case_id: number
    claim_id: number
    court_accept_date: Date | string
    actual?: number
    filled_in?: Date | string
    filled_by: number
    court_level: number
    court_name?: string | null
  }

  export type court_appealsUncheckedCreateInput = {
    appeal_id?: number
    case_id: number
    claim_id: number
    court_accept_date: Date | string
    actual?: number
    filled_in?: Date | string
    filled_by: number
    court_level: number
    court_name?: string | null
  }

  export type court_appealsUpdateInput = {
    case_id?: IntFieldUpdateOperationsInput | number
    claim_id?: IntFieldUpdateOperationsInput | number
    court_accept_date?: DateTimeFieldUpdateOperationsInput | Date | string
    actual?: IntFieldUpdateOperationsInput | number
    filled_in?: DateTimeFieldUpdateOperationsInput | Date | string
    filled_by?: IntFieldUpdateOperationsInput | number
    court_level?: IntFieldUpdateOperationsInput | number
    court_name?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type court_appealsUncheckedUpdateInput = {
    appeal_id?: IntFieldUpdateOperationsInput | number
    case_id?: IntFieldUpdateOperationsInput | number
    claim_id?: IntFieldUpdateOperationsInput | number
    court_accept_date?: DateTimeFieldUpdateOperationsInput | Date | string
    actual?: IntFieldUpdateOperationsInput | number
    filled_in?: DateTimeFieldUpdateOperationsInput | Date | string
    filled_by?: IntFieldUpdateOperationsInput | number
    court_level?: IntFieldUpdateOperationsInput | number
    court_name?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type court_appealsCreateManyInput = {
    appeal_id?: number
    case_id: number
    claim_id: number
    court_accept_date: Date | string
    actual?: number
    filled_in?: Date | string
    filled_by: number
    court_level: number
    court_name?: string | null
  }

  export type court_appealsUpdateManyMutationInput = {
    case_id?: IntFieldUpdateOperationsInput | number
    claim_id?: IntFieldUpdateOperationsInput | number
    court_accept_date?: DateTimeFieldUpdateOperationsInput | Date | string
    actual?: IntFieldUpdateOperationsInput | number
    filled_in?: DateTimeFieldUpdateOperationsInput | Date | string
    filled_by?: IntFieldUpdateOperationsInput | number
    court_level?: IntFieldUpdateOperationsInput | number
    court_name?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type court_appealsUncheckedUpdateManyInput = {
    appeal_id?: IntFieldUpdateOperationsInput | number
    case_id?: IntFieldUpdateOperationsInput | number
    claim_id?: IntFieldUpdateOperationsInput | number
    court_accept_date?: DateTimeFieldUpdateOperationsInput | Date | string
    actual?: IntFieldUpdateOperationsInput | number
    filled_in?: DateTimeFieldUpdateOperationsInput | Date | string
    filled_by?: IntFieldUpdateOperationsInput | number
    court_level?: IntFieldUpdateOperationsInput | number
    court_name?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type court_claim_initiatorsCreateInput = {
    initiator_name: string
  }

  export type court_claim_initiatorsUncheckedCreateInput = {
    id?: number
    initiator_name: string
  }

  export type court_claim_initiatorsUpdateInput = {
    initiator_name?: StringFieldUpdateOperationsInput | string
  }

  export type court_claim_initiatorsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    initiator_name?: StringFieldUpdateOperationsInput | string
  }

  export type court_claim_initiatorsCreateManyInput = {
    id?: number
    initiator_name: string
  }

  export type court_claim_initiatorsUpdateManyMutationInput = {
    initiator_name?: StringFieldUpdateOperationsInput | string
  }

  export type court_claim_initiatorsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    initiator_name?: StringFieldUpdateOperationsInput | string
  }

  export type court_claim_membersCreateInput = {
    claim_id: number
    case_id: number
    person_id: number
    created_at?: Date | string
    actual?: number
  }

  export type court_claim_membersUncheckedCreateInput = {
    id?: number
    claim_id: number
    case_id: number
    person_id: number
    created_at?: Date | string
    actual?: number
  }

  export type court_claim_membersUpdateInput = {
    claim_id?: IntFieldUpdateOperationsInput | number
    case_id?: IntFieldUpdateOperationsInput | number
    person_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    actual?: IntFieldUpdateOperationsInput | number
  }

  export type court_claim_membersUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    claim_id?: IntFieldUpdateOperationsInput | number
    case_id?: IntFieldUpdateOperationsInput | number
    person_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    actual?: IntFieldUpdateOperationsInput | number
  }

  export type court_claim_membersCreateManyInput = {
    id?: number
    claim_id: number
    case_id: number
    person_id: number
    created_at?: Date | string
    actual?: number
  }

  export type court_claim_membersUpdateManyMutationInput = {
    claim_id?: IntFieldUpdateOperationsInput | number
    case_id?: IntFieldUpdateOperationsInput | number
    person_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    actual?: IntFieldUpdateOperationsInput | number
  }

  export type court_claim_membersUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    claim_id?: IntFieldUpdateOperationsInput | number
    case_id?: IntFieldUpdateOperationsInput | number
    person_id?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    actual?: IntFieldUpdateOperationsInput | number
  }

  export type court_claimsCreateInput = {
    claim_serial_number: string
    claim_date: Date | string
    appealable_ms_decision?: number | null
    appealable_court_decision?: number | null
    appealable_claim?: number | null
    filled_by: number
    filled_in_date?: Date | string
    ms_notified_date: Date | string
    ms_lawyer: number
    case_id: number
    court_level: number
    actual?: number
    initiator: number
    claim_status?: number
    appeal_type: number
    status_change_date: Date | string
  }

  export type court_claimsUncheckedCreateInput = {
    claim_id?: number
    claim_serial_number: string
    claim_date: Date | string
    appealable_ms_decision?: number | null
    appealable_court_decision?: number | null
    appealable_claim?: number | null
    filled_by: number
    filled_in_date?: Date | string
    ms_notified_date: Date | string
    ms_lawyer: number
    case_id: number
    court_level: number
    actual?: number
    initiator: number
    claim_status?: number
    appeal_type: number
    status_change_date: Date | string
  }

  export type court_claimsUpdateInput = {
    claim_serial_number?: StringFieldUpdateOperationsInput | string
    claim_date?: DateTimeFieldUpdateOperationsInput | Date | string
    appealable_ms_decision?: NullableIntFieldUpdateOperationsInput | number | null
    appealable_court_decision?: NullableIntFieldUpdateOperationsInput | number | null
    appealable_claim?: NullableIntFieldUpdateOperationsInput | number | null
    filled_by?: IntFieldUpdateOperationsInput | number
    filled_in_date?: DateTimeFieldUpdateOperationsInput | Date | string
    ms_notified_date?: DateTimeFieldUpdateOperationsInput | Date | string
    ms_lawyer?: IntFieldUpdateOperationsInput | number
    case_id?: IntFieldUpdateOperationsInput | number
    court_level?: IntFieldUpdateOperationsInput | number
    actual?: IntFieldUpdateOperationsInput | number
    initiator?: IntFieldUpdateOperationsInput | number
    claim_status?: IntFieldUpdateOperationsInput | number
    appeal_type?: IntFieldUpdateOperationsInput | number
    status_change_date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type court_claimsUncheckedUpdateInput = {
    claim_id?: IntFieldUpdateOperationsInput | number
    claim_serial_number?: StringFieldUpdateOperationsInput | string
    claim_date?: DateTimeFieldUpdateOperationsInput | Date | string
    appealable_ms_decision?: NullableIntFieldUpdateOperationsInput | number | null
    appealable_court_decision?: NullableIntFieldUpdateOperationsInput | number | null
    appealable_claim?: NullableIntFieldUpdateOperationsInput | number | null
    filled_by?: IntFieldUpdateOperationsInput | number
    filled_in_date?: DateTimeFieldUpdateOperationsInput | Date | string
    ms_notified_date?: DateTimeFieldUpdateOperationsInput | Date | string
    ms_lawyer?: IntFieldUpdateOperationsInput | number
    case_id?: IntFieldUpdateOperationsInput | number
    court_level?: IntFieldUpdateOperationsInput | number
    actual?: IntFieldUpdateOperationsInput | number
    initiator?: IntFieldUpdateOperationsInput | number
    claim_status?: IntFieldUpdateOperationsInput | number
    appeal_type?: IntFieldUpdateOperationsInput | number
    status_change_date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type court_claimsCreateManyInput = {
    claim_id?: number
    claim_serial_number: string
    claim_date: Date | string
    appealable_ms_decision?: number | null
    appealable_court_decision?: number | null
    appealable_claim?: number | null
    filled_by: number
    filled_in_date?: Date | string
    ms_notified_date: Date | string
    ms_lawyer: number
    case_id: number
    court_level: number
    actual?: number
    initiator: number
    claim_status?: number
    appeal_type: number
    status_change_date: Date | string
  }

  export type court_claimsUpdateManyMutationInput = {
    claim_serial_number?: StringFieldUpdateOperationsInput | string
    claim_date?: DateTimeFieldUpdateOperationsInput | Date | string
    appealable_ms_decision?: NullableIntFieldUpdateOperationsInput | number | null
    appealable_court_decision?: NullableIntFieldUpdateOperationsInput | number | null
    appealable_claim?: NullableIntFieldUpdateOperationsInput | number | null
    filled_by?: IntFieldUpdateOperationsInput | number
    filled_in_date?: DateTimeFieldUpdateOperationsInput | Date | string
    ms_notified_date?: DateTimeFieldUpdateOperationsInput | Date | string
    ms_lawyer?: IntFieldUpdateOperationsInput | number
    case_id?: IntFieldUpdateOperationsInput | number
    court_level?: IntFieldUpdateOperationsInput | number
    actual?: IntFieldUpdateOperationsInput | number
    initiator?: IntFieldUpdateOperationsInput | number
    claim_status?: IntFieldUpdateOperationsInput | number
    appeal_type?: IntFieldUpdateOperationsInput | number
    status_change_date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type court_claimsUncheckedUpdateManyInput = {
    claim_id?: IntFieldUpdateOperationsInput | number
    claim_serial_number?: StringFieldUpdateOperationsInput | string
    claim_date?: DateTimeFieldUpdateOperationsInput | Date | string
    appealable_ms_decision?: NullableIntFieldUpdateOperationsInput | number | null
    appealable_court_decision?: NullableIntFieldUpdateOperationsInput | number | null
    appealable_claim?: NullableIntFieldUpdateOperationsInput | number | null
    filled_by?: IntFieldUpdateOperationsInput | number
    filled_in_date?: DateTimeFieldUpdateOperationsInput | Date | string
    ms_notified_date?: DateTimeFieldUpdateOperationsInput | Date | string
    ms_lawyer?: IntFieldUpdateOperationsInput | number
    case_id?: IntFieldUpdateOperationsInput | number
    court_level?: IntFieldUpdateOperationsInput | number
    actual?: IntFieldUpdateOperationsInput | number
    initiator?: IntFieldUpdateOperationsInput | number
    claim_status?: IntFieldUpdateOperationsInput | number
    appeal_type?: IntFieldUpdateOperationsInput | number
    status_change_date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type court_cliam_statusCreateInput = {
    court_level: number
    name: string
    button_value?: string | null
  }

  export type court_cliam_statusUncheckedCreateInput = {
    id?: number
    court_level: number
    name: string
    button_value?: string | null
  }

  export type court_cliam_statusUpdateInput = {
    court_level?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    button_value?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type court_cliam_statusUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    court_level?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    button_value?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type court_cliam_statusCreateManyInput = {
    id?: number
    court_level: number
    name: string
    button_value?: string | null
  }

  export type court_cliam_statusUpdateManyMutationInput = {
    court_level?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    button_value?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type court_cliam_statusUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    court_level?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    button_value?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type court_decision_typesCreateInput = {
    court_type: number
    court_decision: string
  }

  export type court_decision_typesUncheckedCreateInput = {
    court_decision_type_id?: number
    court_type: number
    court_decision: string
  }

  export type court_decision_typesUpdateInput = {
    court_type?: IntFieldUpdateOperationsInput | number
    court_decision?: StringFieldUpdateOperationsInput | string
  }

  export type court_decision_typesUncheckedUpdateInput = {
    court_decision_type_id?: IntFieldUpdateOperationsInput | number
    court_type?: IntFieldUpdateOperationsInput | number
    court_decision?: StringFieldUpdateOperationsInput | string
  }

  export type court_decision_typesCreateManyInput = {
    court_decision_type_id?: number
    court_type: number
    court_decision: string
  }

  export type court_decision_typesUpdateManyMutationInput = {
    court_type?: IntFieldUpdateOperationsInput | number
    court_decision?: StringFieldUpdateOperationsInput | string
  }

  export type court_decision_typesUncheckedUpdateManyInput = {
    court_decision_type_id?: IntFieldUpdateOperationsInput | number
    court_type?: IntFieldUpdateOperationsInput | number
    court_decision?: StringFieldUpdateOperationsInput | string
  }

  export type court_decisionsCreateInput = {
    appeal_id: number
    decission_type: number
    decison_date: Date | string
    decision_notification_date: Date | string
    input_date?: Date | string
    input_by: number
    actual?: number
  }

  export type court_decisionsUncheckedCreateInput = {
    court_decision_id?: number
    appeal_id: number
    decission_type: number
    decison_date: Date | string
    decision_notification_date: Date | string
    input_date?: Date | string
    input_by: number
    actual?: number
  }

  export type court_decisionsUpdateInput = {
    appeal_id?: IntFieldUpdateOperationsInput | number
    decission_type?: IntFieldUpdateOperationsInput | number
    decison_date?: DateTimeFieldUpdateOperationsInput | Date | string
    decision_notification_date?: DateTimeFieldUpdateOperationsInput | Date | string
    input_date?: DateTimeFieldUpdateOperationsInput | Date | string
    input_by?: IntFieldUpdateOperationsInput | number
    actual?: IntFieldUpdateOperationsInput | number
  }

  export type court_decisionsUncheckedUpdateInput = {
    court_decision_id?: IntFieldUpdateOperationsInput | number
    appeal_id?: IntFieldUpdateOperationsInput | number
    decission_type?: IntFieldUpdateOperationsInput | number
    decison_date?: DateTimeFieldUpdateOperationsInput | Date | string
    decision_notification_date?: DateTimeFieldUpdateOperationsInput | Date | string
    input_date?: DateTimeFieldUpdateOperationsInput | Date | string
    input_by?: IntFieldUpdateOperationsInput | number
    actual?: IntFieldUpdateOperationsInput | number
  }

  export type court_decisionsCreateManyInput = {
    court_decision_id?: number
    appeal_id: number
    decission_type: number
    decison_date: Date | string
    decision_notification_date: Date | string
    input_date?: Date | string
    input_by: number
    actual?: number
  }

  export type court_decisionsUpdateManyMutationInput = {
    appeal_id?: IntFieldUpdateOperationsInput | number
    decission_type?: IntFieldUpdateOperationsInput | number
    decison_date?: DateTimeFieldUpdateOperationsInput | Date | string
    decision_notification_date?: DateTimeFieldUpdateOperationsInput | Date | string
    input_date?: DateTimeFieldUpdateOperationsInput | Date | string
    input_by?: IntFieldUpdateOperationsInput | number
    actual?: IntFieldUpdateOperationsInput | number
  }

  export type court_decisionsUncheckedUpdateManyInput = {
    court_decision_id?: IntFieldUpdateOperationsInput | number
    appeal_id?: IntFieldUpdateOperationsInput | number
    decission_type?: IntFieldUpdateOperationsInput | number
    decison_date?: DateTimeFieldUpdateOperationsInput | Date | string
    decision_notification_date?: DateTimeFieldUpdateOperationsInput | Date | string
    input_date?: DateTimeFieldUpdateOperationsInput | Date | string
    input_by?: IntFieldUpdateOperationsInput | number
    actual?: IntFieldUpdateOperationsInput | number
  }

  export type court_levelsCreateInput = {
    court_title: string
  }

  export type court_levelsUncheckedCreateInput = {
    court_id?: number
    court_title: string
  }

  export type court_levelsUpdateInput = {
    court_title?: StringFieldUpdateOperationsInput | string
  }

  export type court_levelsUncheckedUpdateInput = {
    court_id?: IntFieldUpdateOperationsInput | number
    court_title?: StringFieldUpdateOperationsInput | string
  }

  export type court_levelsCreateManyInput = {
    court_id?: number
    court_title: string
  }

  export type court_levelsUpdateManyMutationInput = {
    court_title?: StringFieldUpdateOperationsInput | string
  }

  export type court_levelsUncheckedUpdateManyInput = {
    court_id?: IntFieldUpdateOperationsInput | number
    court_title?: StringFieldUpdateOperationsInput | string
  }

  export type cover_sign_statusCreateInput = {
    sign_status_name: string
  }

  export type cover_sign_statusUncheckedCreateInput = {
    sign_status_id?: number
    sign_status_name: string
  }

  export type cover_sign_statusUpdateInput = {
    sign_status_name?: StringFieldUpdateOperationsInput | string
  }

  export type cover_sign_statusUncheckedUpdateInput = {
    sign_status_id?: IntFieldUpdateOperationsInput | number
    sign_status_name?: StringFieldUpdateOperationsInput | string
  }

  export type cover_sign_statusCreateManyInput = {
    sign_status_id?: number
    sign_status_name: string
  }

  export type cover_sign_statusUpdateManyMutationInput = {
    sign_status_name?: StringFieldUpdateOperationsInput | string
  }

  export type cover_sign_statusUncheckedUpdateManyInput = {
    sign_status_id?: IntFieldUpdateOperationsInput | number
    sign_status_name?: StringFieldUpdateOperationsInput | string
  }

  export type filesCreateInput = {
    file_name: string
    uploaded_on?: Date | string
    file_type?: number | null
    uploader: number
    case_id: number
    decision_id?: number | null
    inter_id?: number | null
    coi_id?: number | null
    person_id?: number | null
    draft_id?: number | null
    claim_id?: number | null
    appeal_id?: number | null
    file_path?: string | null
    process_type_id?: number | null
    actual?: number
  }

  export type filesUncheckedCreateInput = {
    id?: number
    file_name: string
    uploaded_on?: Date | string
    file_type?: number | null
    uploader: number
    case_id: number
    decision_id?: number | null
    inter_id?: number | null
    coi_id?: number | null
    person_id?: number | null
    draft_id?: number | null
    claim_id?: number | null
    appeal_id?: number | null
    file_path?: string | null
    process_type_id?: number | null
    actual?: number
  }

  export type filesUpdateInput = {
    file_name?: StringFieldUpdateOperationsInput | string
    uploaded_on?: DateTimeFieldUpdateOperationsInput | Date | string
    file_type?: NullableIntFieldUpdateOperationsInput | number | null
    uploader?: IntFieldUpdateOperationsInput | number
    case_id?: IntFieldUpdateOperationsInput | number
    decision_id?: NullableIntFieldUpdateOperationsInput | number | null
    inter_id?: NullableIntFieldUpdateOperationsInput | number | null
    coi_id?: NullableIntFieldUpdateOperationsInput | number | null
    person_id?: NullableIntFieldUpdateOperationsInput | number | null
    draft_id?: NullableIntFieldUpdateOperationsInput | number | null
    claim_id?: NullableIntFieldUpdateOperationsInput | number | null
    appeal_id?: NullableIntFieldUpdateOperationsInput | number | null
    file_path?: NullableStringFieldUpdateOperationsInput | string | null
    process_type_id?: NullableIntFieldUpdateOperationsInput | number | null
    actual?: IntFieldUpdateOperationsInput | number
  }

  export type filesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    file_name?: StringFieldUpdateOperationsInput | string
    uploaded_on?: DateTimeFieldUpdateOperationsInput | Date | string
    file_type?: NullableIntFieldUpdateOperationsInput | number | null
    uploader?: IntFieldUpdateOperationsInput | number
    case_id?: IntFieldUpdateOperationsInput | number
    decision_id?: NullableIntFieldUpdateOperationsInput | number | null
    inter_id?: NullableIntFieldUpdateOperationsInput | number | null
    coi_id?: NullableIntFieldUpdateOperationsInput | number | null
    person_id?: NullableIntFieldUpdateOperationsInput | number | null
    draft_id?: NullableIntFieldUpdateOperationsInput | number | null
    claim_id?: NullableIntFieldUpdateOperationsInput | number | null
    appeal_id?: NullableIntFieldUpdateOperationsInput | number | null
    file_path?: NullableStringFieldUpdateOperationsInput | string | null
    process_type_id?: NullableIntFieldUpdateOperationsInput | number | null
    actual?: IntFieldUpdateOperationsInput | number
  }

  export type filesCreateManyInput = {
    id?: number
    file_name: string
    uploaded_on?: Date | string
    file_type?: number | null
    uploader: number
    case_id: number
    decision_id?: number | null
    inter_id?: number | null
    coi_id?: number | null
    person_id?: number | null
    draft_id?: number | null
    claim_id?: number | null
    appeal_id?: number | null
    file_path?: string | null
    process_type_id?: number | null
    actual?: number
  }

  export type filesUpdateManyMutationInput = {
    file_name?: StringFieldUpdateOperationsInput | string
    uploaded_on?: DateTimeFieldUpdateOperationsInput | Date | string
    file_type?: NullableIntFieldUpdateOperationsInput | number | null
    uploader?: IntFieldUpdateOperationsInput | number
    case_id?: IntFieldUpdateOperationsInput | number
    decision_id?: NullableIntFieldUpdateOperationsInput | number | null
    inter_id?: NullableIntFieldUpdateOperationsInput | number | null
    coi_id?: NullableIntFieldUpdateOperationsInput | number | null
    person_id?: NullableIntFieldUpdateOperationsInput | number | null
    draft_id?: NullableIntFieldUpdateOperationsInput | number | null
    claim_id?: NullableIntFieldUpdateOperationsInput | number | null
    appeal_id?: NullableIntFieldUpdateOperationsInput | number | null
    file_path?: NullableStringFieldUpdateOperationsInput | string | null
    process_type_id?: NullableIntFieldUpdateOperationsInput | number | null
    actual?: IntFieldUpdateOperationsInput | number
  }

  export type filesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    file_name?: StringFieldUpdateOperationsInput | string
    uploaded_on?: DateTimeFieldUpdateOperationsInput | Date | string
    file_type?: NullableIntFieldUpdateOperationsInput | number | null
    uploader?: IntFieldUpdateOperationsInput | number
    case_id?: IntFieldUpdateOperationsInput | number
    decision_id?: NullableIntFieldUpdateOperationsInput | number | null
    inter_id?: NullableIntFieldUpdateOperationsInput | number | null
    coi_id?: NullableIntFieldUpdateOperationsInput | number | null
    person_id?: NullableIntFieldUpdateOperationsInput | number | null
    draft_id?: NullableIntFieldUpdateOperationsInput | number | null
    claim_id?: NullableIntFieldUpdateOperationsInput | number | null
    appeal_id?: NullableIntFieldUpdateOperationsInput | number | null
    file_path?: NullableStringFieldUpdateOperationsInput | string | null
    process_type_id?: NullableIntFieldUpdateOperationsInput | number | null
    actual?: IntFieldUpdateOperationsInput | number
  }

  export type ipsCreateInput = {
    ip: string
    created_at?: Date | string
  }

  export type ipsUncheckedCreateInput = {
    id?: number
    ip: string
    created_at?: Date | string
  }

  export type ipsUpdateInput = {
    ip?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ipsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    ip?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ipsCreateManyInput = {
    id?: number
    ip: string
    created_at?: Date | string
  }

  export type ipsUpdateManyMutationInput = {
    ip?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ipsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    ip?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type old_case_decisionsCreateInput = {
    old_case_id: number
    ms_decision: number
    ms_decision_date?: Date | string | null
    final_decision?: number | null
    final_decision_date?: Date | string | null
  }

  export type old_case_decisionsUncheckedCreateInput = {
    old_decision_id?: number
    old_case_id: number
    ms_decision: number
    ms_decision_date?: Date | string | null
    final_decision?: number | null
    final_decision_date?: Date | string | null
  }

  export type old_case_decisionsUpdateInput = {
    old_case_id?: IntFieldUpdateOperationsInput | number
    ms_decision?: IntFieldUpdateOperationsInput | number
    ms_decision_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    final_decision?: NullableIntFieldUpdateOperationsInput | number | null
    final_decision_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type old_case_decisionsUncheckedUpdateInput = {
    old_decision_id?: IntFieldUpdateOperationsInput | number
    old_case_id?: IntFieldUpdateOperationsInput | number
    ms_decision?: IntFieldUpdateOperationsInput | number
    ms_decision_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    final_decision?: NullableIntFieldUpdateOperationsInput | number | null
    final_decision_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type old_case_decisionsCreateManyInput = {
    old_decision_id?: number
    old_case_id: number
    ms_decision: number
    ms_decision_date?: Date | string | null
    final_decision?: number | null
    final_decision_date?: Date | string | null
  }

  export type old_case_decisionsUpdateManyMutationInput = {
    old_case_id?: IntFieldUpdateOperationsInput | number
    ms_decision?: IntFieldUpdateOperationsInput | number
    ms_decision_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    final_decision?: NullableIntFieldUpdateOperationsInput | number | null
    final_decision_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type old_case_decisionsUncheckedUpdateManyInput = {
    old_decision_id?: IntFieldUpdateOperationsInput | number
    old_case_id?: IntFieldUpdateOperationsInput | number
    ms_decision?: IntFieldUpdateOperationsInput | number
    ms_decision_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    final_decision?: NullableIntFieldUpdateOperationsInput | number | null
    final_decision_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type old_case_personCreateInput = {
    old_case_id: number
    f_name_arm?: string | null
    l_name_arm?: string | null
    p_name_arm?: string | null
    f_name_eng?: string | null
    l_name_eng?: string | null
    p_name_eng?: string | null
    sex: number
    b_day?: string | null
    b_month?: string | null
    b_year?: string | null
    role: number
    citizenship_id?: number | null
    card_num?: string | null
    doc_num?: string | null
    etnicity?: number | null
    religion?: number | null
    invalid?: number
    pregnant?: number
    seriously_ill?: number
    trafficking_victim?: number
    violence_victim?: number
    comment?: string | null
    illegal_border?: number
    transfer_moj?: number | null
    deport_prescurator?: number
    prison?: number
    image?: string | null
    pnum?: string | null
    doc_type?: number | null
    document_num?: string | null
    status?: number | null
  }

  export type old_case_personUncheckedCreateInput = {
    old_person_id?: number
    old_case_id: number
    f_name_arm?: string | null
    l_name_arm?: string | null
    p_name_arm?: string | null
    f_name_eng?: string | null
    l_name_eng?: string | null
    p_name_eng?: string | null
    sex: number
    b_day?: string | null
    b_month?: string | null
    b_year?: string | null
    role: number
    citizenship_id?: number | null
    card_num?: string | null
    doc_num?: string | null
    etnicity?: number | null
    religion?: number | null
    invalid?: number
    pregnant?: number
    seriously_ill?: number
    trafficking_victim?: number
    violence_victim?: number
    comment?: string | null
    illegal_border?: number
    transfer_moj?: number | null
    deport_prescurator?: number
    prison?: number
    image?: string | null
    pnum?: string | null
    doc_type?: number | null
    document_num?: string | null
    status?: number | null
  }

  export type old_case_personUpdateInput = {
    old_case_id?: IntFieldUpdateOperationsInput | number
    f_name_arm?: NullableStringFieldUpdateOperationsInput | string | null
    l_name_arm?: NullableStringFieldUpdateOperationsInput | string | null
    p_name_arm?: NullableStringFieldUpdateOperationsInput | string | null
    f_name_eng?: NullableStringFieldUpdateOperationsInput | string | null
    l_name_eng?: NullableStringFieldUpdateOperationsInput | string | null
    p_name_eng?: NullableStringFieldUpdateOperationsInput | string | null
    sex?: IntFieldUpdateOperationsInput | number
    b_day?: NullableStringFieldUpdateOperationsInput | string | null
    b_month?: NullableStringFieldUpdateOperationsInput | string | null
    b_year?: NullableStringFieldUpdateOperationsInput | string | null
    role?: IntFieldUpdateOperationsInput | number
    citizenship_id?: NullableIntFieldUpdateOperationsInput | number | null
    card_num?: NullableStringFieldUpdateOperationsInput | string | null
    doc_num?: NullableStringFieldUpdateOperationsInput | string | null
    etnicity?: NullableIntFieldUpdateOperationsInput | number | null
    religion?: NullableIntFieldUpdateOperationsInput | number | null
    invalid?: IntFieldUpdateOperationsInput | number
    pregnant?: IntFieldUpdateOperationsInput | number
    seriously_ill?: IntFieldUpdateOperationsInput | number
    trafficking_victim?: IntFieldUpdateOperationsInput | number
    violence_victim?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    illegal_border?: IntFieldUpdateOperationsInput | number
    transfer_moj?: NullableIntFieldUpdateOperationsInput | number | null
    deport_prescurator?: IntFieldUpdateOperationsInput | number
    prison?: IntFieldUpdateOperationsInput | number
    image?: NullableStringFieldUpdateOperationsInput | string | null
    pnum?: NullableStringFieldUpdateOperationsInput | string | null
    doc_type?: NullableIntFieldUpdateOperationsInput | number | null
    document_num?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type old_case_personUncheckedUpdateInput = {
    old_person_id?: IntFieldUpdateOperationsInput | number
    old_case_id?: IntFieldUpdateOperationsInput | number
    f_name_arm?: NullableStringFieldUpdateOperationsInput | string | null
    l_name_arm?: NullableStringFieldUpdateOperationsInput | string | null
    p_name_arm?: NullableStringFieldUpdateOperationsInput | string | null
    f_name_eng?: NullableStringFieldUpdateOperationsInput | string | null
    l_name_eng?: NullableStringFieldUpdateOperationsInput | string | null
    p_name_eng?: NullableStringFieldUpdateOperationsInput | string | null
    sex?: IntFieldUpdateOperationsInput | number
    b_day?: NullableStringFieldUpdateOperationsInput | string | null
    b_month?: NullableStringFieldUpdateOperationsInput | string | null
    b_year?: NullableStringFieldUpdateOperationsInput | string | null
    role?: IntFieldUpdateOperationsInput | number
    citizenship_id?: NullableIntFieldUpdateOperationsInput | number | null
    card_num?: NullableStringFieldUpdateOperationsInput | string | null
    doc_num?: NullableStringFieldUpdateOperationsInput | string | null
    etnicity?: NullableIntFieldUpdateOperationsInput | number | null
    religion?: NullableIntFieldUpdateOperationsInput | number | null
    invalid?: IntFieldUpdateOperationsInput | number
    pregnant?: IntFieldUpdateOperationsInput | number
    seriously_ill?: IntFieldUpdateOperationsInput | number
    trafficking_victim?: IntFieldUpdateOperationsInput | number
    violence_victim?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    illegal_border?: IntFieldUpdateOperationsInput | number
    transfer_moj?: NullableIntFieldUpdateOperationsInput | number | null
    deport_prescurator?: IntFieldUpdateOperationsInput | number
    prison?: IntFieldUpdateOperationsInput | number
    image?: NullableStringFieldUpdateOperationsInput | string | null
    pnum?: NullableStringFieldUpdateOperationsInput | string | null
    doc_type?: NullableIntFieldUpdateOperationsInput | number | null
    document_num?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type old_case_personCreateManyInput = {
    old_person_id?: number
    old_case_id: number
    f_name_arm?: string | null
    l_name_arm?: string | null
    p_name_arm?: string | null
    f_name_eng?: string | null
    l_name_eng?: string | null
    p_name_eng?: string | null
    sex: number
    b_day?: string | null
    b_month?: string | null
    b_year?: string | null
    role: number
    citizenship_id?: number | null
    card_num?: string | null
    doc_num?: string | null
    etnicity?: number | null
    religion?: number | null
    invalid?: number
    pregnant?: number
    seriously_ill?: number
    trafficking_victim?: number
    violence_victim?: number
    comment?: string | null
    illegal_border?: number
    transfer_moj?: number | null
    deport_prescurator?: number
    prison?: number
    image?: string | null
    pnum?: string | null
    doc_type?: number | null
    document_num?: string | null
    status?: number | null
  }

  export type old_case_personUpdateManyMutationInput = {
    old_case_id?: IntFieldUpdateOperationsInput | number
    f_name_arm?: NullableStringFieldUpdateOperationsInput | string | null
    l_name_arm?: NullableStringFieldUpdateOperationsInput | string | null
    p_name_arm?: NullableStringFieldUpdateOperationsInput | string | null
    f_name_eng?: NullableStringFieldUpdateOperationsInput | string | null
    l_name_eng?: NullableStringFieldUpdateOperationsInput | string | null
    p_name_eng?: NullableStringFieldUpdateOperationsInput | string | null
    sex?: IntFieldUpdateOperationsInput | number
    b_day?: NullableStringFieldUpdateOperationsInput | string | null
    b_month?: NullableStringFieldUpdateOperationsInput | string | null
    b_year?: NullableStringFieldUpdateOperationsInput | string | null
    role?: IntFieldUpdateOperationsInput | number
    citizenship_id?: NullableIntFieldUpdateOperationsInput | number | null
    card_num?: NullableStringFieldUpdateOperationsInput | string | null
    doc_num?: NullableStringFieldUpdateOperationsInput | string | null
    etnicity?: NullableIntFieldUpdateOperationsInput | number | null
    religion?: NullableIntFieldUpdateOperationsInput | number | null
    invalid?: IntFieldUpdateOperationsInput | number
    pregnant?: IntFieldUpdateOperationsInput | number
    seriously_ill?: IntFieldUpdateOperationsInput | number
    trafficking_victim?: IntFieldUpdateOperationsInput | number
    violence_victim?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    illegal_border?: IntFieldUpdateOperationsInput | number
    transfer_moj?: NullableIntFieldUpdateOperationsInput | number | null
    deport_prescurator?: IntFieldUpdateOperationsInput | number
    prison?: IntFieldUpdateOperationsInput | number
    image?: NullableStringFieldUpdateOperationsInput | string | null
    pnum?: NullableStringFieldUpdateOperationsInput | string | null
    doc_type?: NullableIntFieldUpdateOperationsInput | number | null
    document_num?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type old_case_personUncheckedUpdateManyInput = {
    old_person_id?: IntFieldUpdateOperationsInput | number
    old_case_id?: IntFieldUpdateOperationsInput | number
    f_name_arm?: NullableStringFieldUpdateOperationsInput | string | null
    l_name_arm?: NullableStringFieldUpdateOperationsInput | string | null
    p_name_arm?: NullableStringFieldUpdateOperationsInput | string | null
    f_name_eng?: NullableStringFieldUpdateOperationsInput | string | null
    l_name_eng?: NullableStringFieldUpdateOperationsInput | string | null
    p_name_eng?: NullableStringFieldUpdateOperationsInput | string | null
    sex?: IntFieldUpdateOperationsInput | number
    b_day?: NullableStringFieldUpdateOperationsInput | string | null
    b_month?: NullableStringFieldUpdateOperationsInput | string | null
    b_year?: NullableStringFieldUpdateOperationsInput | string | null
    role?: IntFieldUpdateOperationsInput | number
    citizenship_id?: NullableIntFieldUpdateOperationsInput | number | null
    card_num?: NullableStringFieldUpdateOperationsInput | string | null
    doc_num?: NullableStringFieldUpdateOperationsInput | string | null
    etnicity?: NullableIntFieldUpdateOperationsInput | number | null
    religion?: NullableIntFieldUpdateOperationsInput | number | null
    invalid?: IntFieldUpdateOperationsInput | number
    pregnant?: IntFieldUpdateOperationsInput | number
    seriously_ill?: IntFieldUpdateOperationsInput | number
    trafficking_victim?: IntFieldUpdateOperationsInput | number
    violence_victim?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    illegal_border?: IntFieldUpdateOperationsInput | number
    transfer_moj?: NullableIntFieldUpdateOperationsInput | number | null
    deport_prescurator?: IntFieldUpdateOperationsInput | number
    prison?: IntFieldUpdateOperationsInput | number
    image?: NullableStringFieldUpdateOperationsInput | string | null
    pnum?: NullableStringFieldUpdateOperationsInput | string | null
    doc_type?: NullableIntFieldUpdateOperationsInput | number | null
    document_num?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type old_casesCreateInput = {
    application_date: Date | string
    citizenship: number
    RA_address?: string | null
    building?: string | null
    apartment?: string | null
    marz_id?: number | null
    community_id?: number | null
    bnak_id?: number | null
    unaccompanied_child?: number
    separated_child?: number
    single_parent?: number
    prefered_language?: string | null
    contact_tel?: string | null
    comment?: string | null
  }

  export type old_casesUncheckedCreateInput = {
    old_case_id?: number
    application_date: Date | string
    citizenship: number
    RA_address?: string | null
    building?: string | null
    apartment?: string | null
    marz_id?: number | null
    community_id?: number | null
    bnak_id?: number | null
    unaccompanied_child?: number
    separated_child?: number
    single_parent?: number
    prefered_language?: string | null
    contact_tel?: string | null
    comment?: string | null
  }

  export type old_casesUpdateInput = {
    application_date?: DateTimeFieldUpdateOperationsInput | Date | string
    citizenship?: IntFieldUpdateOperationsInput | number
    RA_address?: NullableStringFieldUpdateOperationsInput | string | null
    building?: NullableStringFieldUpdateOperationsInput | string | null
    apartment?: NullableStringFieldUpdateOperationsInput | string | null
    marz_id?: NullableIntFieldUpdateOperationsInput | number | null
    community_id?: NullableIntFieldUpdateOperationsInput | number | null
    bnak_id?: NullableIntFieldUpdateOperationsInput | number | null
    unaccompanied_child?: IntFieldUpdateOperationsInput | number
    separated_child?: IntFieldUpdateOperationsInput | number
    single_parent?: IntFieldUpdateOperationsInput | number
    prefered_language?: NullableStringFieldUpdateOperationsInput | string | null
    contact_tel?: NullableStringFieldUpdateOperationsInput | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type old_casesUncheckedUpdateInput = {
    old_case_id?: IntFieldUpdateOperationsInput | number
    application_date?: DateTimeFieldUpdateOperationsInput | Date | string
    citizenship?: IntFieldUpdateOperationsInput | number
    RA_address?: NullableStringFieldUpdateOperationsInput | string | null
    building?: NullableStringFieldUpdateOperationsInput | string | null
    apartment?: NullableStringFieldUpdateOperationsInput | string | null
    marz_id?: NullableIntFieldUpdateOperationsInput | number | null
    community_id?: NullableIntFieldUpdateOperationsInput | number | null
    bnak_id?: NullableIntFieldUpdateOperationsInput | number | null
    unaccompanied_child?: IntFieldUpdateOperationsInput | number
    separated_child?: IntFieldUpdateOperationsInput | number
    single_parent?: IntFieldUpdateOperationsInput | number
    prefered_language?: NullableStringFieldUpdateOperationsInput | string | null
    contact_tel?: NullableStringFieldUpdateOperationsInput | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type old_casesCreateManyInput = {
    old_case_id?: number
    application_date: Date | string
    citizenship: number
    RA_address?: string | null
    building?: string | null
    apartment?: string | null
    marz_id?: number | null
    community_id?: number | null
    bnak_id?: number | null
    unaccompanied_child?: number
    separated_child?: number
    single_parent?: number
    prefered_language?: string | null
    contact_tel?: string | null
    comment?: string | null
  }

  export type old_casesUpdateManyMutationInput = {
    application_date?: DateTimeFieldUpdateOperationsInput | Date | string
    citizenship?: IntFieldUpdateOperationsInput | number
    RA_address?: NullableStringFieldUpdateOperationsInput | string | null
    building?: NullableStringFieldUpdateOperationsInput | string | null
    apartment?: NullableStringFieldUpdateOperationsInput | string | null
    marz_id?: NullableIntFieldUpdateOperationsInput | number | null
    community_id?: NullableIntFieldUpdateOperationsInput | number | null
    bnak_id?: NullableIntFieldUpdateOperationsInput | number | null
    unaccompanied_child?: IntFieldUpdateOperationsInput | number
    separated_child?: IntFieldUpdateOperationsInput | number
    single_parent?: IntFieldUpdateOperationsInput | number
    prefered_language?: NullableStringFieldUpdateOperationsInput | string | null
    contact_tel?: NullableStringFieldUpdateOperationsInput | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type old_casesUncheckedUpdateManyInput = {
    old_case_id?: IntFieldUpdateOperationsInput | number
    application_date?: DateTimeFieldUpdateOperationsInput | Date | string
    citizenship?: IntFieldUpdateOperationsInput | number
    RA_address?: NullableStringFieldUpdateOperationsInput | string | null
    building?: NullableStringFieldUpdateOperationsInput | string | null
    apartment?: NullableStringFieldUpdateOperationsInput | string | null
    marz_id?: NullableIntFieldUpdateOperationsInput | number | null
    community_id?: NullableIntFieldUpdateOperationsInput | number | null
    bnak_id?: NullableIntFieldUpdateOperationsInput | number | null
    unaccompanied_child?: IntFieldUpdateOperationsInput | number
    separated_child?: IntFieldUpdateOperationsInput | number
    single_parent?: IntFieldUpdateOperationsInput | number
    prefered_language?: NullableStringFieldUpdateOperationsInput | string | null
    contact_tel?: NullableStringFieldUpdateOperationsInput | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type tb_arm_comCreateInput = {
    marz_id: number
    ADM3_PCODE: string
    ADM3_ARM: string
    ADM3_EN: string
    exist?: number
    active?: number
  }

  export type tb_arm_comUncheckedCreateInput = {
    community_id?: number
    marz_id: number
    ADM3_PCODE: string
    ADM3_ARM: string
    ADM3_EN: string
    exist?: number
    active?: number
  }

  export type tb_arm_comUpdateInput = {
    marz_id?: IntFieldUpdateOperationsInput | number
    ADM3_PCODE?: StringFieldUpdateOperationsInput | string
    ADM3_ARM?: StringFieldUpdateOperationsInput | string
    ADM3_EN?: StringFieldUpdateOperationsInput | string
    exist?: IntFieldUpdateOperationsInput | number
    active?: IntFieldUpdateOperationsInput | number
  }

  export type tb_arm_comUncheckedUpdateInput = {
    community_id?: IntFieldUpdateOperationsInput | number
    marz_id?: IntFieldUpdateOperationsInput | number
    ADM3_PCODE?: StringFieldUpdateOperationsInput | string
    ADM3_ARM?: StringFieldUpdateOperationsInput | string
    ADM3_EN?: StringFieldUpdateOperationsInput | string
    exist?: IntFieldUpdateOperationsInput | number
    active?: IntFieldUpdateOperationsInput | number
  }

  export type tb_arm_comCreateManyInput = {
    community_id?: number
    marz_id: number
    ADM3_PCODE: string
    ADM3_ARM: string
    ADM3_EN: string
    exist?: number
    active?: number
  }

  export type tb_arm_comUpdateManyMutationInput = {
    marz_id?: IntFieldUpdateOperationsInput | number
    ADM3_PCODE?: StringFieldUpdateOperationsInput | string
    ADM3_ARM?: StringFieldUpdateOperationsInput | string
    ADM3_EN?: StringFieldUpdateOperationsInput | string
    exist?: IntFieldUpdateOperationsInput | number
    active?: IntFieldUpdateOperationsInput | number
  }

  export type tb_arm_comUncheckedUpdateManyInput = {
    community_id?: IntFieldUpdateOperationsInput | number
    marz_id?: IntFieldUpdateOperationsInput | number
    ADM3_PCODE?: StringFieldUpdateOperationsInput | string
    ADM3_ARM?: StringFieldUpdateOperationsInput | string
    ADM3_EN?: StringFieldUpdateOperationsInput | string
    exist?: IntFieldUpdateOperationsInput | number
    active?: IntFieldUpdateOperationsInput | number
  }

  export type tb_arm_com__CreateInput = {
    marz_id: number
    ADM3_PCODE: string
    ADM3_ARM: string
    ADM3_EN: string
  }

  export type tb_arm_com__UncheckedCreateInput = {
    community_id?: number
    marz_id: number
    ADM3_PCODE: string
    ADM3_ARM: string
    ADM3_EN: string
  }

  export type tb_arm_com__UpdateInput = {
    marz_id?: IntFieldUpdateOperationsInput | number
    ADM3_PCODE?: StringFieldUpdateOperationsInput | string
    ADM3_ARM?: StringFieldUpdateOperationsInput | string
    ADM3_EN?: StringFieldUpdateOperationsInput | string
  }

  export type tb_arm_com__UncheckedUpdateInput = {
    community_id?: IntFieldUpdateOperationsInput | number
    marz_id?: IntFieldUpdateOperationsInput | number
    ADM3_PCODE?: StringFieldUpdateOperationsInput | string
    ADM3_ARM?: StringFieldUpdateOperationsInput | string
    ADM3_EN?: StringFieldUpdateOperationsInput | string
  }

  export type tb_arm_com__CreateManyInput = {
    community_id?: number
    marz_id: number
    ADM3_PCODE: string
    ADM3_ARM: string
    ADM3_EN: string
  }

  export type tb_arm_com__UpdateManyMutationInput = {
    marz_id?: IntFieldUpdateOperationsInput | number
    ADM3_PCODE?: StringFieldUpdateOperationsInput | string
    ADM3_ARM?: StringFieldUpdateOperationsInput | string
    ADM3_EN?: StringFieldUpdateOperationsInput | string
  }

  export type tb_arm_com__UncheckedUpdateManyInput = {
    community_id?: IntFieldUpdateOperationsInput | number
    marz_id?: IntFieldUpdateOperationsInput | number
    ADM3_PCODE?: StringFieldUpdateOperationsInput | string
    ADM3_ARM?: StringFieldUpdateOperationsInput | string
    ADM3_EN?: StringFieldUpdateOperationsInput | string
  }

  export type tb_calendarCreateInput = {
    case_id: number
    user_id: number
    inter_comment: string
    inter_date_from?: Date | string | null
    inter_date_to?: Date | string | null
    text_color: string
    border_color: string
    actual_event?: number
  }

  export type tb_calendarUncheckedCreateInput = {
    interview_id?: number
    case_id: number
    user_id: number
    inter_comment: string
    inter_date_from?: Date | string | null
    inter_date_to?: Date | string | null
    text_color: string
    border_color: string
    actual_event?: number
  }

  export type tb_calendarUpdateInput = {
    case_id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    inter_comment?: StringFieldUpdateOperationsInput | string
    inter_date_from?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    inter_date_to?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    text_color?: StringFieldUpdateOperationsInput | string
    border_color?: StringFieldUpdateOperationsInput | string
    actual_event?: IntFieldUpdateOperationsInput | number
  }

  export type tb_calendarUncheckedUpdateInput = {
    interview_id?: IntFieldUpdateOperationsInput | number
    case_id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    inter_comment?: StringFieldUpdateOperationsInput | string
    inter_date_from?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    inter_date_to?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    text_color?: StringFieldUpdateOperationsInput | string
    border_color?: StringFieldUpdateOperationsInput | string
    actual_event?: IntFieldUpdateOperationsInput | number
  }

  export type tb_calendarCreateManyInput = {
    interview_id?: number
    case_id: number
    user_id: number
    inter_comment: string
    inter_date_from?: Date | string | null
    inter_date_to?: Date | string | null
    text_color: string
    border_color: string
    actual_event?: number
  }

  export type tb_calendarUpdateManyMutationInput = {
    case_id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    inter_comment?: StringFieldUpdateOperationsInput | string
    inter_date_from?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    inter_date_to?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    text_color?: StringFieldUpdateOperationsInput | string
    border_color?: StringFieldUpdateOperationsInput | string
    actual_event?: IntFieldUpdateOperationsInput | number
  }

  export type tb_calendarUncheckedUpdateManyInput = {
    interview_id?: IntFieldUpdateOperationsInput | number
    case_id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    inter_comment?: StringFieldUpdateOperationsInput | string
    inter_date_from?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    inter_date_to?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    text_color?: StringFieldUpdateOperationsInput | string
    border_color?: StringFieldUpdateOperationsInput | string
    actual_event?: IntFieldUpdateOperationsInput | number
  }

  export type tb_cancelCreateInput = {
    personal_id: number
    case_id: number
    decision_date: Date | string
    uploader: number
    uploaded?: Date | string
    file_id: number
  }

  export type tb_cancelUncheckedCreateInput = {
    id?: number
    personal_id: number
    case_id: number
    decision_date: Date | string
    uploader: number
    uploaded?: Date | string
    file_id: number
  }

  export type tb_cancelUpdateInput = {
    personal_id?: IntFieldUpdateOperationsInput | number
    case_id?: IntFieldUpdateOperationsInput | number
    decision_date?: DateTimeFieldUpdateOperationsInput | Date | string
    uploader?: IntFieldUpdateOperationsInput | number
    uploaded?: DateTimeFieldUpdateOperationsInput | Date | string
    file_id?: IntFieldUpdateOperationsInput | number
  }

  export type tb_cancelUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    personal_id?: IntFieldUpdateOperationsInput | number
    case_id?: IntFieldUpdateOperationsInput | number
    decision_date?: DateTimeFieldUpdateOperationsInput | Date | string
    uploader?: IntFieldUpdateOperationsInput | number
    uploaded?: DateTimeFieldUpdateOperationsInput | Date | string
    file_id?: IntFieldUpdateOperationsInput | number
  }

  export type tb_cancelCreateManyInput = {
    id?: number
    personal_id: number
    case_id: number
    decision_date: Date | string
    uploader: number
    uploaded?: Date | string
    file_id: number
  }

  export type tb_cancelUpdateManyMutationInput = {
    personal_id?: IntFieldUpdateOperationsInput | number
    case_id?: IntFieldUpdateOperationsInput | number
    decision_date?: DateTimeFieldUpdateOperationsInput | Date | string
    uploader?: IntFieldUpdateOperationsInput | number
    uploaded?: DateTimeFieldUpdateOperationsInput | Date | string
    file_id?: IntFieldUpdateOperationsInput | number
  }

  export type tb_cancelUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    personal_id?: IntFieldUpdateOperationsInput | number
    case_id?: IntFieldUpdateOperationsInput | number
    decision_date?: DateTimeFieldUpdateOperationsInput | Date | string
    uploader?: IntFieldUpdateOperationsInput | number
    uploaded?: DateTimeFieldUpdateOperationsInput | Date | string
    file_id?: IntFieldUpdateOperationsInput | number
  }

  export type tb_cardsCreateInput = {
    serial: string
    card_number: number
    personal_id: number
    issued: Date | string
    full_address?: string | null
    valid: Date | string
    bar: string
    printed?: Date | string
    actual_card: number
  }

  export type tb_cardsUncheckedCreateInput = {
    card_id?: number
    serial: string
    card_number: number
    personal_id: number
    issued: Date | string
    full_address?: string | null
    valid: Date | string
    bar: string
    printed?: Date | string
    actual_card: number
  }

  export type tb_cardsUpdateInput = {
    serial?: StringFieldUpdateOperationsInput | string
    card_number?: IntFieldUpdateOperationsInput | number
    personal_id?: IntFieldUpdateOperationsInput | number
    issued?: DateTimeFieldUpdateOperationsInput | Date | string
    full_address?: NullableStringFieldUpdateOperationsInput | string | null
    valid?: DateTimeFieldUpdateOperationsInput | Date | string
    bar?: StringFieldUpdateOperationsInput | string
    printed?: DateTimeFieldUpdateOperationsInput | Date | string
    actual_card?: IntFieldUpdateOperationsInput | number
  }

  export type tb_cardsUncheckedUpdateInput = {
    card_id?: IntFieldUpdateOperationsInput | number
    serial?: StringFieldUpdateOperationsInput | string
    card_number?: IntFieldUpdateOperationsInput | number
    personal_id?: IntFieldUpdateOperationsInput | number
    issued?: DateTimeFieldUpdateOperationsInput | Date | string
    full_address?: NullableStringFieldUpdateOperationsInput | string | null
    valid?: DateTimeFieldUpdateOperationsInput | Date | string
    bar?: StringFieldUpdateOperationsInput | string
    printed?: DateTimeFieldUpdateOperationsInput | Date | string
    actual_card?: IntFieldUpdateOperationsInput | number
  }

  export type tb_cardsCreateManyInput = {
    card_id?: number
    serial: string
    card_number: number
    personal_id: number
    issued: Date | string
    full_address?: string | null
    valid: Date | string
    bar: string
    printed?: Date | string
    actual_card: number
  }

  export type tb_cardsUpdateManyMutationInput = {
    serial?: StringFieldUpdateOperationsInput | string
    card_number?: IntFieldUpdateOperationsInput | number
    personal_id?: IntFieldUpdateOperationsInput | number
    issued?: DateTimeFieldUpdateOperationsInput | Date | string
    full_address?: NullableStringFieldUpdateOperationsInput | string | null
    valid?: DateTimeFieldUpdateOperationsInput | Date | string
    bar?: StringFieldUpdateOperationsInput | string
    printed?: DateTimeFieldUpdateOperationsInput | Date | string
    actual_card?: IntFieldUpdateOperationsInput | number
  }

  export type tb_cardsUncheckedUpdateManyInput = {
    card_id?: IntFieldUpdateOperationsInput | number
    serial?: StringFieldUpdateOperationsInput | string
    card_number?: IntFieldUpdateOperationsInput | number
    personal_id?: IntFieldUpdateOperationsInput | number
    issued?: DateTimeFieldUpdateOperationsInput | Date | string
    full_address?: NullableStringFieldUpdateOperationsInput | string | null
    valid?: DateTimeFieldUpdateOperationsInput | Date | string
    bar?: StringFieldUpdateOperationsInput | string
    printed?: DateTimeFieldUpdateOperationsInput | Date | string
    actual_card?: IntFieldUpdateOperationsInput | number
  }

  export type tb_caseCreateInput = {
    application_date: Date | string
    input_date?: Date | string
    reg_by: number
    officer?: number | null
    preferred_lawyer?: number
    unaccompanied_child?: number
    separated_child?: number
    single_parent?: number
    prefered_language?: string | null
    RA_marz?: number | null
    RA_community?: number | null
    RA_settlement?: number | null
    RA_street?: string | null
    RA_building?: string | null
    RA_apartment?: string | null
    contact_tel?: string | null
    contact_email?: string | null
    comment?: string | null
    case_status?: number | null
    mul_num?: string | null
    mul_date?: Date | string | null
    MS_lawyer?: number | null
    special?: number
    reopened?: number
    attached_case?: number | null
  }

  export type tb_caseUncheckedCreateInput = {
    case_id?: number
    application_date: Date | string
    input_date?: Date | string
    reg_by: number
    officer?: number | null
    preferred_lawyer?: number
    unaccompanied_child?: number
    separated_child?: number
    single_parent?: number
    prefered_language?: string | null
    RA_marz?: number | null
    RA_community?: number | null
    RA_settlement?: number | null
    RA_street?: string | null
    RA_building?: string | null
    RA_apartment?: string | null
    contact_tel?: string | null
    contact_email?: string | null
    comment?: string | null
    case_status?: number | null
    mul_num?: string | null
    mul_date?: Date | string | null
    MS_lawyer?: number | null
    special?: number
    reopened?: number
    attached_case?: number | null
  }

  export type tb_caseUpdateInput = {
    application_date?: DateTimeFieldUpdateOperationsInput | Date | string
    input_date?: DateTimeFieldUpdateOperationsInput | Date | string
    reg_by?: IntFieldUpdateOperationsInput | number
    officer?: NullableIntFieldUpdateOperationsInput | number | null
    preferred_lawyer?: IntFieldUpdateOperationsInput | number
    unaccompanied_child?: IntFieldUpdateOperationsInput | number
    separated_child?: IntFieldUpdateOperationsInput | number
    single_parent?: IntFieldUpdateOperationsInput | number
    prefered_language?: NullableStringFieldUpdateOperationsInput | string | null
    RA_marz?: NullableIntFieldUpdateOperationsInput | number | null
    RA_community?: NullableIntFieldUpdateOperationsInput | number | null
    RA_settlement?: NullableIntFieldUpdateOperationsInput | number | null
    RA_street?: NullableStringFieldUpdateOperationsInput | string | null
    RA_building?: NullableStringFieldUpdateOperationsInput | string | null
    RA_apartment?: NullableStringFieldUpdateOperationsInput | string | null
    contact_tel?: NullableStringFieldUpdateOperationsInput | string | null
    contact_email?: NullableStringFieldUpdateOperationsInput | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    case_status?: NullableIntFieldUpdateOperationsInput | number | null
    mul_num?: NullableStringFieldUpdateOperationsInput | string | null
    mul_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    MS_lawyer?: NullableIntFieldUpdateOperationsInput | number | null
    special?: IntFieldUpdateOperationsInput | number
    reopened?: IntFieldUpdateOperationsInput | number
    attached_case?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type tb_caseUncheckedUpdateInput = {
    case_id?: IntFieldUpdateOperationsInput | number
    application_date?: DateTimeFieldUpdateOperationsInput | Date | string
    input_date?: DateTimeFieldUpdateOperationsInput | Date | string
    reg_by?: IntFieldUpdateOperationsInput | number
    officer?: NullableIntFieldUpdateOperationsInput | number | null
    preferred_lawyer?: IntFieldUpdateOperationsInput | number
    unaccompanied_child?: IntFieldUpdateOperationsInput | number
    separated_child?: IntFieldUpdateOperationsInput | number
    single_parent?: IntFieldUpdateOperationsInput | number
    prefered_language?: NullableStringFieldUpdateOperationsInput | string | null
    RA_marz?: NullableIntFieldUpdateOperationsInput | number | null
    RA_community?: NullableIntFieldUpdateOperationsInput | number | null
    RA_settlement?: NullableIntFieldUpdateOperationsInput | number | null
    RA_street?: NullableStringFieldUpdateOperationsInput | string | null
    RA_building?: NullableStringFieldUpdateOperationsInput | string | null
    RA_apartment?: NullableStringFieldUpdateOperationsInput | string | null
    contact_tel?: NullableStringFieldUpdateOperationsInput | string | null
    contact_email?: NullableStringFieldUpdateOperationsInput | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    case_status?: NullableIntFieldUpdateOperationsInput | number | null
    mul_num?: NullableStringFieldUpdateOperationsInput | string | null
    mul_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    MS_lawyer?: NullableIntFieldUpdateOperationsInput | number | null
    special?: IntFieldUpdateOperationsInput | number
    reopened?: IntFieldUpdateOperationsInput | number
    attached_case?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type tb_caseCreateManyInput = {
    case_id?: number
    application_date: Date | string
    input_date?: Date | string
    reg_by: number
    officer?: number | null
    preferred_lawyer?: number
    unaccompanied_child?: number
    separated_child?: number
    single_parent?: number
    prefered_language?: string | null
    RA_marz?: number | null
    RA_community?: number | null
    RA_settlement?: number | null
    RA_street?: string | null
    RA_building?: string | null
    RA_apartment?: string | null
    contact_tel?: string | null
    contact_email?: string | null
    comment?: string | null
    case_status?: number | null
    mul_num?: string | null
    mul_date?: Date | string | null
    MS_lawyer?: number | null
    special?: number
    reopened?: number
    attached_case?: number | null
  }

  export type tb_caseUpdateManyMutationInput = {
    application_date?: DateTimeFieldUpdateOperationsInput | Date | string
    input_date?: DateTimeFieldUpdateOperationsInput | Date | string
    reg_by?: IntFieldUpdateOperationsInput | number
    officer?: NullableIntFieldUpdateOperationsInput | number | null
    preferred_lawyer?: IntFieldUpdateOperationsInput | number
    unaccompanied_child?: IntFieldUpdateOperationsInput | number
    separated_child?: IntFieldUpdateOperationsInput | number
    single_parent?: IntFieldUpdateOperationsInput | number
    prefered_language?: NullableStringFieldUpdateOperationsInput | string | null
    RA_marz?: NullableIntFieldUpdateOperationsInput | number | null
    RA_community?: NullableIntFieldUpdateOperationsInput | number | null
    RA_settlement?: NullableIntFieldUpdateOperationsInput | number | null
    RA_street?: NullableStringFieldUpdateOperationsInput | string | null
    RA_building?: NullableStringFieldUpdateOperationsInput | string | null
    RA_apartment?: NullableStringFieldUpdateOperationsInput | string | null
    contact_tel?: NullableStringFieldUpdateOperationsInput | string | null
    contact_email?: NullableStringFieldUpdateOperationsInput | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    case_status?: NullableIntFieldUpdateOperationsInput | number | null
    mul_num?: NullableStringFieldUpdateOperationsInput | string | null
    mul_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    MS_lawyer?: NullableIntFieldUpdateOperationsInput | number | null
    special?: IntFieldUpdateOperationsInput | number
    reopened?: IntFieldUpdateOperationsInput | number
    attached_case?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type tb_caseUncheckedUpdateManyInput = {
    case_id?: IntFieldUpdateOperationsInput | number
    application_date?: DateTimeFieldUpdateOperationsInput | Date | string
    input_date?: DateTimeFieldUpdateOperationsInput | Date | string
    reg_by?: IntFieldUpdateOperationsInput | number
    officer?: NullableIntFieldUpdateOperationsInput | number | null
    preferred_lawyer?: IntFieldUpdateOperationsInput | number
    unaccompanied_child?: IntFieldUpdateOperationsInput | number
    separated_child?: IntFieldUpdateOperationsInput | number
    single_parent?: IntFieldUpdateOperationsInput | number
    prefered_language?: NullableStringFieldUpdateOperationsInput | string | null
    RA_marz?: NullableIntFieldUpdateOperationsInput | number | null
    RA_community?: NullableIntFieldUpdateOperationsInput | number | null
    RA_settlement?: NullableIntFieldUpdateOperationsInput | number | null
    RA_street?: NullableStringFieldUpdateOperationsInput | string | null
    RA_building?: NullableStringFieldUpdateOperationsInput | string | null
    RA_apartment?: NullableStringFieldUpdateOperationsInput | string | null
    contact_tel?: NullableStringFieldUpdateOperationsInput | string | null
    contact_email?: NullableStringFieldUpdateOperationsInput | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    case_status?: NullableIntFieldUpdateOperationsInput | number | null
    mul_num?: NullableStringFieldUpdateOperationsInput | string | null
    mul_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    MS_lawyer?: NullableIntFieldUpdateOperationsInput | number | null
    special?: IntFieldUpdateOperationsInput | number
    reopened?: IntFieldUpdateOperationsInput | number
    attached_case?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type tb_case_statusCreateInput = {
    case_status: string
    case_status_eng?: string | null
  }

  export type tb_case_statusUncheckedCreateInput = {
    case_status_id?: number
    case_status: string
    case_status_eng?: string | null
  }

  export type tb_case_statusUpdateInput = {
    case_status?: StringFieldUpdateOperationsInput | string
    case_status_eng?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type tb_case_statusUncheckedUpdateInput = {
    case_status_id?: IntFieldUpdateOperationsInput | number
    case_status?: StringFieldUpdateOperationsInput | string
    case_status_eng?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type tb_case_statusCreateManyInput = {
    case_status_id?: number
    case_status: string
    case_status_eng?: string | null
  }

  export type tb_case_statusUpdateManyMutationInput = {
    case_status?: StringFieldUpdateOperationsInput | string
    case_status_eng?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type tb_case_statusUncheckedUpdateManyInput = {
    case_status_id?: IntFieldUpdateOperationsInput | number
    case_status?: StringFieldUpdateOperationsInput | string
    case_status_eng?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type tb_checkinCreateInput = {
    checkin_date?: Date | string | null
    checkout_date?: Date | string | null
    personal_id: number
    order_id: number
    status?: number
    doss_id: number
  }

  export type tb_checkinUncheckedCreateInput = {
    checkin_id?: number
    checkin_date?: Date | string | null
    checkout_date?: Date | string | null
    personal_id: number
    order_id: number
    status?: number
    doss_id: number
  }

  export type tb_checkinUpdateInput = {
    checkin_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkout_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    personal_id?: IntFieldUpdateOperationsInput | number
    order_id?: IntFieldUpdateOperationsInput | number
    status?: IntFieldUpdateOperationsInput | number
    doss_id?: IntFieldUpdateOperationsInput | number
  }

  export type tb_checkinUncheckedUpdateInput = {
    checkin_id?: IntFieldUpdateOperationsInput | number
    checkin_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkout_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    personal_id?: IntFieldUpdateOperationsInput | number
    order_id?: IntFieldUpdateOperationsInput | number
    status?: IntFieldUpdateOperationsInput | number
    doss_id?: IntFieldUpdateOperationsInput | number
  }

  export type tb_checkinCreateManyInput = {
    checkin_id?: number
    checkin_date?: Date | string | null
    checkout_date?: Date | string | null
    personal_id: number
    order_id: number
    status?: number
    doss_id: number
  }

  export type tb_checkinUpdateManyMutationInput = {
    checkin_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkout_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    personal_id?: IntFieldUpdateOperationsInput | number
    order_id?: IntFieldUpdateOperationsInput | number
    status?: IntFieldUpdateOperationsInput | number
    doss_id?: IntFieldUpdateOperationsInput | number
  }

  export type tb_checkinUncheckedUpdateManyInput = {
    checkin_id?: IntFieldUpdateOperationsInput | number
    checkin_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkout_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    personal_id?: IntFieldUpdateOperationsInput | number
    order_id?: IntFieldUpdateOperationsInput | number
    status?: IntFieldUpdateOperationsInput | number
    doss_id?: IntFieldUpdateOperationsInput | number
  }

  export type tb_coiCreateInput = {
    from_officer: number
    to_coispec: number
    case_id: number
    request_date: Date | string
    request_deadline: Date | string
    description?: string | null
    request_text: string
    coi_state: number
    request_count?: number | null
    response_date?: Date | string | null
    coi_status: number
  }

  export type tb_coiUncheckedCreateInput = {
    coi_id?: number
    from_officer: number
    to_coispec: number
    case_id: number
    request_date: Date | string
    request_deadline: Date | string
    description?: string | null
    request_text: string
    coi_state: number
    request_count?: number | null
    response_date?: Date | string | null
    coi_status: number
  }

  export type tb_coiUpdateInput = {
    from_officer?: IntFieldUpdateOperationsInput | number
    to_coispec?: IntFieldUpdateOperationsInput | number
    case_id?: IntFieldUpdateOperationsInput | number
    request_date?: DateTimeFieldUpdateOperationsInput | Date | string
    request_deadline?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    request_text?: StringFieldUpdateOperationsInput | string
    coi_state?: IntFieldUpdateOperationsInput | number
    request_count?: NullableIntFieldUpdateOperationsInput | number | null
    response_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    coi_status?: IntFieldUpdateOperationsInput | number
  }

  export type tb_coiUncheckedUpdateInput = {
    coi_id?: IntFieldUpdateOperationsInput | number
    from_officer?: IntFieldUpdateOperationsInput | number
    to_coispec?: IntFieldUpdateOperationsInput | number
    case_id?: IntFieldUpdateOperationsInput | number
    request_date?: DateTimeFieldUpdateOperationsInput | Date | string
    request_deadline?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    request_text?: StringFieldUpdateOperationsInput | string
    coi_state?: IntFieldUpdateOperationsInput | number
    request_count?: NullableIntFieldUpdateOperationsInput | number | null
    response_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    coi_status?: IntFieldUpdateOperationsInput | number
  }

  export type tb_coiCreateManyInput = {
    coi_id?: number
    from_officer: number
    to_coispec: number
    case_id: number
    request_date: Date | string
    request_deadline: Date | string
    description?: string | null
    request_text: string
    coi_state: number
    request_count?: number | null
    response_date?: Date | string | null
    coi_status: number
  }

  export type tb_coiUpdateManyMutationInput = {
    from_officer?: IntFieldUpdateOperationsInput | number
    to_coispec?: IntFieldUpdateOperationsInput | number
    case_id?: IntFieldUpdateOperationsInput | number
    request_date?: DateTimeFieldUpdateOperationsInput | Date | string
    request_deadline?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    request_text?: StringFieldUpdateOperationsInput | string
    coi_state?: IntFieldUpdateOperationsInput | number
    request_count?: NullableIntFieldUpdateOperationsInput | number | null
    response_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    coi_status?: IntFieldUpdateOperationsInput | number
  }

  export type tb_coiUncheckedUpdateManyInput = {
    coi_id?: IntFieldUpdateOperationsInput | number
    from_officer?: IntFieldUpdateOperationsInput | number
    to_coispec?: IntFieldUpdateOperationsInput | number
    case_id?: IntFieldUpdateOperationsInput | number
    request_date?: DateTimeFieldUpdateOperationsInput | Date | string
    request_deadline?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    request_text?: StringFieldUpdateOperationsInput | string
    coi_state?: IntFieldUpdateOperationsInput | number
    request_count?: NullableIntFieldUpdateOperationsInput | number | null
    response_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    coi_status?: IntFieldUpdateOperationsInput | number
  }

  export type tb_countryCreateInput = {
    country_eng: string
    country_arm: string
  }

  export type tb_countryUncheckedCreateInput = {
    country_id?: number
    country_eng: string
    country_arm: string
  }

  export type tb_countryUpdateInput = {
    country_eng?: StringFieldUpdateOperationsInput | string
    country_arm?: StringFieldUpdateOperationsInput | string
  }

  export type tb_countryUncheckedUpdateInput = {
    country_id?: IntFieldUpdateOperationsInput | number
    country_eng?: StringFieldUpdateOperationsInput | string
    country_arm?: StringFieldUpdateOperationsInput | string
  }

  export type tb_countryCreateManyInput = {
    country_id?: number
    country_eng: string
    country_arm: string
  }

  export type tb_countryUpdateManyMutationInput = {
    country_eng?: StringFieldUpdateOperationsInput | string
    country_arm?: StringFieldUpdateOperationsInput | string
  }

  export type tb_countryUncheckedUpdateManyInput = {
    country_id?: IntFieldUpdateOperationsInput | number
    country_eng?: StringFieldUpdateOperationsInput | string
    country_arm?: StringFieldUpdateOperationsInput | string
  }

  export type tb_cover_filesCreateInput = {
    type: number
    file_name: string
    cover_status: number
    case_id: number
    translation_id: number
    cover_actual?: number | null
  }

  export type tb_cover_filesUncheckedCreateInput = {
    cover_file_id?: number
    type: number
    file_name: string
    cover_status: number
    case_id: number
    translation_id: number
    cover_actual?: number | null
  }

  export type tb_cover_filesUpdateInput = {
    type?: IntFieldUpdateOperationsInput | number
    file_name?: StringFieldUpdateOperationsInput | string
    cover_status?: IntFieldUpdateOperationsInput | number
    case_id?: IntFieldUpdateOperationsInput | number
    translation_id?: IntFieldUpdateOperationsInput | number
    cover_actual?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type tb_cover_filesUncheckedUpdateInput = {
    cover_file_id?: IntFieldUpdateOperationsInput | number
    type?: IntFieldUpdateOperationsInput | number
    file_name?: StringFieldUpdateOperationsInput | string
    cover_status?: IntFieldUpdateOperationsInput | number
    case_id?: IntFieldUpdateOperationsInput | number
    translation_id?: IntFieldUpdateOperationsInput | number
    cover_actual?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type tb_cover_filesCreateManyInput = {
    cover_file_id?: number
    type: number
    file_name: string
    cover_status: number
    case_id: number
    translation_id: number
    cover_actual?: number | null
  }

  export type tb_cover_filesUpdateManyMutationInput = {
    type?: IntFieldUpdateOperationsInput | number
    file_name?: StringFieldUpdateOperationsInput | string
    cover_status?: IntFieldUpdateOperationsInput | number
    case_id?: IntFieldUpdateOperationsInput | number
    translation_id?: IntFieldUpdateOperationsInput | number
    cover_actual?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type tb_cover_filesUncheckedUpdateManyInput = {
    cover_file_id?: IntFieldUpdateOperationsInput | number
    type?: IntFieldUpdateOperationsInput | number
    file_name?: StringFieldUpdateOperationsInput | string
    cover_status?: IntFieldUpdateOperationsInput | number
    case_id?: IntFieldUpdateOperationsInput | number
    translation_id?: IntFieldUpdateOperationsInput | number
    cover_actual?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type tb_deadlineCreateInput = {
    case_id: number
    deadline_type: number
    deadline: Date | string
    actual_dead: number
    process_type_id: number
  }

  export type tb_deadlineUncheckedCreateInput = {
    id?: number
    case_id: number
    deadline_type: number
    deadline: Date | string
    actual_dead: number
    process_type_id: number
  }

  export type tb_deadlineUpdateInput = {
    case_id?: IntFieldUpdateOperationsInput | number
    deadline_type?: IntFieldUpdateOperationsInput | number
    deadline?: DateTimeFieldUpdateOperationsInput | Date | string
    actual_dead?: IntFieldUpdateOperationsInput | number
    process_type_id?: IntFieldUpdateOperationsInput | number
  }

  export type tb_deadlineUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    case_id?: IntFieldUpdateOperationsInput | number
    deadline_type?: IntFieldUpdateOperationsInput | number
    deadline?: DateTimeFieldUpdateOperationsInput | Date | string
    actual_dead?: IntFieldUpdateOperationsInput | number
    process_type_id?: IntFieldUpdateOperationsInput | number
  }

  export type tb_deadlineCreateManyInput = {
    id?: number
    case_id: number
    deadline_type: number
    deadline: Date | string
    actual_dead: number
    process_type_id: number
  }

  export type tb_deadlineUpdateManyMutationInput = {
    case_id?: IntFieldUpdateOperationsInput | number
    deadline_type?: IntFieldUpdateOperationsInput | number
    deadline?: DateTimeFieldUpdateOperationsInput | Date | string
    actual_dead?: IntFieldUpdateOperationsInput | number
    process_type_id?: IntFieldUpdateOperationsInput | number
  }

  export type tb_deadlineUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    case_id?: IntFieldUpdateOperationsInput | number
    deadline_type?: IntFieldUpdateOperationsInput | number
    deadline?: DateTimeFieldUpdateOperationsInput | Date | string
    actual_dead?: IntFieldUpdateOperationsInput | number
    process_type_id?: IntFieldUpdateOperationsInput | number
  }

  export type tb_deadline_typesCreateInput = {
    deadline_type: string
  }

  export type tb_deadline_typesUncheckedCreateInput = {
    deadline_type_id?: number
    deadline_type: string
  }

  export type tb_deadline_typesUpdateInput = {
    deadline_type?: StringFieldUpdateOperationsInput | string
  }

  export type tb_deadline_typesUncheckedUpdateInput = {
    deadline_type_id?: IntFieldUpdateOperationsInput | number
    deadline_type?: StringFieldUpdateOperationsInput | string
  }

  export type tb_deadline_typesCreateManyInput = {
    deadline_type_id?: number
    deadline_type: string
  }

  export type tb_deadline_typesUpdateManyMutationInput = {
    deadline_type?: StringFieldUpdateOperationsInput | string
  }

  export type tb_deadline_typesUncheckedUpdateManyInput = {
    deadline_type_id?: IntFieldUpdateOperationsInput | number
    deadline_type?: StringFieldUpdateOperationsInput | string
  }

  export type tb_decision_statusCreateInput = {
    decision_status: string
    decision_status_eng?: string | null
  }

  export type tb_decision_statusUncheckedCreateInput = {
    decision_status_id?: number
    decision_status: string
    decision_status_eng?: string | null
  }

  export type tb_decision_statusUpdateInput = {
    decision_status?: StringFieldUpdateOperationsInput | string
    decision_status_eng?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type tb_decision_statusUncheckedUpdateInput = {
    decision_status_id?: IntFieldUpdateOperationsInput | number
    decision_status?: StringFieldUpdateOperationsInput | string
    decision_status_eng?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type tb_decision_statusCreateManyInput = {
    decision_status_id?: number
    decision_status: string
    decision_status_eng?: string | null
  }

  export type tb_decision_statusUpdateManyMutationInput = {
    decision_status?: StringFieldUpdateOperationsInput | string
    decision_status_eng?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type tb_decision_statusUncheckedUpdateManyInput = {
    decision_status_id?: IntFieldUpdateOperationsInput | number
    decision_status?: StringFieldUpdateOperationsInput | string
    decision_status_eng?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type tb_decision_typesCreateInput = {
    decision_type: string
    decision_type_eng: string
  }

  export type tb_decision_typesUncheckedCreateInput = {
    decision_type_id?: number
    decision_type: string
    decision_type_eng: string
  }

  export type tb_decision_typesUpdateInput = {
    decision_type?: StringFieldUpdateOperationsInput | string
    decision_type_eng?: StringFieldUpdateOperationsInput | string
  }

  export type tb_decision_typesUncheckedUpdateInput = {
    decision_type_id?: IntFieldUpdateOperationsInput | number
    decision_type?: StringFieldUpdateOperationsInput | string
    decision_type_eng?: StringFieldUpdateOperationsInput | string
  }

  export type tb_decision_typesCreateManyInput = {
    decision_type_id?: number
    decision_type: string
    decision_type_eng: string
  }

  export type tb_decision_typesUpdateManyMutationInput = {
    decision_type?: StringFieldUpdateOperationsInput | string
    decision_type_eng?: StringFieldUpdateOperationsInput | string
  }

  export type tb_decision_typesUncheckedUpdateManyInput = {
    decision_type_id?: IntFieldUpdateOperationsInput | number
    decision_type?: StringFieldUpdateOperationsInput | string
    decision_type_eng?: StringFieldUpdateOperationsInput | string
  }

  export type tb_decisionsCreateInput = {
    case_id: number
    decision_type: number
    decison_date?: Date | string
    decision_status: number
    actual?: number
    decision_out_num?: string | null
  }

  export type tb_decisionsUncheckedCreateInput = {
    decision_id?: number
    case_id: number
    decision_type: number
    decison_date?: Date | string
    decision_status: number
    actual?: number
    decision_out_num?: string | null
  }

  export type tb_decisionsUpdateInput = {
    case_id?: IntFieldUpdateOperationsInput | number
    decision_type?: IntFieldUpdateOperationsInput | number
    decison_date?: DateTimeFieldUpdateOperationsInput | Date | string
    decision_status?: IntFieldUpdateOperationsInput | number
    actual?: IntFieldUpdateOperationsInput | number
    decision_out_num?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type tb_decisionsUncheckedUpdateInput = {
    decision_id?: IntFieldUpdateOperationsInput | number
    case_id?: IntFieldUpdateOperationsInput | number
    decision_type?: IntFieldUpdateOperationsInput | number
    decison_date?: DateTimeFieldUpdateOperationsInput | Date | string
    decision_status?: IntFieldUpdateOperationsInput | number
    actual?: IntFieldUpdateOperationsInput | number
    decision_out_num?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type tb_decisionsCreateManyInput = {
    decision_id?: number
    case_id: number
    decision_type: number
    decison_date?: Date | string
    decision_status: number
    actual?: number
    decision_out_num?: string | null
  }

  export type tb_decisionsUpdateManyMutationInput = {
    case_id?: IntFieldUpdateOperationsInput | number
    decision_type?: IntFieldUpdateOperationsInput | number
    decison_date?: DateTimeFieldUpdateOperationsInput | Date | string
    decision_status?: IntFieldUpdateOperationsInput | number
    actual?: IntFieldUpdateOperationsInput | number
    decision_out_num?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type tb_decisionsUncheckedUpdateManyInput = {
    decision_id?: IntFieldUpdateOperationsInput | number
    case_id?: IntFieldUpdateOperationsInput | number
    decision_type?: IntFieldUpdateOperationsInput | number
    decison_date?: DateTimeFieldUpdateOperationsInput | Date | string
    decision_status?: IntFieldUpdateOperationsInput | number
    actual?: IntFieldUpdateOperationsInput | number
    decision_out_num?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type tb_dossCreateInput = {
    room_num: number
    doss: string
    doss_status: number
    doss_type: string
    doss_sex?: number
  }

  export type tb_dossUncheckedCreateInput = {
    doss_id?: number
    room_num: number
    doss: string
    doss_status: number
    doss_type: string
    doss_sex?: number
  }

  export type tb_dossUpdateInput = {
    room_num?: IntFieldUpdateOperationsInput | number
    doss?: StringFieldUpdateOperationsInput | string
    doss_status?: IntFieldUpdateOperationsInput | number
    doss_type?: StringFieldUpdateOperationsInput | string
    doss_sex?: IntFieldUpdateOperationsInput | number
  }

  export type tb_dossUncheckedUpdateInput = {
    doss_id?: IntFieldUpdateOperationsInput | number
    room_num?: IntFieldUpdateOperationsInput | number
    doss?: StringFieldUpdateOperationsInput | string
    doss_status?: IntFieldUpdateOperationsInput | number
    doss_type?: StringFieldUpdateOperationsInput | string
    doss_sex?: IntFieldUpdateOperationsInput | number
  }

  export type tb_dossCreateManyInput = {
    doss_id?: number
    room_num: number
    doss: string
    doss_status: number
    doss_type: string
    doss_sex?: number
  }

  export type tb_dossUpdateManyMutationInput = {
    room_num?: IntFieldUpdateOperationsInput | number
    doss?: StringFieldUpdateOperationsInput | string
    doss_status?: IntFieldUpdateOperationsInput | number
    doss_type?: StringFieldUpdateOperationsInput | string
    doss_sex?: IntFieldUpdateOperationsInput | number
  }

  export type tb_dossUncheckedUpdateManyInput = {
    doss_id?: IntFieldUpdateOperationsInput | number
    room_num?: IntFieldUpdateOperationsInput | number
    doss?: StringFieldUpdateOperationsInput | string
    doss_status?: IntFieldUpdateOperationsInput | number
    doss_type?: StringFieldUpdateOperationsInput | string
    doss_sex?: IntFieldUpdateOperationsInput | number
  }

  export type tb_draftCreateInput = {
    case_id: number
    autor: number
    uploaded?: Date | string
    receiver: number
    actual?: number
  }

  export type tb_draftUncheckedCreateInput = {
    draft_id?: number
    case_id: number
    autor: number
    uploaded?: Date | string
    receiver: number
    actual?: number
  }

  export type tb_draftUpdateInput = {
    case_id?: IntFieldUpdateOperationsInput | number
    autor?: IntFieldUpdateOperationsInput | number
    uploaded?: DateTimeFieldUpdateOperationsInput | Date | string
    receiver?: IntFieldUpdateOperationsInput | number
    actual?: IntFieldUpdateOperationsInput | number
  }

  export type tb_draftUncheckedUpdateInput = {
    draft_id?: IntFieldUpdateOperationsInput | number
    case_id?: IntFieldUpdateOperationsInput | number
    autor?: IntFieldUpdateOperationsInput | number
    uploaded?: DateTimeFieldUpdateOperationsInput | Date | string
    receiver?: IntFieldUpdateOperationsInput | number
    actual?: IntFieldUpdateOperationsInput | number
  }

  export type tb_draftCreateManyInput = {
    draft_id?: number
    case_id: number
    autor: number
    uploaded?: Date | string
    receiver: number
    actual?: number
  }

  export type tb_draftUpdateManyMutationInput = {
    case_id?: IntFieldUpdateOperationsInput | number
    autor?: IntFieldUpdateOperationsInput | number
    uploaded?: DateTimeFieldUpdateOperationsInput | Date | string
    receiver?: IntFieldUpdateOperationsInput | number
    actual?: IntFieldUpdateOperationsInput | number
  }

  export type tb_draftUncheckedUpdateManyInput = {
    draft_id?: IntFieldUpdateOperationsInput | number
    case_id?: IntFieldUpdateOperationsInput | number
    autor?: IntFieldUpdateOperationsInput | number
    uploaded?: DateTimeFieldUpdateOperationsInput | Date | string
    receiver?: IntFieldUpdateOperationsInput | number
    actual?: IntFieldUpdateOperationsInput | number
  }

  export type tb_droomsCreateInput = {
    room_num?: number | null
    floor?: number | null
    type?: string | null
    capacity?: number | null
    room_sex?: number
  }

  export type tb_droomsUncheckedCreateInput = {
    room_id?: number
    room_num?: number | null
    floor?: number | null
    type?: string | null
    capacity?: number | null
    room_sex?: number
  }

  export type tb_droomsUpdateInput = {
    room_num?: NullableIntFieldUpdateOperationsInput | number | null
    floor?: NullableIntFieldUpdateOperationsInput | number | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    capacity?: NullableIntFieldUpdateOperationsInput | number | null
    room_sex?: IntFieldUpdateOperationsInput | number
  }

  export type tb_droomsUncheckedUpdateInput = {
    room_id?: IntFieldUpdateOperationsInput | number
    room_num?: NullableIntFieldUpdateOperationsInput | number | null
    floor?: NullableIntFieldUpdateOperationsInput | number | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    capacity?: NullableIntFieldUpdateOperationsInput | number | null
    room_sex?: IntFieldUpdateOperationsInput | number
  }

  export type tb_droomsCreateManyInput = {
    room_id?: number
    room_num?: number | null
    floor?: number | null
    type?: string | null
    capacity?: number | null
    room_sex?: number
  }

  export type tb_droomsUpdateManyMutationInput = {
    room_num?: NullableIntFieldUpdateOperationsInput | number | null
    floor?: NullableIntFieldUpdateOperationsInput | number | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    capacity?: NullableIntFieldUpdateOperationsInput | number | null
    room_sex?: IntFieldUpdateOperationsInput | number
  }

  export type tb_droomsUncheckedUpdateManyInput = {
    room_id?: IntFieldUpdateOperationsInput | number
    room_num?: NullableIntFieldUpdateOperationsInput | number | null
    floor?: NullableIntFieldUpdateOperationsInput | number | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    capacity?: NullableIntFieldUpdateOperationsInput | number | null
    room_sex?: IntFieldUpdateOperationsInput | number
  }

  export type tb_edu_lvlCreateInput = {
    edu_lvl: string
  }

  export type tb_edu_lvlUncheckedCreateInput = {
    lvl_id?: number
    edu_lvl: string
  }

  export type tb_edu_lvlUpdateInput = {
    edu_lvl?: StringFieldUpdateOperationsInput | string
  }

  export type tb_edu_lvlUncheckedUpdateInput = {
    lvl_id?: IntFieldUpdateOperationsInput | number
    edu_lvl?: StringFieldUpdateOperationsInput | string
  }

  export type tb_edu_lvlCreateManyInput = {
    lvl_id?: number
    edu_lvl: string
  }

  export type tb_edu_lvlUpdateManyMutationInput = {
    edu_lvl?: StringFieldUpdateOperationsInput | string
  }

  export type tb_edu_lvlUncheckedUpdateManyInput = {
    lvl_id?: IntFieldUpdateOperationsInput | number
    edu_lvl?: StringFieldUpdateOperationsInput | string
  }

  export type tb_educationCreateInput = {
    specialization?: string | null
    institution?: string | null
    edu_lvl: number
    start_year?: string | null
    end_year?: string | null
    personal_id: number
  }

  export type tb_educationUncheckedCreateInput = {
    edu_id?: number
    specialization?: string | null
    institution?: string | null
    edu_lvl: number
    start_year?: string | null
    end_year?: string | null
    personal_id: number
  }

  export type tb_educationUpdateInput = {
    specialization?: NullableStringFieldUpdateOperationsInput | string | null
    institution?: NullableStringFieldUpdateOperationsInput | string | null
    edu_lvl?: IntFieldUpdateOperationsInput | number
    start_year?: NullableStringFieldUpdateOperationsInput | string | null
    end_year?: NullableStringFieldUpdateOperationsInput | string | null
    personal_id?: IntFieldUpdateOperationsInput | number
  }

  export type tb_educationUncheckedUpdateInput = {
    edu_id?: IntFieldUpdateOperationsInput | number
    specialization?: NullableStringFieldUpdateOperationsInput | string | null
    institution?: NullableStringFieldUpdateOperationsInput | string | null
    edu_lvl?: IntFieldUpdateOperationsInput | number
    start_year?: NullableStringFieldUpdateOperationsInput | string | null
    end_year?: NullableStringFieldUpdateOperationsInput | string | null
    personal_id?: IntFieldUpdateOperationsInput | number
  }

  export type tb_educationCreateManyInput = {
    edu_id?: number
    specialization?: string | null
    institution?: string | null
    edu_lvl: number
    start_year?: string | null
    end_year?: string | null
    personal_id: number
  }

  export type tb_educationUpdateManyMutationInput = {
    specialization?: NullableStringFieldUpdateOperationsInput | string | null
    institution?: NullableStringFieldUpdateOperationsInput | string | null
    edu_lvl?: IntFieldUpdateOperationsInput | number
    start_year?: NullableStringFieldUpdateOperationsInput | string | null
    end_year?: NullableStringFieldUpdateOperationsInput | string | null
    personal_id?: IntFieldUpdateOperationsInput | number
  }

  export type tb_educationUncheckedUpdateManyInput = {
    edu_id?: IntFieldUpdateOperationsInput | number
    specialization?: NullableStringFieldUpdateOperationsInput | string | null
    institution?: NullableStringFieldUpdateOperationsInput | string | null
    edu_lvl?: IntFieldUpdateOperationsInput | number
    start_year?: NullableStringFieldUpdateOperationsInput | string | null
    end_year?: NullableStringFieldUpdateOperationsInput | string | null
    personal_id?: IntFieldUpdateOperationsInput | number
  }

  export type tb_employmentCreateInput = {
    start_date?: string | null
    end_date?: string | null
    occupation?: string | null
    organization?: string | null
    personal_id: number
  }

  export type tb_employmentUncheckedCreateInput = {
    employment_id?: number
    start_date?: string | null
    end_date?: string | null
    occupation?: string | null
    organization?: string | null
    personal_id: number
  }

  export type tb_employmentUpdateInput = {
    start_date?: NullableStringFieldUpdateOperationsInput | string | null
    end_date?: NullableStringFieldUpdateOperationsInput | string | null
    occupation?: NullableStringFieldUpdateOperationsInput | string | null
    organization?: NullableStringFieldUpdateOperationsInput | string | null
    personal_id?: IntFieldUpdateOperationsInput | number
  }

  export type tb_employmentUncheckedUpdateInput = {
    employment_id?: IntFieldUpdateOperationsInput | number
    start_date?: NullableStringFieldUpdateOperationsInput | string | null
    end_date?: NullableStringFieldUpdateOperationsInput | string | null
    occupation?: NullableStringFieldUpdateOperationsInput | string | null
    organization?: NullableStringFieldUpdateOperationsInput | string | null
    personal_id?: IntFieldUpdateOperationsInput | number
  }

  export type tb_employmentCreateManyInput = {
    employment_id?: number
    start_date?: string | null
    end_date?: string | null
    occupation?: string | null
    organization?: string | null
    personal_id: number
  }

  export type tb_employmentUpdateManyMutationInput = {
    start_date?: NullableStringFieldUpdateOperationsInput | string | null
    end_date?: NullableStringFieldUpdateOperationsInput | string | null
    occupation?: NullableStringFieldUpdateOperationsInput | string | null
    organization?: NullableStringFieldUpdateOperationsInput | string | null
    personal_id?: IntFieldUpdateOperationsInput | number
  }

  export type tb_employmentUncheckedUpdateManyInput = {
    employment_id?: IntFieldUpdateOperationsInput | number
    start_date?: NullableStringFieldUpdateOperationsInput | string | null
    end_date?: NullableStringFieldUpdateOperationsInput | string | null
    occupation?: NullableStringFieldUpdateOperationsInput | string | null
    organization?: NullableStringFieldUpdateOperationsInput | string | null
    personal_id?: IntFieldUpdateOperationsInput | number
  }

  export type tb_etnicsCreateInput = {
    etnic_arm: string
    etnic_eng: string
  }

  export type tb_etnicsUncheckedCreateInput = {
    etnic_id?: number
    etnic_arm: string
    etnic_eng: string
  }

  export type tb_etnicsUpdateInput = {
    etnic_arm?: StringFieldUpdateOperationsInput | string
    etnic_eng?: StringFieldUpdateOperationsInput | string
  }

  export type tb_etnicsUncheckedUpdateInput = {
    etnic_id?: IntFieldUpdateOperationsInput | number
    etnic_arm?: StringFieldUpdateOperationsInput | string
    etnic_eng?: StringFieldUpdateOperationsInput | string
  }

  export type tb_etnicsCreateManyInput = {
    etnic_id?: number
    etnic_arm: string
    etnic_eng: string
  }

  export type tb_etnicsUpdateManyMutationInput = {
    etnic_arm?: StringFieldUpdateOperationsInput | string
    etnic_eng?: StringFieldUpdateOperationsInput | string
  }

  export type tb_etnicsUncheckedUpdateManyInput = {
    etnic_id?: IntFieldUpdateOperationsInput | number
    etnic_arm?: StringFieldUpdateOperationsInput | string
    etnic_eng?: StringFieldUpdateOperationsInput | string
  }

  export type tb_file_typeCreateInput = {
    file_type: string
    file_filter: number
  }

  export type tb_file_typeUncheckedCreateInput = {
    file_type_id?: number
    file_type: string
    file_filter: number
  }

  export type tb_file_typeUpdateInput = {
    file_type?: StringFieldUpdateOperationsInput | string
    file_filter?: IntFieldUpdateOperationsInput | number
  }

  export type tb_file_typeUncheckedUpdateInput = {
    file_type_id?: IntFieldUpdateOperationsInput | number
    file_type?: StringFieldUpdateOperationsInput | string
    file_filter?: IntFieldUpdateOperationsInput | number
  }

  export type tb_file_typeCreateManyInput = {
    file_type_id?: number
    file_type: string
    file_filter: number
  }

  export type tb_file_typeUpdateManyMutationInput = {
    file_type?: StringFieldUpdateOperationsInput | string
    file_filter?: IntFieldUpdateOperationsInput | number
  }

  export type tb_file_typeUncheckedUpdateManyInput = {
    file_type_id?: IntFieldUpdateOperationsInput | number
    file_type?: StringFieldUpdateOperationsInput | string
    file_filter?: IntFieldUpdateOperationsInput | number
  }

  export type tb_handedCreateInput = {
    case_id: number
    decision_id: number
    created?: Date | string
    hended_by: number
    signed_page?: string | null
  }

  export type tb_handedUncheckedCreateInput = {
    handed_id?: number
    case_id: number
    decision_id: number
    created?: Date | string
    hended_by: number
    signed_page?: string | null
  }

  export type tb_handedUpdateInput = {
    case_id?: IntFieldUpdateOperationsInput | number
    decision_id?: IntFieldUpdateOperationsInput | number
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    hended_by?: IntFieldUpdateOperationsInput | number
    signed_page?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type tb_handedUncheckedUpdateInput = {
    handed_id?: IntFieldUpdateOperationsInput | number
    case_id?: IntFieldUpdateOperationsInput | number
    decision_id?: IntFieldUpdateOperationsInput | number
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    hended_by?: IntFieldUpdateOperationsInput | number
    signed_page?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type tb_handedCreateManyInput = {
    handed_id?: number
    case_id: number
    decision_id: number
    created?: Date | string
    hended_by: number
    signed_page?: string | null
  }

  export type tb_handedUpdateManyMutationInput = {
    case_id?: IntFieldUpdateOperationsInput | number
    decision_id?: IntFieldUpdateOperationsInput | number
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    hended_by?: IntFieldUpdateOperationsInput | number
    signed_page?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type tb_handedUncheckedUpdateManyInput = {
    handed_id?: IntFieldUpdateOperationsInput | number
    case_id?: IntFieldUpdateOperationsInput | number
    decision_id?: IntFieldUpdateOperationsInput | number
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    hended_by?: IntFieldUpdateOperationsInput | number
    signed_page?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type tb_interCreateInput = {
    case_id: number
    author_id: number
    inter_status: number
    inter_reciever: number
    inter_type: number
    send_type: number
    out_num?: string | null
  }

  export type tb_interUncheckedCreateInput = {
    inter_id?: number
    case_id: number
    author_id: number
    inter_status: number
    inter_reciever: number
    inter_type: number
    send_type: number
    out_num?: string | null
  }

  export type tb_interUpdateInput = {
    case_id?: IntFieldUpdateOperationsInput | number
    author_id?: IntFieldUpdateOperationsInput | number
    inter_status?: IntFieldUpdateOperationsInput | number
    inter_reciever?: IntFieldUpdateOperationsInput | number
    inter_type?: IntFieldUpdateOperationsInput | number
    send_type?: IntFieldUpdateOperationsInput | number
    out_num?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type tb_interUncheckedUpdateInput = {
    inter_id?: IntFieldUpdateOperationsInput | number
    case_id?: IntFieldUpdateOperationsInput | number
    author_id?: IntFieldUpdateOperationsInput | number
    inter_status?: IntFieldUpdateOperationsInput | number
    inter_reciever?: IntFieldUpdateOperationsInput | number
    inter_type?: IntFieldUpdateOperationsInput | number
    send_type?: IntFieldUpdateOperationsInput | number
    out_num?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type tb_interCreateManyInput = {
    inter_id?: number
    case_id: number
    author_id: number
    inter_status: number
    inter_reciever: number
    inter_type: number
    send_type: number
    out_num?: string | null
  }

  export type tb_interUpdateManyMutationInput = {
    case_id?: IntFieldUpdateOperationsInput | number
    author_id?: IntFieldUpdateOperationsInput | number
    inter_status?: IntFieldUpdateOperationsInput | number
    inter_reciever?: IntFieldUpdateOperationsInput | number
    inter_type?: IntFieldUpdateOperationsInput | number
    send_type?: IntFieldUpdateOperationsInput | number
    out_num?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type tb_interUncheckedUpdateManyInput = {
    inter_id?: IntFieldUpdateOperationsInput | number
    case_id?: IntFieldUpdateOperationsInput | number
    author_id?: IntFieldUpdateOperationsInput | number
    inter_status?: IntFieldUpdateOperationsInput | number
    inter_reciever?: IntFieldUpdateOperationsInput | number
    inter_type?: IntFieldUpdateOperationsInput | number
    send_type?: IntFieldUpdateOperationsInput | number
    out_num?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type tb_inter_notifiedCreateInput = {
    notified_date?: Date | string | null
    actioned?: Date | string
    file_name?: string | null
    inter_id: number
    notification_status?: $Enums.tb_inter_notified_notification_status | null
  }

  export type tb_inter_notifiedUncheckedCreateInput = {
    inter_notified_id?: number
    notified_date?: Date | string | null
    actioned?: Date | string
    file_name?: string | null
    inter_id: number
    notification_status?: $Enums.tb_inter_notified_notification_status | null
  }

  export type tb_inter_notifiedUpdateInput = {
    notified_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actioned?: DateTimeFieldUpdateOperationsInput | Date | string
    file_name?: NullableStringFieldUpdateOperationsInput | string | null
    inter_id?: IntFieldUpdateOperationsInput | number
    notification_status?: NullableEnumtb_inter_notified_notification_statusFieldUpdateOperationsInput | $Enums.tb_inter_notified_notification_status | null
  }

  export type tb_inter_notifiedUncheckedUpdateInput = {
    inter_notified_id?: IntFieldUpdateOperationsInput | number
    notified_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actioned?: DateTimeFieldUpdateOperationsInput | Date | string
    file_name?: NullableStringFieldUpdateOperationsInput | string | null
    inter_id?: IntFieldUpdateOperationsInput | number
    notification_status?: NullableEnumtb_inter_notified_notification_statusFieldUpdateOperationsInput | $Enums.tb_inter_notified_notification_status | null
  }

  export type tb_inter_notifiedCreateManyInput = {
    inter_notified_id?: number
    notified_date?: Date | string | null
    actioned?: Date | string
    file_name?: string | null
    inter_id: number
    notification_status?: $Enums.tb_inter_notified_notification_status | null
  }

  export type tb_inter_notifiedUpdateManyMutationInput = {
    notified_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actioned?: DateTimeFieldUpdateOperationsInput | Date | string
    file_name?: NullableStringFieldUpdateOperationsInput | string | null
    inter_id?: IntFieldUpdateOperationsInput | number
    notification_status?: NullableEnumtb_inter_notified_notification_statusFieldUpdateOperationsInput | $Enums.tb_inter_notified_notification_status | null
  }

  export type tb_inter_notifiedUncheckedUpdateManyInput = {
    inter_notified_id?: IntFieldUpdateOperationsInput | number
    notified_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    actioned?: DateTimeFieldUpdateOperationsInput | Date | string
    file_name?: NullableStringFieldUpdateOperationsInput | string | null
    inter_id?: IntFieldUpdateOperationsInput | number
    notification_status?: NullableEnumtb_inter_notified_notification_statusFieldUpdateOperationsInput | $Enums.tb_inter_notified_notification_status | null
  }

  export type tb_inter_reciversCreateInput = {
    inter_reciever_text: string
  }

  export type tb_inter_reciversUncheckedCreateInput = {
    inter_reciever_id?: number
    inter_reciever_text: string
  }

  export type tb_inter_reciversUpdateInput = {
    inter_reciever_text?: StringFieldUpdateOperationsInput | string
  }

  export type tb_inter_reciversUncheckedUpdateInput = {
    inter_reciever_id?: IntFieldUpdateOperationsInput | number
    inter_reciever_text?: StringFieldUpdateOperationsInput | string
  }

  export type tb_inter_reciversCreateManyInput = {
    inter_reciever_id?: number
    inter_reciever_text: string
  }

  export type tb_inter_reciversUpdateManyMutationInput = {
    inter_reciever_text?: StringFieldUpdateOperationsInput | string
  }

  export type tb_inter_reciversUncheckedUpdateManyInput = {
    inter_reciever_id?: IntFieldUpdateOperationsInput | number
    inter_reciever_text?: StringFieldUpdateOperationsInput | string
  }

  export type tb_inter_send_typeCreateInput = {
    inter_send_type: string
  }

  export type tb_inter_send_typeUncheckedCreateInput = {
    inter_send_type_id?: number
    inter_send_type: string
  }

  export type tb_inter_send_typeUpdateInput = {
    inter_send_type?: StringFieldUpdateOperationsInput | string
  }

  export type tb_inter_send_typeUncheckedUpdateInput = {
    inter_send_type_id?: IntFieldUpdateOperationsInput | number
    inter_send_type?: StringFieldUpdateOperationsInput | string
  }

  export type tb_inter_send_typeCreateManyInput = {
    inter_send_type_id?: number
    inter_send_type: string
  }

  export type tb_inter_send_typeUpdateManyMutationInput = {
    inter_send_type?: StringFieldUpdateOperationsInput | string
  }

  export type tb_inter_send_typeUncheckedUpdateManyInput = {
    inter_send_type_id?: IntFieldUpdateOperationsInput | number
    inter_send_type?: StringFieldUpdateOperationsInput | string
  }

  export type tb_inter_status_typesCreateInput = {
    inter_status_type: string
  }

  export type tb_inter_status_typesUncheckedCreateInput = {
    id?: number
    inter_status_type: string
  }

  export type tb_inter_status_typesUpdateInput = {
    inter_status_type?: StringFieldUpdateOperationsInput | string
  }

  export type tb_inter_status_typesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    inter_status_type?: StringFieldUpdateOperationsInput | string
  }

  export type tb_inter_status_typesCreateManyInput = {
    id?: number
    inter_status_type: string
  }

  export type tb_inter_status_typesUpdateManyMutationInput = {
    inter_status_type?: StringFieldUpdateOperationsInput | string
  }

  export type tb_inter_status_typesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    inter_status_type?: StringFieldUpdateOperationsInput | string
  }

  export type tb_inter_typeCreateInput = {
    inter_type: string
  }

  export type tb_inter_typeUncheckedCreateInput = {
    inter_type_id?: number
    inter_type: string
  }

  export type tb_inter_typeUpdateInput = {
    inter_type?: StringFieldUpdateOperationsInput | string
  }

  export type tb_inter_typeUncheckedUpdateInput = {
    inter_type_id?: IntFieldUpdateOperationsInput | number
    inter_type?: StringFieldUpdateOperationsInput | string
  }

  export type tb_inter_typeCreateManyInput = {
    inter_type_id?: number
    inter_type: string
  }

  export type tb_inter_typeUpdateManyMutationInput = {
    inter_type?: StringFieldUpdateOperationsInput | string
  }

  export type tb_inter_typeUncheckedUpdateManyInput = {
    inter_type_id?: IntFieldUpdateOperationsInput | number
    inter_type?: StringFieldUpdateOperationsInput | string
  }

  export type tb_lawyerCreateInput = {
    lawyer_name: string
    lawyer_surname: string
    lawyer_organization?: string | null
    lawyer_tel?: string | null
    lawyer_address?: string | null
    lawyer_email?: string | null
    case_id: number
    actual?: number | null
  }

  export type tb_lawyerUncheckedCreateInput = {
    lawyer_id?: number
    lawyer_name: string
    lawyer_surname: string
    lawyer_organization?: string | null
    lawyer_tel?: string | null
    lawyer_address?: string | null
    lawyer_email?: string | null
    case_id: number
    actual?: number | null
  }

  export type tb_lawyerUpdateInput = {
    lawyer_name?: StringFieldUpdateOperationsInput | string
    lawyer_surname?: StringFieldUpdateOperationsInput | string
    lawyer_organization?: NullableStringFieldUpdateOperationsInput | string | null
    lawyer_tel?: NullableStringFieldUpdateOperationsInput | string | null
    lawyer_address?: NullableStringFieldUpdateOperationsInput | string | null
    lawyer_email?: NullableStringFieldUpdateOperationsInput | string | null
    case_id?: IntFieldUpdateOperationsInput | number
    actual?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type tb_lawyerUncheckedUpdateInput = {
    lawyer_id?: IntFieldUpdateOperationsInput | number
    lawyer_name?: StringFieldUpdateOperationsInput | string
    lawyer_surname?: StringFieldUpdateOperationsInput | string
    lawyer_organization?: NullableStringFieldUpdateOperationsInput | string | null
    lawyer_tel?: NullableStringFieldUpdateOperationsInput | string | null
    lawyer_address?: NullableStringFieldUpdateOperationsInput | string | null
    lawyer_email?: NullableStringFieldUpdateOperationsInput | string | null
    case_id?: IntFieldUpdateOperationsInput | number
    actual?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type tb_lawyerCreateManyInput = {
    lawyer_id?: number
    lawyer_name: string
    lawyer_surname: string
    lawyer_organization?: string | null
    lawyer_tel?: string | null
    lawyer_address?: string | null
    lawyer_email?: string | null
    case_id: number
    actual?: number | null
  }

  export type tb_lawyerUpdateManyMutationInput = {
    lawyer_name?: StringFieldUpdateOperationsInput | string
    lawyer_surname?: StringFieldUpdateOperationsInput | string
    lawyer_organization?: NullableStringFieldUpdateOperationsInput | string | null
    lawyer_tel?: NullableStringFieldUpdateOperationsInput | string | null
    lawyer_address?: NullableStringFieldUpdateOperationsInput | string | null
    lawyer_email?: NullableStringFieldUpdateOperationsInput | string | null
    case_id?: IntFieldUpdateOperationsInput | number
    actual?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type tb_lawyerUncheckedUpdateManyInput = {
    lawyer_id?: IntFieldUpdateOperationsInput | number
    lawyer_name?: StringFieldUpdateOperationsInput | string
    lawyer_surname?: StringFieldUpdateOperationsInput | string
    lawyer_organization?: NullableStringFieldUpdateOperationsInput | string | null
    lawyer_tel?: NullableStringFieldUpdateOperationsInput | string | null
    lawyer_address?: NullableStringFieldUpdateOperationsInput | string | null
    lawyer_email?: NullableStringFieldUpdateOperationsInput | string | null
    case_id?: IntFieldUpdateOperationsInput | number
    actual?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type tb_marzCreateInput = {
    ADM1_ARM: string
    ADM1_EN: string
    ADM1_PCODE: string
  }

  export type tb_marzUncheckedCreateInput = {
    marz_id?: number
    ADM1_ARM: string
    ADM1_EN: string
    ADM1_PCODE: string
  }

  export type tb_marzUpdateInput = {
    ADM1_ARM?: StringFieldUpdateOperationsInput | string
    ADM1_EN?: StringFieldUpdateOperationsInput | string
    ADM1_PCODE?: StringFieldUpdateOperationsInput | string
  }

  export type tb_marzUncheckedUpdateInput = {
    marz_id?: IntFieldUpdateOperationsInput | number
    ADM1_ARM?: StringFieldUpdateOperationsInput | string
    ADM1_EN?: StringFieldUpdateOperationsInput | string
    ADM1_PCODE?: StringFieldUpdateOperationsInput | string
  }

  export type tb_marzCreateManyInput = {
    marz_id?: number
    ADM1_ARM: string
    ADM1_EN: string
    ADM1_PCODE: string
  }

  export type tb_marzUpdateManyMutationInput = {
    ADM1_ARM?: StringFieldUpdateOperationsInput | string
    ADM1_EN?: StringFieldUpdateOperationsInput | string
    ADM1_PCODE?: StringFieldUpdateOperationsInput | string
  }

  export type tb_marzUncheckedUpdateManyInput = {
    marz_id?: IntFieldUpdateOperationsInput | number
    ADM1_ARM?: StringFieldUpdateOperationsInput | string
    ADM1_EN?: StringFieldUpdateOperationsInput | string
    ADM1_PCODE?: StringFieldUpdateOperationsInput | string
  }

  export type tb_membersCreateInput = {
    case_id: number
    f_name_arm: string
    f_name_eng: string
    l_name_arm: string
    l_name_eng: string
    m_name_arm?: string | null
    m_name_eng?: string | null
    b_day: string
    b_month: string
    b_year: string
    sex: number
    citizenship?: number | null
    residence?: number | null
    role: number
  }

  export type tb_membersUncheckedCreateInput = {
    member_id?: number
    case_id: number
    f_name_arm: string
    f_name_eng: string
    l_name_arm: string
    l_name_eng: string
    m_name_arm?: string | null
    m_name_eng?: string | null
    b_day: string
    b_month: string
    b_year: string
    sex: number
    citizenship?: number | null
    residence?: number | null
    role: number
  }

  export type tb_membersUpdateInput = {
    case_id?: IntFieldUpdateOperationsInput | number
    f_name_arm?: StringFieldUpdateOperationsInput | string
    f_name_eng?: StringFieldUpdateOperationsInput | string
    l_name_arm?: StringFieldUpdateOperationsInput | string
    l_name_eng?: StringFieldUpdateOperationsInput | string
    m_name_arm?: NullableStringFieldUpdateOperationsInput | string | null
    m_name_eng?: NullableStringFieldUpdateOperationsInput | string | null
    b_day?: StringFieldUpdateOperationsInput | string
    b_month?: StringFieldUpdateOperationsInput | string
    b_year?: StringFieldUpdateOperationsInput | string
    sex?: IntFieldUpdateOperationsInput | number
    citizenship?: NullableIntFieldUpdateOperationsInput | number | null
    residence?: NullableIntFieldUpdateOperationsInput | number | null
    role?: IntFieldUpdateOperationsInput | number
  }

  export type tb_membersUncheckedUpdateInput = {
    member_id?: IntFieldUpdateOperationsInput | number
    case_id?: IntFieldUpdateOperationsInput | number
    f_name_arm?: StringFieldUpdateOperationsInput | string
    f_name_eng?: StringFieldUpdateOperationsInput | string
    l_name_arm?: StringFieldUpdateOperationsInput | string
    l_name_eng?: StringFieldUpdateOperationsInput | string
    m_name_arm?: NullableStringFieldUpdateOperationsInput | string | null
    m_name_eng?: NullableStringFieldUpdateOperationsInput | string | null
    b_day?: StringFieldUpdateOperationsInput | string
    b_month?: StringFieldUpdateOperationsInput | string
    b_year?: StringFieldUpdateOperationsInput | string
    sex?: IntFieldUpdateOperationsInput | number
    citizenship?: NullableIntFieldUpdateOperationsInput | number | null
    residence?: NullableIntFieldUpdateOperationsInput | number | null
    role?: IntFieldUpdateOperationsInput | number
  }

  export type tb_membersCreateManyInput = {
    member_id?: number
    case_id: number
    f_name_arm: string
    f_name_eng: string
    l_name_arm: string
    l_name_eng: string
    m_name_arm?: string | null
    m_name_eng?: string | null
    b_day: string
    b_month: string
    b_year: string
    sex: number
    citizenship?: number | null
    residence?: number | null
    role: number
  }

  export type tb_membersUpdateManyMutationInput = {
    case_id?: IntFieldUpdateOperationsInput | number
    f_name_arm?: StringFieldUpdateOperationsInput | string
    f_name_eng?: StringFieldUpdateOperationsInput | string
    l_name_arm?: StringFieldUpdateOperationsInput | string
    l_name_eng?: StringFieldUpdateOperationsInput | string
    m_name_arm?: NullableStringFieldUpdateOperationsInput | string | null
    m_name_eng?: NullableStringFieldUpdateOperationsInput | string | null
    b_day?: StringFieldUpdateOperationsInput | string
    b_month?: StringFieldUpdateOperationsInput | string
    b_year?: StringFieldUpdateOperationsInput | string
    sex?: IntFieldUpdateOperationsInput | number
    citizenship?: NullableIntFieldUpdateOperationsInput | number | null
    residence?: NullableIntFieldUpdateOperationsInput | number | null
    role?: IntFieldUpdateOperationsInput | number
  }

  export type tb_membersUncheckedUpdateManyInput = {
    member_id?: IntFieldUpdateOperationsInput | number
    case_id?: IntFieldUpdateOperationsInput | number
    f_name_arm?: StringFieldUpdateOperationsInput | string
    f_name_eng?: StringFieldUpdateOperationsInput | string
    l_name_arm?: StringFieldUpdateOperationsInput | string
    l_name_eng?: StringFieldUpdateOperationsInput | string
    m_name_arm?: NullableStringFieldUpdateOperationsInput | string | null
    m_name_eng?: NullableStringFieldUpdateOperationsInput | string | null
    b_day?: StringFieldUpdateOperationsInput | string
    b_month?: StringFieldUpdateOperationsInput | string
    b_year?: StringFieldUpdateOperationsInput | string
    sex?: IntFieldUpdateOperationsInput | number
    citizenship?: NullableIntFieldUpdateOperationsInput | number | null
    residence?: NullableIntFieldUpdateOperationsInput | number | null
    role?: IntFieldUpdateOperationsInput | number
  }

  export type tb_notificationsCreateInput = {
    comment_subject: string
    comment_text?: string | null
    comment_status: number
    comment_from: number
    comment_to: number
    case_id?: number | null
    coi_id?: number | null
    request_id?: number | null
    note_type?: number | null
    draft_id?: number | null
    order_id?: number | null
    readed?: number | null
    note_date?: Date | string
    msg_read?: number
  }

  export type tb_notificationsUncheckedCreateInput = {
    comment_id?: number
    comment_subject: string
    comment_text?: string | null
    comment_status: number
    comment_from: number
    comment_to: number
    case_id?: number | null
    coi_id?: number | null
    request_id?: number | null
    note_type?: number | null
    draft_id?: number | null
    order_id?: number | null
    readed?: number | null
    note_date?: Date | string
    msg_read?: number
  }

  export type tb_notificationsUpdateInput = {
    comment_subject?: StringFieldUpdateOperationsInput | string
    comment_text?: NullableStringFieldUpdateOperationsInput | string | null
    comment_status?: IntFieldUpdateOperationsInput | number
    comment_from?: IntFieldUpdateOperationsInput | number
    comment_to?: IntFieldUpdateOperationsInput | number
    case_id?: NullableIntFieldUpdateOperationsInput | number | null
    coi_id?: NullableIntFieldUpdateOperationsInput | number | null
    request_id?: NullableIntFieldUpdateOperationsInput | number | null
    note_type?: NullableIntFieldUpdateOperationsInput | number | null
    draft_id?: NullableIntFieldUpdateOperationsInput | number | null
    order_id?: NullableIntFieldUpdateOperationsInput | number | null
    readed?: NullableIntFieldUpdateOperationsInput | number | null
    note_date?: DateTimeFieldUpdateOperationsInput | Date | string
    msg_read?: IntFieldUpdateOperationsInput | number
  }

  export type tb_notificationsUncheckedUpdateInput = {
    comment_id?: IntFieldUpdateOperationsInput | number
    comment_subject?: StringFieldUpdateOperationsInput | string
    comment_text?: NullableStringFieldUpdateOperationsInput | string | null
    comment_status?: IntFieldUpdateOperationsInput | number
    comment_from?: IntFieldUpdateOperationsInput | number
    comment_to?: IntFieldUpdateOperationsInput | number
    case_id?: NullableIntFieldUpdateOperationsInput | number | null
    coi_id?: NullableIntFieldUpdateOperationsInput | number | null
    request_id?: NullableIntFieldUpdateOperationsInput | number | null
    note_type?: NullableIntFieldUpdateOperationsInput | number | null
    draft_id?: NullableIntFieldUpdateOperationsInput | number | null
    order_id?: NullableIntFieldUpdateOperationsInput | number | null
    readed?: NullableIntFieldUpdateOperationsInput | number | null
    note_date?: DateTimeFieldUpdateOperationsInput | Date | string
    msg_read?: IntFieldUpdateOperationsInput | number
  }

  export type tb_notificationsCreateManyInput = {
    comment_id?: number
    comment_subject: string
    comment_text?: string | null
    comment_status: number
    comment_from: number
    comment_to: number
    case_id?: number | null
    coi_id?: number | null
    request_id?: number | null
    note_type?: number | null
    draft_id?: number | null
    order_id?: number | null
    readed?: number | null
    note_date?: Date | string
    msg_read?: number
  }

  export type tb_notificationsUpdateManyMutationInput = {
    comment_subject?: StringFieldUpdateOperationsInput | string
    comment_text?: NullableStringFieldUpdateOperationsInput | string | null
    comment_status?: IntFieldUpdateOperationsInput | number
    comment_from?: IntFieldUpdateOperationsInput | number
    comment_to?: IntFieldUpdateOperationsInput | number
    case_id?: NullableIntFieldUpdateOperationsInput | number | null
    coi_id?: NullableIntFieldUpdateOperationsInput | number | null
    request_id?: NullableIntFieldUpdateOperationsInput | number | null
    note_type?: NullableIntFieldUpdateOperationsInput | number | null
    draft_id?: NullableIntFieldUpdateOperationsInput | number | null
    order_id?: NullableIntFieldUpdateOperationsInput | number | null
    readed?: NullableIntFieldUpdateOperationsInput | number | null
    note_date?: DateTimeFieldUpdateOperationsInput | Date | string
    msg_read?: IntFieldUpdateOperationsInput | number
  }

  export type tb_notificationsUncheckedUpdateManyInput = {
    comment_id?: IntFieldUpdateOperationsInput | number
    comment_subject?: StringFieldUpdateOperationsInput | string
    comment_text?: NullableStringFieldUpdateOperationsInput | string | null
    comment_status?: IntFieldUpdateOperationsInput | number
    comment_from?: IntFieldUpdateOperationsInput | number
    comment_to?: IntFieldUpdateOperationsInput | number
    case_id?: NullableIntFieldUpdateOperationsInput | number | null
    coi_id?: NullableIntFieldUpdateOperationsInput | number | null
    request_id?: NullableIntFieldUpdateOperationsInput | number | null
    note_type?: NullableIntFieldUpdateOperationsInput | number | null
    draft_id?: NullableIntFieldUpdateOperationsInput | number | null
    order_id?: NullableIntFieldUpdateOperationsInput | number | null
    readed?: NullableIntFieldUpdateOperationsInput | number | null
    note_date?: DateTimeFieldUpdateOperationsInput | Date | string
    msg_read?: IntFieldUpdateOperationsInput | number
  }

  export type tb_ordersCreateInput = {
    case_id: number
    order_status: number
    date?: Date | string
  }

  export type tb_ordersUncheckedCreateInput = {
    order_id?: number
    case_id: number
    order_status: number
    date?: Date | string
  }

  export type tb_ordersUpdateInput = {
    case_id?: IntFieldUpdateOperationsInput | number
    order_status?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type tb_ordersUncheckedUpdateInput = {
    order_id?: IntFieldUpdateOperationsInput | number
    case_id?: IntFieldUpdateOperationsInput | number
    order_status?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type tb_ordersCreateManyInput = {
    order_id?: number
    case_id: number
    order_status: number
    date?: Date | string
  }

  export type tb_ordersUpdateManyMutationInput = {
    case_id?: IntFieldUpdateOperationsInput | number
    order_status?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type tb_ordersUncheckedUpdateManyInput = {
    order_id?: IntFieldUpdateOperationsInput | number
    case_id?: IntFieldUpdateOperationsInput | number
    order_status?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type tb_personCreateInput = {
    case_id: number
    f_name_arm: string
    f_name_eng: string
    l_name_arm: string
    l_name_eng: string
    m_name_arm?: string | null
    m_name_eng?: string | null
    b_day: string
    b_month: string
    b_year: string
    sex: number
    citizenship: number
    previous_residence?: number | null
    citizen_adr?: string | null
    residence_adr?: string | null
    departure_from_citizen?: string | null
    departure_from_residence?: string | null
    arrival_date?: Date | string | null
    doc_num?: string | null
    etnicity?: number | null
    religion?: number | null
    preferred_traslator_sex: number
    preferred_interviewer_sex: number
    invalid?: number
    pregnant?: number
    seriously_ill?: number
    trafficking_victim?: number
    violence_victim?: number
    comment?: string | null
    illegal_border?: number
    transfer_moj?: number
    deport_prescurator?: number
    prison?: number | null
    role: number
    image?: string | null
    person_status?: number
    ident?: number
    pnum?: string | null
    doc_type?: string | null
    document_num?: string | null
    doc_issued_date?: Date | string | null
    doc_valid?: Date | string | null
    doc_issued_by?: string | null
    bpr_community?: string | null
    bpr_bnakavayr?: string | null
    bpr_street?: string | null
    bpr_house?: string | null
    bpr_aprt?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type tb_personUncheckedCreateInput = {
    personal_id?: number
    case_id: number
    f_name_arm: string
    f_name_eng: string
    l_name_arm: string
    l_name_eng: string
    m_name_arm?: string | null
    m_name_eng?: string | null
    b_day: string
    b_month: string
    b_year: string
    sex: number
    citizenship: number
    previous_residence?: number | null
    citizen_adr?: string | null
    residence_adr?: string | null
    departure_from_citizen?: string | null
    departure_from_residence?: string | null
    arrival_date?: Date | string | null
    doc_num?: string | null
    etnicity?: number | null
    religion?: number | null
    preferred_traslator_sex: number
    preferred_interviewer_sex: number
    invalid?: number
    pregnant?: number
    seriously_ill?: number
    trafficking_victim?: number
    violence_victim?: number
    comment?: string | null
    illegal_border?: number
    transfer_moj?: number
    deport_prescurator?: number
    prison?: number | null
    role: number
    image?: string | null
    person_status?: number
    ident?: number
    pnum?: string | null
    doc_type?: string | null
    document_num?: string | null
    doc_issued_date?: Date | string | null
    doc_valid?: Date | string | null
    doc_issued_by?: string | null
    bpr_community?: string | null
    bpr_bnakavayr?: string | null
    bpr_street?: string | null
    bpr_house?: string | null
    bpr_aprt?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type tb_personUpdateInput = {
    case_id?: IntFieldUpdateOperationsInput | number
    f_name_arm?: StringFieldUpdateOperationsInput | string
    f_name_eng?: StringFieldUpdateOperationsInput | string
    l_name_arm?: StringFieldUpdateOperationsInput | string
    l_name_eng?: StringFieldUpdateOperationsInput | string
    m_name_arm?: NullableStringFieldUpdateOperationsInput | string | null
    m_name_eng?: NullableStringFieldUpdateOperationsInput | string | null
    b_day?: StringFieldUpdateOperationsInput | string
    b_month?: StringFieldUpdateOperationsInput | string
    b_year?: StringFieldUpdateOperationsInput | string
    sex?: IntFieldUpdateOperationsInput | number
    citizenship?: IntFieldUpdateOperationsInput | number
    previous_residence?: NullableIntFieldUpdateOperationsInput | number | null
    citizen_adr?: NullableStringFieldUpdateOperationsInput | string | null
    residence_adr?: NullableStringFieldUpdateOperationsInput | string | null
    departure_from_citizen?: NullableStringFieldUpdateOperationsInput | string | null
    departure_from_residence?: NullableStringFieldUpdateOperationsInput | string | null
    arrival_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    doc_num?: NullableStringFieldUpdateOperationsInput | string | null
    etnicity?: NullableIntFieldUpdateOperationsInput | number | null
    religion?: NullableIntFieldUpdateOperationsInput | number | null
    preferred_traslator_sex?: IntFieldUpdateOperationsInput | number
    preferred_interviewer_sex?: IntFieldUpdateOperationsInput | number
    invalid?: IntFieldUpdateOperationsInput | number
    pregnant?: IntFieldUpdateOperationsInput | number
    seriously_ill?: IntFieldUpdateOperationsInput | number
    trafficking_victim?: IntFieldUpdateOperationsInput | number
    violence_victim?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    illegal_border?: IntFieldUpdateOperationsInput | number
    transfer_moj?: IntFieldUpdateOperationsInput | number
    deport_prescurator?: IntFieldUpdateOperationsInput | number
    prison?: NullableIntFieldUpdateOperationsInput | number | null
    role?: IntFieldUpdateOperationsInput | number
    image?: NullableStringFieldUpdateOperationsInput | string | null
    person_status?: IntFieldUpdateOperationsInput | number
    ident?: IntFieldUpdateOperationsInput | number
    pnum?: NullableStringFieldUpdateOperationsInput | string | null
    doc_type?: NullableStringFieldUpdateOperationsInput | string | null
    document_num?: NullableStringFieldUpdateOperationsInput | string | null
    doc_issued_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    doc_valid?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    doc_issued_by?: NullableStringFieldUpdateOperationsInput | string | null
    bpr_community?: NullableStringFieldUpdateOperationsInput | string | null
    bpr_bnakavayr?: NullableStringFieldUpdateOperationsInput | string | null
    bpr_street?: NullableStringFieldUpdateOperationsInput | string | null
    bpr_house?: NullableStringFieldUpdateOperationsInput | string | null
    bpr_aprt?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type tb_personUncheckedUpdateInput = {
    personal_id?: IntFieldUpdateOperationsInput | number
    case_id?: IntFieldUpdateOperationsInput | number
    f_name_arm?: StringFieldUpdateOperationsInput | string
    f_name_eng?: StringFieldUpdateOperationsInput | string
    l_name_arm?: StringFieldUpdateOperationsInput | string
    l_name_eng?: StringFieldUpdateOperationsInput | string
    m_name_arm?: NullableStringFieldUpdateOperationsInput | string | null
    m_name_eng?: NullableStringFieldUpdateOperationsInput | string | null
    b_day?: StringFieldUpdateOperationsInput | string
    b_month?: StringFieldUpdateOperationsInput | string
    b_year?: StringFieldUpdateOperationsInput | string
    sex?: IntFieldUpdateOperationsInput | number
    citizenship?: IntFieldUpdateOperationsInput | number
    previous_residence?: NullableIntFieldUpdateOperationsInput | number | null
    citizen_adr?: NullableStringFieldUpdateOperationsInput | string | null
    residence_adr?: NullableStringFieldUpdateOperationsInput | string | null
    departure_from_citizen?: NullableStringFieldUpdateOperationsInput | string | null
    departure_from_residence?: NullableStringFieldUpdateOperationsInput | string | null
    arrival_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    doc_num?: NullableStringFieldUpdateOperationsInput | string | null
    etnicity?: NullableIntFieldUpdateOperationsInput | number | null
    religion?: NullableIntFieldUpdateOperationsInput | number | null
    preferred_traslator_sex?: IntFieldUpdateOperationsInput | number
    preferred_interviewer_sex?: IntFieldUpdateOperationsInput | number
    invalid?: IntFieldUpdateOperationsInput | number
    pregnant?: IntFieldUpdateOperationsInput | number
    seriously_ill?: IntFieldUpdateOperationsInput | number
    trafficking_victim?: IntFieldUpdateOperationsInput | number
    violence_victim?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    illegal_border?: IntFieldUpdateOperationsInput | number
    transfer_moj?: IntFieldUpdateOperationsInput | number
    deport_prescurator?: IntFieldUpdateOperationsInput | number
    prison?: NullableIntFieldUpdateOperationsInput | number | null
    role?: IntFieldUpdateOperationsInput | number
    image?: NullableStringFieldUpdateOperationsInput | string | null
    person_status?: IntFieldUpdateOperationsInput | number
    ident?: IntFieldUpdateOperationsInput | number
    pnum?: NullableStringFieldUpdateOperationsInput | string | null
    doc_type?: NullableStringFieldUpdateOperationsInput | string | null
    document_num?: NullableStringFieldUpdateOperationsInput | string | null
    doc_issued_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    doc_valid?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    doc_issued_by?: NullableStringFieldUpdateOperationsInput | string | null
    bpr_community?: NullableStringFieldUpdateOperationsInput | string | null
    bpr_bnakavayr?: NullableStringFieldUpdateOperationsInput | string | null
    bpr_street?: NullableStringFieldUpdateOperationsInput | string | null
    bpr_house?: NullableStringFieldUpdateOperationsInput | string | null
    bpr_aprt?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type tb_personCreateManyInput = {
    personal_id?: number
    case_id: number
    f_name_arm: string
    f_name_eng: string
    l_name_arm: string
    l_name_eng: string
    m_name_arm?: string | null
    m_name_eng?: string | null
    b_day: string
    b_month: string
    b_year: string
    sex: number
    citizenship: number
    previous_residence?: number | null
    citizen_adr?: string | null
    residence_adr?: string | null
    departure_from_citizen?: string | null
    departure_from_residence?: string | null
    arrival_date?: Date | string | null
    doc_num?: string | null
    etnicity?: number | null
    religion?: number | null
    preferred_traslator_sex: number
    preferred_interviewer_sex: number
    invalid?: number
    pregnant?: number
    seriously_ill?: number
    trafficking_victim?: number
    violence_victim?: number
    comment?: string | null
    illegal_border?: number
    transfer_moj?: number
    deport_prescurator?: number
    prison?: number | null
    role: number
    image?: string | null
    person_status?: number
    ident?: number
    pnum?: string | null
    doc_type?: string | null
    document_num?: string | null
    doc_issued_date?: Date | string | null
    doc_valid?: Date | string | null
    doc_issued_by?: string | null
    bpr_community?: string | null
    bpr_bnakavayr?: string | null
    bpr_street?: string | null
    bpr_house?: string | null
    bpr_aprt?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type tb_personUpdateManyMutationInput = {
    case_id?: IntFieldUpdateOperationsInput | number
    f_name_arm?: StringFieldUpdateOperationsInput | string
    f_name_eng?: StringFieldUpdateOperationsInput | string
    l_name_arm?: StringFieldUpdateOperationsInput | string
    l_name_eng?: StringFieldUpdateOperationsInput | string
    m_name_arm?: NullableStringFieldUpdateOperationsInput | string | null
    m_name_eng?: NullableStringFieldUpdateOperationsInput | string | null
    b_day?: StringFieldUpdateOperationsInput | string
    b_month?: StringFieldUpdateOperationsInput | string
    b_year?: StringFieldUpdateOperationsInput | string
    sex?: IntFieldUpdateOperationsInput | number
    citizenship?: IntFieldUpdateOperationsInput | number
    previous_residence?: NullableIntFieldUpdateOperationsInput | number | null
    citizen_adr?: NullableStringFieldUpdateOperationsInput | string | null
    residence_adr?: NullableStringFieldUpdateOperationsInput | string | null
    departure_from_citizen?: NullableStringFieldUpdateOperationsInput | string | null
    departure_from_residence?: NullableStringFieldUpdateOperationsInput | string | null
    arrival_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    doc_num?: NullableStringFieldUpdateOperationsInput | string | null
    etnicity?: NullableIntFieldUpdateOperationsInput | number | null
    religion?: NullableIntFieldUpdateOperationsInput | number | null
    preferred_traslator_sex?: IntFieldUpdateOperationsInput | number
    preferred_interviewer_sex?: IntFieldUpdateOperationsInput | number
    invalid?: IntFieldUpdateOperationsInput | number
    pregnant?: IntFieldUpdateOperationsInput | number
    seriously_ill?: IntFieldUpdateOperationsInput | number
    trafficking_victim?: IntFieldUpdateOperationsInput | number
    violence_victim?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    illegal_border?: IntFieldUpdateOperationsInput | number
    transfer_moj?: IntFieldUpdateOperationsInput | number
    deport_prescurator?: IntFieldUpdateOperationsInput | number
    prison?: NullableIntFieldUpdateOperationsInput | number | null
    role?: IntFieldUpdateOperationsInput | number
    image?: NullableStringFieldUpdateOperationsInput | string | null
    person_status?: IntFieldUpdateOperationsInput | number
    ident?: IntFieldUpdateOperationsInput | number
    pnum?: NullableStringFieldUpdateOperationsInput | string | null
    doc_type?: NullableStringFieldUpdateOperationsInput | string | null
    document_num?: NullableStringFieldUpdateOperationsInput | string | null
    doc_issued_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    doc_valid?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    doc_issued_by?: NullableStringFieldUpdateOperationsInput | string | null
    bpr_community?: NullableStringFieldUpdateOperationsInput | string | null
    bpr_bnakavayr?: NullableStringFieldUpdateOperationsInput | string | null
    bpr_street?: NullableStringFieldUpdateOperationsInput | string | null
    bpr_house?: NullableStringFieldUpdateOperationsInput | string | null
    bpr_aprt?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type tb_personUncheckedUpdateManyInput = {
    personal_id?: IntFieldUpdateOperationsInput | number
    case_id?: IntFieldUpdateOperationsInput | number
    f_name_arm?: StringFieldUpdateOperationsInput | string
    f_name_eng?: StringFieldUpdateOperationsInput | string
    l_name_arm?: StringFieldUpdateOperationsInput | string
    l_name_eng?: StringFieldUpdateOperationsInput | string
    m_name_arm?: NullableStringFieldUpdateOperationsInput | string | null
    m_name_eng?: NullableStringFieldUpdateOperationsInput | string | null
    b_day?: StringFieldUpdateOperationsInput | string
    b_month?: StringFieldUpdateOperationsInput | string
    b_year?: StringFieldUpdateOperationsInput | string
    sex?: IntFieldUpdateOperationsInput | number
    citizenship?: IntFieldUpdateOperationsInput | number
    previous_residence?: NullableIntFieldUpdateOperationsInput | number | null
    citizen_adr?: NullableStringFieldUpdateOperationsInput | string | null
    residence_adr?: NullableStringFieldUpdateOperationsInput | string | null
    departure_from_citizen?: NullableStringFieldUpdateOperationsInput | string | null
    departure_from_residence?: NullableStringFieldUpdateOperationsInput | string | null
    arrival_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    doc_num?: NullableStringFieldUpdateOperationsInput | string | null
    etnicity?: NullableIntFieldUpdateOperationsInput | number | null
    religion?: NullableIntFieldUpdateOperationsInput | number | null
    preferred_traslator_sex?: IntFieldUpdateOperationsInput | number
    preferred_interviewer_sex?: IntFieldUpdateOperationsInput | number
    invalid?: IntFieldUpdateOperationsInput | number
    pregnant?: IntFieldUpdateOperationsInput | number
    seriously_ill?: IntFieldUpdateOperationsInput | number
    trafficking_victim?: IntFieldUpdateOperationsInput | number
    violence_victim?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    illegal_border?: IntFieldUpdateOperationsInput | number
    transfer_moj?: IntFieldUpdateOperationsInput | number
    deport_prescurator?: IntFieldUpdateOperationsInput | number
    prison?: NullableIntFieldUpdateOperationsInput | number | null
    role?: IntFieldUpdateOperationsInput | number
    image?: NullableStringFieldUpdateOperationsInput | string | null
    person_status?: IntFieldUpdateOperationsInput | number
    ident?: IntFieldUpdateOperationsInput | number
    pnum?: NullableStringFieldUpdateOperationsInput | string | null
    doc_type?: NullableStringFieldUpdateOperationsInput | string | null
    document_num?: NullableStringFieldUpdateOperationsInput | string | null
    doc_issued_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    doc_valid?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    doc_issued_by?: NullableStringFieldUpdateOperationsInput | string | null
    bpr_community?: NullableStringFieldUpdateOperationsInput | string | null
    bpr_bnakavayr?: NullableStringFieldUpdateOperationsInput | string | null
    bpr_street?: NullableStringFieldUpdateOperationsInput | string | null
    bpr_house?: NullableStringFieldUpdateOperationsInput | string | null
    bpr_aprt?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type tb_person_statusCreateInput = {
    person_status: string
    person_status_eng?: string | null
  }

  export type tb_person_statusUncheckedCreateInput = {
    person_status_id?: number
    person_status: string
    person_status_eng?: string | null
  }

  export type tb_person_statusUpdateInput = {
    person_status?: StringFieldUpdateOperationsInput | string
    person_status_eng?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type tb_person_statusUncheckedUpdateInput = {
    person_status_id?: IntFieldUpdateOperationsInput | number
    person_status?: StringFieldUpdateOperationsInput | string
    person_status_eng?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type tb_person_statusCreateManyInput = {
    person_status_id?: number
    person_status: string
    person_status_eng?: string | null
  }

  export type tb_person_statusUpdateManyMutationInput = {
    person_status?: StringFieldUpdateOperationsInput | string
    person_status_eng?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type tb_person_statusUncheckedUpdateManyInput = {
    person_status_id?: IntFieldUpdateOperationsInput | number
    person_status?: StringFieldUpdateOperationsInput | string
    person_status_eng?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type tb_processCreateInput = {
    process_type_id: number
    case_id: number
    draft_id?: number | null
    coi_id?: number | null
    request_id?: number | null
    order_id?: number | null
    decision_id?: number | null
    notification_id?: number | null
    sign_status: number
    sign_date?: Date | string
    sign_by: number
    processor: number
    comment_to?: string | null
    actual: number
    comment_status?: number
    out_num?: string | null
  }

  export type tb_processUncheckedCreateInput = {
    process_id?: number
    process_type_id: number
    case_id: number
    draft_id?: number | null
    coi_id?: number | null
    request_id?: number | null
    order_id?: number | null
    decision_id?: number | null
    notification_id?: number | null
    sign_status: number
    sign_date?: Date | string
    sign_by: number
    processor: number
    comment_to?: string | null
    actual: number
    comment_status?: number
    out_num?: string | null
  }

  export type tb_processUpdateInput = {
    process_type_id?: IntFieldUpdateOperationsInput | number
    case_id?: IntFieldUpdateOperationsInput | number
    draft_id?: NullableIntFieldUpdateOperationsInput | number | null
    coi_id?: NullableIntFieldUpdateOperationsInput | number | null
    request_id?: NullableIntFieldUpdateOperationsInput | number | null
    order_id?: NullableIntFieldUpdateOperationsInput | number | null
    decision_id?: NullableIntFieldUpdateOperationsInput | number | null
    notification_id?: NullableIntFieldUpdateOperationsInput | number | null
    sign_status?: IntFieldUpdateOperationsInput | number
    sign_date?: DateTimeFieldUpdateOperationsInput | Date | string
    sign_by?: IntFieldUpdateOperationsInput | number
    processor?: IntFieldUpdateOperationsInput | number
    comment_to?: NullableStringFieldUpdateOperationsInput | string | null
    actual?: IntFieldUpdateOperationsInput | number
    comment_status?: IntFieldUpdateOperationsInput | number
    out_num?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type tb_processUncheckedUpdateInput = {
    process_id?: IntFieldUpdateOperationsInput | number
    process_type_id?: IntFieldUpdateOperationsInput | number
    case_id?: IntFieldUpdateOperationsInput | number
    draft_id?: NullableIntFieldUpdateOperationsInput | number | null
    coi_id?: NullableIntFieldUpdateOperationsInput | number | null
    request_id?: NullableIntFieldUpdateOperationsInput | number | null
    order_id?: NullableIntFieldUpdateOperationsInput | number | null
    decision_id?: NullableIntFieldUpdateOperationsInput | number | null
    notification_id?: NullableIntFieldUpdateOperationsInput | number | null
    sign_status?: IntFieldUpdateOperationsInput | number
    sign_date?: DateTimeFieldUpdateOperationsInput | Date | string
    sign_by?: IntFieldUpdateOperationsInput | number
    processor?: IntFieldUpdateOperationsInput | number
    comment_to?: NullableStringFieldUpdateOperationsInput | string | null
    actual?: IntFieldUpdateOperationsInput | number
    comment_status?: IntFieldUpdateOperationsInput | number
    out_num?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type tb_processCreateManyInput = {
    process_id?: number
    process_type_id: number
    case_id: number
    draft_id?: number | null
    coi_id?: number | null
    request_id?: number | null
    order_id?: number | null
    decision_id?: number | null
    notification_id?: number | null
    sign_status: number
    sign_date?: Date | string
    sign_by: number
    processor: number
    comment_to?: string | null
    actual: number
    comment_status?: number
    out_num?: string | null
  }

  export type tb_processUpdateManyMutationInput = {
    process_type_id?: IntFieldUpdateOperationsInput | number
    case_id?: IntFieldUpdateOperationsInput | number
    draft_id?: NullableIntFieldUpdateOperationsInput | number | null
    coi_id?: NullableIntFieldUpdateOperationsInput | number | null
    request_id?: NullableIntFieldUpdateOperationsInput | number | null
    order_id?: NullableIntFieldUpdateOperationsInput | number | null
    decision_id?: NullableIntFieldUpdateOperationsInput | number | null
    notification_id?: NullableIntFieldUpdateOperationsInput | number | null
    sign_status?: IntFieldUpdateOperationsInput | number
    sign_date?: DateTimeFieldUpdateOperationsInput | Date | string
    sign_by?: IntFieldUpdateOperationsInput | number
    processor?: IntFieldUpdateOperationsInput | number
    comment_to?: NullableStringFieldUpdateOperationsInput | string | null
    actual?: IntFieldUpdateOperationsInput | number
    comment_status?: IntFieldUpdateOperationsInput | number
    out_num?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type tb_processUncheckedUpdateManyInput = {
    process_id?: IntFieldUpdateOperationsInput | number
    process_type_id?: IntFieldUpdateOperationsInput | number
    case_id?: IntFieldUpdateOperationsInput | number
    draft_id?: NullableIntFieldUpdateOperationsInput | number | null
    coi_id?: NullableIntFieldUpdateOperationsInput | number | null
    request_id?: NullableIntFieldUpdateOperationsInput | number | null
    order_id?: NullableIntFieldUpdateOperationsInput | number | null
    decision_id?: NullableIntFieldUpdateOperationsInput | number | null
    notification_id?: NullableIntFieldUpdateOperationsInput | number | null
    sign_status?: IntFieldUpdateOperationsInput | number
    sign_date?: DateTimeFieldUpdateOperationsInput | Date | string
    sign_by?: IntFieldUpdateOperationsInput | number
    processor?: IntFieldUpdateOperationsInput | number
    comment_to?: NullableStringFieldUpdateOperationsInput | string | null
    actual?: IntFieldUpdateOperationsInput | number
    comment_status?: IntFieldUpdateOperationsInput | number
    out_num?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type tb_process_typeCreateInput = {
    process_type: string
  }

  export type tb_process_typeUncheckedCreateInput = {
    process_type_id?: number
    process_type: string
  }

  export type tb_process_typeUpdateInput = {
    process_type?: StringFieldUpdateOperationsInput | string
  }

  export type tb_process_typeUncheckedUpdateInput = {
    process_type_id?: IntFieldUpdateOperationsInput | number
    process_type?: StringFieldUpdateOperationsInput | string
  }

  export type tb_process_typeCreateManyInput = {
    process_type_id?: number
    process_type: string
  }

  export type tb_process_typeUpdateManyMutationInput = {
    process_type?: StringFieldUpdateOperationsInput | string
  }

  export type tb_process_typeUncheckedUpdateManyInput = {
    process_type_id?: IntFieldUpdateOperationsInput | number
    process_type?: StringFieldUpdateOperationsInput | string
  }

  export type tb_religionsCreateInput = {
    religion_arm: string
    religion_eng: string
  }

  export type tb_religionsUncheckedCreateInput = {
    religion_id?: number
    religion_arm: string
    religion_eng: string
  }

  export type tb_religionsUpdateInput = {
    religion_arm?: StringFieldUpdateOperationsInput | string
    religion_eng?: StringFieldUpdateOperationsInput | string
  }

  export type tb_religionsUncheckedUpdateInput = {
    religion_id?: IntFieldUpdateOperationsInput | number
    religion_arm?: StringFieldUpdateOperationsInput | string
    religion_eng?: StringFieldUpdateOperationsInput | string
  }

  export type tb_religionsCreateManyInput = {
    religion_id?: number
    religion_arm: string
    religion_eng: string
  }

  export type tb_religionsUpdateManyMutationInput = {
    religion_arm?: StringFieldUpdateOperationsInput | string
    religion_eng?: StringFieldUpdateOperationsInput | string
  }

  export type tb_religionsUncheckedUpdateManyInput = {
    religion_id?: IntFieldUpdateOperationsInput | number
    religion_arm?: StringFieldUpdateOperationsInput | string
    religion_eng?: StringFieldUpdateOperationsInput | string
  }

  export type tb_request_bodiesCreateInput = {
    body: string
  }

  export type tb_request_bodiesUncheckedCreateInput = {
    body_id?: number
    body: string
  }

  export type tb_request_bodiesUpdateInput = {
    body?: StringFieldUpdateOperationsInput | string
  }

  export type tb_request_bodiesUncheckedUpdateInput = {
    body_id?: IntFieldUpdateOperationsInput | number
    body?: StringFieldUpdateOperationsInput | string
  }

  export type tb_request_bodiesCreateManyInput = {
    body_id?: number
    body: string
  }

  export type tb_request_bodiesUpdateManyMutationInput = {
    body?: StringFieldUpdateOperationsInput | string
  }

  export type tb_request_bodiesUncheckedUpdateManyInput = {
    body_id?: IntFieldUpdateOperationsInput | number
    body?: StringFieldUpdateOperationsInput | string
  }

  export type tb_request_outCreateInput = {
    case_id: number
    author: number
    body: number
    request_date?: Date | string
    request_status?: number
  }

  export type tb_request_outUncheckedCreateInput = {
    request_id?: number
    case_id: number
    author: number
    body: number
    request_date?: Date | string
    request_status?: number
  }

  export type tb_request_outUpdateInput = {
    case_id?: IntFieldUpdateOperationsInput | number
    author?: IntFieldUpdateOperationsInput | number
    body?: IntFieldUpdateOperationsInput | number
    request_date?: DateTimeFieldUpdateOperationsInput | Date | string
    request_status?: IntFieldUpdateOperationsInput | number
  }

  export type tb_request_outUncheckedUpdateInput = {
    request_id?: IntFieldUpdateOperationsInput | number
    case_id?: IntFieldUpdateOperationsInput | number
    author?: IntFieldUpdateOperationsInput | number
    body?: IntFieldUpdateOperationsInput | number
    request_date?: DateTimeFieldUpdateOperationsInput | Date | string
    request_status?: IntFieldUpdateOperationsInput | number
  }

  export type tb_request_outCreateManyInput = {
    request_id?: number
    case_id: number
    author: number
    body: number
    request_date?: Date | string
    request_status?: number
  }

  export type tb_request_outUpdateManyMutationInput = {
    case_id?: IntFieldUpdateOperationsInput | number
    author?: IntFieldUpdateOperationsInput | number
    body?: IntFieldUpdateOperationsInput | number
    request_date?: DateTimeFieldUpdateOperationsInput | Date | string
    request_status?: IntFieldUpdateOperationsInput | number
  }

  export type tb_request_outUncheckedUpdateManyInput = {
    request_id?: IntFieldUpdateOperationsInput | number
    case_id?: IntFieldUpdateOperationsInput | number
    author?: IntFieldUpdateOperationsInput | number
    body?: IntFieldUpdateOperationsInput | number
    request_date?: DateTimeFieldUpdateOperationsInput | Date | string
    request_status?: IntFieldUpdateOperationsInput | number
  }

  export type tb_roleCreateInput = {
    der: string
  }

  export type tb_roleUncheckedCreateInput = {
    role_id?: number
    der: string
  }

  export type tb_roleUpdateInput = {
    der?: StringFieldUpdateOperationsInput | string
  }

  export type tb_roleUncheckedUpdateInput = {
    role_id?: IntFieldUpdateOperationsInput | number
    der?: StringFieldUpdateOperationsInput | string
  }

  export type tb_roleCreateManyInput = {
    role_id?: number
    der: string
  }

  export type tb_roleUpdateManyMutationInput = {
    der?: StringFieldUpdateOperationsInput | string
  }

  export type tb_roleUncheckedUpdateManyInput = {
    role_id?: IntFieldUpdateOperationsInput | number
    der?: StringFieldUpdateOperationsInput | string
  }

  export type tb_settlementCreateInput = {
    com_id: number
    ADM3_CODE: string
    ADM4_PCODE: string
    ADM4_ARM: string
    ADM4_ENG: string
  }

  export type tb_settlementUncheckedCreateInput = {
    settlement_id?: number
    com_id: number
    ADM3_CODE: string
    ADM4_PCODE: string
    ADM4_ARM: string
    ADM4_ENG: string
  }

  export type tb_settlementUpdateInput = {
    com_id?: IntFieldUpdateOperationsInput | number
    ADM3_CODE?: StringFieldUpdateOperationsInput | string
    ADM4_PCODE?: StringFieldUpdateOperationsInput | string
    ADM4_ARM?: StringFieldUpdateOperationsInput | string
    ADM4_ENG?: StringFieldUpdateOperationsInput | string
  }

  export type tb_settlementUncheckedUpdateInput = {
    settlement_id?: IntFieldUpdateOperationsInput | number
    com_id?: IntFieldUpdateOperationsInput | number
    ADM3_CODE?: StringFieldUpdateOperationsInput | string
    ADM4_PCODE?: StringFieldUpdateOperationsInput | string
    ADM4_ARM?: StringFieldUpdateOperationsInput | string
    ADM4_ENG?: StringFieldUpdateOperationsInput | string
  }

  export type tb_settlementCreateManyInput = {
    settlement_id?: number
    com_id: number
    ADM3_CODE: string
    ADM4_PCODE: string
    ADM4_ARM: string
    ADM4_ENG: string
  }

  export type tb_settlementUpdateManyMutationInput = {
    com_id?: IntFieldUpdateOperationsInput | number
    ADM3_CODE?: StringFieldUpdateOperationsInput | string
    ADM4_PCODE?: StringFieldUpdateOperationsInput | string
    ADM4_ARM?: StringFieldUpdateOperationsInput | string
    ADM4_ENG?: StringFieldUpdateOperationsInput | string
  }

  export type tb_settlementUncheckedUpdateManyInput = {
    settlement_id?: IntFieldUpdateOperationsInput | number
    com_id?: IntFieldUpdateOperationsInput | number
    ADM3_CODE?: StringFieldUpdateOperationsInput | string
    ADM4_PCODE?: StringFieldUpdateOperationsInput | string
    ADM4_ARM?: StringFieldUpdateOperationsInput | string
    ADM4_ENG?: StringFieldUpdateOperationsInput | string
  }

  export type tb_settlement_CreateInput = {
    com_id: number
    ADM3_CODE: string
    ADM4_PCODE: string
    ADM4_ARM: string
    ADM4_ENG: string
    active?: number
  }

  export type tb_settlement_UncheckedCreateInput = {
    settlement_id?: number
    com_id: number
    ADM3_CODE: string
    ADM4_PCODE: string
    ADM4_ARM: string
    ADM4_ENG: string
    active?: number
  }

  export type tb_settlement_UpdateInput = {
    com_id?: IntFieldUpdateOperationsInput | number
    ADM3_CODE?: StringFieldUpdateOperationsInput | string
    ADM4_PCODE?: StringFieldUpdateOperationsInput | string
    ADM4_ARM?: StringFieldUpdateOperationsInput | string
    ADM4_ENG?: StringFieldUpdateOperationsInput | string
    active?: IntFieldUpdateOperationsInput | number
  }

  export type tb_settlement_UncheckedUpdateInput = {
    settlement_id?: IntFieldUpdateOperationsInput | number
    com_id?: IntFieldUpdateOperationsInput | number
    ADM3_CODE?: StringFieldUpdateOperationsInput | string
    ADM4_PCODE?: StringFieldUpdateOperationsInput | string
    ADM4_ARM?: StringFieldUpdateOperationsInput | string
    ADM4_ENG?: StringFieldUpdateOperationsInput | string
    active?: IntFieldUpdateOperationsInput | number
  }

  export type tb_settlement_CreateManyInput = {
    settlement_id?: number
    com_id: number
    ADM3_CODE: string
    ADM4_PCODE: string
    ADM4_ARM: string
    ADM4_ENG: string
    active?: number
  }

  export type tb_settlement_UpdateManyMutationInput = {
    com_id?: IntFieldUpdateOperationsInput | number
    ADM3_CODE?: StringFieldUpdateOperationsInput | string
    ADM4_PCODE?: StringFieldUpdateOperationsInput | string
    ADM4_ARM?: StringFieldUpdateOperationsInput | string
    ADM4_ENG?: StringFieldUpdateOperationsInput | string
    active?: IntFieldUpdateOperationsInput | number
  }

  export type tb_settlement_UncheckedUpdateManyInput = {
    settlement_id?: IntFieldUpdateOperationsInput | number
    com_id?: IntFieldUpdateOperationsInput | number
    ADM3_CODE?: StringFieldUpdateOperationsInput | string
    ADM4_PCODE?: StringFieldUpdateOperationsInput | string
    ADM4_ARM?: StringFieldUpdateOperationsInput | string
    ADM4_ENG?: StringFieldUpdateOperationsInput | string
    active?: IntFieldUpdateOperationsInput | number
  }

  export type tb_sign_statusCreateInput = {
    status: string
  }

  export type tb_sign_statusUncheckedCreateInput = {
    status_id?: number
    status: string
  }

  export type tb_sign_statusUpdateInput = {
    status?: StringFieldUpdateOperationsInput | string
  }

  export type tb_sign_statusUncheckedUpdateInput = {
    status_id?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
  }

  export type tb_sign_statusCreateManyInput = {
    status_id?: number
    status: string
  }

  export type tb_sign_statusUpdateManyMutationInput = {
    status?: StringFieldUpdateOperationsInput | string
  }

  export type tb_sign_statusUncheckedUpdateManyInput = {
    status_id?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
  }

  export type tb_translateCreateInput = {
    case_id: number
    translate_type: number
    user_from: number
    user_to: number
    filled_in_date?: Date | string
    translator_company: number
    file_path?: string | null
    file_ids?: string | null
    translate_date?: Date | string | null
    translate_time_from?: string | null
    translate_time_to?: string | null
    sign_status?: number | null
    mailed_to_translators?: Date | string | null
  }

  export type tb_translateUncheckedCreateInput = {
    translate_id?: number
    case_id: number
    translate_type: number
    user_from: number
    user_to: number
    filled_in_date?: Date | string
    translator_company: number
    file_path?: string | null
    file_ids?: string | null
    translate_date?: Date | string | null
    translate_time_from?: string | null
    translate_time_to?: string | null
    sign_status?: number | null
    mailed_to_translators?: Date | string | null
  }

  export type tb_translateUpdateInput = {
    case_id?: IntFieldUpdateOperationsInput | number
    translate_type?: IntFieldUpdateOperationsInput | number
    user_from?: IntFieldUpdateOperationsInput | number
    user_to?: IntFieldUpdateOperationsInput | number
    filled_in_date?: DateTimeFieldUpdateOperationsInput | Date | string
    translator_company?: IntFieldUpdateOperationsInput | number
    file_path?: NullableStringFieldUpdateOperationsInput | string | null
    file_ids?: NullableStringFieldUpdateOperationsInput | string | null
    translate_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    translate_time_from?: NullableStringFieldUpdateOperationsInput | string | null
    translate_time_to?: NullableStringFieldUpdateOperationsInput | string | null
    sign_status?: NullableIntFieldUpdateOperationsInput | number | null
    mailed_to_translators?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type tb_translateUncheckedUpdateInput = {
    translate_id?: IntFieldUpdateOperationsInput | number
    case_id?: IntFieldUpdateOperationsInput | number
    translate_type?: IntFieldUpdateOperationsInput | number
    user_from?: IntFieldUpdateOperationsInput | number
    user_to?: IntFieldUpdateOperationsInput | number
    filled_in_date?: DateTimeFieldUpdateOperationsInput | Date | string
    translator_company?: IntFieldUpdateOperationsInput | number
    file_path?: NullableStringFieldUpdateOperationsInput | string | null
    file_ids?: NullableStringFieldUpdateOperationsInput | string | null
    translate_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    translate_time_from?: NullableStringFieldUpdateOperationsInput | string | null
    translate_time_to?: NullableStringFieldUpdateOperationsInput | string | null
    sign_status?: NullableIntFieldUpdateOperationsInput | number | null
    mailed_to_translators?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type tb_translateCreateManyInput = {
    translate_id?: number
    case_id: number
    translate_type: number
    user_from: number
    user_to: number
    filled_in_date?: Date | string
    translator_company: number
    file_path?: string | null
    file_ids?: string | null
    translate_date?: Date | string | null
    translate_time_from?: string | null
    translate_time_to?: string | null
    sign_status?: number | null
    mailed_to_translators?: Date | string | null
  }

  export type tb_translateUpdateManyMutationInput = {
    case_id?: IntFieldUpdateOperationsInput | number
    translate_type?: IntFieldUpdateOperationsInput | number
    user_from?: IntFieldUpdateOperationsInput | number
    user_to?: IntFieldUpdateOperationsInput | number
    filled_in_date?: DateTimeFieldUpdateOperationsInput | Date | string
    translator_company?: IntFieldUpdateOperationsInput | number
    file_path?: NullableStringFieldUpdateOperationsInput | string | null
    file_ids?: NullableStringFieldUpdateOperationsInput | string | null
    translate_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    translate_time_from?: NullableStringFieldUpdateOperationsInput | string | null
    translate_time_to?: NullableStringFieldUpdateOperationsInput | string | null
    sign_status?: NullableIntFieldUpdateOperationsInput | number | null
    mailed_to_translators?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type tb_translateUncheckedUpdateManyInput = {
    translate_id?: IntFieldUpdateOperationsInput | number
    case_id?: IntFieldUpdateOperationsInput | number
    translate_type?: IntFieldUpdateOperationsInput | number
    user_from?: IntFieldUpdateOperationsInput | number
    user_to?: IntFieldUpdateOperationsInput | number
    filled_in_date?: DateTimeFieldUpdateOperationsInput | Date | string
    translator_company?: IntFieldUpdateOperationsInput | number
    file_path?: NullableStringFieldUpdateOperationsInput | string | null
    file_ids?: NullableStringFieldUpdateOperationsInput | string | null
    translate_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    translate_time_from?: NullableStringFieldUpdateOperationsInput | string | null
    translate_time_to?: NullableStringFieldUpdateOperationsInput | string | null
    sign_status?: NullableIntFieldUpdateOperationsInput | number | null
    mailed_to_translators?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type tb_translate_sign_statusesCreateInput = {
    sign_status: number
    sign_status_name: string
  }

  export type tb_translate_sign_statusesUncheckedCreateInput = {
    status_id?: number
    sign_status: number
    sign_status_name: string
  }

  export type tb_translate_sign_statusesUpdateInput = {
    sign_status?: IntFieldUpdateOperationsInput | number
    sign_status_name?: StringFieldUpdateOperationsInput | string
  }

  export type tb_translate_sign_statusesUncheckedUpdateInput = {
    status_id?: IntFieldUpdateOperationsInput | number
    sign_status?: IntFieldUpdateOperationsInput | number
    sign_status_name?: StringFieldUpdateOperationsInput | string
  }

  export type tb_translate_sign_statusesCreateManyInput = {
    status_id?: number
    sign_status: number
    sign_status_name: string
  }

  export type tb_translate_sign_statusesUpdateManyMutationInput = {
    sign_status?: IntFieldUpdateOperationsInput | number
    sign_status_name?: StringFieldUpdateOperationsInput | string
  }

  export type tb_translate_sign_statusesUncheckedUpdateManyInput = {
    status_id?: IntFieldUpdateOperationsInput | number
    sign_status?: IntFieldUpdateOperationsInput | number
    sign_status_name?: StringFieldUpdateOperationsInput | string
  }

  export type tb_translation_typeCreateInput = {
    trans_type: string
  }

  export type tb_translation_typeUncheckedCreateInput = {
    ttype_id?: number
    trans_type: string
  }

  export type tb_translation_typeUpdateInput = {
    trans_type?: StringFieldUpdateOperationsInput | string
  }

  export type tb_translation_typeUncheckedUpdateInput = {
    ttype_id?: IntFieldUpdateOperationsInput | number
    trans_type?: StringFieldUpdateOperationsInput | string
  }

  export type tb_translation_typeCreateManyInput = {
    ttype_id?: number
    trans_type: string
  }

  export type tb_translation_typeUpdateManyMutationInput = {
    trans_type?: StringFieldUpdateOperationsInput | string
  }

  export type tb_translation_typeUncheckedUpdateManyInput = {
    ttype_id?: IntFieldUpdateOperationsInput | number
    trans_type?: StringFieldUpdateOperationsInput | string
  }

  export type tb_translatorsCreateInput = {
    translator_name_arm: string
    translator_name_eng: string
    email: string
    test_mail: string
    logo_file?: string | null
    active_status?: number | null
  }

  export type tb_translatorsUncheckedCreateInput = {
    translator_id?: number
    translator_name_arm: string
    translator_name_eng: string
    email: string
    test_mail: string
    logo_file?: string | null
    active_status?: number | null
  }

  export type tb_translatorsUpdateInput = {
    translator_name_arm?: StringFieldUpdateOperationsInput | string
    translator_name_eng?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    test_mail?: StringFieldUpdateOperationsInput | string
    logo_file?: NullableStringFieldUpdateOperationsInput | string | null
    active_status?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type tb_translatorsUncheckedUpdateInput = {
    translator_id?: IntFieldUpdateOperationsInput | number
    translator_name_arm?: StringFieldUpdateOperationsInput | string
    translator_name_eng?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    test_mail?: StringFieldUpdateOperationsInput | string
    logo_file?: NullableStringFieldUpdateOperationsInput | string | null
    active_status?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type tb_translatorsCreateManyInput = {
    translator_id?: number
    translator_name_arm: string
    translator_name_eng: string
    email: string
    test_mail: string
    logo_file?: string | null
    active_status?: number | null
  }

  export type tb_translatorsUpdateManyMutationInput = {
    translator_name_arm?: StringFieldUpdateOperationsInput | string
    translator_name_eng?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    test_mail?: StringFieldUpdateOperationsInput | string
    logo_file?: NullableStringFieldUpdateOperationsInput | string | null
    active_status?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type tb_translatorsUncheckedUpdateManyInput = {
    translator_id?: IntFieldUpdateOperationsInput | number
    translator_name_arm?: StringFieldUpdateOperationsInput | string
    translator_name_eng?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    test_mail?: StringFieldUpdateOperationsInput | string
    logo_file?: NullableStringFieldUpdateOperationsInput | string | null
    active_status?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type usersCreateInput = {
    username: string
    password: string
    f_name: string
    l_name: string
    user_type: string
    user_status: number
    last_activity?: bigint | number | null
  }

  export type usersUncheckedCreateInput = {
    id?: number
    username: string
    password: string
    f_name: string
    l_name: string
    user_type: string
    user_status: number
    last_activity?: bigint | number | null
  }

  export type usersUpdateInput = {
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    f_name?: StringFieldUpdateOperationsInput | string
    l_name?: StringFieldUpdateOperationsInput | string
    user_type?: StringFieldUpdateOperationsInput | string
    user_status?: IntFieldUpdateOperationsInput | number
    last_activity?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
  }

  export type usersUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    f_name?: StringFieldUpdateOperationsInput | string
    l_name?: StringFieldUpdateOperationsInput | string
    user_type?: StringFieldUpdateOperationsInput | string
    user_status?: IntFieldUpdateOperationsInput | number
    last_activity?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
  }

  export type usersCreateManyInput = {
    id?: number
    username: string
    password: string
    f_name: string
    l_name: string
    user_type: string
    user_status: number
    last_activity?: bigint | number | null
  }

  export type usersUpdateManyMutationInput = {
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    f_name?: StringFieldUpdateOperationsInput | string
    l_name?: StringFieldUpdateOperationsInput | string
    user_type?: StringFieldUpdateOperationsInput | string
    user_status?: IntFieldUpdateOperationsInput | number
    last_activity?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
  }

  export type usersUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    f_name?: StringFieldUpdateOperationsInput | string
    l_name?: StringFieldUpdateOperationsInput | string
    user_type?: StringFieldUpdateOperationsInput | string
    user_status?: IntFieldUpdateOperationsInput | number
    last_activity?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type court_appeal_typesOrderByRelevanceInput = {
    fields: court_appeal_typesOrderByRelevanceFieldEnum | court_appeal_typesOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type court_appeal_typesCountOrderByAggregateInput = {
    appeal_type_id?: SortOrder
    appeal_type?: SortOrder
  }

  export type court_appeal_typesAvgOrderByAggregateInput = {
    appeal_type_id?: SortOrder
  }

  export type court_appeal_typesMaxOrderByAggregateInput = {
    appeal_type_id?: SortOrder
    appeal_type?: SortOrder
  }

  export type court_appeal_typesMinOrderByAggregateInput = {
    appeal_type_id?: SortOrder
    appeal_type?: SortOrder
  }

  export type court_appeal_typesSumOrderByAggregateInput = {
    appeal_type_id?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type court_appealsOrderByRelevanceInput = {
    fields: court_appealsOrderByRelevanceFieldEnum | court_appealsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type court_appealsCountOrderByAggregateInput = {
    appeal_id?: SortOrder
    case_id?: SortOrder
    claim_id?: SortOrder
    court_accept_date?: SortOrder
    actual?: SortOrder
    filled_in?: SortOrder
    filled_by?: SortOrder
    court_level?: SortOrder
    court_name?: SortOrder
  }

  export type court_appealsAvgOrderByAggregateInput = {
    appeal_id?: SortOrder
    case_id?: SortOrder
    claim_id?: SortOrder
    actual?: SortOrder
    filled_by?: SortOrder
    court_level?: SortOrder
  }

  export type court_appealsMaxOrderByAggregateInput = {
    appeal_id?: SortOrder
    case_id?: SortOrder
    claim_id?: SortOrder
    court_accept_date?: SortOrder
    actual?: SortOrder
    filled_in?: SortOrder
    filled_by?: SortOrder
    court_level?: SortOrder
    court_name?: SortOrder
  }

  export type court_appealsMinOrderByAggregateInput = {
    appeal_id?: SortOrder
    case_id?: SortOrder
    claim_id?: SortOrder
    court_accept_date?: SortOrder
    actual?: SortOrder
    filled_in?: SortOrder
    filled_by?: SortOrder
    court_level?: SortOrder
    court_name?: SortOrder
  }

  export type court_appealsSumOrderByAggregateInput = {
    appeal_id?: SortOrder
    case_id?: SortOrder
    claim_id?: SortOrder
    actual?: SortOrder
    filled_by?: SortOrder
    court_level?: SortOrder
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type court_claim_initiatorsOrderByRelevanceInput = {
    fields: court_claim_initiatorsOrderByRelevanceFieldEnum | court_claim_initiatorsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type court_claim_initiatorsCountOrderByAggregateInput = {
    id?: SortOrder
    initiator_name?: SortOrder
  }

  export type court_claim_initiatorsAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type court_claim_initiatorsMaxOrderByAggregateInput = {
    id?: SortOrder
    initiator_name?: SortOrder
  }

  export type court_claim_initiatorsMinOrderByAggregateInput = {
    id?: SortOrder
    initiator_name?: SortOrder
  }

  export type court_claim_initiatorsSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type court_claim_membersCountOrderByAggregateInput = {
    id?: SortOrder
    claim_id?: SortOrder
    case_id?: SortOrder
    person_id?: SortOrder
    created_at?: SortOrder
    actual?: SortOrder
  }

  export type court_claim_membersAvgOrderByAggregateInput = {
    id?: SortOrder
    claim_id?: SortOrder
    case_id?: SortOrder
    person_id?: SortOrder
    actual?: SortOrder
  }

  export type court_claim_membersMaxOrderByAggregateInput = {
    id?: SortOrder
    claim_id?: SortOrder
    case_id?: SortOrder
    person_id?: SortOrder
    created_at?: SortOrder
    actual?: SortOrder
  }

  export type court_claim_membersMinOrderByAggregateInput = {
    id?: SortOrder
    claim_id?: SortOrder
    case_id?: SortOrder
    person_id?: SortOrder
    created_at?: SortOrder
    actual?: SortOrder
  }

  export type court_claim_membersSumOrderByAggregateInput = {
    id?: SortOrder
    claim_id?: SortOrder
    case_id?: SortOrder
    person_id?: SortOrder
    actual?: SortOrder
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type court_claimsOrderByRelevanceInput = {
    fields: court_claimsOrderByRelevanceFieldEnum | court_claimsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type court_claimsCountOrderByAggregateInput = {
    claim_id?: SortOrder
    claim_serial_number?: SortOrder
    claim_date?: SortOrder
    appealable_ms_decision?: SortOrder
    appealable_court_decision?: SortOrder
    appealable_claim?: SortOrder
    filled_by?: SortOrder
    filled_in_date?: SortOrder
    ms_notified_date?: SortOrder
    ms_lawyer?: SortOrder
    case_id?: SortOrder
    court_level?: SortOrder
    actual?: SortOrder
    initiator?: SortOrder
    claim_status?: SortOrder
    appeal_type?: SortOrder
    status_change_date?: SortOrder
  }

  export type court_claimsAvgOrderByAggregateInput = {
    claim_id?: SortOrder
    appealable_ms_decision?: SortOrder
    appealable_court_decision?: SortOrder
    appealable_claim?: SortOrder
    filled_by?: SortOrder
    ms_lawyer?: SortOrder
    case_id?: SortOrder
    court_level?: SortOrder
    actual?: SortOrder
    initiator?: SortOrder
    claim_status?: SortOrder
    appeal_type?: SortOrder
  }

  export type court_claimsMaxOrderByAggregateInput = {
    claim_id?: SortOrder
    claim_serial_number?: SortOrder
    claim_date?: SortOrder
    appealable_ms_decision?: SortOrder
    appealable_court_decision?: SortOrder
    appealable_claim?: SortOrder
    filled_by?: SortOrder
    filled_in_date?: SortOrder
    ms_notified_date?: SortOrder
    ms_lawyer?: SortOrder
    case_id?: SortOrder
    court_level?: SortOrder
    actual?: SortOrder
    initiator?: SortOrder
    claim_status?: SortOrder
    appeal_type?: SortOrder
    status_change_date?: SortOrder
  }

  export type court_claimsMinOrderByAggregateInput = {
    claim_id?: SortOrder
    claim_serial_number?: SortOrder
    claim_date?: SortOrder
    appealable_ms_decision?: SortOrder
    appealable_court_decision?: SortOrder
    appealable_claim?: SortOrder
    filled_by?: SortOrder
    filled_in_date?: SortOrder
    ms_notified_date?: SortOrder
    ms_lawyer?: SortOrder
    case_id?: SortOrder
    court_level?: SortOrder
    actual?: SortOrder
    initiator?: SortOrder
    claim_status?: SortOrder
    appeal_type?: SortOrder
    status_change_date?: SortOrder
  }

  export type court_claimsSumOrderByAggregateInput = {
    claim_id?: SortOrder
    appealable_ms_decision?: SortOrder
    appealable_court_decision?: SortOrder
    appealable_claim?: SortOrder
    filled_by?: SortOrder
    ms_lawyer?: SortOrder
    case_id?: SortOrder
    court_level?: SortOrder
    actual?: SortOrder
    initiator?: SortOrder
    claim_status?: SortOrder
    appeal_type?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type court_cliam_statusOrderByRelevanceInput = {
    fields: court_cliam_statusOrderByRelevanceFieldEnum | court_cliam_statusOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type court_cliam_statusCountOrderByAggregateInput = {
    id?: SortOrder
    court_level?: SortOrder
    name?: SortOrder
    button_value?: SortOrder
  }

  export type court_cliam_statusAvgOrderByAggregateInput = {
    id?: SortOrder
    court_level?: SortOrder
  }

  export type court_cliam_statusMaxOrderByAggregateInput = {
    id?: SortOrder
    court_level?: SortOrder
    name?: SortOrder
    button_value?: SortOrder
  }

  export type court_cliam_statusMinOrderByAggregateInput = {
    id?: SortOrder
    court_level?: SortOrder
    name?: SortOrder
    button_value?: SortOrder
  }

  export type court_cliam_statusSumOrderByAggregateInput = {
    id?: SortOrder
    court_level?: SortOrder
  }

  export type court_decision_typesOrderByRelevanceInput = {
    fields: court_decision_typesOrderByRelevanceFieldEnum | court_decision_typesOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type court_decision_typesCountOrderByAggregateInput = {
    court_decision_type_id?: SortOrder
    court_type?: SortOrder
    court_decision?: SortOrder
  }

  export type court_decision_typesAvgOrderByAggregateInput = {
    court_decision_type_id?: SortOrder
    court_type?: SortOrder
  }

  export type court_decision_typesMaxOrderByAggregateInput = {
    court_decision_type_id?: SortOrder
    court_type?: SortOrder
    court_decision?: SortOrder
  }

  export type court_decision_typesMinOrderByAggregateInput = {
    court_decision_type_id?: SortOrder
    court_type?: SortOrder
    court_decision?: SortOrder
  }

  export type court_decision_typesSumOrderByAggregateInput = {
    court_decision_type_id?: SortOrder
    court_type?: SortOrder
  }

  export type court_decisionsCountOrderByAggregateInput = {
    court_decision_id?: SortOrder
    appeal_id?: SortOrder
    decission_type?: SortOrder
    decison_date?: SortOrder
    decision_notification_date?: SortOrder
    input_date?: SortOrder
    input_by?: SortOrder
    actual?: SortOrder
  }

  export type court_decisionsAvgOrderByAggregateInput = {
    court_decision_id?: SortOrder
    appeal_id?: SortOrder
    decission_type?: SortOrder
    input_by?: SortOrder
    actual?: SortOrder
  }

  export type court_decisionsMaxOrderByAggregateInput = {
    court_decision_id?: SortOrder
    appeal_id?: SortOrder
    decission_type?: SortOrder
    decison_date?: SortOrder
    decision_notification_date?: SortOrder
    input_date?: SortOrder
    input_by?: SortOrder
    actual?: SortOrder
  }

  export type court_decisionsMinOrderByAggregateInput = {
    court_decision_id?: SortOrder
    appeal_id?: SortOrder
    decission_type?: SortOrder
    decison_date?: SortOrder
    decision_notification_date?: SortOrder
    input_date?: SortOrder
    input_by?: SortOrder
    actual?: SortOrder
  }

  export type court_decisionsSumOrderByAggregateInput = {
    court_decision_id?: SortOrder
    appeal_id?: SortOrder
    decission_type?: SortOrder
    input_by?: SortOrder
    actual?: SortOrder
  }

  export type court_levelsOrderByRelevanceInput = {
    fields: court_levelsOrderByRelevanceFieldEnum | court_levelsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type court_levelsCountOrderByAggregateInput = {
    court_id?: SortOrder
    court_title?: SortOrder
  }

  export type court_levelsAvgOrderByAggregateInput = {
    court_id?: SortOrder
  }

  export type court_levelsMaxOrderByAggregateInput = {
    court_id?: SortOrder
    court_title?: SortOrder
  }

  export type court_levelsMinOrderByAggregateInput = {
    court_id?: SortOrder
    court_title?: SortOrder
  }

  export type court_levelsSumOrderByAggregateInput = {
    court_id?: SortOrder
  }

  export type cover_sign_statusOrderByRelevanceInput = {
    fields: cover_sign_statusOrderByRelevanceFieldEnum | cover_sign_statusOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type cover_sign_statusCountOrderByAggregateInput = {
    sign_status_id?: SortOrder
    sign_status_name?: SortOrder
  }

  export type cover_sign_statusAvgOrderByAggregateInput = {
    sign_status_id?: SortOrder
  }

  export type cover_sign_statusMaxOrderByAggregateInput = {
    sign_status_id?: SortOrder
    sign_status_name?: SortOrder
  }

  export type cover_sign_statusMinOrderByAggregateInput = {
    sign_status_id?: SortOrder
    sign_status_name?: SortOrder
  }

  export type cover_sign_statusSumOrderByAggregateInput = {
    sign_status_id?: SortOrder
  }

  export type filesOrderByRelevanceInput = {
    fields: filesOrderByRelevanceFieldEnum | filesOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type filesCountOrderByAggregateInput = {
    id?: SortOrder
    file_name?: SortOrder
    uploaded_on?: SortOrder
    file_type?: SortOrder
    uploader?: SortOrder
    case_id?: SortOrder
    decision_id?: SortOrder
    inter_id?: SortOrder
    coi_id?: SortOrder
    person_id?: SortOrder
    draft_id?: SortOrder
    claim_id?: SortOrder
    appeal_id?: SortOrder
    file_path?: SortOrder
    process_type_id?: SortOrder
    actual?: SortOrder
  }

  export type filesAvgOrderByAggregateInput = {
    id?: SortOrder
    file_type?: SortOrder
    uploader?: SortOrder
    case_id?: SortOrder
    decision_id?: SortOrder
    inter_id?: SortOrder
    coi_id?: SortOrder
    person_id?: SortOrder
    draft_id?: SortOrder
    claim_id?: SortOrder
    appeal_id?: SortOrder
    process_type_id?: SortOrder
    actual?: SortOrder
  }

  export type filesMaxOrderByAggregateInput = {
    id?: SortOrder
    file_name?: SortOrder
    uploaded_on?: SortOrder
    file_type?: SortOrder
    uploader?: SortOrder
    case_id?: SortOrder
    decision_id?: SortOrder
    inter_id?: SortOrder
    coi_id?: SortOrder
    person_id?: SortOrder
    draft_id?: SortOrder
    claim_id?: SortOrder
    appeal_id?: SortOrder
    file_path?: SortOrder
    process_type_id?: SortOrder
    actual?: SortOrder
  }

  export type filesMinOrderByAggregateInput = {
    id?: SortOrder
    file_name?: SortOrder
    uploaded_on?: SortOrder
    file_type?: SortOrder
    uploader?: SortOrder
    case_id?: SortOrder
    decision_id?: SortOrder
    inter_id?: SortOrder
    coi_id?: SortOrder
    person_id?: SortOrder
    draft_id?: SortOrder
    claim_id?: SortOrder
    appeal_id?: SortOrder
    file_path?: SortOrder
    process_type_id?: SortOrder
    actual?: SortOrder
  }

  export type filesSumOrderByAggregateInput = {
    id?: SortOrder
    file_type?: SortOrder
    uploader?: SortOrder
    case_id?: SortOrder
    decision_id?: SortOrder
    inter_id?: SortOrder
    coi_id?: SortOrder
    person_id?: SortOrder
    draft_id?: SortOrder
    claim_id?: SortOrder
    appeal_id?: SortOrder
    process_type_id?: SortOrder
    actual?: SortOrder
  }

  export type ipsOrderByRelevanceInput = {
    fields: ipsOrderByRelevanceFieldEnum | ipsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ipsCountOrderByAggregateInput = {
    id?: SortOrder
    ip?: SortOrder
    created_at?: SortOrder
  }

  export type ipsAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ipsMaxOrderByAggregateInput = {
    id?: SortOrder
    ip?: SortOrder
    created_at?: SortOrder
  }

  export type ipsMinOrderByAggregateInput = {
    id?: SortOrder
    ip?: SortOrder
    created_at?: SortOrder
  }

  export type ipsSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type old_case_decisionsCountOrderByAggregateInput = {
    old_decision_id?: SortOrder
    old_case_id?: SortOrder
    ms_decision?: SortOrder
    ms_decision_date?: SortOrder
    final_decision?: SortOrder
    final_decision_date?: SortOrder
  }

  export type old_case_decisionsAvgOrderByAggregateInput = {
    old_decision_id?: SortOrder
    old_case_id?: SortOrder
    ms_decision?: SortOrder
    final_decision?: SortOrder
  }

  export type old_case_decisionsMaxOrderByAggregateInput = {
    old_decision_id?: SortOrder
    old_case_id?: SortOrder
    ms_decision?: SortOrder
    ms_decision_date?: SortOrder
    final_decision?: SortOrder
    final_decision_date?: SortOrder
  }

  export type old_case_decisionsMinOrderByAggregateInput = {
    old_decision_id?: SortOrder
    old_case_id?: SortOrder
    ms_decision?: SortOrder
    ms_decision_date?: SortOrder
    final_decision?: SortOrder
    final_decision_date?: SortOrder
  }

  export type old_case_decisionsSumOrderByAggregateInput = {
    old_decision_id?: SortOrder
    old_case_id?: SortOrder
    ms_decision?: SortOrder
    final_decision?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type old_case_personOrderByRelevanceInput = {
    fields: old_case_personOrderByRelevanceFieldEnum | old_case_personOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type old_case_personCountOrderByAggregateInput = {
    old_person_id?: SortOrder
    old_case_id?: SortOrder
    f_name_arm?: SortOrder
    l_name_arm?: SortOrder
    p_name_arm?: SortOrder
    f_name_eng?: SortOrder
    l_name_eng?: SortOrder
    p_name_eng?: SortOrder
    sex?: SortOrder
    b_day?: SortOrder
    b_month?: SortOrder
    b_year?: SortOrder
    role?: SortOrder
    citizenship_id?: SortOrder
    card_num?: SortOrder
    doc_num?: SortOrder
    etnicity?: SortOrder
    religion?: SortOrder
    invalid?: SortOrder
    pregnant?: SortOrder
    seriously_ill?: SortOrder
    trafficking_victim?: SortOrder
    violence_victim?: SortOrder
    comment?: SortOrder
    illegal_border?: SortOrder
    transfer_moj?: SortOrder
    deport_prescurator?: SortOrder
    prison?: SortOrder
    image?: SortOrder
    pnum?: SortOrder
    doc_type?: SortOrder
    document_num?: SortOrder
    status?: SortOrder
  }

  export type old_case_personAvgOrderByAggregateInput = {
    old_person_id?: SortOrder
    old_case_id?: SortOrder
    sex?: SortOrder
    role?: SortOrder
    citizenship_id?: SortOrder
    etnicity?: SortOrder
    religion?: SortOrder
    invalid?: SortOrder
    pregnant?: SortOrder
    seriously_ill?: SortOrder
    trafficking_victim?: SortOrder
    violence_victim?: SortOrder
    illegal_border?: SortOrder
    transfer_moj?: SortOrder
    deport_prescurator?: SortOrder
    prison?: SortOrder
    doc_type?: SortOrder
    status?: SortOrder
  }

  export type old_case_personMaxOrderByAggregateInput = {
    old_person_id?: SortOrder
    old_case_id?: SortOrder
    f_name_arm?: SortOrder
    l_name_arm?: SortOrder
    p_name_arm?: SortOrder
    f_name_eng?: SortOrder
    l_name_eng?: SortOrder
    p_name_eng?: SortOrder
    sex?: SortOrder
    b_day?: SortOrder
    b_month?: SortOrder
    b_year?: SortOrder
    role?: SortOrder
    citizenship_id?: SortOrder
    card_num?: SortOrder
    doc_num?: SortOrder
    etnicity?: SortOrder
    religion?: SortOrder
    invalid?: SortOrder
    pregnant?: SortOrder
    seriously_ill?: SortOrder
    trafficking_victim?: SortOrder
    violence_victim?: SortOrder
    comment?: SortOrder
    illegal_border?: SortOrder
    transfer_moj?: SortOrder
    deport_prescurator?: SortOrder
    prison?: SortOrder
    image?: SortOrder
    pnum?: SortOrder
    doc_type?: SortOrder
    document_num?: SortOrder
    status?: SortOrder
  }

  export type old_case_personMinOrderByAggregateInput = {
    old_person_id?: SortOrder
    old_case_id?: SortOrder
    f_name_arm?: SortOrder
    l_name_arm?: SortOrder
    p_name_arm?: SortOrder
    f_name_eng?: SortOrder
    l_name_eng?: SortOrder
    p_name_eng?: SortOrder
    sex?: SortOrder
    b_day?: SortOrder
    b_month?: SortOrder
    b_year?: SortOrder
    role?: SortOrder
    citizenship_id?: SortOrder
    card_num?: SortOrder
    doc_num?: SortOrder
    etnicity?: SortOrder
    religion?: SortOrder
    invalid?: SortOrder
    pregnant?: SortOrder
    seriously_ill?: SortOrder
    trafficking_victim?: SortOrder
    violence_victim?: SortOrder
    comment?: SortOrder
    illegal_border?: SortOrder
    transfer_moj?: SortOrder
    deport_prescurator?: SortOrder
    prison?: SortOrder
    image?: SortOrder
    pnum?: SortOrder
    doc_type?: SortOrder
    document_num?: SortOrder
    status?: SortOrder
  }

  export type old_case_personSumOrderByAggregateInput = {
    old_person_id?: SortOrder
    old_case_id?: SortOrder
    sex?: SortOrder
    role?: SortOrder
    citizenship_id?: SortOrder
    etnicity?: SortOrder
    religion?: SortOrder
    invalid?: SortOrder
    pregnant?: SortOrder
    seriously_ill?: SortOrder
    trafficking_victim?: SortOrder
    violence_victim?: SortOrder
    illegal_border?: SortOrder
    transfer_moj?: SortOrder
    deport_prescurator?: SortOrder
    prison?: SortOrder
    doc_type?: SortOrder
    status?: SortOrder
  }

  export type old_casesOrderByRelevanceInput = {
    fields: old_casesOrderByRelevanceFieldEnum | old_casesOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type old_casesCountOrderByAggregateInput = {
    old_case_id?: SortOrder
    application_date?: SortOrder
    citizenship?: SortOrder
    RA_address?: SortOrder
    building?: SortOrder
    apartment?: SortOrder
    marz_id?: SortOrder
    community_id?: SortOrder
    bnak_id?: SortOrder
    unaccompanied_child?: SortOrder
    separated_child?: SortOrder
    single_parent?: SortOrder
    prefered_language?: SortOrder
    contact_tel?: SortOrder
    comment?: SortOrder
  }

  export type old_casesAvgOrderByAggregateInput = {
    old_case_id?: SortOrder
    citizenship?: SortOrder
    marz_id?: SortOrder
    community_id?: SortOrder
    bnak_id?: SortOrder
    unaccompanied_child?: SortOrder
    separated_child?: SortOrder
    single_parent?: SortOrder
  }

  export type old_casesMaxOrderByAggregateInput = {
    old_case_id?: SortOrder
    application_date?: SortOrder
    citizenship?: SortOrder
    RA_address?: SortOrder
    building?: SortOrder
    apartment?: SortOrder
    marz_id?: SortOrder
    community_id?: SortOrder
    bnak_id?: SortOrder
    unaccompanied_child?: SortOrder
    separated_child?: SortOrder
    single_parent?: SortOrder
    prefered_language?: SortOrder
    contact_tel?: SortOrder
    comment?: SortOrder
  }

  export type old_casesMinOrderByAggregateInput = {
    old_case_id?: SortOrder
    application_date?: SortOrder
    citizenship?: SortOrder
    RA_address?: SortOrder
    building?: SortOrder
    apartment?: SortOrder
    marz_id?: SortOrder
    community_id?: SortOrder
    bnak_id?: SortOrder
    unaccompanied_child?: SortOrder
    separated_child?: SortOrder
    single_parent?: SortOrder
    prefered_language?: SortOrder
    contact_tel?: SortOrder
    comment?: SortOrder
  }

  export type old_casesSumOrderByAggregateInput = {
    old_case_id?: SortOrder
    citizenship?: SortOrder
    marz_id?: SortOrder
    community_id?: SortOrder
    bnak_id?: SortOrder
    unaccompanied_child?: SortOrder
    separated_child?: SortOrder
    single_parent?: SortOrder
  }

  export type tb_arm_comOrderByRelevanceInput = {
    fields: tb_arm_comOrderByRelevanceFieldEnum | tb_arm_comOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type tb_arm_comCountOrderByAggregateInput = {
    community_id?: SortOrder
    marz_id?: SortOrder
    ADM3_PCODE?: SortOrder
    ADM3_ARM?: SortOrder
    ADM3_EN?: SortOrder
    exist?: SortOrder
    active?: SortOrder
  }

  export type tb_arm_comAvgOrderByAggregateInput = {
    community_id?: SortOrder
    marz_id?: SortOrder
    exist?: SortOrder
    active?: SortOrder
  }

  export type tb_arm_comMaxOrderByAggregateInput = {
    community_id?: SortOrder
    marz_id?: SortOrder
    ADM3_PCODE?: SortOrder
    ADM3_ARM?: SortOrder
    ADM3_EN?: SortOrder
    exist?: SortOrder
    active?: SortOrder
  }

  export type tb_arm_comMinOrderByAggregateInput = {
    community_id?: SortOrder
    marz_id?: SortOrder
    ADM3_PCODE?: SortOrder
    ADM3_ARM?: SortOrder
    ADM3_EN?: SortOrder
    exist?: SortOrder
    active?: SortOrder
  }

  export type tb_arm_comSumOrderByAggregateInput = {
    community_id?: SortOrder
    marz_id?: SortOrder
    exist?: SortOrder
    active?: SortOrder
  }

  export type tb_arm_com__OrderByRelevanceInput = {
    fields: tb_arm_com__OrderByRelevanceFieldEnum | tb_arm_com__OrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type tb_arm_com__CountOrderByAggregateInput = {
    community_id?: SortOrder
    marz_id?: SortOrder
    ADM3_PCODE?: SortOrder
    ADM3_ARM?: SortOrder
    ADM3_EN?: SortOrder
  }

  export type tb_arm_com__AvgOrderByAggregateInput = {
    community_id?: SortOrder
    marz_id?: SortOrder
  }

  export type tb_arm_com__MaxOrderByAggregateInput = {
    community_id?: SortOrder
    marz_id?: SortOrder
    ADM3_PCODE?: SortOrder
    ADM3_ARM?: SortOrder
    ADM3_EN?: SortOrder
  }

  export type tb_arm_com__MinOrderByAggregateInput = {
    community_id?: SortOrder
    marz_id?: SortOrder
    ADM3_PCODE?: SortOrder
    ADM3_ARM?: SortOrder
    ADM3_EN?: SortOrder
  }

  export type tb_arm_com__SumOrderByAggregateInput = {
    community_id?: SortOrder
    marz_id?: SortOrder
  }

  export type tb_calendarOrderByRelevanceInput = {
    fields: tb_calendarOrderByRelevanceFieldEnum | tb_calendarOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type tb_calendarCountOrderByAggregateInput = {
    interview_id?: SortOrder
    case_id?: SortOrder
    user_id?: SortOrder
    inter_comment?: SortOrder
    inter_date_from?: SortOrder
    inter_date_to?: SortOrder
    text_color?: SortOrder
    border_color?: SortOrder
    actual_event?: SortOrder
  }

  export type tb_calendarAvgOrderByAggregateInput = {
    interview_id?: SortOrder
    case_id?: SortOrder
    user_id?: SortOrder
    actual_event?: SortOrder
  }

  export type tb_calendarMaxOrderByAggregateInput = {
    interview_id?: SortOrder
    case_id?: SortOrder
    user_id?: SortOrder
    inter_comment?: SortOrder
    inter_date_from?: SortOrder
    inter_date_to?: SortOrder
    text_color?: SortOrder
    border_color?: SortOrder
    actual_event?: SortOrder
  }

  export type tb_calendarMinOrderByAggregateInput = {
    interview_id?: SortOrder
    case_id?: SortOrder
    user_id?: SortOrder
    inter_comment?: SortOrder
    inter_date_from?: SortOrder
    inter_date_to?: SortOrder
    text_color?: SortOrder
    border_color?: SortOrder
    actual_event?: SortOrder
  }

  export type tb_calendarSumOrderByAggregateInput = {
    interview_id?: SortOrder
    case_id?: SortOrder
    user_id?: SortOrder
    actual_event?: SortOrder
  }

  export type tb_cancelCountOrderByAggregateInput = {
    id?: SortOrder
    personal_id?: SortOrder
    case_id?: SortOrder
    decision_date?: SortOrder
    uploader?: SortOrder
    uploaded?: SortOrder
    file_id?: SortOrder
  }

  export type tb_cancelAvgOrderByAggregateInput = {
    id?: SortOrder
    personal_id?: SortOrder
    case_id?: SortOrder
    uploader?: SortOrder
    file_id?: SortOrder
  }

  export type tb_cancelMaxOrderByAggregateInput = {
    id?: SortOrder
    personal_id?: SortOrder
    case_id?: SortOrder
    decision_date?: SortOrder
    uploader?: SortOrder
    uploaded?: SortOrder
    file_id?: SortOrder
  }

  export type tb_cancelMinOrderByAggregateInput = {
    id?: SortOrder
    personal_id?: SortOrder
    case_id?: SortOrder
    decision_date?: SortOrder
    uploader?: SortOrder
    uploaded?: SortOrder
    file_id?: SortOrder
  }

  export type tb_cancelSumOrderByAggregateInput = {
    id?: SortOrder
    personal_id?: SortOrder
    case_id?: SortOrder
    uploader?: SortOrder
    file_id?: SortOrder
  }

  export type tb_cardsOrderByRelevanceInput = {
    fields: tb_cardsOrderByRelevanceFieldEnum | tb_cardsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type tb_cardsCountOrderByAggregateInput = {
    card_id?: SortOrder
    serial?: SortOrder
    card_number?: SortOrder
    personal_id?: SortOrder
    issued?: SortOrder
    full_address?: SortOrder
    valid?: SortOrder
    bar?: SortOrder
    printed?: SortOrder
    actual_card?: SortOrder
  }

  export type tb_cardsAvgOrderByAggregateInput = {
    card_id?: SortOrder
    card_number?: SortOrder
    personal_id?: SortOrder
    actual_card?: SortOrder
  }

  export type tb_cardsMaxOrderByAggregateInput = {
    card_id?: SortOrder
    serial?: SortOrder
    card_number?: SortOrder
    personal_id?: SortOrder
    issued?: SortOrder
    full_address?: SortOrder
    valid?: SortOrder
    bar?: SortOrder
    printed?: SortOrder
    actual_card?: SortOrder
  }

  export type tb_cardsMinOrderByAggregateInput = {
    card_id?: SortOrder
    serial?: SortOrder
    card_number?: SortOrder
    personal_id?: SortOrder
    issued?: SortOrder
    full_address?: SortOrder
    valid?: SortOrder
    bar?: SortOrder
    printed?: SortOrder
    actual_card?: SortOrder
  }

  export type tb_cardsSumOrderByAggregateInput = {
    card_id?: SortOrder
    card_number?: SortOrder
    personal_id?: SortOrder
    actual_card?: SortOrder
  }

  export type tb_caseOrderByRelevanceInput = {
    fields: tb_caseOrderByRelevanceFieldEnum | tb_caseOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type tb_caseCountOrderByAggregateInput = {
    case_id?: SortOrder
    application_date?: SortOrder
    input_date?: SortOrder
    reg_by?: SortOrder
    officer?: SortOrder
    preferred_lawyer?: SortOrder
    unaccompanied_child?: SortOrder
    separated_child?: SortOrder
    single_parent?: SortOrder
    prefered_language?: SortOrder
    RA_marz?: SortOrder
    RA_community?: SortOrder
    RA_settlement?: SortOrder
    RA_street?: SortOrder
    RA_building?: SortOrder
    RA_apartment?: SortOrder
    contact_tel?: SortOrder
    contact_email?: SortOrder
    comment?: SortOrder
    case_status?: SortOrder
    mul_num?: SortOrder
    mul_date?: SortOrder
    MS_lawyer?: SortOrder
    special?: SortOrder
    reopened?: SortOrder
    attached_case?: SortOrder
  }

  export type tb_caseAvgOrderByAggregateInput = {
    case_id?: SortOrder
    reg_by?: SortOrder
    officer?: SortOrder
    preferred_lawyer?: SortOrder
    unaccompanied_child?: SortOrder
    separated_child?: SortOrder
    single_parent?: SortOrder
    RA_marz?: SortOrder
    RA_community?: SortOrder
    RA_settlement?: SortOrder
    case_status?: SortOrder
    MS_lawyer?: SortOrder
    special?: SortOrder
    reopened?: SortOrder
    attached_case?: SortOrder
  }

  export type tb_caseMaxOrderByAggregateInput = {
    case_id?: SortOrder
    application_date?: SortOrder
    input_date?: SortOrder
    reg_by?: SortOrder
    officer?: SortOrder
    preferred_lawyer?: SortOrder
    unaccompanied_child?: SortOrder
    separated_child?: SortOrder
    single_parent?: SortOrder
    prefered_language?: SortOrder
    RA_marz?: SortOrder
    RA_community?: SortOrder
    RA_settlement?: SortOrder
    RA_street?: SortOrder
    RA_building?: SortOrder
    RA_apartment?: SortOrder
    contact_tel?: SortOrder
    contact_email?: SortOrder
    comment?: SortOrder
    case_status?: SortOrder
    mul_num?: SortOrder
    mul_date?: SortOrder
    MS_lawyer?: SortOrder
    special?: SortOrder
    reopened?: SortOrder
    attached_case?: SortOrder
  }

  export type tb_caseMinOrderByAggregateInput = {
    case_id?: SortOrder
    application_date?: SortOrder
    input_date?: SortOrder
    reg_by?: SortOrder
    officer?: SortOrder
    preferred_lawyer?: SortOrder
    unaccompanied_child?: SortOrder
    separated_child?: SortOrder
    single_parent?: SortOrder
    prefered_language?: SortOrder
    RA_marz?: SortOrder
    RA_community?: SortOrder
    RA_settlement?: SortOrder
    RA_street?: SortOrder
    RA_building?: SortOrder
    RA_apartment?: SortOrder
    contact_tel?: SortOrder
    contact_email?: SortOrder
    comment?: SortOrder
    case_status?: SortOrder
    mul_num?: SortOrder
    mul_date?: SortOrder
    MS_lawyer?: SortOrder
    special?: SortOrder
    reopened?: SortOrder
    attached_case?: SortOrder
  }

  export type tb_caseSumOrderByAggregateInput = {
    case_id?: SortOrder
    reg_by?: SortOrder
    officer?: SortOrder
    preferred_lawyer?: SortOrder
    unaccompanied_child?: SortOrder
    separated_child?: SortOrder
    single_parent?: SortOrder
    RA_marz?: SortOrder
    RA_community?: SortOrder
    RA_settlement?: SortOrder
    case_status?: SortOrder
    MS_lawyer?: SortOrder
    special?: SortOrder
    reopened?: SortOrder
    attached_case?: SortOrder
  }

  export type tb_case_statusOrderByRelevanceInput = {
    fields: tb_case_statusOrderByRelevanceFieldEnum | tb_case_statusOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type tb_case_statusCountOrderByAggregateInput = {
    case_status_id?: SortOrder
    case_status?: SortOrder
    case_status_eng?: SortOrder
  }

  export type tb_case_statusAvgOrderByAggregateInput = {
    case_status_id?: SortOrder
  }

  export type tb_case_statusMaxOrderByAggregateInput = {
    case_status_id?: SortOrder
    case_status?: SortOrder
    case_status_eng?: SortOrder
  }

  export type tb_case_statusMinOrderByAggregateInput = {
    case_status_id?: SortOrder
    case_status?: SortOrder
    case_status_eng?: SortOrder
  }

  export type tb_case_statusSumOrderByAggregateInput = {
    case_status_id?: SortOrder
  }

  export type tb_checkinCountOrderByAggregateInput = {
    checkin_id?: SortOrder
    checkin_date?: SortOrder
    checkout_date?: SortOrder
    personal_id?: SortOrder
    order_id?: SortOrder
    status?: SortOrder
    doss_id?: SortOrder
  }

  export type tb_checkinAvgOrderByAggregateInput = {
    checkin_id?: SortOrder
    personal_id?: SortOrder
    order_id?: SortOrder
    status?: SortOrder
    doss_id?: SortOrder
  }

  export type tb_checkinMaxOrderByAggregateInput = {
    checkin_id?: SortOrder
    checkin_date?: SortOrder
    checkout_date?: SortOrder
    personal_id?: SortOrder
    order_id?: SortOrder
    status?: SortOrder
    doss_id?: SortOrder
  }

  export type tb_checkinMinOrderByAggregateInput = {
    checkin_id?: SortOrder
    checkin_date?: SortOrder
    checkout_date?: SortOrder
    personal_id?: SortOrder
    order_id?: SortOrder
    status?: SortOrder
    doss_id?: SortOrder
  }

  export type tb_checkinSumOrderByAggregateInput = {
    checkin_id?: SortOrder
    personal_id?: SortOrder
    order_id?: SortOrder
    status?: SortOrder
    doss_id?: SortOrder
  }

  export type tb_coiOrderByRelevanceInput = {
    fields: tb_coiOrderByRelevanceFieldEnum | tb_coiOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type tb_coiCountOrderByAggregateInput = {
    coi_id?: SortOrder
    from_officer?: SortOrder
    to_coispec?: SortOrder
    case_id?: SortOrder
    request_date?: SortOrder
    request_deadline?: SortOrder
    description?: SortOrder
    request_text?: SortOrder
    coi_state?: SortOrder
    request_count?: SortOrder
    response_date?: SortOrder
    coi_status?: SortOrder
  }

  export type tb_coiAvgOrderByAggregateInput = {
    coi_id?: SortOrder
    from_officer?: SortOrder
    to_coispec?: SortOrder
    case_id?: SortOrder
    coi_state?: SortOrder
    request_count?: SortOrder
    coi_status?: SortOrder
  }

  export type tb_coiMaxOrderByAggregateInput = {
    coi_id?: SortOrder
    from_officer?: SortOrder
    to_coispec?: SortOrder
    case_id?: SortOrder
    request_date?: SortOrder
    request_deadline?: SortOrder
    description?: SortOrder
    request_text?: SortOrder
    coi_state?: SortOrder
    request_count?: SortOrder
    response_date?: SortOrder
    coi_status?: SortOrder
  }

  export type tb_coiMinOrderByAggregateInput = {
    coi_id?: SortOrder
    from_officer?: SortOrder
    to_coispec?: SortOrder
    case_id?: SortOrder
    request_date?: SortOrder
    request_deadline?: SortOrder
    description?: SortOrder
    request_text?: SortOrder
    coi_state?: SortOrder
    request_count?: SortOrder
    response_date?: SortOrder
    coi_status?: SortOrder
  }

  export type tb_coiSumOrderByAggregateInput = {
    coi_id?: SortOrder
    from_officer?: SortOrder
    to_coispec?: SortOrder
    case_id?: SortOrder
    coi_state?: SortOrder
    request_count?: SortOrder
    coi_status?: SortOrder
  }

  export type tb_countryOrderByRelevanceInput = {
    fields: tb_countryOrderByRelevanceFieldEnum | tb_countryOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type tb_countryCountOrderByAggregateInput = {
    country_id?: SortOrder
    country_eng?: SortOrder
    country_arm?: SortOrder
  }

  export type tb_countryAvgOrderByAggregateInput = {
    country_id?: SortOrder
  }

  export type tb_countryMaxOrderByAggregateInput = {
    country_id?: SortOrder
    country_eng?: SortOrder
    country_arm?: SortOrder
  }

  export type tb_countryMinOrderByAggregateInput = {
    country_id?: SortOrder
    country_eng?: SortOrder
    country_arm?: SortOrder
  }

  export type tb_countrySumOrderByAggregateInput = {
    country_id?: SortOrder
  }

  export type tb_cover_filesOrderByRelevanceInput = {
    fields: tb_cover_filesOrderByRelevanceFieldEnum | tb_cover_filesOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type tb_cover_filesCountOrderByAggregateInput = {
    cover_file_id?: SortOrder
    type?: SortOrder
    file_name?: SortOrder
    cover_status?: SortOrder
    case_id?: SortOrder
    translation_id?: SortOrder
    cover_actual?: SortOrder
  }

  export type tb_cover_filesAvgOrderByAggregateInput = {
    cover_file_id?: SortOrder
    type?: SortOrder
    cover_status?: SortOrder
    case_id?: SortOrder
    translation_id?: SortOrder
    cover_actual?: SortOrder
  }

  export type tb_cover_filesMaxOrderByAggregateInput = {
    cover_file_id?: SortOrder
    type?: SortOrder
    file_name?: SortOrder
    cover_status?: SortOrder
    case_id?: SortOrder
    translation_id?: SortOrder
    cover_actual?: SortOrder
  }

  export type tb_cover_filesMinOrderByAggregateInput = {
    cover_file_id?: SortOrder
    type?: SortOrder
    file_name?: SortOrder
    cover_status?: SortOrder
    case_id?: SortOrder
    translation_id?: SortOrder
    cover_actual?: SortOrder
  }

  export type tb_cover_filesSumOrderByAggregateInput = {
    cover_file_id?: SortOrder
    type?: SortOrder
    cover_status?: SortOrder
    case_id?: SortOrder
    translation_id?: SortOrder
    cover_actual?: SortOrder
  }

  export type tb_deadlineCountOrderByAggregateInput = {
    id?: SortOrder
    case_id?: SortOrder
    deadline_type?: SortOrder
    deadline?: SortOrder
    actual_dead?: SortOrder
    process_type_id?: SortOrder
  }

  export type tb_deadlineAvgOrderByAggregateInput = {
    id?: SortOrder
    case_id?: SortOrder
    deadline_type?: SortOrder
    actual_dead?: SortOrder
    process_type_id?: SortOrder
  }

  export type tb_deadlineMaxOrderByAggregateInput = {
    id?: SortOrder
    case_id?: SortOrder
    deadline_type?: SortOrder
    deadline?: SortOrder
    actual_dead?: SortOrder
    process_type_id?: SortOrder
  }

  export type tb_deadlineMinOrderByAggregateInput = {
    id?: SortOrder
    case_id?: SortOrder
    deadline_type?: SortOrder
    deadline?: SortOrder
    actual_dead?: SortOrder
    process_type_id?: SortOrder
  }

  export type tb_deadlineSumOrderByAggregateInput = {
    id?: SortOrder
    case_id?: SortOrder
    deadline_type?: SortOrder
    actual_dead?: SortOrder
    process_type_id?: SortOrder
  }

  export type tb_deadline_typesOrderByRelevanceInput = {
    fields: tb_deadline_typesOrderByRelevanceFieldEnum | tb_deadline_typesOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type tb_deadline_typesCountOrderByAggregateInput = {
    deadline_type_id?: SortOrder
    deadline_type?: SortOrder
  }

  export type tb_deadline_typesAvgOrderByAggregateInput = {
    deadline_type_id?: SortOrder
  }

  export type tb_deadline_typesMaxOrderByAggregateInput = {
    deadline_type_id?: SortOrder
    deadline_type?: SortOrder
  }

  export type tb_deadline_typesMinOrderByAggregateInput = {
    deadline_type_id?: SortOrder
    deadline_type?: SortOrder
  }

  export type tb_deadline_typesSumOrderByAggregateInput = {
    deadline_type_id?: SortOrder
  }

  export type tb_decision_statusOrderByRelevanceInput = {
    fields: tb_decision_statusOrderByRelevanceFieldEnum | tb_decision_statusOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type tb_decision_statusCountOrderByAggregateInput = {
    decision_status_id?: SortOrder
    decision_status?: SortOrder
    decision_status_eng?: SortOrder
  }

  export type tb_decision_statusAvgOrderByAggregateInput = {
    decision_status_id?: SortOrder
  }

  export type tb_decision_statusMaxOrderByAggregateInput = {
    decision_status_id?: SortOrder
    decision_status?: SortOrder
    decision_status_eng?: SortOrder
  }

  export type tb_decision_statusMinOrderByAggregateInput = {
    decision_status_id?: SortOrder
    decision_status?: SortOrder
    decision_status_eng?: SortOrder
  }

  export type tb_decision_statusSumOrderByAggregateInput = {
    decision_status_id?: SortOrder
  }

  export type tb_decision_typesOrderByRelevanceInput = {
    fields: tb_decision_typesOrderByRelevanceFieldEnum | tb_decision_typesOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type tb_decision_typesCountOrderByAggregateInput = {
    decision_type_id?: SortOrder
    decision_type?: SortOrder
    decision_type_eng?: SortOrder
  }

  export type tb_decision_typesAvgOrderByAggregateInput = {
    decision_type_id?: SortOrder
  }

  export type tb_decision_typesMaxOrderByAggregateInput = {
    decision_type_id?: SortOrder
    decision_type?: SortOrder
    decision_type_eng?: SortOrder
  }

  export type tb_decision_typesMinOrderByAggregateInput = {
    decision_type_id?: SortOrder
    decision_type?: SortOrder
    decision_type_eng?: SortOrder
  }

  export type tb_decision_typesSumOrderByAggregateInput = {
    decision_type_id?: SortOrder
  }

  export type tb_decisionsOrderByRelevanceInput = {
    fields: tb_decisionsOrderByRelevanceFieldEnum | tb_decisionsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type tb_decisionsCountOrderByAggregateInput = {
    decision_id?: SortOrder
    case_id?: SortOrder
    decision_type?: SortOrder
    decison_date?: SortOrder
    decision_status?: SortOrder
    actual?: SortOrder
    decision_out_num?: SortOrder
  }

  export type tb_decisionsAvgOrderByAggregateInput = {
    decision_id?: SortOrder
    case_id?: SortOrder
    decision_type?: SortOrder
    decision_status?: SortOrder
    actual?: SortOrder
  }

  export type tb_decisionsMaxOrderByAggregateInput = {
    decision_id?: SortOrder
    case_id?: SortOrder
    decision_type?: SortOrder
    decison_date?: SortOrder
    decision_status?: SortOrder
    actual?: SortOrder
    decision_out_num?: SortOrder
  }

  export type tb_decisionsMinOrderByAggregateInput = {
    decision_id?: SortOrder
    case_id?: SortOrder
    decision_type?: SortOrder
    decison_date?: SortOrder
    decision_status?: SortOrder
    actual?: SortOrder
    decision_out_num?: SortOrder
  }

  export type tb_decisionsSumOrderByAggregateInput = {
    decision_id?: SortOrder
    case_id?: SortOrder
    decision_type?: SortOrder
    decision_status?: SortOrder
    actual?: SortOrder
  }

  export type tb_dossOrderByRelevanceInput = {
    fields: tb_dossOrderByRelevanceFieldEnum | tb_dossOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type tb_dossCountOrderByAggregateInput = {
    doss_id?: SortOrder
    room_num?: SortOrder
    doss?: SortOrder
    doss_status?: SortOrder
    doss_type?: SortOrder
    doss_sex?: SortOrder
  }

  export type tb_dossAvgOrderByAggregateInput = {
    doss_id?: SortOrder
    room_num?: SortOrder
    doss_status?: SortOrder
    doss_sex?: SortOrder
  }

  export type tb_dossMaxOrderByAggregateInput = {
    doss_id?: SortOrder
    room_num?: SortOrder
    doss?: SortOrder
    doss_status?: SortOrder
    doss_type?: SortOrder
    doss_sex?: SortOrder
  }

  export type tb_dossMinOrderByAggregateInput = {
    doss_id?: SortOrder
    room_num?: SortOrder
    doss?: SortOrder
    doss_status?: SortOrder
    doss_type?: SortOrder
    doss_sex?: SortOrder
  }

  export type tb_dossSumOrderByAggregateInput = {
    doss_id?: SortOrder
    room_num?: SortOrder
    doss_status?: SortOrder
    doss_sex?: SortOrder
  }

  export type tb_draftCountOrderByAggregateInput = {
    draft_id?: SortOrder
    case_id?: SortOrder
    autor?: SortOrder
    uploaded?: SortOrder
    receiver?: SortOrder
    actual?: SortOrder
  }

  export type tb_draftAvgOrderByAggregateInput = {
    draft_id?: SortOrder
    case_id?: SortOrder
    autor?: SortOrder
    receiver?: SortOrder
    actual?: SortOrder
  }

  export type tb_draftMaxOrderByAggregateInput = {
    draft_id?: SortOrder
    case_id?: SortOrder
    autor?: SortOrder
    uploaded?: SortOrder
    receiver?: SortOrder
    actual?: SortOrder
  }

  export type tb_draftMinOrderByAggregateInput = {
    draft_id?: SortOrder
    case_id?: SortOrder
    autor?: SortOrder
    uploaded?: SortOrder
    receiver?: SortOrder
    actual?: SortOrder
  }

  export type tb_draftSumOrderByAggregateInput = {
    draft_id?: SortOrder
    case_id?: SortOrder
    autor?: SortOrder
    receiver?: SortOrder
    actual?: SortOrder
  }

  export type tb_droomsOrderByRelevanceInput = {
    fields: tb_droomsOrderByRelevanceFieldEnum | tb_droomsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type tb_droomsCountOrderByAggregateInput = {
    room_id?: SortOrder
    room_num?: SortOrder
    floor?: SortOrder
    type?: SortOrder
    capacity?: SortOrder
    room_sex?: SortOrder
  }

  export type tb_droomsAvgOrderByAggregateInput = {
    room_id?: SortOrder
    room_num?: SortOrder
    floor?: SortOrder
    capacity?: SortOrder
    room_sex?: SortOrder
  }

  export type tb_droomsMaxOrderByAggregateInput = {
    room_id?: SortOrder
    room_num?: SortOrder
    floor?: SortOrder
    type?: SortOrder
    capacity?: SortOrder
    room_sex?: SortOrder
  }

  export type tb_droomsMinOrderByAggregateInput = {
    room_id?: SortOrder
    room_num?: SortOrder
    floor?: SortOrder
    type?: SortOrder
    capacity?: SortOrder
    room_sex?: SortOrder
  }

  export type tb_droomsSumOrderByAggregateInput = {
    room_id?: SortOrder
    room_num?: SortOrder
    floor?: SortOrder
    capacity?: SortOrder
    room_sex?: SortOrder
  }

  export type tb_edu_lvlOrderByRelevanceInput = {
    fields: tb_edu_lvlOrderByRelevanceFieldEnum | tb_edu_lvlOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type tb_edu_lvlCountOrderByAggregateInput = {
    lvl_id?: SortOrder
    edu_lvl?: SortOrder
  }

  export type tb_edu_lvlAvgOrderByAggregateInput = {
    lvl_id?: SortOrder
  }

  export type tb_edu_lvlMaxOrderByAggregateInput = {
    lvl_id?: SortOrder
    edu_lvl?: SortOrder
  }

  export type tb_edu_lvlMinOrderByAggregateInput = {
    lvl_id?: SortOrder
    edu_lvl?: SortOrder
  }

  export type tb_edu_lvlSumOrderByAggregateInput = {
    lvl_id?: SortOrder
  }

  export type tb_educationOrderByRelevanceInput = {
    fields: tb_educationOrderByRelevanceFieldEnum | tb_educationOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type tb_educationCountOrderByAggregateInput = {
    edu_id?: SortOrder
    specialization?: SortOrder
    institution?: SortOrder
    edu_lvl?: SortOrder
    start_year?: SortOrder
    end_year?: SortOrder
    personal_id?: SortOrder
  }

  export type tb_educationAvgOrderByAggregateInput = {
    edu_id?: SortOrder
    edu_lvl?: SortOrder
    personal_id?: SortOrder
  }

  export type tb_educationMaxOrderByAggregateInput = {
    edu_id?: SortOrder
    specialization?: SortOrder
    institution?: SortOrder
    edu_lvl?: SortOrder
    start_year?: SortOrder
    end_year?: SortOrder
    personal_id?: SortOrder
  }

  export type tb_educationMinOrderByAggregateInput = {
    edu_id?: SortOrder
    specialization?: SortOrder
    institution?: SortOrder
    edu_lvl?: SortOrder
    start_year?: SortOrder
    end_year?: SortOrder
    personal_id?: SortOrder
  }

  export type tb_educationSumOrderByAggregateInput = {
    edu_id?: SortOrder
    edu_lvl?: SortOrder
    personal_id?: SortOrder
  }

  export type tb_employmentOrderByRelevanceInput = {
    fields: tb_employmentOrderByRelevanceFieldEnum | tb_employmentOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type tb_employmentCountOrderByAggregateInput = {
    employment_id?: SortOrder
    start_date?: SortOrder
    end_date?: SortOrder
    occupation?: SortOrder
    organization?: SortOrder
    personal_id?: SortOrder
  }

  export type tb_employmentAvgOrderByAggregateInput = {
    employment_id?: SortOrder
    personal_id?: SortOrder
  }

  export type tb_employmentMaxOrderByAggregateInput = {
    employment_id?: SortOrder
    start_date?: SortOrder
    end_date?: SortOrder
    occupation?: SortOrder
    organization?: SortOrder
    personal_id?: SortOrder
  }

  export type tb_employmentMinOrderByAggregateInput = {
    employment_id?: SortOrder
    start_date?: SortOrder
    end_date?: SortOrder
    occupation?: SortOrder
    organization?: SortOrder
    personal_id?: SortOrder
  }

  export type tb_employmentSumOrderByAggregateInput = {
    employment_id?: SortOrder
    personal_id?: SortOrder
  }

  export type tb_etnicsOrderByRelevanceInput = {
    fields: tb_etnicsOrderByRelevanceFieldEnum | tb_etnicsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type tb_etnicsCountOrderByAggregateInput = {
    etnic_id?: SortOrder
    etnic_arm?: SortOrder
    etnic_eng?: SortOrder
  }

  export type tb_etnicsAvgOrderByAggregateInput = {
    etnic_id?: SortOrder
  }

  export type tb_etnicsMaxOrderByAggregateInput = {
    etnic_id?: SortOrder
    etnic_arm?: SortOrder
    etnic_eng?: SortOrder
  }

  export type tb_etnicsMinOrderByAggregateInput = {
    etnic_id?: SortOrder
    etnic_arm?: SortOrder
    etnic_eng?: SortOrder
  }

  export type tb_etnicsSumOrderByAggregateInput = {
    etnic_id?: SortOrder
  }

  export type tb_file_typeOrderByRelevanceInput = {
    fields: tb_file_typeOrderByRelevanceFieldEnum | tb_file_typeOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type tb_file_typeCountOrderByAggregateInput = {
    file_type_id?: SortOrder
    file_type?: SortOrder
    file_filter?: SortOrder
  }

  export type tb_file_typeAvgOrderByAggregateInput = {
    file_type_id?: SortOrder
    file_filter?: SortOrder
  }

  export type tb_file_typeMaxOrderByAggregateInput = {
    file_type_id?: SortOrder
    file_type?: SortOrder
    file_filter?: SortOrder
  }

  export type tb_file_typeMinOrderByAggregateInput = {
    file_type_id?: SortOrder
    file_type?: SortOrder
    file_filter?: SortOrder
  }

  export type tb_file_typeSumOrderByAggregateInput = {
    file_type_id?: SortOrder
    file_filter?: SortOrder
  }

  export type tb_handedOrderByRelevanceInput = {
    fields: tb_handedOrderByRelevanceFieldEnum | tb_handedOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type tb_handedCountOrderByAggregateInput = {
    handed_id?: SortOrder
    case_id?: SortOrder
    decision_id?: SortOrder
    created?: SortOrder
    hended_by?: SortOrder
    signed_page?: SortOrder
  }

  export type tb_handedAvgOrderByAggregateInput = {
    handed_id?: SortOrder
    case_id?: SortOrder
    decision_id?: SortOrder
    hended_by?: SortOrder
  }

  export type tb_handedMaxOrderByAggregateInput = {
    handed_id?: SortOrder
    case_id?: SortOrder
    decision_id?: SortOrder
    created?: SortOrder
    hended_by?: SortOrder
    signed_page?: SortOrder
  }

  export type tb_handedMinOrderByAggregateInput = {
    handed_id?: SortOrder
    case_id?: SortOrder
    decision_id?: SortOrder
    created?: SortOrder
    hended_by?: SortOrder
    signed_page?: SortOrder
  }

  export type tb_handedSumOrderByAggregateInput = {
    handed_id?: SortOrder
    case_id?: SortOrder
    decision_id?: SortOrder
    hended_by?: SortOrder
  }

  export type tb_interOrderByRelevanceInput = {
    fields: tb_interOrderByRelevanceFieldEnum | tb_interOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type tb_interCountOrderByAggregateInput = {
    inter_id?: SortOrder
    case_id?: SortOrder
    author_id?: SortOrder
    inter_status?: SortOrder
    inter_reciever?: SortOrder
    inter_type?: SortOrder
    send_type?: SortOrder
    out_num?: SortOrder
  }

  export type tb_interAvgOrderByAggregateInput = {
    inter_id?: SortOrder
    case_id?: SortOrder
    author_id?: SortOrder
    inter_status?: SortOrder
    inter_reciever?: SortOrder
    inter_type?: SortOrder
    send_type?: SortOrder
  }

  export type tb_interMaxOrderByAggregateInput = {
    inter_id?: SortOrder
    case_id?: SortOrder
    author_id?: SortOrder
    inter_status?: SortOrder
    inter_reciever?: SortOrder
    inter_type?: SortOrder
    send_type?: SortOrder
    out_num?: SortOrder
  }

  export type tb_interMinOrderByAggregateInput = {
    inter_id?: SortOrder
    case_id?: SortOrder
    author_id?: SortOrder
    inter_status?: SortOrder
    inter_reciever?: SortOrder
    inter_type?: SortOrder
    send_type?: SortOrder
    out_num?: SortOrder
  }

  export type tb_interSumOrderByAggregateInput = {
    inter_id?: SortOrder
    case_id?: SortOrder
    author_id?: SortOrder
    inter_status?: SortOrder
    inter_reciever?: SortOrder
    inter_type?: SortOrder
    send_type?: SortOrder
  }

  export type Enumtb_inter_notified_notification_statusNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.tb_inter_notified_notification_status | Enumtb_inter_notified_notification_statusFieldRefInput<$PrismaModel> | null
    in?: $Enums.tb_inter_notified_notification_status[] | null
    notIn?: $Enums.tb_inter_notified_notification_status[] | null
    not?: NestedEnumtb_inter_notified_notification_statusNullableFilter<$PrismaModel> | $Enums.tb_inter_notified_notification_status | null
  }

  export type tb_inter_notifiedOrderByRelevanceInput = {
    fields: tb_inter_notifiedOrderByRelevanceFieldEnum | tb_inter_notifiedOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type tb_inter_notifiedCountOrderByAggregateInput = {
    inter_notified_id?: SortOrder
    notified_date?: SortOrder
    actioned?: SortOrder
    file_name?: SortOrder
    inter_id?: SortOrder
    notification_status?: SortOrder
  }

  export type tb_inter_notifiedAvgOrderByAggregateInput = {
    inter_notified_id?: SortOrder
    inter_id?: SortOrder
  }

  export type tb_inter_notifiedMaxOrderByAggregateInput = {
    inter_notified_id?: SortOrder
    notified_date?: SortOrder
    actioned?: SortOrder
    file_name?: SortOrder
    inter_id?: SortOrder
    notification_status?: SortOrder
  }

  export type tb_inter_notifiedMinOrderByAggregateInput = {
    inter_notified_id?: SortOrder
    notified_date?: SortOrder
    actioned?: SortOrder
    file_name?: SortOrder
    inter_id?: SortOrder
    notification_status?: SortOrder
  }

  export type tb_inter_notifiedSumOrderByAggregateInput = {
    inter_notified_id?: SortOrder
    inter_id?: SortOrder
  }

  export type Enumtb_inter_notified_notification_statusNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.tb_inter_notified_notification_status | Enumtb_inter_notified_notification_statusFieldRefInput<$PrismaModel> | null
    in?: $Enums.tb_inter_notified_notification_status[] | null
    notIn?: $Enums.tb_inter_notified_notification_status[] | null
    not?: NestedEnumtb_inter_notified_notification_statusNullableWithAggregatesFilter<$PrismaModel> | $Enums.tb_inter_notified_notification_status | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumtb_inter_notified_notification_statusNullableFilter<$PrismaModel>
    _max?: NestedEnumtb_inter_notified_notification_statusNullableFilter<$PrismaModel>
  }

  export type tb_inter_reciversOrderByRelevanceInput = {
    fields: tb_inter_reciversOrderByRelevanceFieldEnum | tb_inter_reciversOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type tb_inter_reciversCountOrderByAggregateInput = {
    inter_reciever_id?: SortOrder
    inter_reciever_text?: SortOrder
  }

  export type tb_inter_reciversAvgOrderByAggregateInput = {
    inter_reciever_id?: SortOrder
  }

  export type tb_inter_reciversMaxOrderByAggregateInput = {
    inter_reciever_id?: SortOrder
    inter_reciever_text?: SortOrder
  }

  export type tb_inter_reciversMinOrderByAggregateInput = {
    inter_reciever_id?: SortOrder
    inter_reciever_text?: SortOrder
  }

  export type tb_inter_reciversSumOrderByAggregateInput = {
    inter_reciever_id?: SortOrder
  }

  export type tb_inter_send_typeOrderByRelevanceInput = {
    fields: tb_inter_send_typeOrderByRelevanceFieldEnum | tb_inter_send_typeOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type tb_inter_send_typeCountOrderByAggregateInput = {
    inter_send_type_id?: SortOrder
    inter_send_type?: SortOrder
  }

  export type tb_inter_send_typeAvgOrderByAggregateInput = {
    inter_send_type_id?: SortOrder
  }

  export type tb_inter_send_typeMaxOrderByAggregateInput = {
    inter_send_type_id?: SortOrder
    inter_send_type?: SortOrder
  }

  export type tb_inter_send_typeMinOrderByAggregateInput = {
    inter_send_type_id?: SortOrder
    inter_send_type?: SortOrder
  }

  export type tb_inter_send_typeSumOrderByAggregateInput = {
    inter_send_type_id?: SortOrder
  }

  export type tb_inter_status_typesOrderByRelevanceInput = {
    fields: tb_inter_status_typesOrderByRelevanceFieldEnum | tb_inter_status_typesOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type tb_inter_status_typesCountOrderByAggregateInput = {
    id?: SortOrder
    inter_status_type?: SortOrder
  }

  export type tb_inter_status_typesAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type tb_inter_status_typesMaxOrderByAggregateInput = {
    id?: SortOrder
    inter_status_type?: SortOrder
  }

  export type tb_inter_status_typesMinOrderByAggregateInput = {
    id?: SortOrder
    inter_status_type?: SortOrder
  }

  export type tb_inter_status_typesSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type tb_inter_typeOrderByRelevanceInput = {
    fields: tb_inter_typeOrderByRelevanceFieldEnum | tb_inter_typeOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type tb_inter_typeCountOrderByAggregateInput = {
    inter_type_id?: SortOrder
    inter_type?: SortOrder
  }

  export type tb_inter_typeAvgOrderByAggregateInput = {
    inter_type_id?: SortOrder
  }

  export type tb_inter_typeMaxOrderByAggregateInput = {
    inter_type_id?: SortOrder
    inter_type?: SortOrder
  }

  export type tb_inter_typeMinOrderByAggregateInput = {
    inter_type_id?: SortOrder
    inter_type?: SortOrder
  }

  export type tb_inter_typeSumOrderByAggregateInput = {
    inter_type_id?: SortOrder
  }

  export type tb_lawyerOrderByRelevanceInput = {
    fields: tb_lawyerOrderByRelevanceFieldEnum | tb_lawyerOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type tb_lawyerCountOrderByAggregateInput = {
    lawyer_id?: SortOrder
    lawyer_name?: SortOrder
    lawyer_surname?: SortOrder
    lawyer_organization?: SortOrder
    lawyer_tel?: SortOrder
    lawyer_address?: SortOrder
    lawyer_email?: SortOrder
    case_id?: SortOrder
    actual?: SortOrder
  }

  export type tb_lawyerAvgOrderByAggregateInput = {
    lawyer_id?: SortOrder
    case_id?: SortOrder
    actual?: SortOrder
  }

  export type tb_lawyerMaxOrderByAggregateInput = {
    lawyer_id?: SortOrder
    lawyer_name?: SortOrder
    lawyer_surname?: SortOrder
    lawyer_organization?: SortOrder
    lawyer_tel?: SortOrder
    lawyer_address?: SortOrder
    lawyer_email?: SortOrder
    case_id?: SortOrder
    actual?: SortOrder
  }

  export type tb_lawyerMinOrderByAggregateInput = {
    lawyer_id?: SortOrder
    lawyer_name?: SortOrder
    lawyer_surname?: SortOrder
    lawyer_organization?: SortOrder
    lawyer_tel?: SortOrder
    lawyer_address?: SortOrder
    lawyer_email?: SortOrder
    case_id?: SortOrder
    actual?: SortOrder
  }

  export type tb_lawyerSumOrderByAggregateInput = {
    lawyer_id?: SortOrder
    case_id?: SortOrder
    actual?: SortOrder
  }

  export type tb_marzOrderByRelevanceInput = {
    fields: tb_marzOrderByRelevanceFieldEnum | tb_marzOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type tb_marzCountOrderByAggregateInput = {
    marz_id?: SortOrder
    ADM1_ARM?: SortOrder
    ADM1_EN?: SortOrder
    ADM1_PCODE?: SortOrder
  }

  export type tb_marzAvgOrderByAggregateInput = {
    marz_id?: SortOrder
  }

  export type tb_marzMaxOrderByAggregateInput = {
    marz_id?: SortOrder
    ADM1_ARM?: SortOrder
    ADM1_EN?: SortOrder
    ADM1_PCODE?: SortOrder
  }

  export type tb_marzMinOrderByAggregateInput = {
    marz_id?: SortOrder
    ADM1_ARM?: SortOrder
    ADM1_EN?: SortOrder
    ADM1_PCODE?: SortOrder
  }

  export type tb_marzSumOrderByAggregateInput = {
    marz_id?: SortOrder
  }

  export type tb_membersOrderByRelevanceInput = {
    fields: tb_membersOrderByRelevanceFieldEnum | tb_membersOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type tb_membersCountOrderByAggregateInput = {
    member_id?: SortOrder
    case_id?: SortOrder
    f_name_arm?: SortOrder
    f_name_eng?: SortOrder
    l_name_arm?: SortOrder
    l_name_eng?: SortOrder
    m_name_arm?: SortOrder
    m_name_eng?: SortOrder
    b_day?: SortOrder
    b_month?: SortOrder
    b_year?: SortOrder
    sex?: SortOrder
    citizenship?: SortOrder
    residence?: SortOrder
    role?: SortOrder
  }

  export type tb_membersAvgOrderByAggregateInput = {
    member_id?: SortOrder
    case_id?: SortOrder
    sex?: SortOrder
    citizenship?: SortOrder
    residence?: SortOrder
    role?: SortOrder
  }

  export type tb_membersMaxOrderByAggregateInput = {
    member_id?: SortOrder
    case_id?: SortOrder
    f_name_arm?: SortOrder
    f_name_eng?: SortOrder
    l_name_arm?: SortOrder
    l_name_eng?: SortOrder
    m_name_arm?: SortOrder
    m_name_eng?: SortOrder
    b_day?: SortOrder
    b_month?: SortOrder
    b_year?: SortOrder
    sex?: SortOrder
    citizenship?: SortOrder
    residence?: SortOrder
    role?: SortOrder
  }

  export type tb_membersMinOrderByAggregateInput = {
    member_id?: SortOrder
    case_id?: SortOrder
    f_name_arm?: SortOrder
    f_name_eng?: SortOrder
    l_name_arm?: SortOrder
    l_name_eng?: SortOrder
    m_name_arm?: SortOrder
    m_name_eng?: SortOrder
    b_day?: SortOrder
    b_month?: SortOrder
    b_year?: SortOrder
    sex?: SortOrder
    citizenship?: SortOrder
    residence?: SortOrder
    role?: SortOrder
  }

  export type tb_membersSumOrderByAggregateInput = {
    member_id?: SortOrder
    case_id?: SortOrder
    sex?: SortOrder
    citizenship?: SortOrder
    residence?: SortOrder
    role?: SortOrder
  }

  export type tb_notificationsOrderByRelevanceInput = {
    fields: tb_notificationsOrderByRelevanceFieldEnum | tb_notificationsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type tb_notificationsCountOrderByAggregateInput = {
    comment_id?: SortOrder
    comment_subject?: SortOrder
    comment_text?: SortOrder
    comment_status?: SortOrder
    comment_from?: SortOrder
    comment_to?: SortOrder
    case_id?: SortOrder
    coi_id?: SortOrder
    request_id?: SortOrder
    note_type?: SortOrder
    draft_id?: SortOrder
    order_id?: SortOrder
    readed?: SortOrder
    note_date?: SortOrder
    msg_read?: SortOrder
  }

  export type tb_notificationsAvgOrderByAggregateInput = {
    comment_id?: SortOrder
    comment_status?: SortOrder
    comment_from?: SortOrder
    comment_to?: SortOrder
    case_id?: SortOrder
    coi_id?: SortOrder
    request_id?: SortOrder
    note_type?: SortOrder
    draft_id?: SortOrder
    order_id?: SortOrder
    readed?: SortOrder
    msg_read?: SortOrder
  }

  export type tb_notificationsMaxOrderByAggregateInput = {
    comment_id?: SortOrder
    comment_subject?: SortOrder
    comment_text?: SortOrder
    comment_status?: SortOrder
    comment_from?: SortOrder
    comment_to?: SortOrder
    case_id?: SortOrder
    coi_id?: SortOrder
    request_id?: SortOrder
    note_type?: SortOrder
    draft_id?: SortOrder
    order_id?: SortOrder
    readed?: SortOrder
    note_date?: SortOrder
    msg_read?: SortOrder
  }

  export type tb_notificationsMinOrderByAggregateInput = {
    comment_id?: SortOrder
    comment_subject?: SortOrder
    comment_text?: SortOrder
    comment_status?: SortOrder
    comment_from?: SortOrder
    comment_to?: SortOrder
    case_id?: SortOrder
    coi_id?: SortOrder
    request_id?: SortOrder
    note_type?: SortOrder
    draft_id?: SortOrder
    order_id?: SortOrder
    readed?: SortOrder
    note_date?: SortOrder
    msg_read?: SortOrder
  }

  export type tb_notificationsSumOrderByAggregateInput = {
    comment_id?: SortOrder
    comment_status?: SortOrder
    comment_from?: SortOrder
    comment_to?: SortOrder
    case_id?: SortOrder
    coi_id?: SortOrder
    request_id?: SortOrder
    note_type?: SortOrder
    draft_id?: SortOrder
    order_id?: SortOrder
    readed?: SortOrder
    msg_read?: SortOrder
  }

  export type tb_ordersCountOrderByAggregateInput = {
    order_id?: SortOrder
    case_id?: SortOrder
    order_status?: SortOrder
    date?: SortOrder
  }

  export type tb_ordersAvgOrderByAggregateInput = {
    order_id?: SortOrder
    case_id?: SortOrder
    order_status?: SortOrder
  }

  export type tb_ordersMaxOrderByAggregateInput = {
    order_id?: SortOrder
    case_id?: SortOrder
    order_status?: SortOrder
    date?: SortOrder
  }

  export type tb_ordersMinOrderByAggregateInput = {
    order_id?: SortOrder
    case_id?: SortOrder
    order_status?: SortOrder
    date?: SortOrder
  }

  export type tb_ordersSumOrderByAggregateInput = {
    order_id?: SortOrder
    case_id?: SortOrder
    order_status?: SortOrder
  }

  export type tb_personOrderByRelevanceInput = {
    fields: tb_personOrderByRelevanceFieldEnum | tb_personOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type tb_personCountOrderByAggregateInput = {
    personal_id?: SortOrder
    case_id?: SortOrder
    f_name_arm?: SortOrder
    f_name_eng?: SortOrder
    l_name_arm?: SortOrder
    l_name_eng?: SortOrder
    m_name_arm?: SortOrder
    m_name_eng?: SortOrder
    b_day?: SortOrder
    b_month?: SortOrder
    b_year?: SortOrder
    sex?: SortOrder
    citizenship?: SortOrder
    previous_residence?: SortOrder
    citizen_adr?: SortOrder
    residence_adr?: SortOrder
    departure_from_citizen?: SortOrder
    departure_from_residence?: SortOrder
    arrival_date?: SortOrder
    doc_num?: SortOrder
    etnicity?: SortOrder
    religion?: SortOrder
    preferred_traslator_sex?: SortOrder
    preferred_interviewer_sex?: SortOrder
    invalid?: SortOrder
    pregnant?: SortOrder
    seriously_ill?: SortOrder
    trafficking_victim?: SortOrder
    violence_victim?: SortOrder
    comment?: SortOrder
    illegal_border?: SortOrder
    transfer_moj?: SortOrder
    deport_prescurator?: SortOrder
    prison?: SortOrder
    role?: SortOrder
    image?: SortOrder
    person_status?: SortOrder
    ident?: SortOrder
    pnum?: SortOrder
    doc_type?: SortOrder
    document_num?: SortOrder
    doc_issued_date?: SortOrder
    doc_valid?: SortOrder
    doc_issued_by?: SortOrder
    bpr_community?: SortOrder
    bpr_bnakavayr?: SortOrder
    bpr_street?: SortOrder
    bpr_house?: SortOrder
    bpr_aprt?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type tb_personAvgOrderByAggregateInput = {
    personal_id?: SortOrder
    case_id?: SortOrder
    sex?: SortOrder
    citizenship?: SortOrder
    previous_residence?: SortOrder
    etnicity?: SortOrder
    religion?: SortOrder
    preferred_traslator_sex?: SortOrder
    preferred_interviewer_sex?: SortOrder
    invalid?: SortOrder
    pregnant?: SortOrder
    seriously_ill?: SortOrder
    trafficking_victim?: SortOrder
    violence_victim?: SortOrder
    illegal_border?: SortOrder
    transfer_moj?: SortOrder
    deport_prescurator?: SortOrder
    prison?: SortOrder
    role?: SortOrder
    person_status?: SortOrder
    ident?: SortOrder
  }

  export type tb_personMaxOrderByAggregateInput = {
    personal_id?: SortOrder
    case_id?: SortOrder
    f_name_arm?: SortOrder
    f_name_eng?: SortOrder
    l_name_arm?: SortOrder
    l_name_eng?: SortOrder
    m_name_arm?: SortOrder
    m_name_eng?: SortOrder
    b_day?: SortOrder
    b_month?: SortOrder
    b_year?: SortOrder
    sex?: SortOrder
    citizenship?: SortOrder
    previous_residence?: SortOrder
    citizen_adr?: SortOrder
    residence_adr?: SortOrder
    departure_from_citizen?: SortOrder
    departure_from_residence?: SortOrder
    arrival_date?: SortOrder
    doc_num?: SortOrder
    etnicity?: SortOrder
    religion?: SortOrder
    preferred_traslator_sex?: SortOrder
    preferred_interviewer_sex?: SortOrder
    invalid?: SortOrder
    pregnant?: SortOrder
    seriously_ill?: SortOrder
    trafficking_victim?: SortOrder
    violence_victim?: SortOrder
    comment?: SortOrder
    illegal_border?: SortOrder
    transfer_moj?: SortOrder
    deport_prescurator?: SortOrder
    prison?: SortOrder
    role?: SortOrder
    image?: SortOrder
    person_status?: SortOrder
    ident?: SortOrder
    pnum?: SortOrder
    doc_type?: SortOrder
    document_num?: SortOrder
    doc_issued_date?: SortOrder
    doc_valid?: SortOrder
    doc_issued_by?: SortOrder
    bpr_community?: SortOrder
    bpr_bnakavayr?: SortOrder
    bpr_street?: SortOrder
    bpr_house?: SortOrder
    bpr_aprt?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type tb_personMinOrderByAggregateInput = {
    personal_id?: SortOrder
    case_id?: SortOrder
    f_name_arm?: SortOrder
    f_name_eng?: SortOrder
    l_name_arm?: SortOrder
    l_name_eng?: SortOrder
    m_name_arm?: SortOrder
    m_name_eng?: SortOrder
    b_day?: SortOrder
    b_month?: SortOrder
    b_year?: SortOrder
    sex?: SortOrder
    citizenship?: SortOrder
    previous_residence?: SortOrder
    citizen_adr?: SortOrder
    residence_adr?: SortOrder
    departure_from_citizen?: SortOrder
    departure_from_residence?: SortOrder
    arrival_date?: SortOrder
    doc_num?: SortOrder
    etnicity?: SortOrder
    religion?: SortOrder
    preferred_traslator_sex?: SortOrder
    preferred_interviewer_sex?: SortOrder
    invalid?: SortOrder
    pregnant?: SortOrder
    seriously_ill?: SortOrder
    trafficking_victim?: SortOrder
    violence_victim?: SortOrder
    comment?: SortOrder
    illegal_border?: SortOrder
    transfer_moj?: SortOrder
    deport_prescurator?: SortOrder
    prison?: SortOrder
    role?: SortOrder
    image?: SortOrder
    person_status?: SortOrder
    ident?: SortOrder
    pnum?: SortOrder
    doc_type?: SortOrder
    document_num?: SortOrder
    doc_issued_date?: SortOrder
    doc_valid?: SortOrder
    doc_issued_by?: SortOrder
    bpr_community?: SortOrder
    bpr_bnakavayr?: SortOrder
    bpr_street?: SortOrder
    bpr_house?: SortOrder
    bpr_aprt?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type tb_personSumOrderByAggregateInput = {
    personal_id?: SortOrder
    case_id?: SortOrder
    sex?: SortOrder
    citizenship?: SortOrder
    previous_residence?: SortOrder
    etnicity?: SortOrder
    religion?: SortOrder
    preferred_traslator_sex?: SortOrder
    preferred_interviewer_sex?: SortOrder
    invalid?: SortOrder
    pregnant?: SortOrder
    seriously_ill?: SortOrder
    trafficking_victim?: SortOrder
    violence_victim?: SortOrder
    illegal_border?: SortOrder
    transfer_moj?: SortOrder
    deport_prescurator?: SortOrder
    prison?: SortOrder
    role?: SortOrder
    person_status?: SortOrder
    ident?: SortOrder
  }

  export type tb_person_statusOrderByRelevanceInput = {
    fields: tb_person_statusOrderByRelevanceFieldEnum | tb_person_statusOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type tb_person_statusCountOrderByAggregateInput = {
    person_status_id?: SortOrder
    person_status?: SortOrder
    person_status_eng?: SortOrder
  }

  export type tb_person_statusAvgOrderByAggregateInput = {
    person_status_id?: SortOrder
  }

  export type tb_person_statusMaxOrderByAggregateInput = {
    person_status_id?: SortOrder
    person_status?: SortOrder
    person_status_eng?: SortOrder
  }

  export type tb_person_statusMinOrderByAggregateInput = {
    person_status_id?: SortOrder
    person_status?: SortOrder
    person_status_eng?: SortOrder
  }

  export type tb_person_statusSumOrderByAggregateInput = {
    person_status_id?: SortOrder
  }

  export type tb_processOrderByRelevanceInput = {
    fields: tb_processOrderByRelevanceFieldEnum | tb_processOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type tb_processCountOrderByAggregateInput = {
    process_id?: SortOrder
    process_type_id?: SortOrder
    case_id?: SortOrder
    draft_id?: SortOrder
    coi_id?: SortOrder
    request_id?: SortOrder
    order_id?: SortOrder
    decision_id?: SortOrder
    notification_id?: SortOrder
    sign_status?: SortOrder
    sign_date?: SortOrder
    sign_by?: SortOrder
    processor?: SortOrder
    comment_to?: SortOrder
    actual?: SortOrder
    comment_status?: SortOrder
    out_num?: SortOrder
  }

  export type tb_processAvgOrderByAggregateInput = {
    process_id?: SortOrder
    process_type_id?: SortOrder
    case_id?: SortOrder
    draft_id?: SortOrder
    coi_id?: SortOrder
    request_id?: SortOrder
    order_id?: SortOrder
    decision_id?: SortOrder
    notification_id?: SortOrder
    sign_status?: SortOrder
    sign_by?: SortOrder
    processor?: SortOrder
    actual?: SortOrder
    comment_status?: SortOrder
  }

  export type tb_processMaxOrderByAggregateInput = {
    process_id?: SortOrder
    process_type_id?: SortOrder
    case_id?: SortOrder
    draft_id?: SortOrder
    coi_id?: SortOrder
    request_id?: SortOrder
    order_id?: SortOrder
    decision_id?: SortOrder
    notification_id?: SortOrder
    sign_status?: SortOrder
    sign_date?: SortOrder
    sign_by?: SortOrder
    processor?: SortOrder
    comment_to?: SortOrder
    actual?: SortOrder
    comment_status?: SortOrder
    out_num?: SortOrder
  }

  export type tb_processMinOrderByAggregateInput = {
    process_id?: SortOrder
    process_type_id?: SortOrder
    case_id?: SortOrder
    draft_id?: SortOrder
    coi_id?: SortOrder
    request_id?: SortOrder
    order_id?: SortOrder
    decision_id?: SortOrder
    notification_id?: SortOrder
    sign_status?: SortOrder
    sign_date?: SortOrder
    sign_by?: SortOrder
    processor?: SortOrder
    comment_to?: SortOrder
    actual?: SortOrder
    comment_status?: SortOrder
    out_num?: SortOrder
  }

  export type tb_processSumOrderByAggregateInput = {
    process_id?: SortOrder
    process_type_id?: SortOrder
    case_id?: SortOrder
    draft_id?: SortOrder
    coi_id?: SortOrder
    request_id?: SortOrder
    order_id?: SortOrder
    decision_id?: SortOrder
    notification_id?: SortOrder
    sign_status?: SortOrder
    sign_by?: SortOrder
    processor?: SortOrder
    actual?: SortOrder
    comment_status?: SortOrder
  }

  export type tb_process_typeOrderByRelevanceInput = {
    fields: tb_process_typeOrderByRelevanceFieldEnum | tb_process_typeOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type tb_process_typeCountOrderByAggregateInput = {
    process_type_id?: SortOrder
    process_type?: SortOrder
  }

  export type tb_process_typeAvgOrderByAggregateInput = {
    process_type_id?: SortOrder
  }

  export type tb_process_typeMaxOrderByAggregateInput = {
    process_type_id?: SortOrder
    process_type?: SortOrder
  }

  export type tb_process_typeMinOrderByAggregateInput = {
    process_type_id?: SortOrder
    process_type?: SortOrder
  }

  export type tb_process_typeSumOrderByAggregateInput = {
    process_type_id?: SortOrder
  }

  export type tb_religionsOrderByRelevanceInput = {
    fields: tb_religionsOrderByRelevanceFieldEnum | tb_religionsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type tb_religionsCountOrderByAggregateInput = {
    religion_id?: SortOrder
    religion_arm?: SortOrder
    religion_eng?: SortOrder
  }

  export type tb_religionsAvgOrderByAggregateInput = {
    religion_id?: SortOrder
  }

  export type tb_religionsMaxOrderByAggregateInput = {
    religion_id?: SortOrder
    religion_arm?: SortOrder
    religion_eng?: SortOrder
  }

  export type tb_religionsMinOrderByAggregateInput = {
    religion_id?: SortOrder
    religion_arm?: SortOrder
    religion_eng?: SortOrder
  }

  export type tb_religionsSumOrderByAggregateInput = {
    religion_id?: SortOrder
  }

  export type tb_request_bodiesOrderByRelevanceInput = {
    fields: tb_request_bodiesOrderByRelevanceFieldEnum | tb_request_bodiesOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type tb_request_bodiesCountOrderByAggregateInput = {
    body_id?: SortOrder
    body?: SortOrder
  }

  export type tb_request_bodiesAvgOrderByAggregateInput = {
    body_id?: SortOrder
  }

  export type tb_request_bodiesMaxOrderByAggregateInput = {
    body_id?: SortOrder
    body?: SortOrder
  }

  export type tb_request_bodiesMinOrderByAggregateInput = {
    body_id?: SortOrder
    body?: SortOrder
  }

  export type tb_request_bodiesSumOrderByAggregateInput = {
    body_id?: SortOrder
  }

  export type tb_request_outCountOrderByAggregateInput = {
    request_id?: SortOrder
    case_id?: SortOrder
    author?: SortOrder
    body?: SortOrder
    request_date?: SortOrder
    request_status?: SortOrder
  }

  export type tb_request_outAvgOrderByAggregateInput = {
    request_id?: SortOrder
    case_id?: SortOrder
    author?: SortOrder
    body?: SortOrder
    request_status?: SortOrder
  }

  export type tb_request_outMaxOrderByAggregateInput = {
    request_id?: SortOrder
    case_id?: SortOrder
    author?: SortOrder
    body?: SortOrder
    request_date?: SortOrder
    request_status?: SortOrder
  }

  export type tb_request_outMinOrderByAggregateInput = {
    request_id?: SortOrder
    case_id?: SortOrder
    author?: SortOrder
    body?: SortOrder
    request_date?: SortOrder
    request_status?: SortOrder
  }

  export type tb_request_outSumOrderByAggregateInput = {
    request_id?: SortOrder
    case_id?: SortOrder
    author?: SortOrder
    body?: SortOrder
    request_status?: SortOrder
  }

  export type tb_roleOrderByRelevanceInput = {
    fields: tb_roleOrderByRelevanceFieldEnum | tb_roleOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type tb_roleCountOrderByAggregateInput = {
    role_id?: SortOrder
    der?: SortOrder
  }

  export type tb_roleAvgOrderByAggregateInput = {
    role_id?: SortOrder
  }

  export type tb_roleMaxOrderByAggregateInput = {
    role_id?: SortOrder
    der?: SortOrder
  }

  export type tb_roleMinOrderByAggregateInput = {
    role_id?: SortOrder
    der?: SortOrder
  }

  export type tb_roleSumOrderByAggregateInput = {
    role_id?: SortOrder
  }

  export type tb_settlementOrderByRelevanceInput = {
    fields: tb_settlementOrderByRelevanceFieldEnum | tb_settlementOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type tb_settlementCountOrderByAggregateInput = {
    settlement_id?: SortOrder
    com_id?: SortOrder
    ADM3_CODE?: SortOrder
    ADM4_PCODE?: SortOrder
    ADM4_ARM?: SortOrder
    ADM4_ENG?: SortOrder
  }

  export type tb_settlementAvgOrderByAggregateInput = {
    settlement_id?: SortOrder
    com_id?: SortOrder
  }

  export type tb_settlementMaxOrderByAggregateInput = {
    settlement_id?: SortOrder
    com_id?: SortOrder
    ADM3_CODE?: SortOrder
    ADM4_PCODE?: SortOrder
    ADM4_ARM?: SortOrder
    ADM4_ENG?: SortOrder
  }

  export type tb_settlementMinOrderByAggregateInput = {
    settlement_id?: SortOrder
    com_id?: SortOrder
    ADM3_CODE?: SortOrder
    ADM4_PCODE?: SortOrder
    ADM4_ARM?: SortOrder
    ADM4_ENG?: SortOrder
  }

  export type tb_settlementSumOrderByAggregateInput = {
    settlement_id?: SortOrder
    com_id?: SortOrder
  }

  export type tb_settlement_OrderByRelevanceInput = {
    fields: tb_settlement_OrderByRelevanceFieldEnum | tb_settlement_OrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type tb_settlement_CountOrderByAggregateInput = {
    settlement_id?: SortOrder
    com_id?: SortOrder
    ADM3_CODE?: SortOrder
    ADM4_PCODE?: SortOrder
    ADM4_ARM?: SortOrder
    ADM4_ENG?: SortOrder
    active?: SortOrder
  }

  export type tb_settlement_AvgOrderByAggregateInput = {
    settlement_id?: SortOrder
    com_id?: SortOrder
    active?: SortOrder
  }

  export type tb_settlement_MaxOrderByAggregateInput = {
    settlement_id?: SortOrder
    com_id?: SortOrder
    ADM3_CODE?: SortOrder
    ADM4_PCODE?: SortOrder
    ADM4_ARM?: SortOrder
    ADM4_ENG?: SortOrder
    active?: SortOrder
  }

  export type tb_settlement_MinOrderByAggregateInput = {
    settlement_id?: SortOrder
    com_id?: SortOrder
    ADM3_CODE?: SortOrder
    ADM4_PCODE?: SortOrder
    ADM4_ARM?: SortOrder
    ADM4_ENG?: SortOrder
    active?: SortOrder
  }

  export type tb_settlement_SumOrderByAggregateInput = {
    settlement_id?: SortOrder
    com_id?: SortOrder
    active?: SortOrder
  }

  export type tb_sign_statusOrderByRelevanceInput = {
    fields: tb_sign_statusOrderByRelevanceFieldEnum | tb_sign_statusOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type tb_sign_statusCountOrderByAggregateInput = {
    status_id?: SortOrder
    status?: SortOrder
  }

  export type tb_sign_statusAvgOrderByAggregateInput = {
    status_id?: SortOrder
  }

  export type tb_sign_statusMaxOrderByAggregateInput = {
    status_id?: SortOrder
    status?: SortOrder
  }

  export type tb_sign_statusMinOrderByAggregateInput = {
    status_id?: SortOrder
    status?: SortOrder
  }

  export type tb_sign_statusSumOrderByAggregateInput = {
    status_id?: SortOrder
  }

  export type tb_translateOrderByRelevanceInput = {
    fields: tb_translateOrderByRelevanceFieldEnum | tb_translateOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type tb_translateCountOrderByAggregateInput = {
    translate_id?: SortOrder
    case_id?: SortOrder
    translate_type?: SortOrder
    user_from?: SortOrder
    user_to?: SortOrder
    filled_in_date?: SortOrder
    translator_company?: SortOrder
    file_path?: SortOrder
    file_ids?: SortOrder
    translate_date?: SortOrder
    translate_time_from?: SortOrder
    translate_time_to?: SortOrder
    sign_status?: SortOrder
    mailed_to_translators?: SortOrder
  }

  export type tb_translateAvgOrderByAggregateInput = {
    translate_id?: SortOrder
    case_id?: SortOrder
    translate_type?: SortOrder
    user_from?: SortOrder
    user_to?: SortOrder
    translator_company?: SortOrder
    sign_status?: SortOrder
  }

  export type tb_translateMaxOrderByAggregateInput = {
    translate_id?: SortOrder
    case_id?: SortOrder
    translate_type?: SortOrder
    user_from?: SortOrder
    user_to?: SortOrder
    filled_in_date?: SortOrder
    translator_company?: SortOrder
    file_path?: SortOrder
    file_ids?: SortOrder
    translate_date?: SortOrder
    translate_time_from?: SortOrder
    translate_time_to?: SortOrder
    sign_status?: SortOrder
    mailed_to_translators?: SortOrder
  }

  export type tb_translateMinOrderByAggregateInput = {
    translate_id?: SortOrder
    case_id?: SortOrder
    translate_type?: SortOrder
    user_from?: SortOrder
    user_to?: SortOrder
    filled_in_date?: SortOrder
    translator_company?: SortOrder
    file_path?: SortOrder
    file_ids?: SortOrder
    translate_date?: SortOrder
    translate_time_from?: SortOrder
    translate_time_to?: SortOrder
    sign_status?: SortOrder
    mailed_to_translators?: SortOrder
  }

  export type tb_translateSumOrderByAggregateInput = {
    translate_id?: SortOrder
    case_id?: SortOrder
    translate_type?: SortOrder
    user_from?: SortOrder
    user_to?: SortOrder
    translator_company?: SortOrder
    sign_status?: SortOrder
  }

  export type tb_translate_sign_statusesOrderByRelevanceInput = {
    fields: tb_translate_sign_statusesOrderByRelevanceFieldEnum | tb_translate_sign_statusesOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type tb_translate_sign_statusesCountOrderByAggregateInput = {
    status_id?: SortOrder
    sign_status?: SortOrder
    sign_status_name?: SortOrder
  }

  export type tb_translate_sign_statusesAvgOrderByAggregateInput = {
    status_id?: SortOrder
    sign_status?: SortOrder
  }

  export type tb_translate_sign_statusesMaxOrderByAggregateInput = {
    status_id?: SortOrder
    sign_status?: SortOrder
    sign_status_name?: SortOrder
  }

  export type tb_translate_sign_statusesMinOrderByAggregateInput = {
    status_id?: SortOrder
    sign_status?: SortOrder
    sign_status_name?: SortOrder
  }

  export type tb_translate_sign_statusesSumOrderByAggregateInput = {
    status_id?: SortOrder
    sign_status?: SortOrder
  }

  export type tb_translation_typeOrderByRelevanceInput = {
    fields: tb_translation_typeOrderByRelevanceFieldEnum | tb_translation_typeOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type tb_translation_typeCountOrderByAggregateInput = {
    ttype_id?: SortOrder
    trans_type?: SortOrder
  }

  export type tb_translation_typeAvgOrderByAggregateInput = {
    ttype_id?: SortOrder
  }

  export type tb_translation_typeMaxOrderByAggregateInput = {
    ttype_id?: SortOrder
    trans_type?: SortOrder
  }

  export type tb_translation_typeMinOrderByAggregateInput = {
    ttype_id?: SortOrder
    trans_type?: SortOrder
  }

  export type tb_translation_typeSumOrderByAggregateInput = {
    ttype_id?: SortOrder
  }

  export type tb_translatorsOrderByRelevanceInput = {
    fields: tb_translatorsOrderByRelevanceFieldEnum | tb_translatorsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type tb_translatorsCountOrderByAggregateInput = {
    translator_id?: SortOrder
    translator_name_arm?: SortOrder
    translator_name_eng?: SortOrder
    email?: SortOrder
    test_mail?: SortOrder
    logo_file?: SortOrder
    active_status?: SortOrder
  }

  export type tb_translatorsAvgOrderByAggregateInput = {
    translator_id?: SortOrder
    active_status?: SortOrder
  }

  export type tb_translatorsMaxOrderByAggregateInput = {
    translator_id?: SortOrder
    translator_name_arm?: SortOrder
    translator_name_eng?: SortOrder
    email?: SortOrder
    test_mail?: SortOrder
    logo_file?: SortOrder
    active_status?: SortOrder
  }

  export type tb_translatorsMinOrderByAggregateInput = {
    translator_id?: SortOrder
    translator_name_arm?: SortOrder
    translator_name_eng?: SortOrder
    email?: SortOrder
    test_mail?: SortOrder
    logo_file?: SortOrder
    active_status?: SortOrder
  }

  export type tb_translatorsSumOrderByAggregateInput = {
    translator_id?: SortOrder
    active_status?: SortOrder
  }

  export type BigIntNullableFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | null
    notIn?: bigint[] | number[] | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableFilter<$PrismaModel> | bigint | number | null
  }

  export type usersOrderByRelevanceInput = {
    fields: usersOrderByRelevanceFieldEnum | usersOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type usersCountOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    password?: SortOrder
    f_name?: SortOrder
    l_name?: SortOrder
    user_type?: SortOrder
    user_status?: SortOrder
    last_activity?: SortOrder
  }

  export type usersAvgOrderByAggregateInput = {
    id?: SortOrder
    user_status?: SortOrder
    last_activity?: SortOrder
  }

  export type usersMaxOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    password?: SortOrder
    f_name?: SortOrder
    l_name?: SortOrder
    user_type?: SortOrder
    user_status?: SortOrder
    last_activity?: SortOrder
  }

  export type usersMinOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    password?: SortOrder
    f_name?: SortOrder
    l_name?: SortOrder
    user_type?: SortOrder
    user_status?: SortOrder
    last_activity?: SortOrder
  }

  export type usersSumOrderByAggregateInput = {
    id?: SortOrder
    user_status?: SortOrder
    last_activity?: SortOrder
  }

  export type BigIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | null
    notIn?: bigint[] | number[] | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableWithAggregatesFilter<$PrismaModel> | bigint | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedBigIntNullableFilter<$PrismaModel>
    _min?: NestedBigIntNullableFilter<$PrismaModel>
    _max?: NestedBigIntNullableFilter<$PrismaModel>
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type NullableEnumtb_inter_notified_notification_statusFieldUpdateOperationsInput = {
    set?: $Enums.tb_inter_notified_notification_status | null
  }

  export type NullableBigIntFieldUpdateOperationsInput = {
    set?: bigint | number | null
    increment?: bigint | number
    decrement?: bigint | number
    multiply?: bigint | number
    divide?: bigint | number
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedEnumtb_inter_notified_notification_statusNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.tb_inter_notified_notification_status | Enumtb_inter_notified_notification_statusFieldRefInput<$PrismaModel> | null
    in?: $Enums.tb_inter_notified_notification_status[] | null
    notIn?: $Enums.tb_inter_notified_notification_status[] | null
    not?: NestedEnumtb_inter_notified_notification_statusNullableFilter<$PrismaModel> | $Enums.tb_inter_notified_notification_status | null
  }

  export type NestedEnumtb_inter_notified_notification_statusNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.tb_inter_notified_notification_status | Enumtb_inter_notified_notification_statusFieldRefInput<$PrismaModel> | null
    in?: $Enums.tb_inter_notified_notification_status[] | null
    notIn?: $Enums.tb_inter_notified_notification_status[] | null
    not?: NestedEnumtb_inter_notified_notification_statusNullableWithAggregatesFilter<$PrismaModel> | $Enums.tb_inter_notified_notification_status | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumtb_inter_notified_notification_statusNullableFilter<$PrismaModel>
    _max?: NestedEnumtb_inter_notified_notification_statusNullableFilter<$PrismaModel>
  }

  export type NestedBigIntNullableFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | null
    notIn?: bigint[] | number[] | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableFilter<$PrismaModel> | bigint | number | null
  }

  export type NestedBigIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | null
    notIn?: bigint[] | number[] | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableWithAggregatesFilter<$PrismaModel> | bigint | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedBigIntNullableFilter<$PrismaModel>
    _min?: NestedBigIntNullableFilter<$PrismaModel>
    _max?: NestedBigIntNullableFilter<$PrismaModel>
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}